<!DOCTYPE html><html lang="[&quot;zh-cn&quot;,&quot;en&quot;,&quot;default&quot;]" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>剑指offer 专项突破 | BMSK</title><meta name="author" content="bmsk"><meta name="copyright" content="bmsk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="剑指Offer专项突破版第三章、字符串014.字符串中的变位词 (567、8月14日)1.我的想法：将字符串s1的各种变位词罗列出来，遍历变位词列表，调用某操作String类的API判断是否为子串。  a.给出子串位置api：s1.indexOf(s2);    b.输出字符串的全排列：这是一个典型的回溯过程，每次先将字符串最左边位置与后面其他位置替换，再将左端位置右移一位，返回后则将最左边位置和">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer 专项突破">
<meta property="og:url" content="https://bmsk1994.github.io/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/index.html">
<meta property="og:site_name" content="BMSK">
<meta property="og:description" content="剑指Offer专项突破版第三章、字符串014.字符串中的变位词 (567、8月14日)1.我的想法：将字符串s1的各种变位词罗列出来，遍历变位词列表，调用某操作String类的API判断是否为子串。  a.给出子串位置api：s1.indexOf(s2);    b.输出字符串的全排列：这是一个典型的回溯过程，每次先将字符串最左边位置与后面其他位置替换，再将左端位置右移一位，返回后则将最左边位置和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bmsk1994.github.io/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg">
<meta property="article:published_time" content="2022-11-14T12:07:42.000Z">
<meta property="article:modified_time" content="2022-11-14T12:38:05.062Z">
<meta property="article:author" content="bmsk">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bmsk1994.github.io/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://bmsk1994.github.io/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '剑指offer 专项突破',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-14 20:38:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">BMSK</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">剑指offer 专项突破</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-11-14T12:07:42.000Z" title="Created 2022-11-14 20:07:42">2022-11-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-11-14T12:38:05.062Z" title="Updated 2022-11-14 20:38:05">2022-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode/">LeetCode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">29.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>100min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="剑指offer 专项突破"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="剑指Offer专项突破版"><a href="#剑指Offer专项突破版" class="headerlink" title="剑指Offer专项突破版"></a>剑指Offer专项突破版</h1><h2 id="第三章、字符串"><a href="#第三章、字符串" class="headerlink" title="第三章、字符串"></a>第三章、字符串</h2><h3 id="014-字符串中的变位词-567、8月14日"><a href="#014-字符串中的变位词-567、8月14日" class="headerlink" title="014.字符串中的变位词 (567、8月14日)"></a>014.字符串中的变位词 (567、8月14日)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：将字符串s1的各种变位词罗列出来，遍历变位词列表，调用某操作String类的API判断是否为子串。</span><br><span class="line">  a.给出子串位置api：s1.indexOf(s2);  </span><br><span class="line">  b.输出字符串的全排列：这是一个典型的回溯过程，每次先将字符串最左边位置与后面其他位置替换，再将左端位置右移一位，返回后则将最左边位置和那个其他位置替换出来，这样每次递进时后面的字符都挨个做当前最左端位置。</span><br><span class="line">      </span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：双指针+hash表。使用hash表记录s2中字符对应位置加<span class="number">1</span>，使用双指针在s1中维护一个和s2长度一致的子串，遍历双指针维护的子串时，将hash表对应字符位置减<span class="number">1</span>，当前子串遍历完毕时hash表全部值为<span class="number">0</span>则说明是变位词。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>：两个hashmap比较，一个是s1的词频，另一个是s2的滑动窗口。每次移动只在滑动窗口的hashmap上改变两端，左端字符减一，右端字符加一，再进行两个hashmap的比较，这样就不需要在滑动窗口内部进行遍历。</span><br><span class="line">      </span><br><span class="line"><span class="number">4.</span>HashMap.equals作用于基本数据类型是能实现map的直接整体比较的。观察源码后发现，map1.equals通过entrySet().iterator()这种方式遍历了map1，判断了map2是否含有相同的键m.containsKey(key)，并判断键值是否相等value.equals(m.get(key))。因此，只有value类不是基本数据类型而是自定义类时，重写了equals和hashcode方法，才需要注意这种整体map调用equals是否合理。</span><br></pre></td></tr></table></figure>

<h3 id="015-字符串中的所有变位词-438、8月15日"><a href="#015-字符串中的所有变位词-438、8月15日" class="headerlink" title="015.字符串中的所有变位词(438、8月15日)"></a>015.字符串中的所有变位词(438、8月15日)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：思路同题目<span class="number">14</span>中的思路<span class="number">2</span>，实现两个hashMap比较，将<span class="keyword">return</span> <span class="literal">true</span>替换为result.add(i-p.length()+<span class="number">1</span>)，即窗口左端。</span><br><span class="line"><span class="number">2.</span>变位词题目思路关键：滑动窗口只改变两端词频+双指针实现滑动窗口，hash表或数组实现窗口内词频统计。</span><br></pre></td></tr></table></figure>

<h3 id="016-不含重复字符的最长连续子字符串-3、8月15日"><a href="#016-不含重复字符的最长连续子字符串-3、8月15日" class="headerlink" title="016.不含重复字符的最长连续子字符串(3、8月15日)"></a>016.不含重复字符的最长连续子字符串(3、8月15日)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题在<span class="number">7</span>月<span class="number">31</span>日做过，这次做看了下以前的笔记。现在记录的更简单些。</span><br><span class="line">    a.做法是维护一个HashMap&lt;Character,Integer&gt;，记录字符和它的上次出现位置；</span><br><span class="line">    b.向右滑动窗口时，遇到重复字符，就调整窗口的左端，保证窗口左端在重复字符上次出现位置的右边；由于可能窗口左端已经被其他重复字符更新，所以会出现在本来就在本重复字符上次位置右边的情况；</span><br><span class="line">        left = Math.max(left,hashMap.get(s.charAt(i))+<span class="number">1</span>);</span><br><span class="line">    c.滑动窗口中是不含重复字符的子串，即题目需求，就是在向右滑动过程中找到最大的滑动窗口；</span><br><span class="line"><span class="number">2.</span>滑动窗口的感觉：每次滑动只有开销很小的改动。</span><br></pre></td></tr></table></figure>

<h3 id="017-含有所有字符的最短字符串（76、8月15日、20日）"><a href="#017-含有所有字符的最短字符串（76、8月15日、20日）" class="headerlink" title="017.含有所有字符的最短字符串（76、8月15日、20日）"></a>017.含有所有字符的最短字符串（76、8月15日、20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：因为是求最短字符串且只返回一个，就将外层循环设置为字符串长度，内层循环设置为起始位置。和变位词类似，先用hashMap记录标准t字符串的词频情况，每次遍历一个滑动窗口时，就将标准t的hashMap拷贝一份tempMap，tempMap减去窗口内标准字符次数，全部小于<span class="number">0</span>则为“含所有字符的最短字符串”。因为需要遍历滑动窗口内部，开销很大，所以在测试最后<span class="number">3</span>个测试用例时，出现了超时。</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> L=t.length();L&lt;=s.length();L++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+L-<span class="number">1</span>&lt;s.length();i++)&#123;</span><br><span class="line"><span class="number">2.</span>我的想法<span class="number">2</span>：因为当外层循环确定滑动窗口大小L时，滑动窗口的移动只是改变两端字符的词频，因此不需要遍历滑动窗口改变tempMap，只需要关注两端造成的滑动窗口的词频改变，下一次移动前，计算滑动窗口hashMapS和标准t的hashMap的包含关系即可。但是，因为标准t字符串的长度可能很大，计算包含关系时，遍历标准t的hashMap造成巨大开销，在倒数第<span class="number">2</span>个测试用例上出现超时。</span><br><span class="line"><span class="number">3.</span>我的想法<span class="number">3</span>：当滑动窗口hashMapS某些元素多于标准t的hashMap时，在hashMap中减去该元素，以此减少最后计算包含关系的开销。但随着滑动窗口移动，可能又不再多于，因此不知道如何实现。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>思路<span class="number">1</span>：本题的解题思路很简单，用hashMap记录s当前子串中标准t字符的词频，先移动右指针扩展子串到满足题目，再移动左指针不断刷新minLength。前面说的“可能有不再多于”，这里是通过判断标准t字符的需求解决的：如最开始count = hashMap.size()，当移动右指针满足题目后count减少到<span class="number">0</span>，移动左指针刷新minLength致某刻count&gt;<span class="number">0</span>，说明某字符导致子串不再满足，这时就需要再移动右指针去尝试满足，直到遍历到字符串末尾。</span><br><span class="line">    这里记录下最外层<span class="keyword">while</span>循环：</span><br><span class="line">    <span class="keyword">while</span>(end&lt;s.length()||(end==s.length()&amp;&amp;count==<span class="number">0</span>))</span><br><span class="line">    (end==s.length()&amp;&amp;count==<span class="number">0</span>)是因为，当遍历到最后一个字符且满足t需求时，仍然需要移动左指针刷新minLength；(end==s.length()&amp;&amp;count!=<span class="number">0</span>)则不可，因为没法移动右指针再满足了。这种写法还能应对s和t长度均为<span class="number">1</span>的特殊情况。</span><br></pre></td></tr></table></figure>

<h3 id="018-有效的回文（125、8月20日）"><a href="#018-有效的回文（125、8月20日）" class="headerlink" title="018.有效的回文（125、8月20日）"></a>018.有效的回文（125、8月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题比较简单，就是两指针分别从开始、末尾出发，在满足左指针小于右指针的情况下，移动不是字母或数字的位置，或是在字母或数字位置判断是否回文，并同时移动指针。</span><br><span class="line"><span class="number">2.</span>常用api记录：</span><br><span class="line">	Character.isLetterOrDigit  <span class="comment">//返回Boolean,判断字符是否为字母或数字</span></span><br><span class="line">	Character.toLowerCase  <span class="comment">//返回字符小写</span></span><br></pre></td></tr></table></figure>

<h3 id="019-最多删除一个字符得到回文（680、8月20日）"><a href="#019-最多删除一个字符得到回文（680、8月20日）" class="headerlink" title="019.最多删除一个字符得到回文（680、8月20日）"></a>019.最多删除一个字符得到回文（680、8月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：设置标志位，当flag减少到-<span class="number">1</span>时跳出循环，外层循环是<span class="keyword">while</span>(i&lt;j &amp;&amp; flag&gt;=<span class="number">0</span>)，返回值是<span class="keyword">return</span> i&gt;=j。遇到一种特殊情况无法解决，即在某一刻左指针下一位等于右指针，右指针下一位也等于左指针：如<span class="string">&quot;lcupuu&quot;</span>和<span class="string">&quot;uupucul&quot;</span>，这会导致本来该移动右指针减去一个u，却使得先移动左指针减去一个c。可以想到这种情况适用回溯法。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：递归法。当不满足回文时，移动左指针或者右指针，将标志位flag设置为<span class="literal">false</span>，向下递归。</span><br><span class="line">     <span class="keyword">return</span> check(s,!flag,left+<span class="number">1</span>,right)||check(s,!flag,left,right-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="020-回文子字符串的个数（647、8月20日）"><a href="#020-回文子字符串的个数（647、8月20日）" class="headerlink" title="020.回文子字符串的个数（647、8月20日）"></a>020.回文子字符串的个数（647、8月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，做了这些滑动窗口的题目，面对这道题还是束手无策。想到从字符串中间开始往两边开滑，那么字符串中间怎么移动呢？如何应对奇数和偶数的区别呢？归根结底是没有看作窗口，滑动窗口是一个子串，需要一个外围循环确定窗口位置，窗口再向两边扩展。</span><br><span class="line"><span class="number">2.</span>这道题直接看题解了，代码非常简单，就是递归。这样就能移动以每个字符为中心的窗口，和前面的题目不同，是递归，而没有滑动窗口对应的存储结构。windowExtend实现计算以i为中心的字符串存在多少回文，或者以(i,i+<span class="number">1</span>)为中心。</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123; count += windowExtend(s,i,i); count += windowExtend(s,i,i+<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结之字符串"><a href="#总结之字符串" class="headerlink" title="总结之字符串"></a>总结之字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>api记录的复制：</span><br><span class="line">    s1.CharAt(index);  <span class="comment">//根据索引确定字符</span></span><br><span class="line">    s1.indexOf(s2);   <span class="comment">//给出子串位置</span></span><br><span class="line">    s.substring(minStart,minEnd);  <span class="comment">//返回子串，包头不包尾</span></span><br><span class="line">	String[] t = time.split(<span class="string">&quot;:&quot;</span>);  <span class="comment">//按指定字符分割String</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.join(<span class="string">&quot; &quot;</span>,t) <span class="comment">//按指定分隔符拼接一个字符串</span></span><br><span class="line">    Character.isLetterOrDigit  <span class="comment">//返回Boolean,判断字符是否为字母或数字</span></span><br><span class="line">    Character.toLowerCase  <span class="comment">//返回字符小写</span></span><br><span class="line">    hashMap.put(ch,hashMap.getOrDefault(ch,<span class="number">0</span>)+<span class="number">1</span>);  <span class="comment">//getOrDefault，如果不存在该键就返回默认值0，省去判断</span></span><br><span class="line">    <span class="type">char</span>[] charArray = s.toCharArray();  <span class="comment">//String转char[] String -&gt; char[]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(charArray);  <span class="comment">//char[]转String  char[] -&gt; String</span></span><br><span class="line"></span><br><span class="line">    result.toString();   <span class="comment">//StringBuffer类转String  StringBuffer -&gt; String</span></span><br><span class="line">  	builder.reverse().toString();  <span class="comment">//StringBuffer类转String  先对StringBuffer进行反转</span></span><br><span class="line">    result.append(x); <span class="comment">//StringBuffer添加char型元素</span></span><br><span class="line">    result.deleteCharAt(index);  <span class="comment">//StringBuffer实现根据索引删除元素</span></span><br><span class="line"><span class="number">2.</span>变位词，想到HashMap；回文，想到双指针。</span><br><span class="line"><span class="number">3.</span>StringBuffer和StringBuilder的区别</span><br><span class="line">    标准答案：前者线程安全，后者线程不安全。前者是早期Java设计者避免开发频繁写<span class="keyword">synchronized</span>代码块造成可读性和易用性降低，就把标准库中StringBuffer、Vector、Hashtable、ByteArray&#123;Input,Output&#125;Stream 等可变对象设计成线程安全的。但后来发现多个线程同时修改一个对象的场景才是少数，故后来的ArrayList、HashMap、StringBuilder等可变类不再默认线程安全，以此换取单线程下的性能提升。</span><br><span class="line"><span class="number">4.</span>字符串的比较：</span><br><span class="line">    （<span class="number">1</span>）.String a=<span class="string">&quot;abc&quot;</span>,b=<span class="string">&quot;abc&quot;</span>;   <span class="comment">//a==b将返回true，相同的字符串在内存中只会存一份，a和b都会指向“abc”常量</span></span><br><span class="line">    （<span class="number">2</span>）.String a=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); String b=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);   </span><br><span class="line">		<span class="comment">//a==b将返回false，a和b指向不同的对象</span></span><br><span class="line">		<span class="comment">//a.equals(b)是比较字符串内容是否相同</span></span><br><span class="line">		<span class="comment">//字符串值比较一定要用s.equals(&quot;0&quot;)，而不是s==&quot;0&quot;，这里s是通过&quot;&quot;+ch不断累加得到的。</span></span><br><span class="line"><span class="number">5.</span><span class="type">int</span>和String互相转换api：</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(str);	<span class="comment">//String转int</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(str).intValue();	<span class="comment">//String装int</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(n);	<span class="comment">//int转String</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toString(n);	<span class="comment">//int转String</span></span><br><span class="line"><span class="number">6.</span>ascii转换api：</span><br><span class="line">    <span class="type">char</span> <span class="variable">zimu</span> <span class="operator">=</span> (<span class="type">char</span>)(<span class="number">96</span>+<span class="number">1</span>);   <span class="comment">//结果为a</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch-<span class="string">&#x27;a&#x27;</span> <span class="comment">//结果为a的ascii编号</span></span><br><span class="line"><span class="number">7.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">8.</span><span class="type">char</span>转<span class="type">int</span>：</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(String.valueOf(charArray[i]));</span><br></pre></td></tr></table></figure>

<h2 id="第四章、链表"><a href="#第四章、链表" class="headerlink" title="第四章、链表"></a>第四章、链表</h2><h3 id="021-删除链表的倒数第n个节点（19、8月21日）"><a href="#021-删除链表的倒数第n个节点（19、8月21日）" class="headerlink" title="021.删除链表的倒数第n个节点（19、8月21日）"></a>021.删除链表的倒数第n个节点（19、8月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，前后指针。先让一个指针first跑n个节点，再让另一个指针tail和first一起跑，这样当first到达链表末尾时，tail正好到达倒数第n个节点的前一个节点。设置dummy节点，将帮助更好理解第n个以及处理单节点输入的特殊情况。这道题调试几次就对了。</span><br></pre></td></tr></table></figure>

<h3 id="022-链表中环的入口节点（142、8月21日）"><a href="#022-链表中环的入口节点（142、8月21日）" class="headerlink" title="022.链表中环的入口节点（142、8月21日）"></a>022.链表中环的入口节点（142、8月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：一个指针遍历到某位置，下个指针从该位置开始遍历，直到与第一个指针重合。但是，循环链表没有<span class="literal">null</span>，导致循环无法停止。</span><br><span class="line"><span class="number">2.</span>我的想法<span class="number">2</span>：将链表节点放入HashSet，当再次遍历到且HashSet已经存储某节点时，就说明该节点是循环链表的入口。如果遍历链表时遇到<span class="literal">null</span>节点，说明该链表不是循环链表。注意，Set&lt;ListNode&gt;而不是Set&lt;Integer&gt;，因为测试用例中存在相同值的不同节点。</span><br><span class="line"><span class="number">3.</span>我在想，能快速写出测试用例、方便调试也算能力吧。</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>思路<span class="number">2</span>：快慢指针。如果链表中有环，快慢两个指针必然会在环中某个节点相遇。假设快指针走两步、慢指针走一步，相遇时慢指针走了k步，快指针走了2k步，到相遇时快指针比慢指针多走k步，那么k必然是环中节点数目的整数倍，那么非环部分a+没走满的部分b=节点数目整数倍，假如一个指针headA从头节点出发，另一个指针headB从相遇慢指针的k位置出发，相同速度均为一步，那么它们都需要走a个单位到达环入口。</span><br><span class="line"><span class="number">5.</span>证明：快慢指针。设链表中环外部分的长度为a，slow指针进入环后，又走了b的距离与fast相遇，还剩c的距离凑够完整环。此时，fast指针已经走完了n圈，总距离为a+n(b+c)+b，而fast指针速度为<span class="number">2</span>，slow指针速度为<span class="number">1</span>，故有：</span><br><span class="line">    a+n(b+c)+b = <span class="number">2</span>(a+b)  -&gt;  a=c+(n-<span class="number">1</span>)(b+c)</span><br><span class="line">-&gt; 从相遇点到入环点的距离加上 n-<span class="number">1</span> 圈的环长，恰好等于从链表头部到入环点的距离。</span><br></pre></td></tr></table></figure>

<h3 id="023-两个链表的第一个重合节点（160、8月21日）"><a href="#023-两个链表的第一个重合节点（160、8月21日）" class="headerlink" title="023.两个链表的第一个重合节点（160、8月21日）"></a>023.两个链表的第一个重合节点（160、8月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：将链表节点放入HashSet。headA链表先遍历一遍，将节点放入hashSet，再遍历headB链表，当遍历到hashSet中已有节点时，说明该节点是重合节点，否则，返回<span class="literal">null</span>。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：快慢指针。假设链表headA=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]，链表headB=[<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],那么可以让链表headB变为环（headB的尾节点next指向headB的头节点），整个链表变为[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]，其中<span class="number">8</span>指向<span class="number">4</span>，问题转换为寻找链表环的入口节点。但这样会改变链表结构。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>：栈。将两个链表压入两个栈，弹栈顶比较元素，直到最后一个相同元素，即从后往前比较。扩展这一想法，可以先求得两个链表的长度，将长的链表先移动d位差值，然后两个链表再同时同速度移动，这样就能同时到达交叉位置。</span><br></pre></td></tr></table></figure>

<h3 id="024-反转链表（206、8月22日）"><a href="#024-反转链表（206、8月22日）" class="headerlink" title="024.反转链表（206、8月22日）"></a>024.反转链表（206、8月22日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，遍历链表节点并压栈，弹栈后在最后一个元素后接<span class="literal">null</span>。这里记录下栈相关api:</span><br><span class="line">	Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	peek()：返回栈顶的值 ；不改变栈的值，查看栈顶的对象而不移除它。</span><br><span class="line">	pop()：Stack(栈)的方法，返回栈顶的值 ；会把栈顶的值删除。</span><br><span class="line">	poll：Queue(队列)的一个方法，获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：迭代法。遍历时维护两个指针prev和cur，每轮遍历将cur.next存储起来，将cur.next修改为指向prev后，完成向前连接；接着将prev指向cur，将cur指向储存的cur.next提供下一轮遍历条件。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>：递归法，先不做。</span><br></pre></td></tr></table></figure>

<h3 id="025、链表中的两数相加（445、8月22日）"><a href="#025、链表中的两数相加（445、8月22日）" class="headerlink" title="025、链表中的两数相加（445、8月22日）"></a>025、链表中的两数相加（445、8月22日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，维护两个栈l1stack和l2stack，遍历两个链表并压栈，弹栈时求和，注意将最后的进位添加节点。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：先用<span class="number">24</span>题迭代法反转两个链表，再按照相同的加法逻辑求和。</span><br></pre></td></tr></table></figure>

<h3 id="026、重排链表（143、8月22日）"><a href="#026、重排链表（143、8月22日）" class="headerlink" title="026、重排链表（143、8月22日）"></a>026、重排链表（143、8月22日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：观察图示，即将链表转换为正向、逆向交替添加到链表。只需要将链表反转压栈，通过栈求得链表长度，按照链表长度遍历索引，如果索引模<span class="number">2</span>余<span class="number">0</span>则正向添加链表节点，如果索引模<span class="number">2</span>余<span class="number">1</span>则弹栈添加逆向链表节点，在外部修改链表结构并不会影响弹栈顺序，且弹栈后会直接修改next指针。注意将最后一个元素后接<span class="literal">null</span>避免环状链表，以及修改head指针指向dummy.next（因为函数返回<span class="keyword">void</span>）。</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)  <span class="comment">//因为目标建立len长度的链表，正向和逆向在结束时，实际都只遍历一半</span></span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：线性表。通过线性表的特定按顺序交替获取元素。</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ListNode&gt;();  <span class="comment">//线性表建表</span></span><br><span class="line">        list.get(i).next = list.get(j);		<span class="comment">//线性表获取元素</span></span><br><span class="line"><span class="number">3.</span>寻找链表中点（通过快慢指针） + 链表逆序 + 合并链表，先不做，和我的想法本质一样，但更加节省空间。</span><br></pre></td></tr></table></figure>

<h3 id="027、回文链表（234、8月22日）"><a href="#027、回文链表（234、8月22日）" class="headerlink" title="027、回文链表（234、8月22日）"></a>027、回文链表（234、8月22日）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法：遍历链表节点并压栈。在外围循环为for(int i=0;i&lt;len/2;i++)的情况下，遍历链表并同时弹栈，观察到node.val不相等时返回false，否则循环结束返回true。为什么是len/2，nodes = [1,2,3,2,1]，len=5，&lt;5/2 = &#123;0,1&#125;。</span><br><span class="line">2.思路2：递归法，先不做。</span><br></pre></td></tr></table></figure>

<h3 id="028、展平多级双向链表（430、8月23日）"><a href="#028、展平多级双向链表（430、8月23日）" class="headerlink" title="028、展平多级双向链表（430、8月23日）"></a>028、展平多级双向链表（430、8月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题目在看到它的序列化输入时，就已经被震慑住了。看书后明白，就是链表的节点既维护双向链表的两个指针prev和next，还维护一个指向子链表的指针child，题目需求是将子链表向上整合到原链表的两个节点之间。因此是典型的递归操作。</span><br><span class="line"><span class="number">2.</span>看懂题解后复现比较简单，就是维护当前链表遍历指针node和尾指针tail，通过node遍历链表时，如果该节点存在子节点child，维护指针Child存储node.child，将node.child置为<span class="literal">null</span>，并通过Child指针递归寻找链尾，在每轮遍历将tail指向新表尾。</span><br></pre></td></tr></table></figure>

<h3 id="029、排序的循环链表（708、8月24日）"><a href="#029、排序的循环链表（708、8月24日）" class="headerlink" title="029、排序的循环链表（708、8月24日）"></a>029、排序的循环链表（708、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法:这道题就是在循环链表中，按照大小顺序插入链表。通过<span class="keyword">while</span>(tail.next!=head)遍历链表节点，会遇到两种情况：</span><br><span class="line">    a.插入节点位于从小到大链表的中间</span><br><span class="line">    	<span class="keyword">if</span>(insertVal &gt;= tail.val &amp;&amp; insertVal &lt;= tail.next.val)</span><br><span class="line">    b.插入节点位于从小到大链表的开始或末尾</span><br><span class="line">    	<span class="keyword">if</span>(tail.val&gt; tail.next.val)</span><br><span class="line">                <span class="keyword">if</span>(insertVal &gt;= tail.val || insertVal &lt;= tail.next.val)</span><br><span class="line">    在这两种情况下<span class="keyword">break</span>，在当前遍历节点tail后添加插入节点即可。如果插入节点在链尾，tail.next=head，逻辑仍然是在tail后添加插入节点。</span><br></pre></td></tr></table></figure>

<h3 id="总结之链表"><a href="#总结之链表" class="headerlink" title="总结之链表"></a>总结之链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>api记录的复制：</span><br><span class="line">    Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        peek()：返回栈顶的值 ；不改变栈的值，查看栈顶的对象而不移除它。</span><br><span class="line">        pop()：Stack(栈)的方法，返回栈顶的值 ；会把栈顶的值删除。</span><br><span class="line">        poll：Queue(队列)的一个方法，获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。</span><br><span class="line">    List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ListNode&gt;();  <span class="comment">//线性表建表</span></span><br><span class="line">    	list.get(i).next = list.get(j);		<span class="comment">//线性表获取元素</span></span><br><span class="line"><span class="number">2.</span>反转链表有两种方法：其一，维护prev、cur和temp三个指针，其中temp是为了cur.next修改为指向prev时，temp存储cur.next避免破坏链表的结构；其二、遍历链表节点并压栈，弹栈构造反转链表。反转链表后，需要注意在最后一个元素后接<span class="literal">null</span>，避免环状。</span><br><span class="line"><span class="number">3.</span>添加虚节点dummy有助于避免头节点造成的边界特殊情况，用临时指针tail遍历不会改变链表结构：</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();  ... <span class="keyword">return</span> dummy.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummy;</span><br><span class="line"><span class="number">4.</span>前后双指针、快慢双指针、虚节点、接<span class="literal">null</span>避免产生环状、反转链表。</span><br></pre></td></tr></table></figure>

<h2 id="第二章、数组"><a href="#第二章、数组" class="headerlink" title="第二章、数组"></a>第二章、数组</h2><h3 id="006、排序数组中两个数字之和（167、8月24日）"><a href="#006、排序数组中两个数字之和（167、8月24日）" class="headerlink" title="006、排序数组中两个数字之和（167、8月24日）"></a>006、排序数组中两个数字之和（167、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：双指针。&gt;target向左移动右指针，&lt;target向右移动左指针，外层<span class="keyword">while</span>循环避免两指针相遇，=target时跳出循环。</span><br></pre></td></tr></table></figure>

<h3 id="007、数组中和为0的三个数（15、8月24日）"><a href="#007、数组中和为0的三个数（15、8月24日）" class="headerlink" title="007、数组中和为0的三个数（15、8月24日）"></a>007、数组中和为0的三个数（15、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：双指针。首先通过Arrays.sort(nums)将数组变为有序数组，通过<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)让第一个数确定外层循环，再维护left、right双指针，按照第<span class="number">6</span>题中求两数之和的方法确定指针位置。这是第<span class="number">2</span>次做这道题，做出来比较容易，只需注意每层循环都应该有这个去重逻辑：</span><br><span class="line">    <span class="keyword">if</span>(left!=i+<span class="number">1</span>&amp;&amp;nums[left]==nums[left-<span class="number">1</span>])&#123;</span><br><span class="line">      left++;   </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="008、-和大于等于-target-的最短子数组（209、8月24日）"><a href="#008、-和大于等于-target-的最短子数组（209、8月24日）" class="headerlink" title="008、 和大于等于 target 的最短子数组（209、8月24日）"></a>008、 和大于等于 target 的最短子数组（209、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：双指针。先移动右指针使sum&gt;target，再移动左指针使sum&lt;target来缩小子数组长度，最后返回right-left+<span class="number">1</span>。问题是，假如输入是[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]，右指针提前在第二个<span class="number">2</span>上停下，就会得到长度为<span class="number">4</span>的答案，实际应该在<span class="number">3</span>停下且答案为<span class="number">2</span>。可以发现，</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，双指针。改进我的思路，应该不要让右指针停下，而是在不断向右遍历直到结束；每找到答案，就在当前位置通过左指针求子数组（左指针移动会被保留），通过Math.min(result, end - start + <span class="number">1</span>)更新result。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，前缀和+二分查找，先不做。</span><br><span class="line"><span class="number">4.</span>这是第二次遇见这种思路的题，最开始写得时候不知道外围循环咋写，是按长度遍历，还是按右指针遍历。现在知道了，要按右指针遍历，解法是在每一个满足条件的右指针下更新左指针并比较result是否更小。</span><br></pre></td></tr></table></figure>

<h3 id="009、乘积小于k的子数组（713、8月26日）"><a href="#009、乘积小于k的子数组（713、8月26日）" class="headerlink" title="009、乘积小于k的子数组（713、8月26日）"></a>009、乘积小于k的子数组（713、8月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">2</span>，滑动窗口。维护双指针left、right，按右指针遍历，当累计乘积大于k后，更新左指针至小于k，统计滑动窗口内的子数组数目。这里要统计的子数组数目，是以right指针结尾的子数组，因此有(right-left+<span class="number">1</span>)个。</span><br><span class="line">	a.不以right结尾的在前面已经统计过了;</span><br><span class="line">	b.以right结尾，以更左的left开头的子数组是不存在的;</span><br><span class="line">  这道题结构写对了，对滑动窗口固定写法比较熟悉，但是想不出来如何统计子数组的数目，想不到(right-left+<span class="number">1</span>)。</span><br></pre></td></tr></table></figure>

<h3 id="010、和为k的子数组（560、8月26日）"><a href="#010、和为k的子数组（560、8月26日）" class="headerlink" title="010、和为k的子数组（560、8月26日）"></a>010、和为k的子数组（560、8月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：滑动窗口。按右指针遍历，当成绩不等于k后，更新左指针至等于k，并在更新过程中记录满足条件的数目。但是遇到了[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>]这种输入，对于以<span class="number">0</span>结尾的right指针子数组，存在[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>]和[<span class="number">0</span>]两种满足条件的情况，在前面算法中只会被记录<span class="number">1</span>次。书里说“双指针解决数组之和的前提是，数组中的所有数字都是正数”。</span><br><span class="line"><span class="number">2.</span>我的想法，暴力破解。按右指针遍历，将当前sum拷贝到tempSum中；在每一个右指针下移动左指针，同时减小tempSum，记录等于k的情况。	<span class="keyword">for</span>(<span class="type">int</span> left=<span class="number">0</span>;left&lt;right;left++) &#123;</span><br><span class="line">    	tempSum -= nums[left];</span><br><span class="line">    	<span class="keyword">if</span>(tempSum==k) result+=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，前缀和+哈希表优化。因为[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]之和+[<span class="number">4</span>,<span class="number">5</span>]之和=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]之和，故维护HashMap记录键值对&lt;当前和,次数&gt;，这样[<span class="number">4</span>,<span class="number">5</span>]=<span class="number">9</span>就能通过<span class="number">15</span>-[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]记录这个次数。需要注意，最开始map.put(<span class="number">0</span>,<span class="number">1</span>)，即应对第一个数字为k的情况。</span><br></pre></td></tr></table></figure>

<h3 id="011、0和1个数相同的子数组（525、8月26日）"><a href="#011、0和1个数相同的子数组（525、8月26日）" class="headerlink" title="011、0和1个数相同的子数组（525、8月26日）"></a>011、0和1个数相同的子数组（525、8月26日）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法：虽然看了题解知道这道题和第10题想法相同，但还是不会做。只知道这种古老的Math.max在召唤我。</span><br><span class="line">2.思路1：前缀和+哈希表优化。首先很巧妙的是把0转换成-1，这样某段子数组0和1数目相同时，就有[1,2,3]之和+[4,5]之和=[1,2,3,4,5]之和的效果，因为[4,5]此时-1和1恰巧相互抵消，[1,2,3]和[1,2,3,4,5]的累计和sum相同。这样只需维护hashMap&lt;sum,出现位置&gt;，当sum再次出现时，记录其和第一次出现位置的差值，这样就能不断通过Math.max更新最长长度。这道题思路比较特殊在：</span><br><span class="line">	a.把0转换成-1，子数组满足条件时累计和为0；</span><br><span class="line">	b.map.put(0,-1);  因为道理上应该子数组是（sum第一次出现的下一位，本位），所以每次放入本位，第一次放入-1位。</span><br></pre></td></tr></table></figure>

<h3 id="012、左右两边子数组的和相等（724、8月27日）"><a href="#012、左右两边子数组的和相等（724、8月27日）" class="headerlink" title="012、左右两边子数组的和相等（724、8月27日）"></a>012、左右两边子数组的和相等（724、8月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：维护两个整型和：leftSum和rightSum，先遍历数组将rightSum设置为数组中全部元素求和，然后第二次遍历数组，每轮遍历先将本位在rightSum中剔除，再比较leftSum和rightSum，最后在leftSum加上本位。因为本位不参与左右数组求和。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：前缀和。先给整体数组求和得total，那这时就有如下关系式，无需维护leftSum：</span><br><span class="line">	<span class="keyword">if</span>(sum-nums[i] == total-sum)</span><br></pre></td></tr></table></figure>

<h3 id="013、二维子矩阵的和（304、8月27日）"><a href="#013、二维子矩阵的和（304、8月27日）" class="headerlink" title="013、二维子矩阵的和（304、8月27日）"></a>013、二维子矩阵的和（304、8月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：暴力破解。维护整型sum，设置两层循环不要越界即可。看其他解答好难得样子？</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=row1;i&lt;=row2;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=col1;j&lt;=col2;j++)</span><br><span class="line">                sum += matrix[i][j];</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：前缀和。维护二维数组<span class="type">int</span>[][] sums，在构造函数中给每一行求前缀和并存储，在计算子矩阵求和时，只需列下标、通过前缀和思想求得子矩阵每一行的和。这一解法中定义sums如下：</span><br><span class="line">    定义时：sums = <span class="keyword">new</span> <span class="title class_">int</span>[Length][rowLength+<span class="number">1</span>];</span><br><span class="line">    构造时：sums[i][j+<span class="number">1</span>] = matrix[i][j] + sums[i][j];</span><br><span class="line">    使用时：sum += sums[i][col2+<span class="number">1</span>]-sums[i][col1];</span><br><span class="line">	因为不能像原来hashMap解决前缀和问题是，直接map.put(<span class="number">0</span>,-<span class="number">1</span>)这种处理首位，所以数组扩列。</span><br><span class="line"><span class="number">3.</span>由衷感叹，前缀和中对第一位元素处理和边界想象都是难搞的。现在都是写出算法结构后想不出来，调也调不出来，只能看题解的边界处理。</span><br></pre></td></tr></table></figure>

<h3 id="总结之数组"><a href="#总结之数组" class="headerlink" title="总结之数组"></a>总结之数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>最短子数组和子串问题：要按右指针遍历，解法是在每一个满足条件的右指针下更新左指针并比较result是否更小。</span><br><span class="line"><span class="number">2.</span>数组中和为<span class="number">0</span>的x个数问题中的去重逻辑：<span class="keyword">if</span>(left!=i+<span class="number">1</span>&amp;&amp;nums[left]==nums[left-<span class="number">1</span>])&#123;	left++;   <span class="keyword">continue</span>;&#125;</span><br><span class="line"><span class="number">3.</span>前缀和问题：任何位置子数组的求和，都能通过两个前缀和的相减得到，一般通过hashMap存储前缀和位置或次数，边界问题需要调试。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>数组操作相关api记录复制：</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]);  <span class="comment">//将二维数组intervals中的数组，按照索引0位置大小排序</span></span><br><span class="line">	<span class="comment">//将List转换为二维数组，需要先定义有外层初值的二维数组resultArray，再调用toArray API</span></span><br><span class="line">	List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	<span class="type">int</span>[][] resultArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][];</span><br><span class="line">	resultArray = result.toArray(resultArray);</span><br><span class="line"><span class="number">5.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="第一章、整数"><a href="#第一章、整数" class="headerlink" title="第一章、整数"></a>第一章、整数</h2><h3 id="001、整数除法（29、8月31日）"><a href="#001、整数除法（29、8月31日）" class="headerlink" title="001、整数除法（29、8月31日）"></a>001、整数除法（29、8月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>你是故意找茬是不是？直接面向结果编程。它好像是做倍数运算，介于<span class="number">3</span>倍到<span class="number">4</span>倍时就选<span class="number">3</span>倍，再继续对余数重复这一过程，还要考虑<span class="type">int</span>型<span class="number">32</span>位溢出的情况。  </span><br></pre></td></tr></table></figure>

<h3 id="002、二进制加法（67、8月31日）"><a href="#002、二进制加法（67、8月31日）" class="headerlink" title="002、二进制加法（67、8月31日）"></a>002、二进制加法（67、8月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>：模拟。这道题和前面链表中的两数相加解法相同。需要注意在余数和进位上的处理。另外，这道题不同于链表上的<span class="type">int</span>型整数，需要做ascii码上的减法确定其数值：</span><br><span class="line">    sum += i&gt;=<span class="number">0</span>?a.charAt(i--)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="003、前n个数字二进制中1的个数（338、8月31日）"><a href="#003、前n个数字二进制中1的个数（338、8月31日）" class="headerlink" title="003、前n个数字二进制中1的个数（338、8月31日）"></a>003、前n个数字二进制中1的个数（338、8月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>：按位与运算。i&amp;(i-<span class="number">1</span>)能将整数i最右边的<span class="number">1</span>变成<span class="number">0</span>。比如<span class="number">1100</span>，减<span class="number">1</span>会造成最右边的<span class="number">1</span>借位得到<span class="number">1011</span>，这样<span class="number">1100</span>&amp;<span class="number">1011</span>=<span class="number">1000</span>，就会使最右边的<span class="number">1</span>变成<span class="number">0</span>，这样循环往复知道<span class="number">1100</span>等于<span class="number">0</span>，循环次数就是<span class="number">1100</span>中<span class="number">1</span>的数目。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：动态规划。由上面关系知，i比i&amp;(i-<span class="number">1</span>)要多一个<span class="number">1</span>，这时就能写状态转移方程：</span><br><span class="line">	result[i] = result[i &amp; (i-<span class="number">1</span>)] + <span class="number">1</span>;  <span class="comment">//此时边界上，result[1] == result[2] = result[0]+1;</span></span><br><span class="line"><span class="number">3.</span>这道题就先记住这两种思路，关键是i&amp;(i-<span class="number">1</span>)会做掉最右边的<span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<h3 id="004、只出现1次的数字（137、9月1日）"><a href="#004、只出现1次的数字（137、9月1日）" class="headerlink" title="004、只出现1次的数字（137、9月1日）"></a>004、只出现1次的数字（137、9月1日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，哈希表。维护一个hashMap，当遇到旧键时就删除或者减少次数，当遇到新键时就往hashMap中添加(新键, <span class="number">2</span>)，最后hashMap中只剩目标键将其取出即可。（思路<span class="number">1</span>，当然也可以正向做，最后遍历找值为<span class="number">1</span>的键。）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，按位累加运算。</span><br><span class="line">    a.将数组中所有数字同一位置的数位相加，由于其他数都会出现<span class="number">3</span>次，故能被<span class="number">3</span>整除；</span><br><span class="line">    b.但是，目标数只出现<span class="number">1</span>次，因此它的该数位为<span class="number">1</span>时，全部数字该数位累加和mod3余<span class="number">1</span>，它的该数位为<span class="number">0</span>时，全部数字该数位累加和mod3余<span class="number">0</span>；</span><br><span class="line">    c.因此，能从全部数字数位级累加和mod3的结果上，直接推导出目标数字。</span><br><span class="line">需要记住：</span><br><span class="line">    按位累加：bitSums[i] += (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;</span><br><span class="line">	组合结果：result = (result&lt;&lt;<span class="number">1</span>)+bitSums[i]%<span class="number">3</span>;</span><br><span class="line"><span class="number">3.</span>题外话。任何一个数字异或它自己的结果都是<span class="number">0</span>，能解“目标只出现<span class="number">1</span>次，其他出现<span class="number">2</span>次”的题目。</span><br></pre></td></tr></table></figure>

<h3 id="005、单词长度的最大乘积（318、9月1日）"><a href="#005、单词长度的最大乘积（318、9月1日）" class="headerlink" title="005、单词长度的最大乘积（318、9月1日）"></a>005、单词长度的最大乘积（318、9月1日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，按位与运算。</span><br><span class="line">    a.将字符串转换为整数，比如字符串中包含<span class="string">&#x27;a&#x27;</span>，就将整数的倒数第<span class="number">1</span>位置为<span class="number">1</span>，如果字符串中包含<span class="string">&#x27;b&#x27;</span>，就将整数的倒数第<span class="number">2</span>位置为<span class="number">1</span>；</span><br><span class="line">    b.这样两个字符串如果包含相同的字符，其转换得到的整数相与时必然不会为<span class="number">0</span>，比如字符串<span class="number">1</span>有<span class="string">&#x27;a&#x27;</span>，字符串<span class="number">2</span>没有<span class="string">&#x27;a&#x27;</span>，这样<span class="number">1</span>&amp;<span class="number">0</span>=<span class="number">0</span>，只有<span class="number">1</span>&amp;<span class="number">1</span>=<span class="number">1</span>；</span><br><span class="line">需要记住：</span><br><span class="line">    记录字符串中的字符构成（不涉及次数）：  flags[i] |= <span class="number">1</span>&lt;&lt;(ch-<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="整数之总结"><a href="#整数之总结" class="headerlink" title="整数之总结"></a>整数之总结</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>基本数据类型：</span><br><span class="line">	<span class="number">4</span>种整数类型：<span class="number">8</span>位的<span class="type">byte</span>，<span class="number">16</span>位的<span class="type">short</span>，<span class="number">32</span>位的<span class="type">int</span>，<span class="number">64</span>位的<span class="type">long</span>;</span><br><span class="line">	<span class="number">2</span>种浮点类型：<span class="number">32</span>位的<span class="type">float</span>（储存<span class="number">8</span>位有效数字），<span class="number">64</span>位的<span class="type">double</span>(储存<span class="number">16</span>位有效数字)；</span><br><span class="line">	<span class="number">1</span>种逻辑类型：<span class="type">boolean</span></span><br><span class="line">	<span class="number">1</span>种字符类型：<span class="number">16</span>位的<span class="type">char</span></span><br><span class="line"><span class="number">2.</span>java中变量都是以补码的形式保存的。原码就是二进制码，其最高位为符号位；正数反码是它本身，负数反码是除符号位全部按位取反；正数的补码是它本身，负数补码是反码加一。注意：除符号位，除符号位，除符号位，按位取反。</span><br><span class="line"><span class="number">3.</span>二进制位运算有<span class="number">6</span>种，与&amp;、或|、非~、异或^、左移&lt;&lt;、右移&gt;&gt;(无符号异或，&gt;&gt;&gt;)。</span><br><span class="line"><span class="number">4.</span>位运算常用技巧：</span><br><span class="line">	i&amp;(i-<span class="number">1</span>)		<span class="comment">//能将整数i最右边的1变成0。1100&amp;1011=1000，因为最右边的1负责借位</span></span><br><span class="line">	i&gt;&gt;<span class="number">1</span>         <span class="comment">//计算i/2  如3==1，11&gt;&gt;1=01=1，即3/2=1</span></span><br><span class="line">	i&amp;<span class="number">1</span>          <span class="comment">//计算i%2  如3==11，11&amp;01=01=1，即3%2=1</span></span><br><span class="line">	bitSums[i] += (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;   <span class="comment">//按位累加多个数字</span></span><br><span class="line">	result = (result&lt;&lt;<span class="number">1</span>)+bitSums[i]%<span class="number">3</span>;   <span class="comment">//按需求（mod3）组合结果为int</span></span><br><span class="line">	flags[i] |= <span class="number">1</span>&lt;&lt;(ch-<span class="string">&#x27;a&#x27;</span>);	<span class="comment">//记录字符串中的字符构成</span></span><br><span class="line">	mid -= mid &amp; <span class="number">1</span>;  <span class="comment">//小于等于mid的最后一个偶数</span></span><br><span class="line"><span class="number">5.</span>二进制位运算时，最好加上括号，这里应该涉及到优先级。比如，<span class="keyword">if</span>((flags[i]&amp;flags[j])==<span class="number">0</span>)。</span><br><span class="line"><span class="number">6.</span>利用整型位运算相关的思路求解问题，很多技巧都难以想到，只能说尽量熟悉。</span><br><span class="line"><span class="number">7.</span><span class="type">int</span>/<span class="type">int</span> = <span class="type">int</span>; <span class="type">double</span>/<span class="type">int</span>=<span class="type">double</span>; <span class="type">int</span>*<span class="type">double</span>=<span class="type">double</span>;可以通过(类型)进行强制类型转换。</span><br></pre></td></tr></table></figure>

<h2 id="第五章、哈希表"><a href="#第五章、哈希表" class="headerlink" title="第五章、哈希表"></a>第五章、哈希表</h2><h3 id="030、插入、删除和随机访问都是O-1-的容器（380、8月28日）"><a href="#030、插入、删除和随机访问都是O-1-的容器（380、8月28日）" class="headerlink" title="030、插入、删除和随机访问都是O(1)的容器（380、8月28日）"></a>030、插入、删除和随机访问都是O(1)的容器（380、8月28日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>，我的想法，调用HashSet官方API，但是没有提供getRandom类似的方法。看书后发现哈希表这章，强调的是，利用哈希表设计更加高级、更加复杂的数据结构。因此，调用官方API是可以的，但需要想新的功能怎么实现。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，这里维护一个HashMap和ArrayList。arrayList存储元素，hashMap存储元素和其在arrayList的位置。</span><br><span class="line">	a.插入元素。直接在arrayList末尾插入，并在hashMap中记录位置，时间复杂度O(<span class="number">1</span>);</span><br><span class="line">	b.删除元素。</span><br><span class="line">		首先通过hashMap找到目标元素在arrayList中的位置，并删除目标元素，时间复杂度O(<span class="number">1</span>)；</span><br><span class="line">		在hashMap中，将arrayList末尾元素的位置修改为上一步存储的位置；</span><br><span class="line">		通过nums.set直接用末尾元素覆盖目标位置，时间复杂度O(<span class="number">1</span>)；</span><br><span class="line">		在nums中，删除末尾元素；</span><br><span class="line">	c.随机访问</span><br><span class="line">		这道题在hashMap外加上数组，就是因为数组能实现而hashMap不能实现随机访问</span><br><span class="line">		产生一个随机整数API：<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(nums.size());</span><br><span class="line"><span class="number">3.</span>需要思考的地方：通过外加数组实现随机访问，通过用末位元素替换而不是数组移动实现删除O(<span class="number">1</span>)。</span><br></pre></td></tr></table></figure>

<h3 id="031、最近最少使用缓存（146、9月1日）"><a href="#031、最近最少使用缓存（146、9月1日）" class="headerlink" title="031、最近最少使用缓存（146、9月1日）"></a>031、最近最少使用缓存（146、9月1日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，维护两个HashMap。cache存储键值对，LRU存储键和使用次数的映射。进行get和put操作时，都会在LRU中增加相应键的使用次数。当要put新键且cache.size()==capacity时，遍历LRU寻找最小使用次数的键，将该键对应的键值对在cache和LRU中移除。但是，这种结构没法在LRU中比较相同使用次数的键。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，哈希表+双向链表，LinkedHashMap。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，哈希表+双向链表，自己实现。</span><br><span class="line">	a.首先定义双向链表节点DlinkedNode；</span><br><span class="line">	b.定义LRU私有变量，包括当前容量size，限定容量capacity，缓存hashMap&lt;Integer,DlinkedNode&gt;，以及双向链表虚节点head、tail；缓存hashMap是为了定位当前键对应的节点，真正的顺序由双向链表维护；</span><br><span class="line">	c.get操作：从hashMap取出节点后，将节点放在双向链表的表头（删除原位置，放到表头）；</span><br><span class="line">	d.put操作：如果hashMap中有该键，则修改节点值、放到表头即可；如果hashMap中没有该键，则新建节点将其放入hashMap，并将其放到链表头部，如果造成超过capacity，则将tail节点前一节点在链表和hashMap删除；</span><br><span class="line"><span class="number">4.</span>思路<span class="number">2</span>中的双向链表首位都是虚节点，这和前面单链表中单独的dummy节点有所区别。</span><br></pre></td></tr></table></figure>

<h3 id="032、有效的变位词（242、9月2日）"><a href="#032、有效的变位词（242、9月2日）" class="headerlink" title="032、有效的变位词（242、9月2日）"></a>032、有效的变位词（242、9月2日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，哈希表。先将字符串s的所有字符放入hashMap，再用字符串t的字符减小hashMap中的值，减小到<span class="number">0</span>时删除该键。如果不存在某键，或者最终hashMap没空，则返回<span class="literal">false</span>。要考虑的情况：</span><br><span class="line">	a.对于条件“字符顺序不完全相同”，并不需要记录字符位置，只需s.equals(t)排除完全相同的情况；</span><br><span class="line">	b.对于字符串t提前结束，hashMap中仍有键值，只需s.length()!=t.length()排除这种情况；</span><br><span class="line">	故可以通过下面的代码简化我的想法，不用再判断hashMap.size==<span class="number">0</span>：</span><br><span class="line">		<span class="keyword">if</span>(s.length()!=t.length()||s.equals(t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h3 id="033、变位词组（49、9月2日）"><a href="#033、变位词组（49、9月2日）" class="headerlink" title="033、变位词组（49、9月2日）"></a>033、变位词组（49、9月2日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，转换为数字进行位元素。看到整型第<span class="number">5</span>题后，发现转会为数字，只能记录字符构成，不包含字符次数，遂放弃。看题解有用质数代替字符的，字符串转变为质数乘积，这样只有唯一质数分解，故能通过积分类同位词。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：哈希表。将变位词排序，如<span class="string">&quot;eta&quot;</span>、<span class="string">&quot;tea&quot;</span>和<span class="string">&quot;ate&quot;</span>都映射成<span class="string">&quot;aet&quot;</span>，这样维护一个HashMap&lt;String,List&lt;String&gt;&gt;，就能在一次遍历中把变位词根据其键放到对应列表中。</span><br><span class="line">	注意,<span class="type">char</span>[]转String是String.valueOf(strArray)，而不是strArray.toString()，StringBuffer转String才是buffer.toString()。Arrays.sort(strArray)能直接将<span class="type">char</span>[]按照字母顺序修改排序。</span><br><span class="line">	hashmap.putIfAbsent(key, value);	<span class="comment">//先判断指定的键（key）是否存在，不存在则将键/值对插入到HashMap中。</span></span><br></pre></td></tr></table></figure>

<h3 id="034、外星语言是否排序（953、9月6日）"><a href="#034、外星语言是否排序（953、9月6日）" class="headerlink" title="034、外星语言是否排序（953、9月6日）"></a>034、外星语言是否排序（953、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，暴力破解。根据字母表将其顺序放入hashMap，从左到右对比相邻字符串；依此取两个字符串的字母，对比其在haspMap中的位置，如果相等则继续至某字符串结束；只有前一字符串先结束才说明字符顺序正确。</span><br><span class="line"><span class="number">2.</span>本题需要记住，对比字符串a和b时，</span><br><span class="line">    a.如果a[i]&lt;b[i]，那就不用再比较了，即使a更长在这一刻它已经输了，我第一次时潜意识以为更小和相等时都需要再比下去；</span><br><span class="line">    b.同理，如果a[i]&gt;b[i]那也不用再比较了，只有二者一直相等才先结束的更小；</span><br></pre></td></tr></table></figure>

<h3 id="035、最小时间差（539、9月6日）"><a href="#035、最小时间差（539、9月6日）" class="headerlink" title="035、最小时间差（539、9月6日）"></a>035、最小时间差（539、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，排序。将n个时间配许，排序之后就计算两相邻时间的间隔。需注意的情况是，要把排序数组的第<span class="number">1</span>位时间和最后<span class="number">1</span>位时间的时间间隔考虑在内，因为它对应着“<span class="number">00</span>:<span class="number">00</span>”这种时间是第二天的最小情况。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：用数组代替排序。因为一天有<span class="number">1440</span>分钟，可以用长度为<span class="number">1440</span>的<span class="type">boolean</span>数组记录List&lt;String&gt;中的所有时间。这里记录几个处理通用情况的手段：</span><br><span class="line">    a.遍历<span class="type">boolean</span>数组时，因为要计算与上一时间的时间间隔，第一位没有上一时间，这样处理：</span><br><span class="line">    	<span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;timeList.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(timeList[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(prev&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    minGap = Math.min(i-prev,minGap);</span><br><span class="line">                &#125; prev=i;...&#125;&#125;</span><br><span class="line">	b.因为要记录<span class="type">boolean</span>数组中第一个为<span class="literal">true</span>和最后一个为<span class="literal">true</span>的元素索引，这样处理（即初始为大往小取or相反）：</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> timeList.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		...</span><br><span class="line">        first = Math.min(first,i);</span><br><span class="line">        last = Math.max(last,i);</span><br></pre></td></tr></table></figure>

<h3 id="总结之哈希表"><a href="#总结之哈希表" class="headerlink" title="总结之哈希表"></a>总结之哈希表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>LRU的实现是：hashMap&lt;Integer,DlinkedNode&gt; + DlinkedNode双向链表，表头添加，表尾删除。其中双向链表定义时，要定义首尾两个虚节点head、tail，这与单链表中单独的dummy节点有所区别。这道题比较有代表性，估计下次还是很难直接做出来。</span><br><span class="line"><span class="number">2.</span>LinkedHashMap的使用：继承LinkedHashMap，重写removeEldestEntry方法，写出用于“删除最早添加节点”的布尔表达式。</span><br><span class="line"><span class="number">3.</span>如果哈希表的键取值范围固定，并不是很大，则可以用数组模拟哈希表。例如，单词中只包含英文小写字母，那么就可以用一个长度为<span class="number">26</span>的数组来模拟这个哈希表。</span><br><span class="line"><span class="number">4.</span>常用api：</span><br><span class="line">	 hashMap.put(ch,hashMap.getOrDefault(ch,<span class="number">0</span>)+<span class="number">1</span>);  <span class="comment">//getOrDefault，如果不存在该键就返回默认值0，省去判断</span></span><br><span class="line">	 hashmap.putIfAbsent(key, value);	<span class="comment">//先判断指定的键（key）是否存在，不存在则将键/值对插入到HashMap中。</span></span><br><span class="line"><span class="number">5.</span>后半部分hashMap的应用每道题关联不大，可能也是状态不太好，几道题都没有第一想法。</span><br></pre></td></tr></table></figure>

<h2 id="第六章、栈"><a href="#第六章、栈" class="headerlink" title="第六章、栈"></a>第六章、栈</h2><h3 id="036、后缀表达式（150、9月6日）"><a href="#036、后缀表达式（150、9月6日）" class="headerlink" title="036、后缀表达式（150、9月6日）"></a>036、后缀表达式（150、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈。遇到操作符，就弹两次栈进行运算，并将结果压回栈中；遇到其他（数字）字符，就直接压栈；最后返回栈顶元素。</span><br><span class="line"><span class="number">2.</span>这道题比较不优雅的地方，是要对运算符进行分类，题解用了<span class="keyword">switch</span> <span class="keyword">case</span>，<span class="keyword">default</span>时说明是数字直接压栈，我用的是<span class="keyword">if</span>...<span class="keyword">else</span>。此外，可以直接用isNumber判断是否为数字，比我的List&lt;String&gt;.contains(操作符)更紧凑些，没啥难的。</span><br></pre></td></tr></table></figure>

<h3 id="037、小行星碰撞（735、9月6日）"><a href="#037、小行星碰撞（735、9月6日）" class="headerlink" title="037、小行星碰撞（735、9月6日）"></a>037、小行星碰撞（735、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，双栈。维护两个栈记录向左走和向右走的小行星，如果将向左走的小行星压栈时，向右走的栈顶有小行星，则比较后决定两颗行星的去留，反之亦然。最后将没有空的栈元素取出，组装成<span class="type">int</span>[]数组返回。这种想法的错误是，题目说“表示在同一行的小行星”，如果最左边的小行星决定向左移动，那天王老子也炸不了它，并不是围绕恒星，即这个题目不但考虑方向，还要考虑位置。</span><br><span class="line"><span class="number">2.</span>我的想法，单栈。终究是做出来了，是一道考虑特殊情况的题目。维护向右走小行星的栈，也维护向左走小行星的List，这样考虑：</span><br><span class="line">    （<span class="number">1</span>）.如果小行星向左走：</span><br><span class="line">    	a.栈为空，直接在List中添加小行星；</span><br><span class="line">    	b.栈不为空，满足(!stack.isEmpty()&amp;&amp;stack.peek()&lt;-asteroid)条件下弹栈，直到向右走小行星全军覆没或挡住这颗行星。接下来，如果全军覆没则在List中添加这颗，如果恰好相等则弹栈，如果大于则不管；</span><br><span class="line">    （<span class="number">2</span>）.如果小行星向右走则直接压栈；</span><br><span class="line">    （<span class="number">3</span>）.如果栈不为空则通过pollLast依次获取栈底元素；</span><br><span class="line">    	避免pollLast（栈底），可以改为<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)，这样能从栈顶弹。</span><br><span class="line">    （<span class="number">4</span>）.List通过size转<span class="type">int</span>[size]，实在找不到高端api；</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，单栈。题解是把朝两个方向运动的小行星都入栈，设置<span class="type">boolean</span>值alive，为每一颗向左走的小行星给一条命，只有它能：</span><br><span class="line">    alive &amp;&amp; aster &lt; <span class="number">0</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() &gt; <span class="number">0</span></span><br><span class="line">    栈为空，栈顶也是一颗向左走的小行星，没被向右走的小行星打爆或同归于尽，他才能入栈。</span><br></pre></td></tr></table></figure>

<h3 id="038、每日温度（739、9月6日）"><a href="#038、每日温度（739、9月6日）" class="headerlink" title="038、每日温度（739、9月6日）"></a>038、每日温度（739、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈。维护一个栈记录温度的索引号，从左到右遍历温度数组，</span><br><span class="line">    a.如果栈为空，就将当前温度直接压栈；</span><br><span class="line">    b.如果栈不为空，通过<span class="keyword">while</span>循环比较栈顶元素和当前温度的大小，</span><br><span class="line">    	当栈顶元素对应温度&lt;当前温度时，在数组中记录对应索引的结果：result[stack.peek()] = i-stack.peek();</span><br><span class="line">	    当当前温度不管小于、等于和大于栈顶温度，都需要将当前温度入栈；</span><br><span class="line">    c.最后，将栈中剩下的索引，把result数组对应位置置为<span class="number">0</span>；</span><br><span class="line">简单说下，就是栈里只记录处理不了的索引，能处理时则通过索引相减获得时间差距。这道题趴下头想一想就做出来了耶。 </span><br><span class="line"><span class="number">2.</span>关键词：栈存索引</span><br></pre></td></tr></table></figure>

<h3 id="【039、直方图最大矩形面积（84、9月7日）】"><a href="#【039、直方图最大矩形面积（84、9月7日）】" class="headerlink" title="【039、直方图最大矩形面积（84、9月7日）】"></a>【039、直方图最大矩形面积（84、9月7日）】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，暴力破解。不知道为啥连穷举都想不出来，一直在想着怎么和栈上靠，还有怎么区分单柱和多柱组成的面积。题解中穷举思路很简单，从左往右遍历单柱，首先将目前单柱的高设为最低，然后从目前单柱开始不断更新最低柱高，并更新最低柱高下的面积。卡在超时上。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，分治法。最大矩形面积受限于最低柱高，对于接触过最低柱高的矩形来说，最大矩形面积是全局的面积；此时只有最低柱高左侧的情况，或者最低柱高右侧的情况，可能超过最大矩形。单独分析左侧情况时，问题回到和全局类似，因此用分治法。（关键词，低柱两边）</span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>，单调栈。这也太难了，今晚太饿没有精力想明白。（没做出来）</span><br></pre></td></tr></table></figure>

<h3 id="【040、矩阵中最大的矩形（85、9月7日）】"><a href="#【040、矩阵中最大的矩形（85、9月7日）】" class="headerlink" title="【040、矩阵中最大的矩形（85、9月7日）】"></a>【040、矩阵中最大的矩形（85、9月7日）】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，单调栈。将矩阵转换为题目<span class="number">39</span>中的直方图，什么神仙脑洞。（没做出来）</span><br></pre></td></tr></table></figure>

<h3 id="总结之栈"><a href="#总结之栈" class="headerlink" title="总结之栈"></a>总结之栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>栈相关api记录复制：</span><br><span class="line">	Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        peek()：返回栈顶的值 ；不改变栈的值，查看栈顶的对象而不移除它。</span><br><span class="line">        pop()：Stack(栈)的方法，返回栈顶的值 ；会把栈顶的值删除。</span><br><span class="line">        poll：Queue(队列)的一个方法，获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。</span><br><span class="line">        pollLast：Dueue(队列)的一个方法，能获取队列尾部，需要记住这里队列首部才是栈顶，而poll和pollFirst等价于pop。</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"><span class="number">2.</span>Queue是队列；Deque是双端队列，支持在两端插入和移除元素，因此可以用它模拟栈。</span><br><span class="line"><span class="number">3.</span>将栈中结果按原顺序返回：<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) result[i]=stack.pop();</span><br></pre></td></tr></table></figure>

<h2 id="第七章、队列"><a href="#第七章、队列" class="headerlink" title="第七章、队列"></a>第七章、队列</h2><h3 id="041、滑动窗口的平均值（346、9月10日）"><a href="#041、滑动窗口的平均值（346、9月10日）" class="headerlink" title="041、滑动窗口的平均值（346、9月10日）"></a>041、滑动窗口的平均值（346、9月10日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，队列。这道题比较简单，就是维护队列、队列最高容量和窗口内数值和这<span class="number">3</span>个变量。当队列容量到达最高容量时，从队列头部删除元素，窗口数值和减去该元素，并将新元素添加到队列尾部并加给数值和。通过维护窗口数值和sum，就不需要再遍历整个滑动窗口了。</span><br><span class="line"><span class="number">2.</span>在队列尾部添加元素api：</span><br><span class="line">	offer(): 在队列尾部添加新元素，如果队列已满，返回<span class="literal">false</span>，add方法会抛出异常；</span><br></pre></td></tr></table></figure>

<h3 id="042、最近请求次数（933、9月11日）"><a href="#042、最近请求次数（933、9月11日）" class="headerlink" title="042、最近请求次数（933、9月11日）"></a>042、最近请求次数（933、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，队列。这道题比较简单，就是维护队列，当调用ping时，通过<span class="keyword">while</span>循环检查window.peek()&lt;t-<span class="number">3000</span>，并移除。</span><br></pre></td></tr></table></figure>

<h3 id="043、往完全二叉树添加节点（919、9月11日）"><a href="#043、往完全二叉树添加节点（919、9月11日）" class="headerlink" title="043、往完全二叉树添加节点（919、9月11日）"></a>043、往完全二叉树添加节点（919、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>完全二叉树，叶子节点只会出现在最下层和次下层，只有最下层不满且叶子节点集中出现在左侧。满二叉树是完全二叉树的特例。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，队列解决广度优先遍历。用队列解决广度优先遍历，是一种经典的方法，当遍历到某层节点时，将其左右子节点分别放入队列，这样就能保持广度优先遍历。每次遍历将父节点从队列前端poll掉，又在队列尾端offer其左右子节点。本题中需注意：</span><br><span class="line">    a.在构造函数记录root根节点后，就将root节点放入队列，提取其左右节点后在队列中删除root节点，并不断重复这一操作，直到某节点不具备左子节点或者右子节点跳出循环。要注意这个节点的左、右子节点都没有放入队列；</span><br><span class="line">    b.当insert新节点时，队列中存储的就是这个不完全节点，设置该节点的left或right属性，只有在right属性设置完毕，才能从队列中删除该不完全节点，并将left和right加入队列；因为这里存在一种特殊情况，如果不完全节点有left属性，而判断right==<span class="literal">null</span>的逻辑中只加入right到队列，就会使left节点没有放入，构造函数中并没有把这个left放入；</span><br><span class="line">    c.当get_root时，返回最初记录的root节点即可，队列中并不存放完整树，而是存放当前遍历到的节点；</span><br></pre></td></tr></table></figure>

<h3 id="044、二叉树每层的最大值（515、9月11日）"><a href="#044、二叉树每层的最大值（515、9月11日）" class="headerlink" title="044、二叉树每层的最大值（515、9月11日）"></a>044、二叉树每层的最大值（515、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历。为每层维护一个len，记录该层节点数目，通过<span class="keyword">while</span>(len&gt;<span class="number">0</span>)遍历队列中节点，通过Math.max(maxVaule,t.val)更新该层最大值，将其子节点加入队列。这样当len为<span class="number">0</span>时跳出循环，队列中为新的一层节点，len更新为新层的节点数目，并重复上述。（关键词，len记录层节点数目）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，深度优先遍历。深度优先遍历时，假如访问root后再访问root.left，这时result.size为<span class="number">1</span>，深度<span class="number">0</span>+<span class="number">1</span>=<span class="number">1</span>，深度==result.size，这时就能把root.left节点的值放入到result。即最先遍历到该层的节点先将值放入result占位，后来再遍历到该层其他节点时，在result中更新该层深度对应的值。（关键词，通过深度在result中索引）</span><br></pre></td></tr></table></figure>

<h3 id="045、二叉树最底层最左边的值（513、9月11日）"><a href="#045、二叉树最底层最左边的值（513、9月11日）" class="headerlink" title="045、二叉树最底层最左边的值（513、9月11日）"></a>045、二叉树最底层最左边的值（513、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历。为每层维护一个len，记录该层节点数目，通过<span class="keyword">while</span>(len&gt;<span class="number">0</span>)遍历队列中节点。当遍历到新层时，len更新为该层的节点数目，并将result更新为当前队列头部元素的值。这道题和第<span class="number">44</span>题广度解法一致。（关键词，len记录层节点数目）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，广度优先遍历。从右往左遍历队列中的节点，这样最底层最左边的元素，就是被最后一个访问到，记录该值即可。（关键词，从右往左）</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，深度优先遍历。用height记录遍历到的节点高度，用curHeight记录上一次更新result的高度。遍历每个节点时，先深度遍历其左子节点，再深度遍历其右子节点，直到子节点为<span class="literal">null</span>时返回。由于只在超过curHeight时才更新curHeight和result，因此到达最底层时只会更新依次result。（关键词，存档点）</span><br><span class="line">    注意，这里将curHeight和result设置为类变量，不放入函数参数，这里涉及到修改形参的知识。</span><br></pre></td></tr></table></figure>

<h3 id="046、二叉树的右侧视图（199、9月11日）"><a href="#046、二叉树的右侧视图（199、9月11日）" class="headerlink" title="046、二叉树的右侧视图（199、9月11日）"></a>046、二叉树的右侧视图（199、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历。为每层维护一个len，记录该层节点数目，通过<span class="keyword">while</span>(len&gt;<span class="number">0</span>)遍历队列中节点。当每层len变为<span class="number">0</span>时，说明正在访问该层的最右侧节点，将节点值放入result。这道题和第<span class="number">44</span>题广度解法一致。（关键词，len记录层节点数目）</span><br></pre></td></tr></table></figure>

<h3 id="总结之队列"><a href="#总结之队列" class="headerlink" title="总结之队列"></a>总结之队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>队列相关api记录复制：</span><br><span class="line">	Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  <span class="comment">//队列是尾部添加，头部删除</span></span><br><span class="line">		offer(): 在队列尾部添加新元素，如果队列已满，返回<span class="literal">false</span>。add方法会抛出异常；</span><br><span class="line">		poll()：获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。remove方法会抛出异常；</span><br><span class="line"> 		peek()：用于在队列头部查询元素，如果此队列为空，返回<span class="literal">null</span>。element方法会抛出异常；</span><br><span class="line"><span class="number">2.</span>用队列解决广度优先遍历：这是一种经典的方法，当遍历到某层节点时，将其左右子节点分别放入队列，这样就能保持广度优先遍历。每次遍历将父节点从队列前端poll掉，又在队列尾端offer其左右子节点。</span><br><span class="line"><span class="number">3.</span>java改变传入参数的值（在深度优先遍历、回溯时经常遇到）：</span><br><span class="line">	对于基本数据类型，实现的是传值，只是个形参，不会改变原有值。对于引用数据类型，对这个引用进行操作，其实也是相当于对形参的操作，不会改变原来的引用。但是，当对这个引用的属性进行操作的时候，相当于CPP中的传址调用，可以改变这个引用的属性的值。</span><br><span class="line">	即修改形参，基本类型不会改变值，引用类型会改变值。如果是类变量，则会更加清晰必然修改。</span><br><span class="line"><span class="number">4.</span>队列问题的体会：</span><br><span class="line">	a.队列从来不作为完整存储容器，不是作为滑动窗口，就是为树存储当前遍历到的节点；</span><br><span class="line">	b.用队列做广度优先遍历是经典方法，堪比反转链表，只要记住维护len变量记录层节点数目即可；</span><br><span class="line">	c.遍历访问树节点时，判断左右子树是否存在，不用<span class="keyword">if</span>...<span class="keyword">else</span>，而是<span class="keyword">if</span>、<span class="keyword">if</span>单独判断，比如只有右子树存在的情况，<span class="keyword">if</span>...<span class="keyword">else</span>就不好。</span><br></pre></td></tr></table></figure>

<h2 id="第八章、树"><a href="#第八章、树" class="headerlink" title="第八章、树"></a>第八章、树</h2><h3 id="047、二叉树剪枝（814、9月11日）"><a href="#047、二叉树剪枝（814、9月11日）" class="headerlink" title="047、二叉树剪枝（814、9月11日）"></a>047、二叉树剪枝（814、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，深度优先遍历。dfs函数设置布尔返回值，对于每个节点，如果左子树、右子树或者本身含<span class="number">1</span>（满足任何一个），则立刻返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。如果深度遍历到最底层<span class="literal">null</span>还没返回，说明这棵子树不含<span class="number">1</span>，返回<span class="literal">false</span>；当左、右子树不含<span class="number">1</span>时，将其置为<span class="literal">null</span>。</span><br><span class="line">	注意，当输入全<span class="number">0</span>的树时，dfs处理后只剩根节点[<span class="number">0</span>]，但这不符合输出要求。此时，左右子树均为<span class="literal">null</span>，且标志位为<span class="literal">false</span>，要根据标志位决定是返会root节点，还是直接返回<span class="literal">null</span>，而不是<span class="keyword">new</span> <span class="title class_">TreeNode</span>()。（关键词，左右<span class="number">2</span>个标志位）</span><br></pre></td></tr></table></figure>

<h3 id="048、序列化与反序列化树（297、9月12日）"><a href="#048、序列化与反序列化树（297、9月12日）" class="headerlink" title="048、序列化与反序列化树（297、9月12日）"></a>048、序列化与反序列化树（297、9月12日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，<span class="string">&#x27;,&#x27;</span>分割+满二叉树+队列实现广度优先遍历。这道题是困难题，结合了StringBuilder、字符串分割、和队列等知识，但我竟然本地调试后，提交一次就通过了，简直unbelievable！！耍！</span><br><span class="line">（<span class="number">1</span>）序列化时，</span><br><span class="line">    a.每层节点当其本身不等于<span class="literal">null</span>时，就将其值放入StringBuilder，并将左、右子节点放入队列（不管是否为<span class="literal">null</span>）；</span><br><span class="line">    b.等于<span class="literal">null</span>时，就将“<span class="literal">null</span>,”放入StringBuilder，这样能实现满二叉树，底层没有元素的位置会被填入<span class="literal">null</span>，且<span class="literal">null</span>节点的孩子节点不会被放入队列；</span><br><span class="line">    c.输出字符串<span class="string">&quot;1,2,3,null,null,4,5,null,null,null,null,&quot;</span>；</span><br><span class="line">（<span class="number">2</span>）反序列化时，</span><br><span class="line">    a.先通过split(<span class="string">&quot;,&quot;</span>)将节点数值分割出来，再根据索引遍历，最后一个逗号后面的空不会被设为字符；</span><br><span class="line">    b.遍历时，先peek队列头部，再将本字符串转为TreeNode，如果不为<span class="literal">null</span>，则加入队列；先peek是考虑到，首字符串放入队列再peek得到的是它本身；</span><br><span class="line">    c.这时候队列维护的是“没被安装左、右子节点的parent节点”，观察到对于满二叉树，索引为奇数时是左子节点，为偶数时是右子节点，根据这一规律，在队列头部节点被安装好后poll掉它；且要设置root变量记住根节点，以便返回；（关键词，满二叉树）</span><br></pre></td></tr></table></figure>

<h3 id="049、从根节点到叶节点的路径数字之和（129、9月12日）"><a href="#049、从根节点到叶节点的路径数字之和（129、9月12日）" class="headerlink" title="049、从根节点到叶节点的路径数字之和（129、9月12日）"></a>049、从根节点到叶节点的路径数字之和（129、9月12日）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.思路1，深度优先搜索。因为路径相关问题，大都采用深度优先搜索。这道题用dfs更方便的原因，还在于通过path = path*10+root.val;求当前累积和，比如路径为3-&gt;9-&gt;5，3*10+9=39，39*10+5=395，就能直接把路径数字表示出来。</span><br><span class="line">	对于每个节点，返回其左、右子树的累积结果时，直接return dfs(root.left,path)+dfs(root.right,path)，比如path=39，391+395=...，这都是从数值为9的节点开始的全部路径和。注意叶子节点为null，则返回0。（关键词，dfs相加）</span><br></pre></td></tr></table></figure>

<h3 id="050、向下的路径节点之和（437、9月12日）"><a href="#050、向下的路径节点之和（437、9月12日）" class="headerlink" title="050、向下的路径节点之和（437、9月12日）"></a>050、向下的路径节点之和（437、9月12日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，深度优先搜索+前缀和+回溯。咋这几道中等题反而越来越难想嘞？因为题目要求统计次数，故通过hashMap记录前缀和即可，键为当前累积和path，值为path的出现次数。</span><br><span class="line">    a.对于一条路径，不断深入的过程中path加上节点值，并使得hashMap中path对应的值增加<span class="number">1</span>，每次更新当前累积和path时，在hashMap中寻找(path-target)的出现次数，即为这条路径能提供的目标子串数目；</span><br><span class="line">    b.还要像题目<span class="number">49</span>，把path向左、右子节点传递下去，子节点dfs返回后，要将hashMap中path对应的值减<span class="number">1</span>，抹除本路径、本节点的影响，这样便是回溯。（关键词，前缀和、）</span><br><span class="line"><span class="number">2.</span>这道题的测试用例被添加了奇怪的东西，必须将path设置为<span class="number">64</span>位的Long。</span><br><span class="line"><span class="number">3.</span>DFS的代码都很短，但是想到却很困难。对于root节点到叶子节点的全部路径，或者从任意节点开始的部分路径，dfs怎样操作子节点还是不能轻松想到。再次遇到求部分和次数的题目，看来子数组、子串、子路径都要记住hashMap前缀和的方法。</span><br></pre></td></tr></table></figure>

<h3 id="051、节点之和最大的路径（124、9月12日）"><a href="#051、节点之和最大的路径（124、9月12日）" class="headerlink" title="051、节点之和最大的路径（124、9月12日）"></a>051、节点之和最大的路径（124、9月12日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，深度优先搜索。题目没有对路径限制，那对于每个节点有<span class="number">3</span>种情况，但我分析不出返回值该是啥：</span><br><span class="line">    a.b.从其他节点延申过来，经过其左子树或者右子树的路径；</span><br><span class="line">    c.从其左子树开始，经过本节点，再经过其右子树的路径；</span><br><span class="line">我的疑虑主要在，从root节点到某子节点的路径和某节点自身的左右两边路径，这两种情况怎么设计返回值？</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，深度优先搜索。对于每个节点来说，返回值是其本身的值，加上左子树或者右子树返回的值或者<span class="number">0</span>，这样它不是这条路径的核心，不同时提供左右子树，只提供一个边；对于每个节点来说(想象成root节点)，它通过比较左、右子树的返回值、以及两个返回值加上它本身这<span class="number">3</span>个对象，就能覆盖其节点上的最值信息。（关键词，返回root.val+max(left,right)）</span><br><span class="line"><span class="number">3.</span>这道题很困难，代码简单能量爆炸。</span><br></pre></td></tr></table></figure>

<h3 id="052、展平二叉搜索树（897、9月13日）"><a href="#052、展平二叉搜索树（897、9月13日）" class="headerlink" title="052、展平二叉搜索树（897、9月13日）"></a>052、展平二叉搜索树（897、9月13日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，二叉树中序遍历。因为二叉搜索树本身就维护了递增顺序，只需对其中序遍历，将节点放入List，再按照List中的顺序连接。连接时需要将每个节点的左指针置为空，右指针指向List下一节点，最后节点右指针置为空，记住新的root节点即可。（关键词，中序遍历）</span><br><span class="line">    本题中序遍历用dfs递归实现。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二叉树中序遍历。List中可以不放节点，而是放节点值，重组时新建节点。</span><br><span class="line"><span class="number">3.</span>二叉搜索树，左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点。</span><br></pre></td></tr></table></figure>

<h3 id="053、二叉搜索树中的中序后继（285、9月13日）"><a href="#053、二叉搜索树中的中序后继（285、9月13日）" class="headerlink" title="053、二叉搜索树中的中序后继（285、9月13日）"></a>053、二叉搜索树中的中序后继（285、9月13日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，栈实现中序遍历。设置标志位flag初始为<span class="literal">false</span>，栈实现中序遍历代码中，弹栈时当前节点等于目标节点，则将标志位flag置为<span class="literal">true</span>。由于当前节点的右指针为<span class="literal">null</span>时会弹栈，这时flag等于<span class="literal">true</span>跳出循环，当前节点就是目标节点。（关键词，栈实现、标志位）</span><br><span class="line"><span class="number">2.</span>本来准备用dfs递归实现，但在函数递归调用中传递标志位，并考虑返回值好麻烦，没找到时返回值咋设置。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，二叉搜索树。二叉搜索树自身就有排序功能，能根据其性质按照正确的方向去寻找，每个节点比目标值大则向左找，否则向右。注意只在比目标值大时，才将结果节点result更新储存当前节点，因为接下来往左找时新的当前节点值可能小于等于目标值，等于时result中确实存储其中序后继，小于时则不可能是中序后继。（关键词，大于目标是更新result）</span><br></pre></td></tr></table></figure>

<h3 id="054、所有大于等于节点的值之和（538、1038、9月13日）"><a href="#054、所有大于等于节点的值之和（538、1038、9月13日）" class="headerlink" title="054、所有大于等于节点的值之和（538、1038、9月13日）"></a>054、所有大于等于节点的值之和（538、1038、9月13日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归实现先遍历右子树。这道题一看涉及到累积和path，那肯定传参path，返回path。因为是二叉搜索树，根据题目应该先访问右节点，再中间节点，最后是左节点。dfs辅助函数根据前面的遍历顺序修改path值，注意如果节点等于<span class="literal">null</span>，应该返回path而不是返回<span class="number">0</span>，因为dfs函数返回的是修改后的path值，而不是修改量。（关键词，反序中序遍历）</span><br></pre></td></tr></table></figure>

<h3 id="055、二叉搜索树迭代器（173、9月15日）"><a href="#055、二叉搜索树迭代器（173、9月15日）" class="headerlink" title="055、二叉搜索树迭代器（173、9月15日）"></a>055、二叉搜索树迭代器（173、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，栈实现中序遍历。这道题看了很多遍不知道到底在说什么，就看了题解。next函数是返回二叉搜索树中下一个最小的节点值，因此每次访问next函数，先不断调用next指针并压栈使其触底，next弹栈一个元素取值后，将当前节点指向右指针，即完成了中序遍历。</span><br><span class="line">    （关键词，栈实现中序遍历）</span><br></pre></td></tr></table></figure>

<h3 id="056、二叉搜索树中两个节点之和（653、9月15日）"><a href="#056、二叉搜索树中两个节点之和（653、9月15日）" class="headerlink" title="056、二叉搜索树中两个节点之和（653、9月15日）"></a>056、二叉搜索树中两个节点之和（653、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，栈实现中序遍历+hashMap。这几道题都考察栈实现中序遍历，只需在弹栈时，在hashMap中寻找(k-val)，并将val加入hashMap，找到则返回<span class="literal">true</span>，双层<span class="keyword">while</span>循环结束则返回<span class="literal">false</span>。（关键词，栈实现中序遍历）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，双指针，先不做。</span><br></pre></td></tr></table></figure>

<h3 id="057、值和下标之差都在给定的范围内（220、9月15日）"><a href="#057、值和下标之差都在给定的范围内（220、9月15日）" class="headerlink" title="057、值和下标之差都在给定的范围内（220、9月15日）"></a>057、值和下标之差都在给定的范围内（220、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，TreeMap。维护一个TreeMap，键为数字，值为它在数组中的最新索引。从左向右遍历数组，取TreeMap中恰好小于等于（floor）、大于等于（ceiling）当前遍历数字的键，计算其是否满足要求，并将当前遍历数字和索引放入TreeMap。但是，这么做存在问题，假设（&#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">11</span>,<span class="number">9</span>&#125;，索引=<span class="number">1</span>，差值=<span class="number">2</span>）的数字，当遍历到<span class="number">9</span>时，ceiling会取<span class="number">10</span>，从而不满足条件，即使<span class="number">11</span>满足但不在逻辑中。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，TreeSet。维护一个TreeSet，键为数字，这里把它当作滑动窗口，当超过k时，就剔除nums[i-k]。其他步骤同上。此外，为了应付一些特殊测试用例，应该强制类型转换成<span class="number">64</span>位的<span class="type">long</span>。（关键词，滑动窗口）</span><br></pre></td></tr></table></figure>

<h3 id="058、日程表（729、9月15日）"><a href="#058、日程表（729、9月15日）" class="headerlink" title="058、日程表（729、9月15日）"></a>058、日程表（729、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，TreeMap。维护一个TreeMap，键为start，值为end。每次book时，（关键词，TreeMap）</span><br><span class="line">    a.先取小于等于start的最大键值对，如果value大于start，则返回<span class="literal">false</span>；</span><br><span class="line">    b.再取大于等于start的最小键值对，如果key小于end，则返回<span class="literal">false</span>；</span><br><span class="line">    因为题目规定[start,end)，因此再判断大小时，相等是没问题的，即首尾重合没有问题。</span><br><span class="line"><span class="number">2.</span>TreeSet和TreeMap使用起来很简单，遇到的题目，解题都是依次调用一遍floor和ceiling做判断，再put本元素即可。</span><br><span class="line"><span class="number">3.</span>HashMap和TreeMap是同级的，都继承AbstractMap。必须TreeMap&lt;Integer,Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();，如果前面Class为Map&lt;Integer,Integer&gt;，则会因为多态而失去TreeMap的方法。</span><br></pre></td></tr></table></figure>

<h3 id="总结之树"><a href="#总结之树" class="headerlink" title="总结之树"></a>总结之树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>二叉树分类定义：</span><br><span class="line">	满二叉树，除了叶子结点之外的每一个结点都有两个孩子结点；即只有有孩子，必然有两个；</span><br><span class="line">	完全二叉树，除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐；和完美二叉树区别在，底层不一定完全填充；</span><br><span class="line">	完美二叉树，除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充，是完全二叉树的特例；</span><br><span class="line">	二叉搜索树，左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点；<span class="comment">//整个左子树小于根节点，而不单是左子节点小于</span></span><br><span class="line">	平衡二叉树，二叉搜索树的特例，还需满足：a.左子树和右子树的高度之差的绝对值小于等于<span class="number">1</span>；b.左子树和右子树也是平衡二叉树；是为了避免二叉搜索树高度过高，使其查找、增加和删除的时间复杂度从O(h)退化到O(n)而存在；</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>DFS的代码都很短，但是想到却很困难。对于root节点到叶子节点的全部路径，或者从任意节点开始的部分路径，dfs怎样操作子节点还是不能轻松想到。再次遇到求部分和次数的题目，看来子数组、子串、子路径都要记住hashMap前缀和的方法。呜呜呜呜....</span><br><span class="line"><span class="number">3.</span>目前遇到的习题，二叉树章节基本考察dfs，队列章节则基本考察bfs。二叉树章节的前几道题，都是dfs的奇思妙想，但本章比较基础也比较关键的是，通过dfs（递归）实现前序、中序和后序遍历，另外更困难的遍历实现是利用栈。</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>二叉树前序、中序和后序遍历，栈解法：</span><br><span class="line">    a.中序遍历，双层<span class="keyword">while</span>循环，内部循环顺着左指针一直向下移动并压栈，弹栈时访问值并将当前节点指向右指针；外层循环判断当前节点是否为<span class="literal">null</span>或者栈是否为空，并以新节点接续顺着左指针压栈；实际就是每到右指针指向节点，又开始遍历其左子树；（关键词，双<span class="keyword">while</span>）</span><br><span class="line">    b.前序遍历，双层<span class="keyword">while</span>循环，和中序遍历一致，就是内层循环一直移动左指针时，就访问节点值；即假设对于最底层节点（没有右指针），中序是在弹栈弹掉最底层节点时访问它的值，再弹栈其上层根节点并访问；前序是现在压栈时访问其上层根节点，再压栈并访问最底层节点，弹栈时不访问，因此根节点最先被访问到；（关键词，双<span class="keyword">while</span>、压栈时访问）</span><br><span class="line">    c.后序遍历，双层<span class="keyword">while</span>循环，和中序遍历一致，就是维护指针prev指向上一次访问的节点，帮助弹栈时做判断。</span><br><span class="line">      弹栈时（其实是peek栈顶，这里说弹栈指对应中序遍历的代码块），</span><br><span class="line">    	如果当前节点cur右指针不为<span class="literal">null</span>且没有指向prev，说明还没有访问cur右子树，将cur指向cur.right进行循环，此时不弹栈；</span><br><span class="line">    	其他情况下是经典操作，直接弹栈并访问弹出节点，将prev指针指向弹出节点做记录，将cur指向<span class="literal">null</span>，等待下次循环栈顶复制；</span><br><span class="line">	（关键词，双<span class="keyword">while</span>，弹栈时判断右指针是否指向上一次cur）</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>Java根据红黑树这种平衡的二叉搜索树实现TreeSet和TreeMap两种数据结构，其查找、添加和删除操作的时间复杂度都是O(logn)；TreeSet常用api：</span><br><span class="line">    ceilling  <span class="comment">//返回键大于或等于给定值的最小键，没有则返回null；</span></span><br><span class="line">    floor	  <span class="comment">//返回键小于或等于给定值的最大键，没有则返回null；</span></span><br><span class="line">    higher	  <span class="comment">//返回键大于给定值的最小键，没有则返回null；</span></span><br><span class="line">    lower	  <span class="comment">//返回键小于给定值的最大键，没有则返回null；</span></span><br><span class="line">TreeMap常用api和TreeSet一致，只是在方法名后加Entry或者Key表示返回键值对还是键，比较的时候都是比较键；</span><br><span class="line">如果题目出现数据集合是动态的，并需要根据数据的大小实现快速查找，则使用TreeSet或TreeMap。HashMap做不到这一点，是因为其只能判断某键是否存在，并不能有“比某键大的所有数字中最小的那一个”这种功能。</span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span>TreeSet和TreeMap使用起来很简单，遇到的题目，解题都是依次调用一遍floor和ceiling做判断，再put本元素即可。    </span><br><span class="line"><span class="number">7.</span>HashMap和TreeMap是同级的，都继承AbstractMap。必须TreeMap&lt;Integer,Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();，如果前面Class为Map&lt;Integer,Integer&gt;，则会因为多态而失去TreeMap的方法。</span><br></pre></td></tr></table></figure>

<h2 id="第九章、堆"><a href="#第九章、堆" class="headerlink" title="第九章、堆"></a>第九章、堆</h2><h3 id="059、数据流的第K大数值（703、9月16日）"><a href="#059、数据流的第K大数值（703、9月16日）" class="headerlink" title="059、数据流的第K大数值（703、9月16日）"></a>059、数据流的第K大数值（703、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，暴力破解。维护一个List存放数字，每次添加元素时，使用官方api进行逆序排列，再根据k索引到目标值。（关键词，集合api）</span><br><span class="line">	Collections.sort(list, Comparator.reverseOrder());</span><br><span class="line"><span class="number">2.</span>Arrays.sort是数组排序，Collections.sort是集合排序，都可以传入Comparator接口的实现类，实现自定义排序。自定义排序这块还是不太熟悉，PriorityQueue、上面的逆排序都需要自定义排序比较器，后面需要掌握。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，最小堆。维护一个PriorityQueue，其默认是最小堆，堆顶是整个堆的最小值，这个堆的目的是保存数组中前k大的数字。设计add函数时，按如下逻辑。因为只维护了PriorityQueue，空间复杂度为O(k)。（关键词，前k大元素的最小堆）</span><br><span class="line">	a.如果当前堆大小小于k，直接将数字添加到堆;</span><br><span class="line">	b.如果当前堆大小大于等于k，且要添加的数字超过堆顶，删除堆顶，并将新数字放入PriorityQueue，否则无视新数字；</span><br><span class="line">	c.这样每次返回堆顶，堆顶是前k大数字中的最小值，即为第k大的数字；</span><br><span class="line"> <span class="number">4.</span>最小堆常求前k大元素，最大堆常求前k小元素，是反的。</span><br></pre></td></tr></table></figure>

<h3 id="060、出现频率最高的k个数字（347、9月16日）"><a href="#060、出现频率最高的k个数字（347、9月16日）" class="headerlink" title="060、出现频率最高的k个数字（347、9月16日）"></a>060、出现频率最高的k个数字（347、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，最小堆。先遍历一遍，将数字和出现次数放入hashMap；再遍历hashMap，按照上一题的方式，不满时放入最小堆，满时比较堆顶元素决定是否删除堆顶并放入。但是，这么做出现了问题，因为放入堆时会根据数字大小构造最小堆，而不是数字频率。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，最小堆。维护一个PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt;，构造函数传入的Comparator用键的值比较。</span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; minHeap =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1.getValue()-e2.getValue());</span><br><span class="line">	这里用了lambda表达式。（关键词，最小堆放entry）</span><br></pre></td></tr></table></figure>

<h3 id="061、和最小的k个数对（373、9月16日）"><a href="#061、和最小的k个数对（373、9月16日）" class="headerlink" title="061、和最小的k个数对（373、9月16日）"></a>061、和最小的k个数对（373、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，最大堆。维护一个PriorityQueue&lt;<span class="type">int</span>[]&gt;，自定义Comparator如下：</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;(e2[<span class="number">0</span>]+e2[<span class="number">1</span>])-(e1[<span class="number">0</span>]+e1[<span class="number">1</span>]));</span><br><span class="line">两层<span class="keyword">for</span>循环遍历两个数组，按照上一题的方式，不满时放入最大堆，满时比较堆顶元素决定是否删除堆顶并放入。</span><br><span class="line">遍历完后，如果最大堆的大小小于k，则再两层<span class="keyword">for</span>循环遍历两个数组将所有结果放入返回值；否则将堆中结果放入返回值。</span><br><span class="line">	（关键词，最大堆<span class="type">int</span>[]）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，我的想法优化。因为两个数组是递增排序的，双层<span class="keyword">for</span>循环时不必遍历全部元素，都只用遍历前k个：</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Math.min(k,nums1.length);i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; Math.min(k,nums2.length); j++) &#123;</span><br><span class="line">  此外，可以用<span class="keyword">while</span>(!maxHeap.isEmpty())避免最大堆大小小于k，即双层<span class="keyword">for</span>的全部结果数目小于k的情况，不用额外再双<span class="keyword">for</span>原始数组。</span><br></pre></td></tr></table></figure>

<h3 id="总结之堆"><a href="#总结之堆" class="headerlink" title="总结之堆"></a>总结之堆</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Arrays.sort是数组排序，Collections.sort是集合排序，都可以传入Comparator接口的实现类，实现自定义排序。自定义排序这块还是不太熟悉，PriorityQueue、上面的逆排序都需要自定义排序比较器，后面需要掌握。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>堆分类定义（堆通常用完全二叉树实现，最大特点是最值位于堆顶）：</span><br><span class="line">    最大堆，每个节点的值总是大于或等于其任意子节点的值；在最大堆中，根节点就是整个堆的最大值；</span><br><span class="line">    最小堆，每个节点的值总是小于或等于其任意子节点的值；在最小堆中，根节点就是整个堆的最小值；</span><br><span class="line"><span class="number">3.</span>堆的经典面试题，就是求一个数据集合中值最大或最小的k个元素；如果面试题是求出一个动态集合中的最大值或最小值，考虑用堆。最小堆常求前k大元素，最大堆常求前k小元素，是反的。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>Java提供了PriorityQueue实现堆结构，默认情况下是一个最小堆，如果使用最大堆调用构造函数时就需要传入Comparator改变比较排序规则，其常用api：</span><br><span class="line">	add(e)  <span class="comment">//插入新的元素，会抛出异常；而offer(e)等效但不抛异常，而是返回null</span></span><br><span class="line">	remove  <span class="comment">//删除堆顶元素，会抛出异常；而poll等效但不抛出异常，而是返回null</span></span><br><span class="line">	element <span class="comment">//返回堆顶元素，会抛出异常；而peek等效但不抛出异常</span></span><br><span class="line">    Java中PriorityQueue实现了Queue接口，但它并不是一个队列，不按照“先入先出”顺序删除元素；它本质是一个堆，每次调用remove或者poll都是删除堆顶元素。最大堆中每次删除值最大的元素，最小堆中每次删除值最小的元素。element和peek同理。</span><br><span class="line"><span class="number">5.</span>PriorityQueue中，使用lambda表达式自定义Comparator例子：</span><br><span class="line">   PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; minHeap =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1.getValue()-e2.getValue()); </span><br></pre></td></tr></table></figure>

<h2 id="第十章、前缀树"><a href="#第十章、前缀树" class="headerlink" title="第十章、前缀树"></a>第十章、前缀树</h2><h3 id="062、实现前缀树（208、9月16日）"><a href="#062、实现前缀树（208、9月16日）" class="headerlink" title="062、实现前缀树（208、9月16日）"></a>062、实现前缀树（208、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，前缀树。定义前缀树节点时，可以将其children指针指向长度为<span class="number">26</span>的TrieNode数组，因为前缀树一般考察小写字母，此外，维护一个布尔标志位，表示路径截止到该字符是否为字符串。本题需要先定义静态前缀树节点类，在insert、search和startsWith方法实现时，根据children指针遍历路径时，记住根节点是空的，还有children数组中不为<span class="literal">null</span>的单元即代表有效字母即可。（关键词，定义TrieNode）</span><br></pre></td></tr></table></figure>

<h3 id="063、替换单词（648、9月17日）"><a href="#063、替换单词（648、9月17日）" class="headerlink" title="063、替换单词（648、9月17日）"></a>063、替换单词（648、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，前缀树。用前缀树解决问题分为两步，第一步是创建前缀树，第二步是在前缀树中查找。</span><br><span class="line">创建前缀树时，</span><br><span class="line">	遍历前缀树，当children对应字母指针为<span class="literal">null</span>时，在该字母指针上添加新节点，遍历晚字符串将当前节点isWord标志位设置为<span class="literal">null</span>。注意，对于字典中的每个字符串，都是从root节点开始遍历前缀树，每到新字符串要将node指向root；</span><br><span class="line">	在前缀树中查找时，通过StringBuilder累积路径，当isWord标志位为<span class="literal">true</span>说明是最短前缀，或者children对应字母指针为<span class="literal">null</span>说明不存在前缀，这时候跳出循环并根据条件返回。</span><br><span class="line">	在主函数中，通过以下api分割和组合字符串：</span><br><span class="line">		 String[] units = sentence.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		 <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>,units);</span><br></pre></td></tr></table></figure>

<h3 id="064、神奇的字典（676、9月17日）"><a href="#064、神奇的字典（676、9月17日）" class="headerlink" title="064、神奇的字典（676、9月17日）"></a>064、神奇的字典（676、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，前缀树。创建前缀树逻辑如旧。在前缀树中查找时，显然是用递归。每次访问新的字母时，尝试当前节点的<span class="number">26</span>个children字母指针，并根据是否为当前字母，决定“已修改次数标志位”是否加<span class="number">1</span>，并继续递归。对于我目前水平来说，还是不熟悉dfs方法传参和返回值的设计：</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TrieNode root,String word,<span class="type">int</span> i,<span class="type">int</span> edit)</span>  <span class="comment">//传参新节点，word，当前字母位置，修改次数</span></span><br><span class="line">需要考虑的情况：</span><br><span class="line">    a.<span class="literal">false</span>边界：root为<span class="literal">null</span>，说明不存在该字母指针，即字典不存在该单词；</span><br><span class="line">    b.<span class="literal">true</span>边界：当前字母位置i走到尽头，root是单词，已经修改一次；</span><br><span class="line">    c.当前字母位置i没有走到尽头，且标志位修改小于等于<span class="number">1</span>次，继续递归；</span><br><span class="line">    d.方法边界：其他情况都返回<span class="literal">false</span>，<span class="literal">true</span>只有“<span class="literal">true</span>边界”那一种情况；</span><br><span class="line">    （关键词，dfs）</span><br></pre></td></tr></table></figure>

<h3 id="065、最短的单词编码（820、9月17日）"><a href="#065、最短的单词编码（820、9月17日）" class="headerlink" title="065、最短的单词编码（820、9月17日）"></a>065、最短的单词编码（820、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>题目解释，这道题是给出单词数组words，但希望换成字符串s表示，并且字符串尽可能短。要求words[i]在s中以#结束，故不能考虑前缀重合，这时候就需要把一些尾缀相同的words[i]联合起来，但是为了表明words[i]在s中的开始位置，就用indices[i]索引words[i]的开始位置。题目答案要给出最短的字符串s长度。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，前缀树。将words中的单词逆序生成前缀树，实际维护了后缀相同的单词，此时要查询生成最短字符串的长度。对字符串a和b来说，如果a恰被淹没在b的路径里，那么只需累加b的长度；如果a和b只是部分前缀重合，那么a和b的长度都需要累加，这样能发现，最短字符串即全部叶子节点到root节点的路径。由于只需要统计长度，那就递归即可。dfs函数的设计还是很巧妙：</span><br><span class="line">    a.先将标志位isLeaf设置为<span class="literal">true</span>；</span><br><span class="line">    b.遍历<span class="number">26</span>个字母指针，如果指针不指向<span class="literal">null</span>，继续递归，并把标志位修改为<span class="literal">false</span>；</span><br><span class="line">    c.继而判断标志位是否为<span class="literal">true</span>，如果为<span class="literal">true</span>说明没有修改，即children指针均指向<span class="literal">null</span>，是叶子节点，此时累加长度；</span><br><span class="line">    初始化length为<span class="number">1</span>，即root节点（空节点）为<span class="number">1</span>，第一个节点时length为<span class="number">2</span>，满足“第一个字母#”长度为<span class="number">2</span>的要求。（关键词，dfs）</span><br><span class="line"><span class="number">3.</span>前缀树中dfs用标志位判断是否为叶子节点，不用root==<span class="literal">null</span>，因为大多数children指针确实为<span class="literal">null</span>。</span><br></pre></td></tr></table></figure>

<h3 id="066、单词之和（677、9月17日）"><a href="#066、单词之和（677、9月17日）" class="headerlink" title="066、单词之和（677、9月17日）"></a>066、单词之和（677、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashMap+前缀树。维护一个HashMap&lt;String,Integer&gt;和一个前缀树。insert方法把新键值插入hashMap的同时，还要把新键加入到前缀树中。这里重点说sum方法，是我为数不多自己实现回溯：</span><br><span class="line">    先通过prefix字符串遍历到最后的节点，并将prefix加入StringBuilder，进入dfs函数：</span><br><span class="line">     dfs(TrieNode node,<span class="type">int</span>[] sum,StringBuilder builder,<span class="type">int</span> index)</span><br><span class="line">    a.遍历当前节点node的<span class="number">26</span>个字母指针，如果不为<span class="literal">null</span>，将builder增加当前字母，并放入dfs继续递归，传入下一层字符的索引值index+<span class="number">1</span>，回溯时再在builder中删除当前字母；注意index初始为prefix长度，而不是<span class="number">0</span>；</span><br><span class="line">    b.如果当前节点为单词，将builder转化为字符串，从hashMap中根据键取值，并累积到最终结果；（关键词，dfs+hashMap）</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，前缀树。相比我的想法改进在，如果一个节点对应一个字符串的最后一个字符，那么该节点的整数字段的值就设为字符串的值，否则设为<span class="number">0</span>；这时候需要修改TrieNode定义，不再需要<span class="type">boolean</span>标志位isWord，而是整数值value。</span><br></pre></td></tr></table></figure>

<h3 id="067、最大的异或（421、9月17日）"><a href="#067、最大的异或（421、9月17日）" class="headerlink" title="067、最大的异或（421、9月17日）"></a>067、最大的异或（421、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，暴力破解。双层<span class="keyword">for</span>循环遍历，Math.max(value,nums[i]^nums[j])，然而超时了。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，前缀树。因为对于整数异或位运算，相异为<span class="number">1</span>，相同为<span class="number">0</span>，为使结果数值更大，应该尽量高位为<span class="number">1</span>。故构建前缀树时，高位作为前缀。遍历nums整数数组时，从高位开始遍历当前数字num的<span class="number">32</span>位，看前缀树是否有与当前位不同的位，</span><br><span class="line">    a.如果有则将node节点优先移动到该位，并将结果的该位置为<span class="number">1</span>；  xor = (xor&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    b.没有则移动到相同位，并将结果的该位置为<span class="number">0</span>；  xor = xor&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	当前数字num按位访问结束后，通过Math.max(max,xor)更新结果值。（关键词，高位前缀树取不同）</span><br><span class="line">        </span><br><span class="line"><span class="number">3.</span>回忆整数章节技巧：</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> (num&gt;&gt;i)&amp;<span class="number">1</span>;   <span class="comment">//从32位整数高位开始，右移i位，每次只保留末尾位</span></span><br></pre></td></tr></table></figure>

<h3 id="总结之前缀树"><a href="#总结之前缀树" class="headerlink" title="总结之前缀树"></a>总结之前缀树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>前缀树定义：</span><br><span class="line">	前缀树是一棵多叉树，一个节点可能有多个子节点。前缀树中除根节点外，每个节点表示字符串中的一个字符，而字符串由前缀树的路径表示。例如，“can”和“cat”前两个字符相同，它们在前缀树对应的两条路径中最开始的<span class="number">3</span>个节点重叠（根节点，<span class="string">&#x27;c&#x27;</span>和<span class="string">&#x27;a&#x27;</span>）。</span><br><span class="line"><span class="number">2.</span>前缀树主要用来解决字符串查找相关的问题，一般题目要求根据字符串的前缀进行查找。用前缀树解决问题分为两步，第一步是创建前缀树，第二步是在前缀树中查找。这部分需要熟练TrieNode节点定义、创建前缀树经典代码这<span class="number">2</span>步惯性操作，查找通常用dfs比较多样。</span><br><span class="line"><span class="number">3.</span>可以按需求修改TrieNode定义，比如增加字段<span class="type">int</span> value，记录单词对应的值。</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>越来越觉得，递归、回溯以及dfs方法要从四个方向考虑：<span class="literal">false</span>边界、<span class="literal">true</span>边界、继续递归条件和方法边界，而传参和返回值看代码需要什么，是后面才补充的。这部分还是不太熟练。</span><br><span class="line"><span class="number">5.</span>前缀树中dfs用标志位判断是否为叶子节点，不用root==<span class="literal">null</span>，因为大多数children指针确实为<span class="literal">null</span>。</span><br></pre></td></tr></table></figure>

<h2 id="第十三章、回溯法"><a href="#第十三章、回溯法" class="headerlink" title="第十三章、回溯法"></a>第十三章、回溯法</h2><h3 id="079、所有子集（78、9月18日）"><a href="#079、所有子集（78、9月18日）" class="headerlink" title="079、所有子集（78、9月18日）"></a>079、所有子集（78、9月18日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。从左到右遍历整数数组nums，用subSet记录当前集合。遍历到每个元素时，可以选择不放入当前元素继续递归；或者将当前元素放入subSet后继续递归，递归结束将元素从当前集合删除。当遍历深度达到数组长度，则将subSet纳入结果。这道题需要注意：</span><br><span class="line">	a.使用LinkedList，在删除元素时用removeLast方法；而不是使用List，删除元素时用remove(index)。这是因为，假设当前index为<span class="number">2</span>，subSet=[<span class="number">3</span>]，即前两次加的都是空，这样remove(<span class="number">2</span>)时就会越界，为了恢复状态应该用removeLast方法；</span><br><span class="line">	b.双层List嵌套结果，需要用下面的方式放入结果。如果直接result.add(subSet)，后面再操作subSet时，会改变result中subSet值：</span><br><span class="line">		result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line">（关键词，回溯经典）</span><br></pre></td></tr></table></figure>

<h3 id="080、含有k个元素的组合（77、9月18日）"><a href="#080、含有k个元素的组合（77、9月18日）" class="headerlink" title="080、含有k个元素的组合（77、9月18日）"></a>080、含有k个元素的组合（77、9月18日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。显然不能穷举，k为多少就设多少层循环，应该传index回溯。这道题和上一道逻辑相同，因为需要提取k个数，所以外界判断subSet是否到达k，达到则纳入结果；当没有到达k时，有两种选择，可以选择不放入当前元素继续递归，给其他元素一个机会；或者将当前元素放入subSet后继续递归，递归结束将元素从当前集合删除。需注意当前元素不可越界，越界后会走不到判断逻辑并返回，不会继续越界。</span><br><span class="line">     <span class="keyword">if</span>(subSet.size()==k)&#123;</span><br><span class="line">            results.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(start&lt;=n)&#123;</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                </span><br><span class="line">                subSet.add(start);</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                subSet.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">（关键词，回溯经典）</span><br></pre></td></tr></table></figure>

<h3 id="081、允许重复选择元素的组合（39、9月19日）"><a href="#081、允许重复选择元素的组合（39、9月19日）" class="headerlink" title="081、允许重复选择元素的组合（39、9月19日）"></a>081、允许重复选择元素的组合（39、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。做完前几道有点进步了，按照惯性思路完成本题。dfs函数设计如下，index用于定位当前数字，sum是当前累积和，subSet是本集合，results是最终结果集合。</span><br><span class="line">	dfs(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> index, <span class="type">int</span>[] sum, LinkedList&lt;Integer&gt; subSet,List&lt;List&lt;Integer&gt;&gt; results)</span><br><span class="line">dfs逻辑为，当前累计和sum小于target时，有两种选择：</span><br><span class="line">    a.index加一，不访问本索引数字，直接递进下个数字的dfs；</span><br><span class="line">    b.subSet和sum都累加本索引数字，index不变进入下一轮dfs，dfs结束后subSet和sum恢复原状，这样涵盖了多次使用一个数字的情况；</span><br><span class="line">当前累积和sum等于target时，将本集合subSet纳入结果；超过target则没有逻辑自动返回；</span><br><span class="line">（关键词，重复不加）</span><br></pre></td></tr></table></figure>

<h3 id="082、含有重复元素集合的组合（40、9月19日）"><a href="#082、含有重复元素集合的组合（40、9月19日）" class="headerlink" title="082、含有重复元素集合的组合（40、9月19日）"></a>082、含有重复元素集合的组合（40、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。经过题解点拨，“避免重复组合的方法是，当在某一步决定跳过某个值为m的数字时，跳过所有值为m的数字”。因此dfs逻辑为，当前累积和sun小于target时只有一种选择：</span><br><span class="line">	subSet和sum都累加本索引数字，index加一，进入下一轮dfs，dfs结束后subSet和sum恢复原状，这样就不会使用某元素多次；</span><br><span class="line">但是，需要解决不同位置、值相同元素造成的结果重复。这时候，可以先通过Arrays.sort(candidates)排序初始数组，遍历到某数字时，如果下一数字等于本数字，就不断自增index直到不同的数字再dfs。（关键词，要跳全跳）</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>写完才发现完全依靠这句点拨，否则还是难想，辅以示例；比如原始数字集合candidates为[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]，某目标subSet为[<span class="number">2</span>,<span class="number">2</span>]，但会有<span class="number">3</span>种重复，用上面的逻辑，决定调<span class="number">2</span>时会跳出所有的<span class="number">2</span>，那么就会排除重复解：</span><br><span class="line">    a.跳过第一个<span class="number">2</span>，保留后两个<span class="number">2</span>；	b.跳过中间的<span class="number">2</span>，保留前后的<span class="number">2</span>；</span><br><span class="line">这样，任何对<span class="number">2</span>的需求，都是取靠前位置的<span class="number">2</span>，靠后位置的<span class="number">2</span>不被选择故不会重复。</span><br></pre></td></tr></table></figure>

<h3 id="083、没有重复元素集合的全排列（46、9月19日）"><a href="#083、没有重复元素集合的全排列（46、9月19日）" class="headerlink" title="083、没有重复元素集合的全排列（46、9月19日）"></a>083、没有重复元素集合的全排列（46、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。题解的思路基于示例更好说明，假设输入集合[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，对于第一个位置，这<span class="number">3</span>个数字都有可能；对于第二个位置，只有<span class="number">2</span>个数字有可能；第三个位置已经没得选择。dfs函数设计如下：</span><br><span class="line">    a.当索引i达到数组长度时，将当前数组转换为List并纳入结果；</span><br><span class="line">    b.当索引i还没有达到数组长度时，从i开始，后面的每个数字都可以与i位置数字交换，i自增后进入下一轮dfs，dfs结束后将i位置和j位置数字交换回来；</span><br><span class="line">这种思路，每次交换到前面的数字都不再被访问，随着i的增加后面位置情况减少。</span><br><span class="line">（关键词，回溯交换）</span><br></pre></td></tr></table></figure>

<h3 id="084、含有重复元素集合的全排列（47、9月19日）"><a href="#084、含有重复元素集合的全排列（47、9月19日）" class="headerlink" title="084、含有重复元素集合的全排列（47、9月19日）"></a>084、含有重复元素集合的全排列（47、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。当索引i还没有到达数组长度时，从i开始，后面的每个数字只有与位置i的数字不同，都可以与i位置数字交换，其他步骤同第<span class="number">83</span>题。但是，有很多测试用例没通过。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，回溯法。观察题解发现，这里不能只判断“后面的每个数字只有与位置i的数字不同”，还有如果某数字已经与位置i的数字交换，那么与其值相同的数字就不应该再与位置i的数字交换。比如数组[<span class="number">1</span>,<span class="number">2</span>,i=<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]，这时候第二个<span class="number">3</span>不应该交换，第二个<span class="number">5</span>也不应该交换。</span><br><span class="line">（关键词，回溯交换+hashSet）</span><br></pre></td></tr></table></figure>

<h3 id="085、生成匹配的括号（22、9月19日）"><a href="#085、生成匹配的括号（22、9月19日）" class="headerlink" title="085、生成匹配的括号（22、9月19日）"></a>085、生成匹配的括号（22、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。这应该是第二次做这道题，虽然间隔很久，但是还是做出来了。思路就是，通过StringBuilder增加‘(’字符，进入下一轮dfs，dfs结束后将该字符从builder中移除，再同样操作‘)’字符。当递进深度达到<span class="number">2</span>*n时，判断字符串是否为有效括号，有效则纳入结果。</span><br><span class="line">    判断有效括号： ‘(’字符时压栈，‘)’字符时弹栈，弹栈时如果栈为空则<span class="literal">false</span>，全部字符遍历结束则返回<span class="literal">true</span>。</span><br><span class="line">但是，只击败了<span class="number">5</span>%的同学，肯定不是最优解了。  （关键词，先递进再判断）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，回溯法。相比我的优点是，不用专门判断括号是否有效。由于只存在圆括号“()”，那只需注意两点：</span><br><span class="line">    a.‘(’括号和‘)’括号，数目都不能超过n；</span><br><span class="line">    b.为满足括号匹配，任意时刻左括号数目 &gt;= 右括号数目；</span><br><span class="line">因此，当left&lt;n时，dfs进入left+<span class="number">1</span>；当left&gt;right时，dfs进入right+<span class="number">1</span>。  （关键词，left&gt;=n）</span><br></pre></td></tr></table></figure>

<h3 id="086、分割回文字符串（131、9月20日）"><a href="#086、分割回文字符串（131、9月20日）" class="headerlink" title="086、分割回文字符串（131、9月20日）"></a>086、分割回文字符串（131、9月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。从start开始遍历，如果从start开始到i结束(包括i)的字符串为回文字符串，那就通过s.substring(start,i+<span class="number">1</span>)把这段字符串切割出来，从(i+<span class="number">1</span>)进入下一轮dfs，dfs结束后将该段字符串删除。</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;s.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPara(s,start,i))&#123;</span><br><span class="line">判断回文字符串的isPara方法，是用双指针实现，通过<span class="keyword">while</span>确定左右两指针是否相遇，在这一过程对比字符。又是只击败了<span class="number">5</span>%，可能还是最后双层List&lt;List&lt;String&gt;&gt; 转 String[][]的步骤太耗费时间。</span><br><span class="line">    （关键词，先判断后递进）</span><br><span class="line"><span class="number">2.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="087、复原IP（93、9月20日）"><a href="#087、复原IP（93、9月20日）" class="headerlink" title="087、复原IP（93、9月20日）"></a>087、复原IP（93、9月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。当没有遍历到末尾，且<span class="string">&#x27;.&#x27;</span>字符数量不足<span class="number">3</span>时，对于当前字符有两种选择：</span><br><span class="line">    a.如果seg加当前字符后仍然有效，可以不创建新段，直接seg+ch，并进入下一轮dfs；</span><br><span class="line">    	<span class="keyword">if</span>(isAvaliable(seg+ch))</span><br><span class="line">    b.如果<span class="string">&#x27;.&#x27;</span>字符数量小于<span class="number">3</span>，且当前段有字符，可以创建新段<span class="string">&#x27;&#x27;</span>+ch，并在ip上添加当前段seg+<span class="string">&#x27;.&#x27;</span>，再进入下一轮dfs；</span><br><span class="line">		<span class="keyword">if</span>(numSplit&lt;<span class="number">3</span>&amp;&amp;seg.length()&gt;<span class="number">0</span>)</span><br><span class="line">这道题的边界条件比较复杂，比较难想到。此外，其isAvaliable方法设计很简洁，即规定范围且要满足<span class="number">0</span>的出现要求：</span><br><span class="line">	<span class="keyword">return</span> Integer.parseInt(s)&lt;=<span class="number">255</span>&amp;&amp;(s.equals(<span class="string">&quot;0&quot;</span>)||s.charAt(<span class="number">0</span>)!=<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">这道题解法并没有回溯，更像是所有可能走到头的穷举。估计下次做还是做不出来hhhh</span><br><span class="line">（关键词，先判断后递进）</span><br><span class="line"><span class="number">2.</span>字符串值比较一定要用s.equals(<span class="string">&quot;0&quot;</span>)，而不是s==<span class="string">&quot;0&quot;</span>，这里s是通过<span class="string">&quot;&quot;</span>+ch不断累加得到的。</span><br></pre></td></tr></table></figure>

<h3 id="总结之回溯法"><a href="#总结之回溯法" class="headerlink" title="总结之回溯法"></a>总结之回溯法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>官方描述提炼：</span><br><span class="line">	a.在采用回溯法解决问题时，如果到达树形结构的叶子节点，就找到了问题的一个解；</span><br><span class="line">	b.如果在前往某个节点时对问题的解的状态进行了修改，那么在回溯到它的父节点时要记得清除相应的修改；</span><br><span class="line">	c.如果明确知道某些子树没有必要遍历，那么在遍历的时候应该避开这些子树以优化效率，这种操作叫剪枝；</span><br><span class="line"><span class="number">2.</span>组合（子集）不看顺序，排列需要注意顺序（排列题目用swap）。</span><br><span class="line"><span class="number">3.</span>LinkedList类有removeLast方法，而ArrayList类并没有，注意多态别List。</span><br><span class="line"><span class="number">4.</span>双层List嵌套结果，需要用下面的方式放入结果。如果直接result.add(subSet)，后面再操作subSet时，会改变result中subSet值：</span><br><span class="line">		result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>回溯法dfs函数的经典结构（组合问题）：</span><br><span class="line">    <span class="keyword">if</span>(subSet.size()==k)&#123;</span><br><span class="line">            results.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(start&lt;=n)&#123;</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                </span><br><span class="line">                subSet.add(start);</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                subSet.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="number">6.</span>避免重复组合的方法是，当在某一步决定跳过某个值为m的数字时，跳过所有值为m的数字。</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> index;</span><br><span class="line">    <span class="keyword">while</span>(step+<span class="number">1</span>&lt;candidates.length&amp;&amp;candidates[step+<span class="number">1</span>] == candidates[step])&#123;</span><br><span class="line">        step += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(candidates, target, step + <span class="number">1</span>, sum, subSet, results);</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>适合回溯法的问题的一个特点是解决这个问题存在多个解，而且题目往往要求列出所有的解。</span><br></pre></td></tr></table></figure>

<h2 id="第十一章、二分查找"><a href="#第十一章、二分查找" class="headerlink" title="第十一章、二分查找"></a>第十一章、二分查找</h2><h3 id="068、查找插入位置（35、9月23日）"><a href="#068、查找插入位置（35、9月23日）" class="headerlink" title="068、查找插入位置（35、9月23日）"></a>068、查找插入位置（35、9月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举。从左到右遍历数组，如果当前数字大于等于目标值，返回当前索引；否则遍历结束后，返回数组长度，即目标值应该插入有序数组的最后一位。（关键词，穷举）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二分查找。经典的二分查找代码，维护left和right双指针，当left&lt;=right时，每轮取中间与目标值比较，根据大小关系决定移动哪个指针，下一轮遍历哪半部分。其中，left等于right是因为，长度为<span class="number">1</span>的子数组也是有效范围。</span><br><span class="line">    稍有不同的是，指针越界则返回left指针，说明上一轮指针重合，target恰好介于二者之间。</span><br></pre></td></tr></table></figure>

<h3 id="069、山峰数组的顶部（852、9月23日）"><a href="#069、山峰数组的顶部（852、9月23日）" class="headerlink" title="069、山峰数组的顶部（852、9月23日）"></a>069、山峰数组的顶部（852、9月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举+标志位。维护一个整型标志位flagIndex，记录山峰位置索引。从索引<span class="number">1</span>开始，从左到右遍历数组，如果当前值大于上一个值，就更新flagIndex，否则跳出循环，返回结果flagIndex。本题简单是因为输入是标准的山峰数组。（关键词，标志位）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二分查找。经典二分查找代码，但不知道如何维护边界。因为山峰的范围在[<span class="number">1</span>,length-<span class="number">2</span>]，故左指针从<span class="number">1</span>开始，右指针从（length-<span class="number">1</span>）开始，其他不变。（关键词，山峰边界）</span><br></pre></td></tr></table></figure>

<h3 id="070、排序数组中只出现一次的数字（540、9月23日）"><a href="#070、排序数组中只出现一次的数字（540、9月23日）" class="headerlink" title="070、排序数组中只出现一次的数字（540、9月23日）"></a>070、排序数组中只出现一次的数字（540、9月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举+标志位。维护一个整型标志位flag，记录当前遍历节点。因为是有序列表，如果本元素和前元素相等，就将flag恢复为Integer.MIN_VALUE，如果不相等，则返回上一元素。遍历到新数字时，如果flag等于Integer.MIN_VALUE，说明前两元素相等并清空了flag，这时候要将flag设置为本数字，避免本数字为最后的数字。（关键词，标志位）</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二分查找。对于<span class="number">3</span>前面的每个数对如(<span class="number">1</span>,<span class="number">1</span>)，第一个数是偶数；对于<span class="number">3</span>后面的每个数对如(<span class="number">4</span>,<span class="number">4</span>)，第一个数是奇数。因此，每次取到偶数mid时，如果nums[mid] == nums[mid + <span class="number">1</span>]说明mid是在<span class="number">3</span>之前，就移动左指针到mid+<span class="number">2</span>（下一个偶数），反之移动右指针到mid。（关键词，索引奇偶性找规律）</span><br><span class="line">	[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>]</span><br><span class="line">    [偶,奇,偶,奇,偶,奇,偶,奇,偶]</span><br><span class="line">    （二分查找看了几遍，没做出来）</span><br></pre></td></tr></table></figure>

<h3 id="071、按权重生成随机数（528、9月26日）"><a href="#071、按权重生成随机数（528、9月26日）" class="headerlink" title="071、按权重生成随机数（528、9月26日）"></a>071、按权重生成随机数（528、9月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，前缀和+二分查找。这道题要求按权重获取随机数，题解思路的精妙之处，在于维护一个前缀和数组，比如权重[<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]，维护一个前缀和数组[<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">12</span>],从[<span class="number">1</span>,<span class="number">12</span>]的范围里通过random API平均取随机数，如果取到<span class="number">9</span>，就对应取到前缀和数组中的索引<span class="number">3</span>，这样就实现了下标按权重随机获取。Solution构造方法初始化前缀和数组，pickIndex方法[<span class="number">0</span>,权重总和]随机获取值后，在前缀和数组里二分查找获取索引。</span><br><span class="line">    （关键词，前缀和数组）</span><br><span class="line"><span class="number">2.</span>本题数组中存着前缀和，因此要在[<span class="number">1</span>,total]中随机取值</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total);  <span class="comment">//在[0,total-1]中随机取值</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total)+<span class="number">1</span>;  <span class="comment">//在[1,total]中随机取值</span></span><br></pre></td></tr></table></figure>

<h3 id="072、求平方根（69、9月25日）"><a href="#072、求平方根（69、9月25日）" class="headerlink" title="072、求平方根（69、9月25日）"></a>072、求平方根（69、9月25日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，二分查找。每次取left、right指针的中间，如果mid*mid小于目标值，移动左指针到(mid-<span class="number">1</span>)，否则移动右指针到(mid+<span class="number">1</span>)。注意，判断条件left&lt;=right，这样如果目标值为<span class="number">0</span>就能处理。结果返回(left-<span class="number">1</span>)，因为mid才是平方恰小于目标值的数。（关键词，二分查找）</span><br><span class="line">    还需要<span class="type">long</span>来处理一些特别的测试用例。</span><br></pre></td></tr></table></figure>

<h3 id="073、狒狒吃香蕉（875、9月26日）"><a href="#073、狒狒吃香蕉（875、9月26日）" class="headerlink" title="073、狒狒吃香蕉（875、9月26日）"></a>073、狒狒吃香蕉（875、9月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，二分查找。没想到这样的题也能用二分查找，首先是在给定速度speed下时间的计算公式：</span><br><span class="line">	<span class="type">int</span> <span class="variable">curTime</span> <span class="operator">=</span> (pile+speed-<span class="number">1</span>)/speed;</span><br><span class="line">	time += curTime;</span><br><span class="line">这道题的思路就是，在最低、最高速度范围内，通过二分查找选出速度，并计算时间，如果时间低于目标值，就减小速度的最高界，反之增加速度的最低界。根据题解，狒狒吃香蕉速度最低每小时<span class="number">1</span>根，最高每小时最大堆根，因此将left、right指针分别指向<span class="number">0</span>和max，在二分查找时更新left、right指针，并更新获得的最低速度。</span><br><span class="line">    （关键词，二分查找速度+计算时间再判断）</span><br></pre></td></tr></table></figure>

<h3 id="总结之二分查找"><a href="#总结之二分查找" class="headerlink" title="总结之二分查找"></a>总结之二分查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>在一个长度为n的数组中查找一个数字，从左到右遍历的话需要O(n)的时间；如果数组是排序的（通常递增），那么可以采用二分查找进行优化。二分查找步骤如下：</span><br><span class="line">	取出位于数组中间的数字和目标数字比较，如果中间数字大于目标数字，那么只需要查找数组的前半部分，没必要再看后半部分。</span><br><span class="line"><span class="number">2.</span>经典二分查找代码：（关键词，left和right双指针，每轮取中间）</span><br><span class="line">    经典的二分查找代码，维护left和right双指针，当left&lt;=right时，每轮取中间与目标值比较，根据大小关系决定移动哪个指针，下一轮遍历哪半部分。其中，left等于right是因为，长度为<span class="number">1</span>的子数组也是有效范围。</span><br><span class="line">	<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> left;  <span class="comment">//如果找不到则返回比target大的后一位</span></span><br><span class="line"><span class="number">3.</span>Random API复制记录：</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total);  <span class="comment">//在[0,total-1]中随机取值</span></span><br><span class="line">  	<span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total)+<span class="number">1</span>;  <span class="comment">//在[1,total]中随机取值</span></span><br></pre></td></tr></table></figure>

<h2 id="第十二章、排序"><a href="#第十二章、排序" class="headerlink" title="第十二章、排序"></a>第十二章、排序</h2><h3 id="074、合并区间（56、9月26日）"><a href="#074、合并区间（56、9月26日）" class="headerlink" title="074、合并区间（56、9月26日）"></a>074、合并区间（56、9月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，先排序再比较。先将二维数组内层根据start从小到达排序，这时候就可比较相邻数组的end。这里使用双重<span class="keyword">while</span>控制，对于内层<span class="keyword">while</span>，如果遍历到的新数组start仍小于临时数组的end，就将新数组范围添加到临时数组（即更新临时数组end），直到某新数组不符合要求，则将临时数组添加到结果集中，在当前遍历点开始新一轮外层循环。</span><br><span class="line">    （关键词，排序后双<span class="keyword">while</span>）</span><br><span class="line"><span class="number">2.</span>数组操作相关api：</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]);  <span class="comment">//将二维数组intervals中的数组，按照索引0位置大小排序</span></span><br><span class="line">	<span class="comment">//将List转换为二维数组，需要先定义有外层初值的二维数组resultArray，再调用toArray API</span></span><br><span class="line">	List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	<span class="type">int</span>[][] resultArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][];</span><br><span class="line">	resultArray = result.toArray(resultArray);</span><br></pre></td></tr></table></figure>

<h3 id="075、数组相对排序（1122、9月27日）"><a href="#075、数组相对排序（1122、9月27日）" class="headerlink" title="075、数组相对排序（1122、9月27日）"></a>075、数组相对排序（1122、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>计数排序：如果数组长度为n，整数范围（最大整数和最小整数的差值）为k，对于k远小于n的场景，计数排序的时间复杂度优于其他基于比较的排序算法（如归并排序，快速排序等）。计数排序的基本思想是，先统计数组中每个整数在数组中出现的次数，然后按照从小到大的顺序将每个整数按照它出现的次数填到数组中。</span><br><span class="line">    即先根据输入的极值为每个可能的位置挖好坑（辅助数组），再遍历数组将每个位置的次数输入辅助数组，最后按顺序遍历辅助数组即可得到有序的结果。时间复杂度O(n+k)，空间复杂度O(k)。（关键词，counts数组）</span><br><span class="line">    <span class="comment">//计数排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            min = Math.min(min,num);</span><br><span class="line">            max = Math.max(max,num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[max-min+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            counts[num-min]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num=min;num&lt;=max;num++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(counts[num-min]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums[i++] = num;</span><br><span class="line">                counts[num-min] -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，计数排序。题目提示<span class="number">0</span> &lt;= arr1[i], arr2[i] &lt;= <span class="number">1000</span>，给出了数字范围k，是可以用计数排序的提示。先定义counts数组为<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>]，将arr1数组中每个数字的次数填入counts数组的对应索引位置，遍历arr2数组将counts数组对应数字依次取出，再将counts数组剩余元素依次取出，即可得到有序结果。（关键词，arr1放入counts[<span class="number">1001</span>]）</span><br></pre></td></tr></table></figure>

<h3 id="076、数组中的第k大的数字（215、9月27日）"><a href="#076、数组中的第k大的数字（215、9月27日）" class="headerlink" title="076、数组中的第k大的数字（215、9月27日）"></a>076、数组中的第k大的数字（215、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>快速排序：快速排序的基本思想是分治法，排序过程如下：在输入数组中随机选取一个元素作为中间值（pivot），然后对数组进行分区（partition），使所有比中间值小的数据移动到数组的左边，所有比中间值大的数据移动到数组的右边。接下来对两侧的子数组用相同的步骤排序，直到子数组只有一个数字为止。（关键词，随机获取中间值+small指针交换）</span><br><span class="line">	<span class="comment">//快速排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray_quick(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        quicksort(nums,<span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end&gt;start)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(nums,start,end);</span><br><span class="line">            quicksort(nums,start,pivot-<span class="number">1</span>);</span><br><span class="line">            quicksort(nums,pivot+<span class="number">1</span>,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//small指针始终指向已经发现的最后一个小于中间值的数字</span></span><br><span class="line">	<span class="comment">//即对于某一子数组，从左到右遍历时，如果发现nums[i]小于中间值，就和small指针位置的数字交换；介于small到i的数字，都是比中间值要大的数字，当i到达end时，将small指针位置数字和end交换，就使得大于中间值的数字放在了右边。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(end-start+<span class="number">1</span>)+start;</span><br><span class="line">        swap(nums,random,end);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> start - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[end])&#123;</span><br><span class="line">                small++;</span><br><span class="line">                swap(nums,i,small);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        small++;</span><br><span class="line">        swap(nums,small,end);</span><br><span class="line">        <span class="comment">//不是返回random，而是返回small，观察两次交换，random位置的值先到end，再到了small</span></span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index1,<span class="type">int</span> index2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index1!=index2)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">            nums[index1] = nums[index2];</span><br><span class="line">            nums[index2] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，快速排序+二分查找。先通过partition方法获取确定的中间值索引index，如果index小于目标索引位置，说明需要在右侧子数组中继续寻找，将二分查找的left指针指向index+<span class="number">1</span>；如果index大于目标索引位置，说明需要在左侧子数组中继续寻找，将二分查找的right指针指向index-<span class="number">1</span>；并继续递归调用partition方法，直到撞出目标索引位置后返回。（关键词，快排+二分查找）</span><br></pre></td></tr></table></figure>

<h3 id="077、链表排序（148、9月27日）"><a href="#077、链表排序（148、9月27日）" class="headerlink" title="077、链表排序（148、9月27日）"></a>077、链表排序（148、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>归并排序：归并排序也是一种基于分治法的排序算法，为了排序长度为n的数组，需要先排序两个长度为n/<span class="number">2</span>的子数组，然后合并两个排序的子数组。示例：  需要维护两个数组来回倒腾（关键词，子数组翻倍排序）</span><br><span class="line">    [<span class="number">4</span>,<span class="number">1</span>, <span class="number">5</span>,<span class="number">6</span>, <span class="number">2</span>,<span class="number">7</span>, <span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">  -&gt;[<span class="number">1</span>,<span class="number">4</span>, <span class="number">5</span>,<span class="number">6</span>, <span class="number">2</span>,<span class="number">7</span>, <span class="number">3</span>,<span class="number">8</span>]</span><br><span class="line">  -&gt;[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>    <span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">  -&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>   ]</span><br><span class="line">	<span class="comment">//归并排序 非递归实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray_guibing(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] src = nums;</span><br><span class="line">        <span class="type">int</span>[] dst = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">    	<span class="comment">//外层遍历每次翻倍合并两个数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> seg=<span class="number">1</span>;seg&lt;length;seg+=seg)&#123;</span><br><span class="line">            <span class="comment">//内层遍历从左到右，合并排序2*seg范围里的两个有序子数组，</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> start=<span class="number">0</span>;start&lt;length;start+=seg*<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> Math.min(start+seg, length);</span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(start+seg*<span class="number">2</span>,length);</span><br><span class="line">                <span class="type">int</span> i=start,j=mid,k=start;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;mid||j&lt;end)&#123;</span><br><span class="line">                    <span class="comment">//靠右的子数组可能先结束，如果其提前结束，就只选取前一数组的值</span></span><br><span class="line">                    <span class="keyword">if</span>(j == end||(i&lt;mid&amp;&amp;src[i]&lt;src[j]))&#123;</span><br><span class="line">                        dst[k++] = src[i++];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dst[k++] = src[j++];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换src和temp，屠龙勇士终成龙</span></span><br><span class="line">            <span class="type">int</span>[] temp = src;</span><br><span class="line">            src = dst;</span><br><span class="line">            dst = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序 递归实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray_guibing2(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span>[] dst = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dst = Arrays.copyOf(nums,nums.length);</span><br><span class="line">        mergeSort(nums,dst,<span class="number">0</span>,nums.length);</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] src,<span class="type">int</span>[] dst,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start+<span class="number">1</span>&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start+end)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(dst,src,start,mid);</span><br><span class="line">        mergeSort(dst,src,mid,end);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start,j = mid,k = start;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;mid||j&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == end||(i&lt;mid&amp;&amp;src[i]&lt;src[j]))&#123;</span><br><span class="line">                dst[k++] = src[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dst[k++] = src[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，归并排序。最近有点急火攻心，感冒了也迷茫了，在不知道的位置滚雪球，真的是在前进吗？总体结构如下代码，先通过split方法（快慢指针）获取链表的中间位置并切开，递归调用sortList将两边排序好后，再用merge方法组合两个链表。在merge方法中，因为传入两个链表的目的就是合并，因此可以移动两个链表的头指针，比较两个头指针大小后接到新链表cur上。</span><br><span class="line">    （关键词，快慢指针切开+归并排序）</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> split(head);</span><br><span class="line">        </span><br><span class="line">        head1 = sortList(head1);</span><br><span class="line">        head2 = sortList(head2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(head1,head2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="078、合并排序链表（23、9月27日）"><a href="#078、合并排序链表（23、9月27日）" class="headerlink" title="078、合并排序链表（23、9月27日）"></a>078、合并排序链表（23、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，最小堆。定义PriorityQueue如下，首先将每个链表的表头放入minHeap，由于是最小堆，此时poll操作获取值最小的节点，先将该节点链入新列表，再将其next指针指向的节点再放入minHeap，重复次操作直到最小堆为空。</span><br><span class="line">	PriorityQueue&lt;ListNode&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1.val-e2.val);</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，归并排序。将这些列表看作经典代码split方法切割后的列表。这时候只有对两边数组排序后再合并即可。注意边界调节，如果某范围start+<span class="number">1</span>==end，说明只有一条链表，此时不用再切开递进，直接返回后准备在上一层和另一条链表进行合并。</span><br><span class="line">    （关键词，索引切开+链表归并排序+最小单位是一条链表）</span><br></pre></td></tr></table></figure>

<h3 id="总结之排序"><a href="#总结之排序" class="headerlink" title="总结之排序"></a>总结之排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>面试经常要求应聘者比较插入排序、冒泡排序、堆排序、计数排序、归并排序和快速排序等不同算法的优劣，需要能够从额外空间消耗、平均时间复杂度和最差时间复杂度方面比较，最可能遇到的是计数排序、快速排序和归并排序。</span><br><span class="line"><span class="number">2.</span>排序能够为二分查找创建基础，在时间复杂度允许的情况下，可以先排序再解题。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数组操作相关api记录复制：</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]);  <span class="comment">//将二维数组intervals中的数组，按照索引0位置大小排序</span></span><br><span class="line">	<span class="comment">//将List转换为二维数组，需要先定义有外层初值的二维数组resultArray，再调用toArray API</span></span><br><span class="line">	List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	<span class="type">int</span>[][] resultArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][];</span><br><span class="line">	resultArray = result.toArray(resultArray);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>计数排序定义即经典代码 见<span class="number">075</span>、数组相对排序；  	    时间O(n+k)</span><br><span class="line">  快速排序定义即经典代码 见<span class="number">076</span>、数组中的第k大的数字；	  平均时间O(nlogn)</span><br><span class="line">  归并排序定义即经典代码 见<span class="number">077</span>、链表排序；			 时间O(nlogn)  空间O(n)</span><br><span class="line"><span class="number">5.</span>链表归并排序，合并时的经典复用代码（即按顺序合并两条有序的单链表）：</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1,ListNode head2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(head1!=<span class="literal">null</span>&amp;&amp;head2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1.val&lt;=head2.val)&#123;</span><br><span class="line">                cur.next = head1;</span><br><span class="line">                <span class="comment">//改造链表是因为，当被传入merge时已经是切成的小段，目的就是连城大段</span></span><br><span class="line">                head1= head1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = head2;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = head1==<span class="literal">null</span>?head2:head1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">6.</span>从<span class="number">8</span>月<span class="number">14</span>日走向<span class="number">9</span>月<span class="number">27</span>日，从最开始感受到稳定进步的兴奋，到现在每天滚着雪球惯性向前的茫然，这一个半月，听着师兄们找工作的挫败感，记起最初Java安全岗的梦想飘然远逝，在西电的深色夜幕中，汹涌人潮在黑暗中起落不止，失去光彩的星星一颗颗砸入噤声的大海。</span><br><span class="line">	不管怎么样，一个原以为坚持不下来的小阶段，还是磕磕绊绊地完成了，我知道了刷题到底是怎么回事。在接下来的“动态规划”和“图”两章中，我要适当放慢自己地脚步，将刷题约束在明确时间范围内，并在十月结束前刷完这本书，结束笔记。剩下的时间追逐梦想吧！！！</span><br></pre></td></tr></table></figure>

<h2 id="第十四章、动态规划"><a href="#第十四章、动态规划" class="headerlink" title="第十四章、动态规划"></a>第十四章、动态规划</h2><h3 id="088、爬楼梯的最少成本（746、10月31日）"><a href="#088、爬楼梯的最少成本（746、10月31日）" class="headerlink" title="088、爬楼梯的最少成本（746、10月31日）"></a>088、爬楼梯的最少成本（746、10月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>打算用整个十一月把top100和剑指offer2刷完，遂重启该部分，开始学习动态规划。</span><br><span class="line"><span class="number">2.</span>我的想法，递归。我知道爬楼梯的公式是f(x)=f(x-<span class="number">1</span>)+f(x-<span class="number">2</span>)，但显然使用递归是不理智的，因为对于dfs(<span class="number">8</span>)或dfs(<span class="number">9</span>)都要计算dfs(<span class="number">7</span>)及以下，时间开销很大所以没通过。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，动态规划。用迭代实现，规定dp[i]从i位置起步的最小开销，则有dp[<span class="number">0</span>]=cost[<span class="number">0</span>]，dp[<span class="number">1</span>]=cost[<span class="number">1</span>]，从i=<span class="number">2</span>开始计算即可。</span><br></pre></td></tr></table></figure>

<h3 id="089、房屋偷盗（198、10月31日）"><a href="#089、房屋偷盗（198、10月31日）" class="headerlink" title="089、房屋偷盗（198、10月31日）"></a>089、房屋偷盗（198、10月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。感觉自己还是挺聪明的，懂得变化。这道题不能偷盗相邻的房子，和爬楼梯的最少成本很相似，因此，定义dp[i]表示偷盗到第i个房子的积累金额，那么dp[i]的计算由于无后效性，不应该太远：</span><br><span class="line">	合法的上一次偷盗是dp[i-<span class="number">2</span>]，但是dp[i-<span class="number">2</span>]不能包括dp[i-<span class="number">3</span>]的情况，故表示该情况为dp[i-<span class="number">1</span>]-nums[i]，故计算公式如下：</span><br><span class="line">	dp[i] = Math.max(dp[i-<span class="number">2</span>],dp[i-<span class="number">1</span>]-nums[i-<span class="number">1</span>])+nums[i];   <span class="comment">//两种情况：不相邻的合法、相邻的合法</span></span><br></pre></td></tr></table></figure>

<h3 id="090、环形房屋偷盗（213、10月31日）"><a href="#090、环形房屋偷盗（213、10月31日）" class="headerlink" title="090、环形房屋偷盗（213、10月31日）"></a>090、环形房屋偷盗（213、10月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这道题相比第<span class="number">89</span>道题多了一条限制，即路径中不可以同时出现第<span class="number">0</span>号屋子和第(nums.length-<span class="number">1</span>)号屋子。因此，将问题划分为两个子问题，[<span class="number">0</span>,nums.length-<span class="number">2</span>]范围里的最优解和[<span class="number">1</span>,nums.lenght-<span class="number">1</span>]范围里的最优解，只需要将输入数组范围改变即可。</span><br><span class="line">    对于[<span class="number">1</span>,nums.lenght-<span class="number">1</span>]范围，可以初始化dp[<span class="number">0</span>]=<span class="number">0</span>，dp[<span class="number">1</span>]=nums[<span class="number">1</span>]，dp[<span class="number">2</span>]=nums[<span class="number">2</span>]，从i=<span class="number">3</span>开始公式计算；对于[<span class="number">0</span>,nums.length-<span class="number">2</span>]范围照旧即可。最后返回这两个最优解中的最大值。</span><br><span class="line">    此外，需要注意nums.length&lt;=<span class="number">2</span>时的特殊情况。</span><br></pre></td></tr></table></figure>

<h3 id="091、粉刷房子（256、11月2日）"><a href="#091、粉刷房子（256、11月2日）" class="headerlink" title="091、粉刷房子（256、11月2日）"></a>091、粉刷房子（256、11月2日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。没得想法，看到题解状态转移公式时恍然大悟，一共有三个表达式r(i)、b(i)和g(i)，计算方法一致皆为</span><br><span class="line">    r(i) = min(b(i-<span class="number">1</span>),g(i-<span class="number">1</span>))+cost[i][<span class="number">0</span>]  <span class="comment">//r(i)表示本次选择粉刷红色时，从0到i所有房子的最小成本</span></span><br><span class="line">因此，每栋房子粉刷的颜色受上一幢房子决定，无后效性。</span><br><span class="line">    <span class="keyword">return</span> Math.min(r[n-<span class="number">1</span>],Math.min(b[n-<span class="number">1</span>],g[n-<span class="number">1</span>]));  <span class="comment">//三值比较更为优雅的写法</span></span><br><span class="line">因为转移公式中只涉及dp[i-<span class="number">1</span>]和dp[i]，可以进一步减小空间复杂度：</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">如示例中，b[i-<span class="number">1</span>]表示为dp[(j+<span class="number">1</span>)%<span class="number">3</span>][(i-<span class="number">1</span>)%<span class="number">2</span>]，g[i-<span class="number">1</span>]表示为dp[(j+<span class="number">2</span>)%<span class="number">3</span>][(i-<span class="number">1</span>)%<span class="number">2</span>]。</span><br></pre></td></tr></table></figure>

<h3 id="092、翻转字符（926、11月3日）"><a href="#092、翻转字符（926、11月3日）" class="headerlink" title="092、翻转字符（926、11月3日）"></a>092、翻转字符（926、11月3日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。显然这道题要分情况讨论，应该有两个状态转移方程。根据题解，设f(i)表示把字符串中从<span class="number">0</span>到i的字符变成符合要求的字符并且最后一个字符是<span class="string">&#x27;0&#x27;</span>所需最少翻转次数；设g[i]表示把字符串从<span class="number">0</span>到i的字符变成符合要求并且最后一个字符时<span class="string">&#x27;1&#x27;</span>所需最少反转次数。</span><br><span class="line">	当字符串中下标i的字符是<span class="string">&#x27;0&#x27;</span>时，f(i)=f(i-<span class="number">1</span>)，是<span class="string">&#x27;1&#x27;</span>时则f(i)=f(i-<span class="number">1</span>)+<span class="number">1</span>；</span><br><span class="line">	当字符串中下标i的字符是<span class="string">&#x27;0&#x27;</span>时，g(i)=min&#123;f(i-<span class="number">1</span>),g(i-<span class="number">1</span>)&#125;+<span class="number">1</span>，是<span class="string">&#x27;1&#x27;</span>时则g(i)=min(f(i-<span class="number">1</span>),g(i-<span class="number">1</span>))；</span><br><span class="line"><span class="number">2.</span>做这道题时，猜到会和粉刷房子一样，存在两个转移方程。但还是差点感觉，所有转移函数的定义都是包含本索引的，在本索引做了什么事情后，从<span class="number">0</span>到本索引的最小成本。无后效性，本索引i的成本只与(i-<span class="number">1</span>)相关，除非(i-<span class="number">1</span>)不能表达所有情况，才会与(i-<span class="number">2</span>)相关，但是不会太远。</span><br></pre></td></tr></table></figure>

<h3 id="093、最长斐波那契数列（873、11月3日）"><a href="#093、最长斐波那契数列（873、11月3日）" class="headerlink" title="093、最长斐波那契数列（873、11月3日）"></a>093、最长斐波那契数列（873、11月3日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划+hashMap。这道题很难，状态转移公式为 dp(i,j) = dp(j,k)+<span class="number">1</span>，即假如(k,j,i)组成了斐波那契数列，则其延续的是(?,k,j)数列的长度。转移公式是通过(i,j)两位确定下来，即数列也是通过两位才能确定，单纯的i并不能确定。 </span><br><span class="line">    （关键词， 双层数组 dp(i,j) = dp(j,k)+<span class="number">1</span>）</span><br><span class="line"><span class="number">2.</span>此外，需要注意<span class="keyword">return</span> result&gt;<span class="number">0</span>?result+<span class="number">2</span>:<span class="number">0</span>，即最终数列还包含前<span class="number">2</span>个数字。</span><br></pre></td></tr></table></figure>

<h3 id="094、最少回文分割（132、11月5日）"><a href="#094、最少回文分割（132、11月5日）" class="headerlink" title="094、最少回文分割（132、11月5日）"></a>094、最少回文分割（132、11月5日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。首先维护二维数组isHuwen[i][j]，表示从i到j的字符串是否为回文。通过Arrays.fill填满<span class="literal">true</span>，然后双层<span class="keyword">for</span>循环，外层i从n-<span class="number">1</span>到<span class="number">0</span>，内层j从<span class="number">0</span>到i+<span class="number">1</span>到n。这两步很有技巧性，也是本题的关键，这里说明：</span><br><span class="line">	a.填满True的原因，计算公式为下面式子，如果i=<span class="number">3</span>，j=<span class="number">4</span>，isHuiwen[<span class="number">4</span>][<span class="number">3</span>]没有意义，所以要isHuiwen[<span class="number">4</span>][<span class="number">3</span>]=<span class="literal">true</span>，这样只考虑前面</span><br><span class="line">    	isHuiwen[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; isHuiwen[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">	b.为什么从末尾开始，是因为计算isHuiwen[i][j]时，isHuiwen[i+<span class="number">1</span>][j-<span class="number">1</span>]已经被上一层外层循环计算了.如果从<span class="number">0</span>开始，要计算isHuiwen[<span class="number">0</span>][<span class="number">3</span>]，此时isHuiwen[<span class="number">1</span>][<span class="number">2</span>]还没被计算。</span><br><span class="line">	最后要计算分割次数f，就是从<span class="number">0</span>开始遍历，如果isHuiwen[<span class="number">0</span>][i]为<span class="literal">true</span>则f[i]=<span class="number">0</span>；如果isHuiwen[<span class="number">0</span>][i]为<span class="literal">false</span>，则 <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)，min&#123;f[j&#125;]+<span class="number">1</span>=f[i]；最后返回f[n-<span class="number">1</span>]；</span><br><span class="line">        </span><br><span class="line"><span class="number">2.</span>Arrays.fill(g[i], <span class="literal">true</span>);  <span class="comment">//g是二维数组，则需要for循环索引填充每层一维数组g[i]</span></span><br></pre></td></tr></table></figure>

<h3 id="095、最长公共子序列（1143、11月9日）"><a href="#095、最长公共子序列（1143、11月9日）" class="headerlink" title="095、最长公共子序列（1143、11月9日）"></a>095、最长公共子序列（1143、11月9日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。确实打不过，没办法实力差距，一直都在想将dp[i][j-&gt;m]和dp[i-&gt;n][j]都设置为dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>，但是逻辑有点乱。这道题关键想法在，dp[i-<span class="number">1</span>][j-<span class="number">1</span>]是第（i开始至末尾）个text1字符和第（j开始至末尾）个text2字符没参与过的，</span><br><span class="line">	a.如果第i个text1字符和第j个text2字符相等，则dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>，即使j前的text2字符也可能与（i）相等；</span><br><span class="line">	b.如果第i个text1字符和第j个text2字符不等，则dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])，即可能(i）或(j)造成了相等，并继续维持下去；</span><br><span class="line">	这样的好处是a情况，后来又有一个j字符与i相等，并不是从dp[i][(j-<span class="number">1</span>)以前]去计算。</span><br><span class="line"><span class="number">2.</span>本题需要考虑dp[<span class="number">0</span>][<span class="number">0</span>]，所以设置dp大小为dp[n+<span class="number">1</span>][m+<span class="number">1</span>], 注意dp和text1、text2的索引关系即可。</span><br><span class="line"><span class="number">3.</span>做dp的题好有意思唉，各种各样的转移方程都见过了，还是做不出来啊啊。</span><br></pre></td></tr></table></figure>

<h3 id="096、字符串交织（97、11月9日）"><a href="#096、字符串交织（97、11月9日）" class="headerlink" title="096、字符串交织（97、11月9日）"></a>096、字符串交织（97、11月9日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。感觉和上一道题很像，但是还是做不出来。根据题解分析下吧。定义dp[i][j]表示s1的前i个字符和s2的前j个字符能否组成s3的前（i+j）个字符。那么dp[i][j]既可能因为第（i-<span class="number">1</span>）个s1字符变为<span class="literal">true</span>，也可能因为第（j-<span class="number">1</span>）个s2字符变为<span class="literal">true</span>，故计算如下：</span><br><span class="line">	dp[i][j] = dp[i-<span class="number">1</span>][j]&amp;&amp;(s1.charAt(i-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>));    <span class="comment">//因为第(i-1)个字符</span></span><br><span class="line">	dp[i][j] = dp[i][j] || (dp[i][j-<span class="number">1</span>]&amp;&amp;(s2.charAt(j-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>)));   <span class="comment">//因为第(j-1)个字符</span></span><br><span class="line">此外，需要注意还要计算dp[<span class="number">1</span>][<span class="number">0</span>]、dp[<span class="number">2</span>][<span class="number">0</span>]、dp[<span class="number">0</span>][<span class="number">1</span>]、dp[<span class="number">0</span>][<span class="number">2</span>]等，故不能 <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>)<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>)。</span><br></pre></td></tr></table></figure>

<h3 id="总结之动态规划"><a href="#总结之动态规划" class="headerlink" title="总结之动态规划"></a>总结之动态规划</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.爬楼梯问题、房屋偷盗问题的根源公式都是f(x)=f(x-1)+f(x-2)，即x位置的状态计算由它的相邻位置和它的最后不相邻位置决定。</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://bmsk1994.github.io">bmsk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bmsk1994.github.io/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/">https://bmsk1994.github.io/2022/11/14/剑指offer-专项突破/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/14/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"><img class="prev-cover" src="/img/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">学习日志</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/14/HOT-100/"><img class="next-cover" src="/img/hot100.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">HOT 100</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/11/14/HOT-100/" title="HOT 100"><img class="cover" src="/img/hot100.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-14</div><div class="title">HOT 100</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">bmsk</div><div class="author-info__description">此时一切都好</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/BMSK1994"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/BMSK1994" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1679897187@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%91%E6%8C%87Offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88"><span class="toc-number">1.</span> <span class="toc-text">剑指Offer专项突破版</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.</span> <span class="toc-text">第三章、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#014-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D-567%E3%80%818%E6%9C%8814%E6%97%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">014.字符串中的变位词 (567、8月14日)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#015-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%98%E4%BD%8D%E8%AF%8D-438%E3%80%818%E6%9C%8815%E6%97%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">015.字符串中的所有变位词(438、8月15日)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#016-%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-3%E3%80%818%E6%9C%8815%E6%97%A5"><span class="toc-number">1.1.3.</span> <span class="toc-text">016.不含重复字符的最长连续子字符串(3、8月15日)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#017-%E5%90%AB%E6%9C%89%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8876%E3%80%818%E6%9C%8815%E6%97%A5%E3%80%8120%E6%97%A5%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">017.含有所有字符的最短字符串（76、8月15日、20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#018-%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%96%87%EF%BC%88125%E3%80%818%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.1.5.</span> <span class="toc-text">018.有效的回文（125、8月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#019-%E6%9C%80%E5%A4%9A%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%BE%97%E5%88%B0%E5%9B%9E%E6%96%87%EF%BC%88680%E3%80%818%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.1.6.</span> <span class="toc-text">019.最多删除一个字符得到回文（680、8月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#020-%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%88647%E3%80%818%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.1.7.</span> <span class="toc-text">020.回文子字符串的个数（647、8月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.8.</span> <span class="toc-text">总结之字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">第四章、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#021-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8819%E3%80%818%E6%9C%8821%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">021.删除链表的倒数第n个节点（19、8月21日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#022-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%EF%BC%88142%E3%80%818%E6%9C%8821%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">022.链表中环的入口节点（142、8月21日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#023-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%87%8D%E5%90%88%E8%8A%82%E7%82%B9%EF%BC%88160%E3%80%818%E6%9C%8821%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">023.两个链表的第一个重合节点（160、8月21日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#024-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88206%E3%80%818%E6%9C%8822%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">024.反转链表（206、8月22日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#025%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88445%E3%80%818%E6%9C%8822%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">025、链表中的两数相加（445、8月22日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#026%E3%80%81%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%EF%BC%88143%E3%80%818%E6%9C%8822%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.6.</span> <span class="toc-text">026、重排链表（143、8月22日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#027%E3%80%81%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%88234%E3%80%818%E6%9C%8822%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.7.</span> <span class="toc-text">027、回文链表（234、8月22日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#028%E3%80%81%E5%B1%95%E5%B9%B3%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%88430%E3%80%818%E6%9C%8823%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.8.</span> <span class="toc-text">028、展平多级双向链表（430、8月23日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#029%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%88708%E3%80%818%E6%9C%8824%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.9.</span> <span class="toc-text">029、排序的循环链表（708、8月24日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.10.</span> <span class="toc-text">总结之链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">第二章、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#006%E3%80%81%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%EF%BC%88167%E3%80%818%E6%9C%8824%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">006、排序数组中两个数字之和（167、8月24日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#007%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA0%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0%EF%BC%8815%E3%80%818%E6%9C%8824%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">007、数组中和为0的三个数（15、8月24日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#008%E3%80%81-%E5%92%8C%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E-target-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88209%E3%80%818%E6%9C%8824%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">008、 和大于等于 target 的最短子数组（209、8月24日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#009%E3%80%81%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8Ek%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88713%E3%80%818%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">009、乘积小于k的子数组（713、8月26日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#010%E3%80%81%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88560%E3%80%818%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">010、和为k的子数组（560、8月26日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#011%E3%80%810%E5%92%8C1%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88525%E3%80%818%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.6.</span> <span class="toc-text">011、0和1个数相同的子数组（525、8月26日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#012%E3%80%81%E5%B7%A6%E5%8F%B3%E4%B8%A4%E8%BE%B9%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89%EF%BC%88724%E3%80%818%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.7.</span> <span class="toc-text">012、左右两边子数组的和相等（724、8月27日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#013%E3%80%81%E4%BA%8C%E7%BB%B4%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C%EF%BC%88304%E3%80%818%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.8.</span> <span class="toc-text">013、二维子矩阵的和（304、8月27日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.9.</span> <span class="toc-text">总结之数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%81%E6%95%B4%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">第一章、整数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#001%E3%80%81%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95%EF%BC%8829%E3%80%818%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">001、整数除法（29、8月31日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#002%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%EF%BC%8867%E3%80%818%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">002、二进制加法（67、8月31日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#003%E3%80%81%E5%89%8Dn%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%88338%E3%80%818%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">003、前n个数字二进制中1的个数（338、8月31日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#004%E3%80%81%E5%8F%AA%E5%87%BA%E7%8E%B01%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88137%E3%80%819%E6%9C%881%E6%97%A5%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">004、只出现1次的数字（137、9月1日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#005%E3%80%81%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%EF%BC%88318%E3%80%819%E6%9C%881%E6%97%A5%EF%BC%89"><span class="toc-number">1.4.5.</span> <span class="toc-text">005、单词长度的最大乘积（318、9月1日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E4%B9%8B%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.6.</span> <span class="toc-text">整数之总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">第五章、哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#030%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E9%83%BD%E6%98%AFO-1-%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%88380%E3%80%818%E6%9C%8828%E6%97%A5%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">030、插入、删除和随机访问都是O(1)的容器（380、8月28日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#031%E3%80%81%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%88146%E3%80%819%E6%9C%881%E6%97%A5%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">031、最近最少使用缓存（146、9月1日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#032%E3%80%81%E6%9C%89%E6%95%88%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D%EF%BC%88242%E3%80%819%E6%9C%882%E6%97%A5%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">032、有效的变位词（242、9月2日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#033%E3%80%81%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84%EF%BC%8849%E3%80%819%E6%9C%882%E6%97%A5%EF%BC%89"><span class="toc-number">1.5.4.</span> <span class="toc-text">033、变位词组（49、9月2日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#034%E3%80%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%A8%80%E6%98%AF%E5%90%A6%E6%8E%92%E5%BA%8F%EF%BC%88953%E3%80%819%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.5.5.</span> <span class="toc-text">034、外星语言是否排序（953、9月6日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#035%E3%80%81%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE%EF%BC%88539%E3%80%819%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.5.6.</span> <span class="toc-text">035、最小时间差（539、9月6日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.5.7.</span> <span class="toc-text">总结之哈希表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E6%A0%88"><span class="toc-number">1.6.</span> <span class="toc-text">第六章、栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#036%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88150%E3%80%819%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">036、后缀表达式（150、9月6日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#037%E3%80%81%E5%B0%8F%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E%EF%BC%88735%E3%80%819%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">037、小行星碰撞（735、9月6日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#038%E3%80%81%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6%EF%BC%88739%E3%80%819%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">038、每日温度（739、9月6日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90039%E3%80%81%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%EF%BC%8884%E3%80%819%E6%9C%887%E6%97%A5%EF%BC%89%E3%80%91"><span class="toc-number">1.6.4.</span> <span class="toc-text">【039、直方图最大矩形面积（84、9月7日）】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90040%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2%EF%BC%8885%E3%80%819%E6%9C%887%E6%97%A5%EF%BC%89%E3%80%91"><span class="toc-number">1.6.5.</span> <span class="toc-text">【040、矩阵中最大的矩形（85、9月7日）】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E6%A0%88"><span class="toc-number">1.6.6.</span> <span class="toc-text">总结之栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E9%98%9F%E5%88%97"><span class="toc-number">1.7.</span> <span class="toc-text">第七章、队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#041%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC%EF%BC%88346%E3%80%819%E6%9C%8810%E6%97%A5%EF%BC%89"><span class="toc-number">1.7.1.</span> <span class="toc-text">041、滑动窗口的平均值（346、9月10日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#042%E3%80%81%E6%9C%80%E8%BF%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0%EF%BC%88933%E3%80%819%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">042、最近请求次数（933、9月11日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#043%E3%80%81%E5%BE%80%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%EF%BC%88919%E3%80%819%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.7.3.</span> <span class="toc-text">043、往完全二叉树添加节点（919、9月11日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#044%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%8F%E5%B1%82%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%88515%E3%80%819%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.7.4.</span> <span class="toc-text">044、二叉树每层的最大值（515、9月11日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#045%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%BA%95%E5%B1%82%E6%9C%80%E5%B7%A6%E8%BE%B9%E7%9A%84%E5%80%BC%EF%BC%88513%E3%80%819%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.7.5.</span> <span class="toc-text">045、二叉树最底层最左边的值（513、9月11日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#046%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E4%BE%A7%E8%A7%86%E5%9B%BE%EF%BC%88199%E3%80%819%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.7.6.</span> <span class="toc-text">046、二叉树的右侧视图（199、9月11日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E9%98%9F%E5%88%97"><span class="toc-number">1.7.7.</span> <span class="toc-text">总结之队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%81%E6%A0%91"><span class="toc-number">1.8.</span> <span class="toc-text">第八章、树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#047%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D%EF%BC%88814%E3%80%819%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.1.</span> <span class="toc-text">047、二叉树剪枝（814、9月11日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#048%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%A0%91%EF%BC%88297%E3%80%819%E6%9C%8812%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.2.</span> <span class="toc-text">048、序列化与反序列化树（297、9月12日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#049%E3%80%81%E4%BB%8E%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%EF%BC%88129%E3%80%819%E6%9C%8812%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.3.</span> <span class="toc-text">049、从根节点到叶节点的路径数字之和（129、9月12日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#050%E3%80%81%E5%90%91%E4%B8%8B%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C%EF%BC%88437%E3%80%819%E6%9C%8812%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.4.</span> <span class="toc-text">050、向下的路径节点之和（437、9月12日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#051%E3%80%81%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%88124%E3%80%819%E6%9C%8812%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.5.</span> <span class="toc-text">051、节点之和最大的路径（124、9月12日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#052%E3%80%81%E5%B1%95%E5%B9%B3%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88897%E3%80%819%E6%9C%8813%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.6.</span> <span class="toc-text">052、展平二叉搜索树（897、9月13日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#053%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7%EF%BC%88285%E3%80%819%E6%9C%8813%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.7.</span> <span class="toc-text">053、二叉搜索树中的中序后继（285、9月13日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#054%E3%80%81%E6%89%80%E6%9C%89%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E4%B9%8B%E5%92%8C%EF%BC%88538%E3%80%811038%E3%80%819%E6%9C%8813%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.8.</span> <span class="toc-text">054、所有大于等于节点的值之和（538、1038、9月13日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#055%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88173%E3%80%819%E6%9C%8815%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.9.</span> <span class="toc-text">055、二叉搜索树迭代器（173、9月15日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#056%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C%EF%BC%88653%E3%80%819%E6%9C%8815%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.10.</span> <span class="toc-text">056、二叉搜索树中两个节点之和（653、9月15日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#057%E3%80%81%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E4%B9%8B%E5%B7%AE%E9%83%BD%E5%9C%A8%E7%BB%99%E5%AE%9A%E7%9A%84%E8%8C%83%E5%9B%B4%E5%86%85%EF%BC%88220%E3%80%819%E6%9C%8815%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.11.</span> <span class="toc-text">057、值和下标之差都在给定的范围内（220、9月15日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#058%E3%80%81%E6%97%A5%E7%A8%8B%E8%A1%A8%EF%BC%88729%E3%80%819%E6%9C%8815%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.12.</span> <span class="toc-text">058、日程表（729、9月15日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E6%A0%91"><span class="toc-number">1.8.13.</span> <span class="toc-text">总结之树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%E3%80%81%E5%A0%86"><span class="toc-number">1.9.</span> <span class="toc-text">第九章、堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#059%E3%80%81%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AC%ACK%E5%A4%A7%E6%95%B0%E5%80%BC%EF%BC%88703%E3%80%819%E6%9C%8816%E6%97%A5%EF%BC%89"><span class="toc-number">1.9.1.</span> <span class="toc-text">059、数据流的第K大数值（703、9月16日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#060%E3%80%81%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84k%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%88347%E3%80%819%E6%9C%8816%E6%97%A5%EF%BC%89"><span class="toc-number">1.9.2.</span> <span class="toc-text">060、出现频率最高的k个数字（347、9月16日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#061%E3%80%81%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%E5%AF%B9%EF%BC%88373%E3%80%819%E6%9C%8816%E6%97%A5%EF%BC%89"><span class="toc-number">1.9.3.</span> <span class="toc-text">061、和最小的k个数对（373、9月16日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E5%A0%86"><span class="toc-number">1.9.4.</span> <span class="toc-text">总结之堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">1.10.</span> <span class="toc-text">第十章、前缀树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#062%E3%80%81%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%88208%E3%80%819%E6%9C%8816%E6%97%A5%EF%BC%89"><span class="toc-number">1.10.1.</span> <span class="toc-text">062、实现前缀树（208、9月16日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#063%E3%80%81%E6%9B%BF%E6%8D%A2%E5%8D%95%E8%AF%8D%EF%BC%88648%E3%80%819%E6%9C%8817%E6%97%A5%EF%BC%89"><span class="toc-number">1.10.2.</span> <span class="toc-text">063、替换单词（648、9月17日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#064%E3%80%81%E7%A5%9E%E5%A5%87%E7%9A%84%E5%AD%97%E5%85%B8%EF%BC%88676%E3%80%819%E6%9C%8817%E6%97%A5%EF%BC%89"><span class="toc-number">1.10.3.</span> <span class="toc-text">064、神奇的字典（676、9月17日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#065%E3%80%81%E6%9C%80%E7%9F%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E7%BC%96%E7%A0%81%EF%BC%88820%E3%80%819%E6%9C%8817%E6%97%A5%EF%BC%89"><span class="toc-number">1.10.4.</span> <span class="toc-text">065、最短的单词编码（820、9月17日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#066%E3%80%81%E5%8D%95%E8%AF%8D%E4%B9%8B%E5%92%8C%EF%BC%88677%E3%80%819%E6%9C%8817%E6%97%A5%EF%BC%89"><span class="toc-number">1.10.5.</span> <span class="toc-text">066、单词之和（677、9月17日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#067%E3%80%81%E6%9C%80%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96%EF%BC%88421%E3%80%819%E6%9C%8817%E6%97%A5%EF%BC%89"><span class="toc-number">1.10.6.</span> <span class="toc-text">067、最大的异或（421、9月17日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">1.10.7.</span> <span class="toc-text">总结之前缀树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E3%80%81%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">第十三章、回溯法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#079%E3%80%81%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86%EF%BC%8878%E3%80%819%E6%9C%8818%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.1.</span> <span class="toc-text">079、所有子集（78、9月18日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#080%E3%80%81%E5%90%AB%E6%9C%89k%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%84%E5%90%88%EF%BC%8877%E3%80%819%E6%9C%8818%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.2.</span> <span class="toc-text">080、含有k个元素的组合（77、9月18日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#081%E3%80%81%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%84%E5%90%88%EF%BC%8839%E3%80%819%E6%9C%8819%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.3.</span> <span class="toc-text">081、允许重复选择元素的组合（39、9月19日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#082%E3%80%81%E5%90%AB%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%84%E5%90%88%EF%BC%8840%E3%80%819%E6%9C%8819%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.4.</span> <span class="toc-text">082、含有重复元素集合的组合（40、9月19日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#083%E3%80%81%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8846%E3%80%819%E6%9C%8819%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.5.</span> <span class="toc-text">083、没有重复元素集合的全排列（46、9月19日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#084%E3%80%81%E5%90%AB%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8847%E3%80%819%E6%9C%8819%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.6.</span> <span class="toc-text">084、含有重复元素集合的全排列（47、9月19日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#085%E3%80%81%E7%94%9F%E6%88%90%E5%8C%B9%E9%85%8D%E7%9A%84%E6%8B%AC%E5%8F%B7%EF%BC%8822%E3%80%819%E6%9C%8819%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.7.</span> <span class="toc-text">085、生成匹配的括号（22、9月19日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#086%E3%80%81%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88131%E3%80%819%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.8.</span> <span class="toc-text">086、分割回文字符串（131、9月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#087%E3%80%81%E5%A4%8D%E5%8E%9FIP%EF%BC%8893%E3%80%819%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.9.</span> <span class="toc-text">087、复原IP（93、9月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-number">1.11.10.</span> <span class="toc-text">总结之回溯法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.12.</span> <span class="toc-text">第十一章、二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#068%E3%80%81%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%8835%E3%80%819%E6%9C%8823%E6%97%A5%EF%BC%89"><span class="toc-number">1.12.1.</span> <span class="toc-text">068、查找插入位置（35、9月23日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#069%E3%80%81%E5%B1%B1%E5%B3%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%B6%E9%83%A8%EF%BC%88852%E3%80%819%E6%9C%8823%E6%97%A5%EF%BC%89"><span class="toc-number">1.12.2.</span> <span class="toc-text">069、山峰数组的顶部（852、9月23日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#070%E3%80%81%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88540%E3%80%819%E6%9C%8823%E6%97%A5%EF%BC%89"><span class="toc-number">1.12.3.</span> <span class="toc-text">070、排序数组中只出现一次的数字（540、9月23日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#071%E3%80%81%E6%8C%89%E6%9D%83%E9%87%8D%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%88528%E3%80%819%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.12.4.</span> <span class="toc-text">071、按权重生成随机数（528、9月26日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#072%E3%80%81%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9%EF%BC%8869%E3%80%819%E6%9C%8825%E6%97%A5%EF%BC%89"><span class="toc-number">1.12.5.</span> <span class="toc-text">072、求平方根（69、9月25日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#073%E3%80%81%E7%8B%92%E7%8B%92%E5%90%83%E9%A6%99%E8%95%89%EF%BC%88875%E3%80%819%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.12.6.</span> <span class="toc-text">073、狒狒吃香蕉（875、9月26日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.12.7.</span> <span class="toc-text">总结之二分查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E3%80%81%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.</span> <span class="toc-text">第十二章、排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#074%E3%80%81%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%EF%BC%8856%E3%80%819%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.13.1.</span> <span class="toc-text">074、合并区间（56、9月26日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#075%E3%80%81%E6%95%B0%E7%BB%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F%EF%BC%881122%E3%80%819%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.13.2.</span> <span class="toc-text">075、数组相对排序（1122、9月27日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#076%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88215%E3%80%819%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.13.3.</span> <span class="toc-text">076、数组中的第k大的数字（215、9月27日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#077%E3%80%81%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%EF%BC%88148%E3%80%819%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.13.4.</span> <span class="toc-text">077、链表排序（148、9月27日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#078%E3%80%81%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%8823%E3%80%819%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.13.5.</span> <span class="toc-text">078、合并排序链表（23、9月27日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.6.</span> <span class="toc-text">总结之排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.14.</span> <span class="toc-text">第十四章、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#088%E3%80%81%E7%88%AC%E6%A5%BC%E6%A2%AF%E7%9A%84%E6%9C%80%E5%B0%91%E6%88%90%E6%9C%AC%EF%BC%88746%E3%80%8110%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.1.</span> <span class="toc-text">088、爬楼梯的最少成本（746、10月31日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#089%E3%80%81%E6%88%BF%E5%B1%8B%E5%81%B7%E7%9B%97%EF%BC%88198%E3%80%8110%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.2.</span> <span class="toc-text">089、房屋偷盗（198、10月31日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#090%E3%80%81%E7%8E%AF%E5%BD%A2%E6%88%BF%E5%B1%8B%E5%81%B7%E7%9B%97%EF%BC%88213%E3%80%8110%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.3.</span> <span class="toc-text">090、环形房屋偷盗（213、10月31日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#091%E3%80%81%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90%EF%BC%88256%E3%80%8111%E6%9C%882%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.4.</span> <span class="toc-text">091、粉刷房子（256、11月2日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#092%E3%80%81%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%EF%BC%88926%E3%80%8111%E6%9C%883%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.5.</span> <span class="toc-text">092、翻转字符（926、11月3日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#093%E3%80%81%E6%9C%80%E9%95%BF%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%EF%BC%88873%E3%80%8111%E6%9C%883%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.6.</span> <span class="toc-text">093、最长斐波那契数列（873、11月3日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#094%E3%80%81%E6%9C%80%E5%B0%91%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2%EF%BC%88132%E3%80%8111%E6%9C%885%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.7.</span> <span class="toc-text">094、最少回文分割（132、11月5日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#095%E3%80%81%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%881143%E3%80%8111%E6%9C%889%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.8.</span> <span class="toc-text">095、最长公共子序列（1143、11月9日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#096%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E7%BB%87%EF%BC%8897%E3%80%8111%E6%9C%889%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.9.</span> <span class="toc-text">096、字符串交织（97、11月9日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.14.10.</span> <span class="toc-text">总结之动态规划</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/14/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/" title="学习日志"><img src="/img/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习日志"/></a><div class="content"><a class="title" href="/2022/11/14/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/" title="学习日志">学习日志</a><time datetime="2022-11-14T12:09:14.000Z" title="Created 2022-11-14 20:09:14">2022-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/" title="剑指offer 专项突破"><img src="/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="剑指offer 专项突破"/></a><div class="content"><a class="title" href="/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/" title="剑指offer 专项突破">剑指offer 专项突破</a><time datetime="2022-11-14T12:07:42.000Z" title="Created 2022-11-14 20:07:42">2022-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/14/HOT-100/" title="HOT 100"><img src="/img/hot100.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HOT 100"/></a><div class="content"><a class="title" href="/2022/11/14/HOT-100/" title="HOT 100">HOT 100</a><time datetime="2022-11-14T12:05:09.000Z" title="Created 2022-11-14 20:05:09">2022-11-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By bmsk</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>