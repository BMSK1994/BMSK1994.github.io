<!DOCTYPE html><html lang="[&quot;zh-cn&quot;,&quot;en&quot;,&quot;default&quot;]" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>剑指offer 专项突破 | BMSK</title><meta name="author" content="bmsk"><meta name="copyright" content="bmsk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="剑指Offer专项突破版第三章、字符串014.字符串中的变位词 (567、8月14日)1.我的想法：将字符串s1的各种变位词罗列出来，遍历变位词列表，调用某操作String类的API判断是否为子串。  a.给出子串位置api：s1.indexOf(s2);    b.输出字符串的全排列：这是一个典型的回溯过程，每次先将字符串最左边位置与后面其他位置替换，再将左端位置右移一位，返回后则将最左边位置和">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer 专项突破">
<meta property="og:url" content="https://bmsk1994.github.io/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/index.html">
<meta property="og:site_name" content="BMSK">
<meta property="og:description" content="剑指Offer专项突破版第三章、字符串014.字符串中的变位词 (567、8月14日)1.我的想法：将字符串s1的各种变位词罗列出来，遍历变位词列表，调用某操作String类的API判断是否为子串。  a.给出子串位置api：s1.indexOf(s2);    b.输出字符串的全排列：这是一个典型的回溯过程，每次先将字符串最左边位置与后面其他位置替换，再将左端位置右移一位，返回后则将最左边位置和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bmsk1994.github.io/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg">
<meta property="article:published_time" content="2022-11-14T12:07:42.000Z">
<meta property="article:modified_time" content="2023-03-20T05:35:05.598Z">
<meta property="article:author" content="bmsk">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bmsk1994.github.io/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://bmsk1994.github.io/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '剑指offer 专项突破',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-20 13:35:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">BMSK</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">剑指offer 专项突破</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-11-14T12:07:42.000Z" title="Created 2022-11-14 20:07:42">2022-11-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-03-20T05:35:05.598Z" title="Updated 2023-03-20 13:35:05">2023-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode/">LeetCode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">35.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>121min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="剑指offer 专项突破"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="剑指Offer专项突破版"><a href="#剑指Offer专项突破版" class="headerlink" title="剑指Offer专项突破版"></a>剑指Offer专项突破版</h1><h2 id="第三章、字符串"><a href="#第三章、字符串" class="headerlink" title="第三章、字符串"></a>第三章、字符串</h2><h3 id="014-字符串中的变位词-567、8月14日"><a href="#014-字符串中的变位词-567、8月14日" class="headerlink" title="014.字符串中的变位词 (567、8月14日)"></a>014.字符串中的变位词 (567、8月14日)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：将字符串s1的各种变位词罗列出来，遍历变位词列表，调用某操作String类的API判断是否为子串。</span><br><span class="line">  a.给出子串位置api：s1.indexOf(s2);  </span><br><span class="line">  b.输出字符串的全排列：这是一个典型的回溯过程，每次先将字符串最左边位置与后面其他位置替换，再将左端位置右移一位，返回后则将最左边位置和那个其他位置替换出来，这样每次递进时后面的字符都挨个做当前最左端位置。</span><br><span class="line">      </span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：双指针+hash表。使用hash表记录s2中字符对应位置加<span class="number">1</span>，使用双指针在s1中维护一个和s2长度一致的子串，遍历双指针维护的子串时，将hash表对应字符位置减<span class="number">1</span>，当前子串遍历完毕时hash表全部值为<span class="number">0</span>则说明是变位词。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>：两个hashmap比较，一个是s1的词频，另一个是s2的滑动窗口。每次移动只在滑动窗口的hashmap上改变两端，左端字符减一，右端字符加一，再进行两个hashmap的比较，这样就不需要在滑动窗口内部进行遍历。</span><br><span class="line">      </span><br><span class="line"><span class="number">4.</span>HashMap.equals作用于基本数据类型是能实现map的直接整体比较的。观察源码后发现，map1.equals通过entrySet().iterator()这种方式遍历了map1，判断了map2是否含有相同的键m.containsKey(key)，并判断键值是否相等value.equals(m.get(key))。因此，只有value类不是基本数据类型而是自定义类时，重写了equals和hashcode方法，才需要注意这种整体map调用equals是否合理。</span><br></pre></td></tr></table></figure>

<h3 id="015-字符串中的所有变位词-438、8月15日"><a href="#015-字符串中的所有变位词-438、8月15日" class="headerlink" title="015.字符串中的所有变位词(438、8月15日)"></a>015.字符串中的所有变位词(438、8月15日)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：思路同题目<span class="number">14</span>中的思路<span class="number">2</span>，实现两个hashMap比较，将<span class="keyword">return</span> <span class="literal">true</span>替换为result.add(i-p.length()+<span class="number">1</span>)，即窗口左端。</span><br><span class="line"><span class="number">2.</span>变位词题目思路关键：滑动窗口只改变两端词频+双指针实现滑动窗口，hash表或数组实现窗口内词频统计。</span><br></pre></td></tr></table></figure>

<h3 id="016-不含重复字符的最长连续子字符串-3、8月15日"><a href="#016-不含重复字符的最长连续子字符串-3、8月15日" class="headerlink" title="016.不含重复字符的最长连续子字符串(3、8月15日)"></a>016.不含重复字符的最长连续子字符串(3、8月15日)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题在<span class="number">7</span>月<span class="number">31</span>日做过，这次做看了下以前的笔记。现在记录的更简单些。</span><br><span class="line">    a.做法是维护一个HashMap&lt;Character,Integer&gt;，记录字符和它的上次出现位置；</span><br><span class="line">    b.向右滑动窗口时，遇到重复字符，就调整窗口的左端，保证窗口左端在重复字符上次出现位置的右边；由于可能窗口左端已经被其他重复字符更新，所以会出现在本来就在本重复字符上次位置右边的情况；</span><br><span class="line">        left = Math.max(left,hashMap.get(s.charAt(i))+<span class="number">1</span>);</span><br><span class="line">    c.滑动窗口中是不含重复字符的子串，即题目需求，就是在向右滑动过程中找到最大的滑动窗口；</span><br><span class="line"><span class="number">2.</span>滑动窗口的感觉：每次滑动只有开销很小的改动。</span><br></pre></td></tr></table></figure>

<h3 id="017-含有所有字符的最短字符串（76、8月15日、20日）"><a href="#017-含有所有字符的最短字符串（76、8月15日、20日）" class="headerlink" title="017.含有所有字符的最短字符串（76、8月15日、20日）"></a>017.含有所有字符的最短字符串（76、8月15日、20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：因为是求最短字符串且只返回一个，就将外层循环设置为字符串长度，内层循环设置为起始位置。和变位词类似，先用hashMap记录标准t字符串的词频情况，每次遍历一个滑动窗口时，就将标准t的hashMap拷贝一份tempMap，tempMap减去窗口内标准字符次数，全部小于<span class="number">0</span>则为“含所有字符的最短字符串”。因为需要遍历滑动窗口内部，开销很大，所以在测试最后<span class="number">3</span>个测试用例时，出现了超时。</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> L=t.length();L&lt;=s.length();L++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+L-<span class="number">1</span>&lt;s.length();i++)&#123;</span><br><span class="line"><span class="number">2.</span>我的想法<span class="number">2</span>：因为当外层循环确定滑动窗口大小L时，滑动窗口的移动只是改变两端字符的词频，因此不需要遍历滑动窗口改变tempMap，只需要关注两端造成的滑动窗口的词频改变，下一次移动前，计算滑动窗口hashMapS和标准t的hashMap的包含关系即可。但是，因为标准t字符串的长度可能很大，计算包含关系时，遍历标准t的hashMap造成巨大开销，在倒数第<span class="number">2</span>个测试用例上出现超时。</span><br><span class="line"><span class="number">3.</span>我的想法<span class="number">3</span>：当滑动窗口hashMapS某些元素多于标准t的hashMap时，在hashMap中减去该元素，以此减少最后计算包含关系的开销。但随着滑动窗口移动，可能又不再多于，因此不知道如何实现。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>思路<span class="number">1</span>：本题的解题思路很简单，用hashMap记录s当前子串中标准t字符的词频，先移动右指针扩展子串到满足题目，再移动左指针不断刷新minLength。前面说的“可能有不再多于”，这里是通过判断标准t字符的需求解决的：如最开始count = hashMap.size()，当移动右指针满足题目后count减少到<span class="number">0</span>，移动左指针刷新minLength致某刻count&gt;<span class="number">0</span>，说明某字符导致子串不再满足，这时就需要再移动右指针去尝试满足，直到遍历到字符串末尾。</span><br><span class="line">    这里记录下最外层<span class="keyword">while</span>循环：</span><br><span class="line">    <span class="keyword">while</span>(end&lt;s.length()||(end==s.length()&amp;&amp;count==<span class="number">0</span>))</span><br><span class="line">    (end==s.length()&amp;&amp;count==<span class="number">0</span>)是因为，当遍历到最后一个字符且满足t需求时，仍然需要移动左指针刷新minLength；(end==s.length()&amp;&amp;count!=<span class="number">0</span>)则不可，因为没法移动右指针再满足了。这种写法还能应对s和t长度均为<span class="number">1</span>的特殊情况。</span><br></pre></td></tr></table></figure>

<h3 id="018-有效的回文（125、8月20日）"><a href="#018-有效的回文（125、8月20日）" class="headerlink" title="018.有效的回文（125、8月20日）"></a>018.有效的回文（125、8月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题比较简单，就是两指针分别从开始、末尾出发，在满足左指针小于右指针的情况下，移动不是字母或数字的位置，或是在字母或数字位置判断是否回文，并同时移动指针。</span><br><span class="line"><span class="number">2.</span>常用api记录：</span><br><span class="line">	Character.isLetterOrDigit  <span class="comment">//返回Boolean,判断字符是否为字母或数字</span></span><br><span class="line">	Character.toLowerCase  <span class="comment">//返回字符小写</span></span><br></pre></td></tr></table></figure>

<h3 id="019-最多删除一个字符得到回文（680、8月20日）"><a href="#019-最多删除一个字符得到回文（680、8月20日）" class="headerlink" title="019.最多删除一个字符得到回文（680、8月20日）"></a>019.最多删除一个字符得到回文（680、8月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：设置标志位，当flag减少到-<span class="number">1</span>时跳出循环，外层循环是<span class="keyword">while</span>(i&lt;j &amp;&amp; flag&gt;=<span class="number">0</span>)，返回值是<span class="keyword">return</span> i&gt;=j。遇到一种特殊情况无法解决，即在某一刻左指针下一位等于右指针，右指针下一位也等于左指针：如<span class="string">&quot;lcupuu&quot;</span>和<span class="string">&quot;uupucul&quot;</span>，这会导致本来该移动右指针减去一个u，却使得先移动左指针减去一个c。可以想到这种情况适用回溯法。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：递归法。当不满足回文时，移动左指针或者右指针，将标志位flag设置为<span class="literal">false</span>，向下递归。</span><br><span class="line">     <span class="keyword">return</span> check(s,!flag,left+<span class="number">1</span>,right)||check(s,!flag,left,right-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="020-回文子字符串的个数（647、8月20日）"><a href="#020-回文子字符串的个数（647、8月20日）" class="headerlink" title="020.回文子字符串的个数（647、8月20日）"></a>020.回文子字符串的个数（647、8月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，做了这些滑动窗口的题目，面对这道题还是束手无策。想到从字符串中间开始往两边开滑，那么字符串中间怎么移动呢？如何应对奇数和偶数的区别呢？归根结底是没有看作窗口，滑动窗口是一个子串，需要一个外围循环确定窗口位置，窗口再向两边扩展。</span><br><span class="line"><span class="number">2.</span>这道题直接看题解了，代码非常简单，就是递归。这样就能移动以每个字符为中心的窗口，和前面的题目不同，是递归，而没有滑动窗口对应的存储结构。windowExtend实现计算以i为中心的字符串存在多少回文，或者以(i,i+<span class="number">1</span>)为中心。</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123; count += windowExtend(s,i,i); count += windowExtend(s,i,i+<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结之字符串"><a href="#总结之字符串" class="headerlink" title="总结之字符串"></a>总结之字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>api记录的复制：</span><br><span class="line">    s1.CharAt(index);  <span class="comment">//根据索引确定字符</span></span><br><span class="line">    s1.indexOf(s2);   <span class="comment">//给出子串位置</span></span><br><span class="line">    s.substring(minStart,minEnd);  <span class="comment">//返回子串，包头不包尾</span></span><br><span class="line">	String[] t = time.split(<span class="string">&quot;:&quot;</span>);  <span class="comment">//按指定字符分割String</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.join(<span class="string">&quot; &quot;</span>,t) <span class="comment">//按指定分隔符拼接一个字符串</span></span><br><span class="line">    Character.isLetterOrDigit  <span class="comment">//返回Boolean,判断字符是否为字母或数字</span></span><br><span class="line">    Character.toLowerCase  <span class="comment">//返回字符小写</span></span><br><span class="line">    hashMap.put(ch,hashMap.getOrDefault(ch,<span class="number">0</span>)+<span class="number">1</span>);  <span class="comment">//getOrDefault，如果不存在该键就返回默认值0，省去判断</span></span><br><span class="line">    <span class="type">char</span>[] charArray = s.toCharArray();  <span class="comment">//String转char[] String -&gt; char[]</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(charArray);  <span class="comment">//char[]转String  char[] -&gt; String</span></span><br><span class="line"></span><br><span class="line">    result.toString();   <span class="comment">//StringBuffer类转String  StringBuffer -&gt; String</span></span><br><span class="line">  	builder.reverse().toString();  <span class="comment">//StringBuffer类转String  先对StringBuffer进行反转</span></span><br><span class="line">    result.append(x); <span class="comment">//StringBuffer添加char型元素</span></span><br><span class="line">    result.deleteCharAt(index);  <span class="comment">//StringBuffer实现根据索引删除元素</span></span><br><span class="line"><span class="number">2.</span>变位词，想到HashMap；回文，想到双指针。</span><br><span class="line"><span class="number">3.</span>StringBuffer和StringBuilder的区别</span><br><span class="line">    标准答案：前者线程安全，后者线程不安全。前者是早期Java设计者避免开发频繁写<span class="keyword">synchronized</span>代码块造成可读性和易用性降低，就把标准库中StringBuffer、Vector、Hashtable、ByteArray&#123;Input,Output&#125;Stream 等可变对象设计成线程安全的。但后来发现多个线程同时修改一个对象的场景才是少数，故后来的ArrayList、HashMap、StringBuilder等可变类不再默认线程安全，以此换取单线程下的性能提升。</span><br><span class="line"><span class="number">4.</span>字符串的比较：</span><br><span class="line">    （<span class="number">1</span>）.String a=<span class="string">&quot;abc&quot;</span>,b=<span class="string">&quot;abc&quot;</span>;   <span class="comment">//a==b将返回true，相同的字符串在内存中只会存一份，a和b都会指向“abc”常量</span></span><br><span class="line">    （<span class="number">2</span>）.String a=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); String b=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);   </span><br><span class="line">		<span class="comment">//a==b将返回false，a和b指向不同的对象</span></span><br><span class="line">		<span class="comment">//a.equals(b)是比较字符串内容是否相同</span></span><br><span class="line">		<span class="comment">//字符串值比较一定要用s.equals(&quot;0&quot;)，而不是s==&quot;0&quot;，这里s是通过&quot;&quot;+ch不断累加得到的。</span></span><br><span class="line"><span class="number">5.</span><span class="type">int</span>和String互相转换api：</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(str);	<span class="comment">//String转int</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(str).intValue();	<span class="comment">//String装int</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(n);	<span class="comment">//int转String</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toString(n);	<span class="comment">//int转String</span></span><br><span class="line"><span class="number">6.</span>ascii转换api：</span><br><span class="line">    <span class="type">char</span> <span class="variable">zimu</span> <span class="operator">=</span> (<span class="type">char</span>)(<span class="number">96</span>+<span class="number">1</span>);   <span class="comment">//结果为a</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch-<span class="string">&#x27;a&#x27;</span> <span class="comment">//结果为a的ascii编号</span></span><br><span class="line"><span class="number">7.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">8.</span><span class="type">char</span>转<span class="type">int</span>：</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(String.valueOf(charArray[i]));</span><br><span class="line"><span class="number">9.</span>字符串和整数比较方法：</span><br><span class="line">	<span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> src.substring(i-<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(tmp.compareTo(<span class="string">&quot;25&quot;</span>)&lt;=<span class="number">0</span>)		<span class="comment">//判断字符串是否小于等于25</span></span><br><span class="line"><span class="number">10.</span>arrs[i].equals(<span class="string">&quot;null&quot;</span>) 和 arrs[i]==<span class="string">&quot;null&quot;</span></span><br><span class="line">	不能用arrs[i]==<span class="string">&quot;null&quot;</span>去比较字符串，因为arrs[i]是split分割字符串得到的，应该是调用了<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xxx&quot;</span>)，这是新的对象，比较结果必然是<span class="literal">false</span>，应该用equals比较字符串内容。</span><br></pre></td></tr></table></figure>

<h2 id="第四章、链表"><a href="#第四章、链表" class="headerlink" title="第四章、链表"></a>第四章、链表</h2><h3 id="021-删除链表的倒数第n个节点（19、8月21日）"><a href="#021-删除链表的倒数第n个节点（19、8月21日）" class="headerlink" title="021.删除链表的倒数第n个节点（19、8月21日）"></a>021.删除链表的倒数第n个节点（19、8月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，前后指针。先让一个指针first跑n个节点，再让另一个指针tail和first一起跑，这样当first到达链表末尾时，tail正好到达倒数第n个节点的前一个节点。设置dummy节点，将帮助更好理解第n个以及处理单节点输入的特殊情况。这道题调试几次就对了。</span><br></pre></td></tr></table></figure>

<h3 id="022-链表中环的入口节点（142、8月21日）"><a href="#022-链表中环的入口节点（142、8月21日）" class="headerlink" title="022.链表中环的入口节点（142、8月21日）"></a>022.链表中环的入口节点（142、8月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：一个指针遍历到某位置，下个指针从该位置开始遍历，直到与第一个指针重合。但是，循环链表没有<span class="literal">null</span>，导致循环无法停止。</span><br><span class="line"><span class="number">2.</span>我的想法<span class="number">2</span>：将链表节点放入HashSet，当再次遍历到且HashSet已经存储某节点时，就说明该节点是循环链表的入口。如果遍历链表时遇到<span class="literal">null</span>节点，说明该链表不是循环链表。注意，Set&lt;ListNode&gt;而不是Set&lt;Integer&gt;，因为测试用例中存在相同值的不同节点。</span><br><span class="line"><span class="number">3.</span>我在想，能快速写出测试用例、方便调试也算能力吧。</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>思路<span class="number">2</span>：快慢指针。如果链表中有环，快慢两个指针必然会在环中某个节点相遇。假设快指针走两步、慢指针走一步，相遇时慢指针走了k步，快指针走了2k步，到相遇时快指针比慢指针多走k步，那么k必然是环中节点数目的整数倍，那么非环部分a+没走满的部分b=节点数目整数倍，假如一个指针headA从头节点出发，另一个指针headB从相遇慢指针的k位置出发，相同速度均为一步，那么它们都需要走a个单位到达环入口。</span><br><span class="line"><span class="number">5.</span>证明：快慢指针。设链表中环外部分的长度为a，slow指针进入环后，又走了b的距离与fast相遇，还剩c的距离凑够完整环。此时，fast指针已经走完了n圈，总距离为a+n(b+c)+b，而fast指针速度为<span class="number">2</span>，slow指针速度为<span class="number">1</span>，故有：</span><br><span class="line">    a+n(b+c)+b = <span class="number">2</span>(a+b)  -&gt;  a=c+(n-<span class="number">1</span>)(b+c)</span><br><span class="line">-&gt; 从相遇点到入环点的距离加上 n-<span class="number">1</span> 圈的环长，恰好等于从链表头部到入环点的距离。</span><br></pre></td></tr></table></figure>

<h3 id="023-两个链表的第一个重合节点（160、8月21日）"><a href="#023-两个链表的第一个重合节点（160、8月21日）" class="headerlink" title="023.两个链表的第一个重合节点（160、8月21日）"></a>023.两个链表的第一个重合节点（160、8月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：将链表节点放入HashSet。headA链表先遍历一遍，将节点放入hashSet，再遍历headB链表，当遍历到hashSet中已有节点时，说明该节点是重合节点，否则，返回<span class="literal">null</span>。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：快慢指针。假设链表headA=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]，链表headB=[<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],那么可以让链表headB变为环（headB的尾节点next指向headB的头节点），整个链表变为[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]，其中<span class="number">8</span>指向<span class="number">4</span>，问题转换为寻找链表环的入口节点。但这样会改变链表结构。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>：栈。将两个链表压入两个栈，弹栈顶比较元素，直到最后一个相同元素，即从后往前比较。扩展这一想法，可以先求得两个链表的长度，将长的链表先移动d位差值，然后两个链表再同时同速度移动，这样就能同时到达交叉位置。</span><br></pre></td></tr></table></figure>

<h3 id="024-反转链表（206、8月22日）"><a href="#024-反转链表（206、8月22日）" class="headerlink" title="024.反转链表（206、8月22日）"></a>024.反转链表（206、8月22日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，遍历链表节点并压栈，弹栈后在最后一个元素后接<span class="literal">null</span>。这里记录下栈相关api:</span><br><span class="line">	Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	peek()：返回栈顶的值 ；不改变栈的值，查看栈顶的对象而不移除它。</span><br><span class="line">	pop()：Stack(栈)的方法，返回栈顶的值 ；会把栈顶的值删除。</span><br><span class="line">	poll：Queue(队列)的一个方法，获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：迭代法。遍历时维护两个指针prev和cur，每轮遍历将cur.next存储起来，将cur.next修改为指向prev后，完成向前连接；接着将prev指向cur，将cur指向储存的cur.next提供下一轮遍历条件。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>：递归法，先不做。</span><br></pre></td></tr></table></figure>

<h3 id="025、链表中的两数相加（445、8月22日）"><a href="#025、链表中的两数相加（445、8月22日）" class="headerlink" title="025、链表中的两数相加（445、8月22日）"></a>025、链表中的两数相加（445、8月22日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，维护两个栈l1stack和l2stack，遍历两个链表并压栈，弹栈时求和，注意将最后的进位添加节点。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：先用<span class="number">24</span>题迭代法反转两个链表，再按照相同的加法逻辑求和。</span><br></pre></td></tr></table></figure>

<h3 id="026、重排链表（143、8月22日）"><a href="#026、重排链表（143、8月22日）" class="headerlink" title="026、重排链表（143、8月22日）"></a>026、重排链表（143、8月22日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：观察图示，即将链表转换为正向、逆向交替添加到链表。只需要将链表反转压栈，通过栈求得链表长度，按照链表长度遍历索引，如果索引模<span class="number">2</span>余<span class="number">0</span>则正向添加链表节点，如果索引模<span class="number">2</span>余<span class="number">1</span>则弹栈添加逆向链表节点，在外部修改链表结构并不会影响弹栈顺序，且弹栈后会直接修改next指针。注意将最后一个元素后接<span class="literal">null</span>避免环状链表，以及修改head指针指向dummy.next（因为函数返回<span class="keyword">void</span>）。</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)  <span class="comment">//因为目标建立len长度的链表，正向和逆向在结束时，实际都只遍历一半</span></span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：线性表。通过线性表的特定按顺序交替获取元素。</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ListNode&gt;();  <span class="comment">//线性表建表</span></span><br><span class="line">        list.get(i).next = list.get(j);		<span class="comment">//线性表获取元素</span></span><br><span class="line"><span class="number">3.</span>寻找链表中点（通过快慢指针） + 链表逆序 + 合并链表，先不做，和我的想法本质一样，但更加节省空间。</span><br></pre></td></tr></table></figure>

<h3 id="027、回文链表（234、8月22日）"><a href="#027、回文链表（234、8月22日）" class="headerlink" title="027、回文链表（234、8月22日）"></a>027、回文链表（234、8月22日）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法：遍历链表节点并压栈。在外围循环为for(int i=0;i&lt;len/2;i++)的情况下，遍历链表并同时弹栈，观察到node.val不相等时返回false，否则循环结束返回true。为什么是len/2，nodes = [1,2,3,2,1]，len=5，&lt;5/2 = &#123;0,1&#125;。</span><br><span class="line">2.思路2：递归法，先不做。</span><br></pre></td></tr></table></figure>

<h3 id="028、展平多级双向链表（430、8月23日）"><a href="#028、展平多级双向链表（430、8月23日）" class="headerlink" title="028、展平多级双向链表（430、8月23日）"></a>028、展平多级双向链表（430、8月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题目在看到它的序列化输入时，就已经被震慑住了。看书后明白，就是链表的节点既维护双向链表的两个指针prev和next，还维护一个指向子链表的指针child，题目需求是将子链表向上整合到原链表的两个节点之间。因此是典型的递归操作。</span><br><span class="line"><span class="number">2.</span>看懂题解后复现比较简单，就是维护当前链表遍历指针node和尾指针tail，通过node遍历链表时，如果该节点存在子节点child，维护指针Child存储node.child，将node.child置为<span class="literal">null</span>，并通过Child指针递归寻找链尾，在每轮遍历将tail指向新表尾。</span><br></pre></td></tr></table></figure>

<h3 id="029、排序的循环链表（708、8月24日）"><a href="#029、排序的循环链表（708、8月24日）" class="headerlink" title="029、排序的循环链表（708、8月24日）"></a>029、排序的循环链表（708、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法:这道题就是在循环链表中，按照大小顺序插入链表。通过<span class="keyword">while</span>(tail.next!=head)遍历链表节点，会遇到两种情况：</span><br><span class="line">    a.插入节点位于从小到大链表的中间</span><br><span class="line">    	<span class="keyword">if</span>(insertVal &gt;= tail.val &amp;&amp; insertVal &lt;= tail.next.val)</span><br><span class="line">    b.插入节点位于从小到大链表的开始或末尾</span><br><span class="line">    	<span class="keyword">if</span>(tail.val&gt; tail.next.val)</span><br><span class="line">                <span class="keyword">if</span>(insertVal &gt;= tail.val || insertVal &lt;= tail.next.val)</span><br><span class="line">    在这两种情况下<span class="keyword">break</span>，在当前遍历节点tail后添加插入节点即可。如果插入节点在链尾，tail.next=head，逻辑仍然是在tail后添加插入节点。</span><br></pre></td></tr></table></figure>

<h3 id="总结之链表"><a href="#总结之链表" class="headerlink" title="总结之链表"></a>总结之链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>api记录的复制：</span><br><span class="line">    Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        peek()：返回栈顶的值 ；不改变栈的值，查看栈顶的对象而不移除它。</span><br><span class="line">        pop()：Stack(栈)的方法，返回栈顶的值 ；会把栈顶的值删除。</span><br><span class="line">        poll：Queue(队列)的一个方法，获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。</span><br><span class="line">    List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ListNode&gt;();  <span class="comment">//线性表建表</span></span><br><span class="line">    	list.get(i).next = list.get(j);		<span class="comment">//线性表获取元素</span></span><br><span class="line"><span class="number">2.</span>反转链表有两种方法：其一，维护prev、cur和temp三个指针，其中temp是为了cur.next修改为指向prev时，temp存储cur.next避免破坏链表的结构；其二、遍历链表节点并压栈，弹栈构造反转链表。反转链表后，需要注意在最后一个元素后接<span class="literal">null</span>，避免环状。</span><br><span class="line"><span class="number">3.</span>添加虚节点dummy有助于避免头节点造成的边界特殊情况，用临时指针tail遍历不会改变链表结构：</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();  ... <span class="keyword">return</span> dummy.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummy;</span><br><span class="line"><span class="number">4.</span>前后双指针、快慢双指针、虚节点、接<span class="literal">null</span>避免产生环状、反转链表。</span><br></pre></td></tr></table></figure>

<h2 id="第二章、数组"><a href="#第二章、数组" class="headerlink" title="第二章、数组"></a>第二章、数组</h2><h3 id="006、排序数组中两个数字之和（167、8月24日）"><a href="#006、排序数组中两个数字之和（167、8月24日）" class="headerlink" title="006、排序数组中两个数字之和（167、8月24日）"></a>006、排序数组中两个数字之和（167、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：双指针。&gt;target向左移动右指针，&lt;target向右移动左指针，外层<span class="keyword">while</span>循环避免两指针相遇，=target时跳出循环。</span><br></pre></td></tr></table></figure>

<h3 id="007、数组中和为0的三个数（15、8月24日）"><a href="#007、数组中和为0的三个数（15、8月24日）" class="headerlink" title="007、数组中和为0的三个数（15、8月24日）"></a>007、数组中和为0的三个数（15、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：双指针。首先通过Arrays.sort(nums)将数组变为有序数组，通过<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)让第一个数确定外层循环，再维护left、right双指针，按照第<span class="number">6</span>题中求两数之和的方法确定指针位置。这是第<span class="number">2</span>次做这道题，做出来比较容易，只需注意每层循环都应该有这个去重逻辑：</span><br><span class="line">    <span class="keyword">if</span>(left!=i+<span class="number">1</span>&amp;&amp;nums[left]==nums[left-<span class="number">1</span>])&#123;</span><br><span class="line">      left++;   </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="008、-和大于等于-target-的最短子数组（209、8月24日）"><a href="#008、-和大于等于-target-的最短子数组（209、8月24日）" class="headerlink" title="008、 和大于等于 target 的最短子数组（209、8月24日）"></a>008、 和大于等于 target 的最短子数组（209、8月24日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：双指针。先移动右指针使sum&gt;target，再移动左指针使sum&lt;target来缩小子数组长度，最后返回right-left+<span class="number">1</span>。问题是，假如输入是[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]，右指针提前在第二个<span class="number">2</span>上停下，就会得到长度为<span class="number">4</span>的答案，实际应该在<span class="number">3</span>停下且答案为<span class="number">2</span>。可以发现，</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，双指针。改进我的思路，应该不要让右指针停下，而是在不断向右遍历直到结束；每找到答案，就在当前位置通过左指针求子数组（左指针移动会被保留），通过Math.min(result, end - start + <span class="number">1</span>)更新result。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，前缀和+二分查找，先不做。</span><br><span class="line"><span class="number">4.</span>这是第二次遇见这种思路的题，最开始写得时候不知道外围循环咋写，是按长度遍历，还是按右指针遍历。现在知道了，要按右指针遍历，解法是在每一个满足条件的右指针下更新左指针并比较result是否更小。</span><br></pre></td></tr></table></figure>

<h3 id="009、乘积小于k的子数组（713、8月26日）"><a href="#009、乘积小于k的子数组（713、8月26日）" class="headerlink" title="009、乘积小于k的子数组（713、8月26日）"></a>009、乘积小于k的子数组（713、8月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">2</span>，滑动窗口。维护双指针left、right，按右指针遍历，当累计乘积大于k后，更新左指针至小于k，统计滑动窗口内的子数组数目。这里要统计的子数组数目，是以right指针结尾的子数组，因此有(right-left+<span class="number">1</span>)个。</span><br><span class="line">	a.不以right结尾的在前面已经统计过了;</span><br><span class="line">	b.以right结尾，以更左的left开头的子数组是不存在的;</span><br><span class="line">  这道题结构写对了，对滑动窗口固定写法比较熟悉，但是想不出来如何统计子数组的数目，想不到(right-left+<span class="number">1</span>)。</span><br></pre></td></tr></table></figure>

<h3 id="010、和为k的子数组（560、8月26日）"><a href="#010、和为k的子数组（560、8月26日）" class="headerlink" title="010、和为k的子数组（560、8月26日）"></a>010、和为k的子数组（560、8月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：滑动窗口。按右指针遍历，当成绩不等于k后，更新左指针至等于k，并在更新过程中记录满足条件的数目。但是遇到了[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>]这种输入，对于以<span class="number">0</span>结尾的right指针子数组，存在[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>]和[<span class="number">0</span>]两种满足条件的情况，在前面算法中只会被记录<span class="number">1</span>次。书里说“双指针解决数组之和的前提是，数组中的所有数字都是正数”。</span><br><span class="line"><span class="number">2.</span>我的想法，暴力破解。按右指针遍历，将当前sum拷贝到tempSum中；在每一个右指针下移动左指针，同时减小tempSum，记录等于k的情况。	<span class="keyword">for</span>(<span class="type">int</span> left=<span class="number">0</span>;left&lt;right;left++) &#123;</span><br><span class="line">    	tempSum -= nums[left];</span><br><span class="line">    	<span class="keyword">if</span>(tempSum==k) result+=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，前缀和+哈希表优化。因为[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]之和+[<span class="number">4</span>,<span class="number">5</span>]之和=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]之和，故维护HashMap记录键值对&lt;当前和,次数&gt;，这样[<span class="number">4</span>,<span class="number">5</span>]=<span class="number">9</span>就能通过<span class="number">15</span>-[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]记录这个次数。需要注意，最开始map.put(<span class="number">0</span>,<span class="number">1</span>)，即应对第一个数字为k的情况。</span><br></pre></td></tr></table></figure>

<h3 id="011、0和1个数相同的子数组（525、8月26日）"><a href="#011、0和1个数相同的子数组（525、8月26日）" class="headerlink" title="011、0和1个数相同的子数组（525、8月26日）"></a>011、0和1个数相同的子数组（525、8月26日）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法：虽然看了题解知道这道题和第10题想法相同，但还是不会做。只知道这种古老的Math.max在召唤我。</span><br><span class="line">2.思路1：前缀和+哈希表优化。首先很巧妙的是把0转换成-1，这样某段子数组0和1数目相同时，就有[1,2,3]之和+[4,5]之和=[1,2,3,4,5]之和的效果，因为[4,5]此时-1和1恰巧相互抵消，[1,2,3]和[1,2,3,4,5]的累计和sum相同。这样只需维护hashMap&lt;sum,出现位置&gt;，当sum再次出现时，记录其和第一次出现位置的差值，这样就能不断通过Math.max更新最长长度。这道题思路比较特殊在：</span><br><span class="line">	a.把0转换成-1，子数组满足条件时累计和为0；</span><br><span class="line">	b.map.put(0,-1);  因为道理上应该子数组是（sum第一次出现的下一位，本位），所以每次放入本位，第一次放入-1位。</span><br></pre></td></tr></table></figure>

<h3 id="012、左右两边子数组的和相等（724、8月27日）"><a href="#012、左右两边子数组的和相等（724、8月27日）" class="headerlink" title="012、左右两边子数组的和相等（724、8月27日）"></a>012、左右两边子数组的和相等（724、8月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：维护两个整型和：leftSum和rightSum，先遍历数组将rightSum设置为数组中全部元素求和，然后第二次遍历数组，每轮遍历先将本位在rightSum中剔除，再比较leftSum和rightSum，最后在leftSum加上本位。因为本位不参与左右数组求和。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：前缀和。先给整体数组求和得total，那这时就有如下关系式，无需维护leftSum：</span><br><span class="line">	<span class="keyword">if</span>(sum-nums[i] == total-sum)</span><br></pre></td></tr></table></figure>

<h3 id="013、二维子矩阵的和（304、8月27日）"><a href="#013、二维子矩阵的和（304、8月27日）" class="headerlink" title="013、二维子矩阵的和（304、8月27日）"></a>013、二维子矩阵的和（304、8月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法：暴力破解。维护整型sum，设置两层循环不要越界即可。看其他解答好难得样子？</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=row1;i&lt;=row2;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=col1;j&lt;=col2;j++)</span><br><span class="line">                sum += matrix[i][j];</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：前缀和。维护二维数组<span class="type">int</span>[][] sums，在构造函数中给每一行求前缀和并存储，在计算子矩阵求和时，只需列下标、通过前缀和思想求得子矩阵每一行的和。这一解法中定义sums如下：</span><br><span class="line">    定义时：sums = <span class="keyword">new</span> <span class="title class_">int</span>[Length][rowLength+<span class="number">1</span>];</span><br><span class="line">    构造时：sums[i][j+<span class="number">1</span>] = matrix[i][j] + sums[i][j];</span><br><span class="line">    使用时：sum += sums[i][col2+<span class="number">1</span>]-sums[i][col1];</span><br><span class="line">	因为不能像原来hashMap解决前缀和问题是，直接map.put(<span class="number">0</span>,-<span class="number">1</span>)这种处理首位，所以数组扩列。</span><br><span class="line"><span class="number">3.</span>由衷感叹，前缀和中对第一位元素处理和边界想象都是难搞的。现在都是写出算法结构后想不出来，调也调不出来，只能看题解的边界处理。</span><br></pre></td></tr></table></figure>

<h3 id="总结之数组"><a href="#总结之数组" class="headerlink" title="总结之数组"></a>总结之数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>最短子数组和子串问题：要按右指针遍历，解法是在每一个满足条件的右指针下更新左指针并比较result是否更小。</span><br><span class="line"><span class="number">2.</span>数组中和为<span class="number">0</span>的x个数问题中的去重逻辑：<span class="keyword">if</span>(left!=i+<span class="number">1</span>&amp;&amp;nums[left]==nums[left-<span class="number">1</span>])&#123;	left++;   <span class="keyword">continue</span>;&#125;</span><br><span class="line"><span class="number">3.</span>前缀和问题：任何位置子数组的求和，都能通过两个前缀和的相减得到，一般通过hashMap存储前缀和位置或次数，边界问题需要调试。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>数组操作相关api记录复制：</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]);  <span class="comment">//将二维数组intervals中的数组，按照索引0位置大小排序</span></span><br><span class="line">	<span class="comment">//将List转换为二维数组，需要先定义有外层初值的二维数组resultArray，再调用toArray API</span></span><br><span class="line">	List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	<span class="type">int</span>[][] resultArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][];</span><br><span class="line">	resultArray = result.toArray(resultArray);</span><br><span class="line"><span class="number">5.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="第一章、整数"><a href="#第一章、整数" class="headerlink" title="第一章、整数"></a>第一章、整数</h2><h3 id="001、整数除法（29、8月31日）"><a href="#001、整数除法（29、8月31日）" class="headerlink" title="001、整数除法（29、8月31日）"></a>001、整数除法（29、8月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>你是故意找茬是不是？直接面向结果编程。它好像是做倍数运算，介于<span class="number">3</span>倍到<span class="number">4</span>倍时就选<span class="number">3</span>倍，再继续对余数重复这一过程，还要考虑<span class="type">int</span>型<span class="number">32</span>位溢出的情况。  </span><br></pre></td></tr></table></figure>

<h3 id="002、二进制加法（67、8月31日）"><a href="#002、二进制加法（67、8月31日）" class="headerlink" title="002、二进制加法（67、8月31日）"></a>002、二进制加法（67、8月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>：模拟。这道题和前面链表中的两数相加解法相同。需要注意在余数和进位上的处理。另外，这道题不同于链表上的<span class="type">int</span>型整数，需要做ascii码上的减法确定其数值：</span><br><span class="line">    sum += i&gt;=<span class="number">0</span>?a.charAt(i--)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="003、前n个数字二进制中1的个数（338、8月31日）"><a href="#003、前n个数字二进制中1的个数（338、8月31日）" class="headerlink" title="003、前n个数字二进制中1的个数（338、8月31日）"></a>003、前n个数字二进制中1的个数（338、8月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>：按位与运算。i&amp;(i-<span class="number">1</span>)能将整数i最右边的<span class="number">1</span>变成<span class="number">0</span>。比如<span class="number">1100</span>，减<span class="number">1</span>会造成最右边的<span class="number">1</span>借位得到<span class="number">1011</span>，这样<span class="number">1100</span>&amp;<span class="number">1011</span>=<span class="number">1000</span>，就会使最右边的<span class="number">1</span>变成<span class="number">0</span>，这样循环往复知道<span class="number">1100</span>等于<span class="number">0</span>，循环次数就是<span class="number">1100</span>中<span class="number">1</span>的数目。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：动态规划。由上面关系知，i比i&amp;(i-<span class="number">1</span>)要多一个<span class="number">1</span>，这时就能写状态转移方程：</span><br><span class="line">	result[i] = result[i &amp; (i-<span class="number">1</span>)] + <span class="number">1</span>;  <span class="comment">//此时边界上，result[1] == result[2] = result[0]+1;</span></span><br><span class="line"><span class="number">3.</span>这道题就先记住这两种思路，关键是i&amp;(i-<span class="number">1</span>)会做掉最右边的<span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<h3 id="004、只出现1次的数字（137、9月1日）"><a href="#004、只出现1次的数字（137、9月1日）" class="headerlink" title="004、只出现1次的数字（137、9月1日）"></a>004、只出现1次的数字（137、9月1日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，哈希表。维护一个hashMap，当遇到旧键时就删除或者减少次数，当遇到新键时就往hashMap中添加(新键, <span class="number">2</span>)，最后hashMap中只剩目标键将其取出即可。（思路<span class="number">1</span>，当然也可以正向做，最后遍历找值为<span class="number">1</span>的键。）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，按位累加运算。</span><br><span class="line">    a.将数组中所有数字同一位置的数位相加，由于其他数都会出现<span class="number">3</span>次，故能被<span class="number">3</span>整除；</span><br><span class="line">    b.但是，目标数只出现<span class="number">1</span>次，因此它的该数位为<span class="number">1</span>时，全部数字该数位累加和mod3余<span class="number">1</span>，它的该数位为<span class="number">0</span>时，全部数字该数位累加和mod3余<span class="number">0</span>；</span><br><span class="line">    c.因此，能从全部数字数位级累加和mod3的结果上，直接推导出目标数字。</span><br><span class="line">需要记住：</span><br><span class="line">    按位累加：bitSums[i] += (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;</span><br><span class="line">	组合结果：result = (result&lt;&lt;<span class="number">1</span>)+bitSums[i]%<span class="number">3</span>;</span><br><span class="line"><span class="number">3.</span>题外话。任何一个数字异或它自己的结果都是<span class="number">0</span>，能解“目标只出现<span class="number">1</span>次，其他出现<span class="number">2</span>次”的题目。</span><br></pre></td></tr></table></figure>

<h3 id="005、单词长度的最大乘积（318、9月1日）"><a href="#005、单词长度的最大乘积（318、9月1日）" class="headerlink" title="005、单词长度的最大乘积（318、9月1日）"></a>005、单词长度的最大乘积（318、9月1日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，按位与运算。</span><br><span class="line">    a.将字符串转换为整数，比如字符串中包含<span class="string">&#x27;a&#x27;</span>，就将整数的倒数第<span class="number">1</span>位置为<span class="number">1</span>，如果字符串中包含<span class="string">&#x27;b&#x27;</span>，就将整数的倒数第<span class="number">2</span>位置为<span class="number">1</span>；</span><br><span class="line">    b.这样两个字符串如果包含相同的字符，其转换得到的整数相与时必然不会为<span class="number">0</span>，比如字符串<span class="number">1</span>有<span class="string">&#x27;a&#x27;</span>，字符串<span class="number">2</span>没有<span class="string">&#x27;a&#x27;</span>，这样<span class="number">1</span>&amp;<span class="number">0</span>=<span class="number">0</span>，只有<span class="number">1</span>&amp;<span class="number">1</span>=<span class="number">1</span>；</span><br><span class="line">需要记住：</span><br><span class="line">    记录字符串中的字符构成（不涉及次数）：  flags[i] |= <span class="number">1</span>&lt;&lt;(ch-<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="整数之总结"><a href="#整数之总结" class="headerlink" title="整数之总结"></a>整数之总结</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>基本数据类型：</span><br><span class="line">	<span class="number">4</span>种整数类型：<span class="number">8</span>位的<span class="type">byte</span>，<span class="number">16</span>位的<span class="type">short</span>，<span class="number">32</span>位的<span class="type">int</span>，<span class="number">64</span>位的<span class="type">long</span>;</span><br><span class="line">	<span class="number">2</span>种浮点类型：<span class="number">32</span>位的<span class="type">float</span>（储存<span class="number">8</span>位有效数字），<span class="number">64</span>位的<span class="type">double</span>(储存<span class="number">16</span>位有效数字)；</span><br><span class="line">	<span class="number">1</span>种逻辑类型：<span class="type">boolean</span></span><br><span class="line">	<span class="number">1</span>种字符类型：<span class="number">16</span>位的<span class="type">char</span></span><br><span class="line"><span class="number">2.</span>java中变量都是以补码的形式保存的。原码就是二进制码，其最高位为符号位；正数反码是它本身，负数反码是除符号位全部按位取反；正数的补码是它本身，负数补码是反码加一。注意：除符号位，除符号位，除符号位，按位取反。</span><br><span class="line"><span class="number">3.</span>二进制位运算有<span class="number">6</span>种，与&amp;、或|、非~、异或^、左移&lt;&lt;、右移&gt;&gt;(无符号异或，&gt;&gt;&gt;)。</span><br><span class="line"><span class="number">4.</span>位运算常用技巧：</span><br><span class="line">	i&amp;(i-<span class="number">1</span>)		<span class="comment">//能将整数i最右边的1变成0。1100&amp;1011=1000，因为最右边的1负责借位</span></span><br><span class="line">	i&gt;&gt;<span class="number">1</span>         <span class="comment">//计算i/2  如3==1，11&gt;&gt;1=01=1，即3/2=1</span></span><br><span class="line">	i&amp;<span class="number">1</span>          <span class="comment">//计算i%2  如3==11，11&amp;01=01=1，即3%2=1</span></span><br><span class="line">	bitSums[i] += (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;   <span class="comment">//按位累加多个数字</span></span><br><span class="line">	result = (result&lt;&lt;<span class="number">1</span>)+bitSums[i]%<span class="number">3</span>;   <span class="comment">//按需求（mod3）组合结果为int</span></span><br><span class="line">	flags[i] |= <span class="number">1</span>&lt;&lt;(ch-<span class="string">&#x27;a&#x27;</span>);	<span class="comment">//记录字符串中的字符构成</span></span><br><span class="line">	mid -= mid &amp; <span class="number">1</span>;  <span class="comment">//小于等于mid的最后一个偶数</span></span><br><span class="line"><span class="number">5.</span>二进制位运算时，最好加上括号，这里应该涉及到优先级。比如，<span class="keyword">if</span>((flags[i]&amp;flags[j])==<span class="number">0</span>)。</span><br><span class="line"><span class="number">6.</span>利用整型位运算相关的思路求解问题，很多技巧都难以想到，只能说尽量熟悉。</span><br><span class="line"><span class="number">7.</span><span class="type">int</span>/<span class="type">int</span> = <span class="type">int</span>; <span class="type">double</span>/<span class="type">int</span>=<span class="type">double</span>; <span class="type">int</span>*<span class="type">double</span>=<span class="type">double</span>;可以通过(类型)进行强制类型转换。</span><br></pre></td></tr></table></figure>

<h2 id="第五章、哈希表"><a href="#第五章、哈希表" class="headerlink" title="第五章、哈希表"></a>第五章、哈希表</h2><h3 id="030、插入、删除和随机访问都是O-1-的容器（380、8月28日）"><a href="#030、插入、删除和随机访问都是O-1-的容器（380、8月28日）" class="headerlink" title="030、插入、删除和随机访问都是O(1)的容器（380、8月28日）"></a>030、插入、删除和随机访问都是O(1)的容器（380、8月28日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>，我的想法，调用HashSet官方API，但是没有提供getRandom类似的方法。看书后发现哈希表这章，强调的是，利用哈希表设计更加高级、更加复杂的数据结构。因此，调用官方API是可以的，但需要想新的功能怎么实现。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，这里维护一个HashMap和ArrayList。arrayList存储元素，hashMap存储元素和其在arrayList的位置。</span><br><span class="line">	a.插入元素。直接在arrayList末尾插入，并在hashMap中记录位置，时间复杂度O(<span class="number">1</span>);</span><br><span class="line">	b.删除元素。</span><br><span class="line">		首先通过hashMap找到目标元素在arrayList中的位置，并删除目标元素，时间复杂度O(<span class="number">1</span>)；</span><br><span class="line">		在hashMap中，将arrayList末尾元素的位置修改为上一步存储的位置；</span><br><span class="line">		通过nums.set直接用末尾元素覆盖目标位置，时间复杂度O(<span class="number">1</span>)；</span><br><span class="line">		在nums中，删除末尾元素；</span><br><span class="line">	c.随机访问</span><br><span class="line">		这道题在hashMap外加上数组，就是因为数组能实现而hashMap不能实现随机访问</span><br><span class="line">		产生一个随机整数API：<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(nums.size());</span><br><span class="line"><span class="number">3.</span>需要思考的地方：通过外加数组实现随机访问，通过用末位元素替换而不是数组移动实现删除O(<span class="number">1</span>)。</span><br></pre></td></tr></table></figure>

<h3 id="031、最近最少使用缓存（146、9月1日）"><a href="#031、最近最少使用缓存（146、9月1日）" class="headerlink" title="031、最近最少使用缓存（146、9月1日）"></a>031、最近最少使用缓存（146、9月1日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，维护两个HashMap。cache存储键值对，LRU存储键和使用次数的映射。进行get和put操作时，都会在LRU中增加相应键的使用次数。当要put新键且cache.size()==capacity时，遍历LRU寻找最小使用次数的键，将该键对应的键值对在cache和LRU中移除。但是，这种结构没法在LRU中比较相同使用次数的键。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，哈希表+双向链表，LinkedHashMap。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，哈希表+双向链表，自己实现。</span><br><span class="line">	a.首先定义双向链表节点DlinkedNode；</span><br><span class="line">	b.定义LRU私有变量，包括当前容量size，限定容量capacity，缓存hashMap&lt;Integer,DlinkedNode&gt;，以及双向链表虚节点head、tail；缓存hashMap是为了定位当前键对应的节点，真正的顺序由双向链表维护；</span><br><span class="line">	c.get操作：从hashMap取出节点后，将节点放在双向链表的表头（删除原位置，放到表头）；</span><br><span class="line">	d.put操作：如果hashMap中有该键，则修改节点值、放到表头即可；如果hashMap中没有该键，则新建节点将其放入hashMap，并将其放到链表头部，如果造成超过capacity，则将tail节点前一节点在链表和hashMap删除；</span><br><span class="line"><span class="number">4.</span>思路<span class="number">2</span>中的双向链表首位都是虚节点，这和前面单链表中单独的dummy节点有所区别。</span><br></pre></td></tr></table></figure>

<h3 id="032、有效的变位词（242、9月2日）"><a href="#032、有效的变位词（242、9月2日）" class="headerlink" title="032、有效的变位词（242、9月2日）"></a>032、有效的变位词（242、9月2日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，哈希表。先将字符串s的所有字符放入hashMap，再用字符串t的字符减小hashMap中的值，减小到<span class="number">0</span>时删除该键。如果不存在某键，或者最终hashMap没空，则返回<span class="literal">false</span>。要考虑的情况：</span><br><span class="line">	a.对于条件“字符顺序不完全相同”，并不需要记录字符位置，只需s.equals(t)排除完全相同的情况；</span><br><span class="line">	b.对于字符串t提前结束，hashMap中仍有键值，只需s.length()!=t.length()排除这种情况；</span><br><span class="line">	故可以通过下面的代码简化我的想法，不用再判断hashMap.size==<span class="number">0</span>：</span><br><span class="line">		<span class="keyword">if</span>(s.length()!=t.length()||s.equals(t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h3 id="033、变位词组（49、9月2日）"><a href="#033、变位词组（49、9月2日）" class="headerlink" title="033、变位词组（49、9月2日）"></a>033、变位词组（49、9月2日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，转换为数字进行位元素。看到整型第<span class="number">5</span>题后，发现转会为数字，只能记录字符构成，不包含字符次数，遂放弃。看题解有用质数代替字符的，字符串转变为质数乘积，这样只有唯一质数分解，故能通过积分类同位词。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：哈希表。将变位词排序，如<span class="string">&quot;eta&quot;</span>、<span class="string">&quot;tea&quot;</span>和<span class="string">&quot;ate&quot;</span>都映射成<span class="string">&quot;aet&quot;</span>，这样维护一个HashMap&lt;String,List&lt;String&gt;&gt;，就能在一次遍历中把变位词根据其键放到对应列表中。</span><br><span class="line">	注意,<span class="type">char</span>[]转String是String.valueOf(strArray)，而不是strArray.toString()，StringBuffer转String才是buffer.toString()。Arrays.sort(strArray)能直接将<span class="type">char</span>[]按照字母顺序修改排序。</span><br><span class="line">	hashmap.putIfAbsent(key, value);	<span class="comment">//先判断指定的键（key）是否存在，不存在则将键/值对插入到HashMap中。</span></span><br></pre></td></tr></table></figure>

<h3 id="034、外星语言是否排序（953、9月6日）"><a href="#034、外星语言是否排序（953、9月6日）" class="headerlink" title="034、外星语言是否排序（953、9月6日）"></a>034、外星语言是否排序（953、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，暴力破解。根据字母表将其顺序放入hashMap，从左到右对比相邻字符串；依此取两个字符串的字母，对比其在haspMap中的位置，如果相等则继续至某字符串结束；只有前一字符串先结束才说明字符顺序正确。</span><br><span class="line"><span class="number">2.</span>本题需要记住，对比字符串a和b时，</span><br><span class="line">    a.如果a[i]&lt;b[i]，那就不用再比较了，即使a更长在这一刻它已经输了，我第一次时潜意识以为更小和相等时都需要再比下去；</span><br><span class="line">    b.同理，如果a[i]&gt;b[i]那也不用再比较了，只有二者一直相等才先结束的更小；</span><br></pre></td></tr></table></figure>

<h3 id="035、最小时间差（539、9月6日）"><a href="#035、最小时间差（539、9月6日）" class="headerlink" title="035、最小时间差（539、9月6日）"></a>035、最小时间差（539、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，排序。将n个时间配许，排序之后就计算两相邻时间的间隔。需注意的情况是，要把排序数组的第<span class="number">1</span>位时间和最后<span class="number">1</span>位时间的时间间隔考虑在内，因为它对应着“<span class="number">00</span>:<span class="number">00</span>”这种时间是第二天的最小情况。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：用数组代替排序。因为一天有<span class="number">1440</span>分钟，可以用长度为<span class="number">1440</span>的<span class="type">boolean</span>数组记录List&lt;String&gt;中的所有时间。这里记录几个处理通用情况的手段：</span><br><span class="line">    a.遍历<span class="type">boolean</span>数组时，因为要计算与上一时间的时间间隔，第一位没有上一时间，这样处理：</span><br><span class="line">    	<span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;timeList.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(timeList[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(prev&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    minGap = Math.min(i-prev,minGap);</span><br><span class="line">                &#125; prev=i;...&#125;&#125;</span><br><span class="line">	b.因为要记录<span class="type">boolean</span>数组中第一个为<span class="literal">true</span>和最后一个为<span class="literal">true</span>的元素索引，这样处理（即初始为大往小取or相反）：</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> timeList.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		...</span><br><span class="line">        first = Math.min(first,i);</span><br><span class="line">        last = Math.max(last,i);</span><br></pre></td></tr></table></figure>

<h3 id="总结之哈希表"><a href="#总结之哈希表" class="headerlink" title="总结之哈希表"></a>总结之哈希表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>LRU的实现是：hashMap&lt;Integer,DlinkedNode&gt; + DlinkedNode双向链表，表头添加，表尾删除。其中双向链表定义时，要定义首尾两个虚节点head、tail，这与单链表中单独的dummy节点有所区别。这道题比较有代表性，估计下次还是很难直接做出来。</span><br><span class="line"><span class="number">2.</span>LinkedHashMap的使用：继承LinkedHashMap，重写removeEldestEntry方法，写出用于“删除最早添加节点”的布尔表达式。</span><br><span class="line"><span class="number">3.</span>如果哈希表的键取值范围固定，并不是很大，则可以用数组模拟哈希表。例如，单词中只包含英文小写字母，那么就可以用一个长度为<span class="number">26</span>的数组来模拟这个哈希表。</span><br><span class="line"><span class="number">4.</span>常用api：</span><br><span class="line">	 hashMap.put(ch,hashMap.getOrDefault(ch,<span class="number">0</span>)+<span class="number">1</span>);  <span class="comment">//getOrDefault，如果不存在该键就返回默认值0，省去判断</span></span><br><span class="line">	 hashmap.putIfAbsent(key, value);	<span class="comment">//先判断指定的键（key）是否存在，不存在则将键/值对插入到HashMap中。</span></span><br><span class="line"><span class="number">5.</span>后半部分hashMap的应用每道题关联不大，可能也是状态不太好，几道题都没有第一想法。</span><br></pre></td></tr></table></figure>

<h2 id="第六章、栈"><a href="#第六章、栈" class="headerlink" title="第六章、栈"></a>第六章、栈</h2><h3 id="036、后缀表达式（150、9月6日）"><a href="#036、后缀表达式（150、9月6日）" class="headerlink" title="036、后缀表达式（150、9月6日）"></a>036、后缀表达式（150、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈。遇到操作符，就弹两次栈进行运算，并将结果压回栈中；遇到其他（数字）字符，就直接压栈；最后返回栈顶元素。</span><br><span class="line"><span class="number">2.</span>这道题比较不优雅的地方，是要对运算符进行分类，题解用了<span class="keyword">switch</span> <span class="keyword">case</span>，<span class="keyword">default</span>时说明是数字直接压栈，我用的是<span class="keyword">if</span>...<span class="keyword">else</span>。此外，可以直接用isNumber判断是否为数字，比我的List&lt;String&gt;.contains(操作符)更紧凑些，没啥难的。</span><br></pre></td></tr></table></figure>

<h3 id="037、小行星碰撞（735、9月6日）"><a href="#037、小行星碰撞（735、9月6日）" class="headerlink" title="037、小行星碰撞（735、9月6日）"></a>037、小行星碰撞（735、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，双栈。维护两个栈记录向左走和向右走的小行星，如果将向左走的小行星压栈时，向右走的栈顶有小行星，则比较后决定两颗行星的去留，反之亦然。最后将没有空的栈元素取出，组装成<span class="type">int</span>[]数组返回。这种想法的错误是，题目说“表示在同一行的小行星”，如果最左边的小行星决定向左移动，那天王老子也炸不了它，并不是围绕恒星，即这个题目不但考虑方向，还要考虑位置。</span><br><span class="line"><span class="number">2.</span>我的想法，单栈。终究是做出来了，是一道考虑特殊情况的题目。维护向右走小行星的栈，也维护向左走小行星的List，这样考虑：</span><br><span class="line">    （<span class="number">1</span>）.如果小行星向左走：</span><br><span class="line">    	a.栈为空，直接在List中添加小行星；</span><br><span class="line">    	b.栈不为空，满足(!stack.isEmpty()&amp;&amp;stack.peek()&lt;-asteroid)条件下弹栈，直到向右走小行星全军覆没或挡住这颗行星。接下来，如果全军覆没则在List中添加这颗，如果恰好相等则弹栈，如果大于则不管；</span><br><span class="line">    （<span class="number">2</span>）.如果小行星向右走则直接压栈；</span><br><span class="line">    （<span class="number">3</span>）.如果栈不为空则通过pollLast依次获取栈底元素；</span><br><span class="line">    	避免pollLast（栈底），可以改为<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)，这样能从栈顶弹。</span><br><span class="line">    （<span class="number">4</span>）.List通过size转<span class="type">int</span>[size]，实在找不到高端api；</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，单栈。题解是把朝两个方向运动的小行星都入栈，设置<span class="type">boolean</span>值alive，为每一颗向左走的小行星给一条命，只有它能：</span><br><span class="line">    alive &amp;&amp; aster &lt; <span class="number">0</span> &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() &gt; <span class="number">0</span></span><br><span class="line">    栈为空，栈顶也是一颗向左走的小行星，没被向右走的小行星打爆或同归于尽，他才能入栈。</span><br></pre></td></tr></table></figure>

<h3 id="038、每日温度（739、9月6日）"><a href="#038、每日温度（739、9月6日）" class="headerlink" title="038、每日温度（739、9月6日）"></a>038、每日温度（739、9月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈。维护一个栈记录温度的索引号，从左到右遍历温度数组，</span><br><span class="line">    a.如果栈为空，就将当前温度直接压栈；</span><br><span class="line">    b.如果栈不为空，通过<span class="keyword">while</span>循环比较栈顶元素和当前温度的大小，</span><br><span class="line">    	当栈顶元素对应温度&lt;当前温度时，在数组中记录对应索引的结果：result[stack.peek()] = i-stack.peek();</span><br><span class="line">	    当当前温度不管小于、等于和大于栈顶温度，都需要将当前温度入栈；</span><br><span class="line">    c.最后，将栈中剩下的索引，把result数组对应位置置为<span class="number">0</span>；</span><br><span class="line">简单说下，就是栈里只记录处理不了的索引，能处理时则通过索引相减获得时间差距。这道题趴下头想一想就做出来了耶。 </span><br><span class="line"><span class="number">2.</span>关键词：栈存索引</span><br></pre></td></tr></table></figure>

<h3 id="【039、直方图最大矩形面积（84、9月7日）】"><a href="#【039、直方图最大矩形面积（84、9月7日）】" class="headerlink" title="【039、直方图最大矩形面积（84、9月7日）】"></a>【039、直方图最大矩形面积（84、9月7日）】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，暴力破解。不知道为啥连穷举都想不出来，一直在想着怎么和栈上靠，还有怎么区分单柱和多柱组成的面积。题解中穷举思路很简单，从左往右遍历单柱，首先将目前单柱的高设为最低，然后从目前单柱开始不断更新最低柱高，并更新最低柱高下的面积。卡在超时上。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，分治法。最大矩形面积受限于最低柱高，对于接触过最低柱高的矩形来说，最大矩形面积是全局的面积；此时只有最低柱高左侧的情况，或者最低柱高右侧的情况，可能超过最大矩形。单独分析左侧情况时，问题回到和全局类似，因此用分治法。（关键词，低柱两边）</span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>，单调栈。这也太难了，今晚太饿没有精力想明白。（没做出来）</span><br></pre></td></tr></table></figure>

<h3 id="【040、矩阵中最大的矩形（85、9月7日）】"><a href="#【040、矩阵中最大的矩形（85、9月7日）】" class="headerlink" title="【040、矩阵中最大的矩形（85、9月7日）】"></a>【040、矩阵中最大的矩形（85、9月7日）】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，单调栈。将矩阵转换为题目<span class="number">39</span>中的直方图，什么神仙脑洞。（没做出来）</span><br></pre></td></tr></table></figure>

<h3 id="总结之栈"><a href="#总结之栈" class="headerlink" title="总结之栈"></a>总结之栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>栈相关api记录复制：</span><br><span class="line">	Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        peek()：返回栈顶的值 ；不改变栈的值，查看栈顶的对象而不移除它。</span><br><span class="line">        pop()：Stack(栈)的方法，返回栈顶的值 ；会把栈顶的值删除。</span><br><span class="line">        poll：Queue(队列)的一个方法，获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。</span><br><span class="line">        pollLast：Dueue(队列)的一个方法，能获取队列尾部，需要记住这里队列首部才是栈顶，而poll和pollFirst等价于pop。</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"><span class="number">2.</span>Queue是队列；Deque是双端队列，支持在两端插入和移除元素，因此可以用它模拟栈。</span><br><span class="line"><span class="number">3.</span>将栈中结果按原顺序返回：<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) result[i]=stack.pop();</span><br></pre></td></tr></table></figure>

<h2 id="第七章、队列"><a href="#第七章、队列" class="headerlink" title="第七章、队列"></a>第七章、队列</h2><h3 id="041、滑动窗口的平均值（346、9月10日）"><a href="#041、滑动窗口的平均值（346、9月10日）" class="headerlink" title="041、滑动窗口的平均值（346、9月10日）"></a>041、滑动窗口的平均值（346、9月10日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，队列。这道题比较简单，就是维护队列、队列最高容量和窗口内数值和这<span class="number">3</span>个变量。当队列容量到达最高容量时，从队列头部删除元素，窗口数值和减去该元素，并将新元素添加到队列尾部并加给数值和。通过维护窗口数值和sum，就不需要再遍历整个滑动窗口了。</span><br><span class="line"><span class="number">2.</span>在队列尾部添加元素api：</span><br><span class="line">	offer(): 在队列尾部添加新元素，如果队列已满，返回<span class="literal">false</span>，add方法会抛出异常；</span><br></pre></td></tr></table></figure>

<h3 id="042、最近请求次数（933、9月11日）"><a href="#042、最近请求次数（933、9月11日）" class="headerlink" title="042、最近请求次数（933、9月11日）"></a>042、最近请求次数（933、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，队列。这道题比较简单，就是维护队列，当调用ping时，通过<span class="keyword">while</span>循环检查window.peek()&lt;t-<span class="number">3000</span>，并移除。</span><br></pre></td></tr></table></figure>

<h3 id="043、往完全二叉树添加节点（919、9月11日）"><a href="#043、往完全二叉树添加节点（919、9月11日）" class="headerlink" title="043、往完全二叉树添加节点（919、9月11日）"></a>043、往完全二叉树添加节点（919、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>完全二叉树，叶子节点只会出现在最下层和次下层，只有最下层不满且叶子节点集中出现在左侧。满二叉树是完全二叉树的特例。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，队列解决广度优先遍历。用队列解决广度优先遍历，是一种经典的方法，当遍历到某层节点时，将其左右子节点分别放入队列，这样就能保持广度优先遍历。每次遍历将父节点从队列前端poll掉，又在队列尾端offer其左右子节点。本题中需注意：</span><br><span class="line">    a.在构造函数记录root根节点后，就将root节点放入队列，提取其左右节点后在队列中删除root节点，并不断重复这一操作，直到某节点不具备左子节点或者右子节点跳出循环。要注意这个节点的左、右子节点都没有放入队列；</span><br><span class="line">    b.当insert新节点时，队列中存储的就是这个不完全节点，设置该节点的left或right属性，只有在right属性设置完毕，才能从队列中删除该不完全节点，并将left和right加入队列；因为这里存在一种特殊情况，如果不完全节点有left属性，而判断right==<span class="literal">null</span>的逻辑中只加入right到队列，就会使left节点没有放入，构造函数中并没有把这个left放入；</span><br><span class="line">    c.当get_root时，返回最初记录的root节点即可，队列中并不存放完整树，而是存放当前遍历到的节点；</span><br></pre></td></tr></table></figure>

<h3 id="044、二叉树每层的最大值（515、9月11日）"><a href="#044、二叉树每层的最大值（515、9月11日）" class="headerlink" title="044、二叉树每层的最大值（515、9月11日）"></a>044、二叉树每层的最大值（515、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历。为每层维护一个len，记录该层节点数目，通过<span class="keyword">while</span>(len&gt;<span class="number">0</span>)遍历队列中节点，通过Math.max(maxVaule,t.val)更新该层最大值，将其子节点加入队列。这样当len为<span class="number">0</span>时跳出循环，队列中为新的一层节点，len更新为新层的节点数目，并重复上述。（关键词，len记录层节点数目）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，深度优先遍历。深度优先遍历时，假如访问root后再访问root.left，这时result.size为<span class="number">1</span>，深度<span class="number">0</span>+<span class="number">1</span>=<span class="number">1</span>，深度==result.size，这时就能把root.left节点的值放入到result。即最先遍历到该层的节点先将值放入result占位，后来再遍历到该层其他节点时，在result中更新该层深度对应的值。（关键词，通过深度在result中索引）</span><br></pre></td></tr></table></figure>

<h3 id="045、二叉树最底层最左边的值（513、9月11日）"><a href="#045、二叉树最底层最左边的值（513、9月11日）" class="headerlink" title="045、二叉树最底层最左边的值（513、9月11日）"></a>045、二叉树最底层最左边的值（513、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历。为每层维护一个len，记录该层节点数目，通过<span class="keyword">while</span>(len&gt;<span class="number">0</span>)遍历队列中节点。当遍历到新层时，len更新为该层的节点数目，并将result更新为当前队列头部元素的值。这道题和第<span class="number">44</span>题广度解法一致。（关键词，len记录层节点数目）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，广度优先遍历。从右往左遍历队列中的节点，这样最底层最左边的元素，就是被最后一个访问到，记录该值即可。（关键词，从右往左）</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，深度优先遍历。用height记录遍历到的节点高度，用curHeight记录上一次更新result的高度。遍历每个节点时，先深度遍历其左子节点，再深度遍历其右子节点，直到子节点为<span class="literal">null</span>时返回。由于只在超过curHeight时才更新curHeight和result，因此到达最底层时只会更新依次result。（关键词，存档点）</span><br><span class="line">    注意，这里将curHeight和result设置为类变量，不放入函数参数，这里涉及到修改形参的知识。</span><br></pre></td></tr></table></figure>

<h3 id="046、二叉树的右侧视图（199、9月11日）"><a href="#046、二叉树的右侧视图（199、9月11日）" class="headerlink" title="046、二叉树的右侧视图（199、9月11日）"></a>046、二叉树的右侧视图（199、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历。为每层维护一个len，记录该层节点数目，通过<span class="keyword">while</span>(len&gt;<span class="number">0</span>)遍历队列中节点。当每层len变为<span class="number">0</span>时，说明正在访问该层的最右侧节点，将节点值放入result。这道题和第<span class="number">44</span>题广度解法一致。（关键词，len记录层节点数目）</span><br></pre></td></tr></table></figure>

<h3 id="总结之队列"><a href="#总结之队列" class="headerlink" title="总结之队列"></a>总结之队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>队列相关api记录复制：</span><br><span class="line">	Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  <span class="comment">//队列是尾部添加，头部删除</span></span><br><span class="line">		offer(): 在队列尾部添加新元素，如果队列已满，返回<span class="literal">false</span>。add方法会抛出异常；</span><br><span class="line">		poll()：获取并移除此队列的头，如果此队列为空，则返回<span class="literal">null</span>。remove方法会抛出异常；</span><br><span class="line"> 		peek()：用于在队列头部查询元素，如果此队列为空，返回<span class="literal">null</span>。element方法会抛出异常；</span><br><span class="line"><span class="number">2.</span>用队列解决广度优先遍历：这是一种经典的方法，当遍历到某层节点时，将其左右子节点分别放入队列，这样就能保持广度优先遍历。每次遍历将父节点从队列前端poll掉，又在队列尾端offer其左右子节点。</span><br><span class="line"><span class="number">3.</span>java改变传入参数的值（在深度优先遍历、回溯时经常遇到）：</span><br><span class="line">	对于基本数据类型，实现的是传值，只是个形参，不会改变原有值。对于引用数据类型，对这个引用进行操作，其实也是相当于对形参的操作，不会改变原来的引用。但是，当对这个引用的属性进行操作的时候，相当于CPP中的传址调用，可以改变这个引用的属性的值。</span><br><span class="line">	即修改形参，基本类型不会改变值，引用类型会改变值。如果是类变量，则会更加清晰必然修改。</span><br><span class="line"><span class="number">4.</span>队列问题的体会：</span><br><span class="line">	a.队列从来不作为完整存储容器，不是作为滑动窗口，就是为树存储当前遍历到的节点；</span><br><span class="line">	b.用队列做广度优先遍历是经典方法，堪比反转链表，只要记住维护len变量记录层节点数目即可；</span><br><span class="line">	c.遍历访问树节点时，判断左右子树是否存在，不用<span class="keyword">if</span>...<span class="keyword">else</span>，而是<span class="keyword">if</span>、<span class="keyword">if</span>单独判断，比如只有右子树存在的情况，<span class="keyword">if</span>...<span class="keyword">else</span>就不好。</span><br></pre></td></tr></table></figure>

<h2 id="第八章、树"><a href="#第八章、树" class="headerlink" title="第八章、树"></a>第八章、树</h2><h3 id="047、二叉树剪枝（814、9月11日）"><a href="#047、二叉树剪枝（814、9月11日）" class="headerlink" title="047、二叉树剪枝（814、9月11日）"></a>047、二叉树剪枝（814、9月11日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，深度优先遍历。dfs函数设置布尔返回值，对于每个节点，如果左子树、右子树或者本身含<span class="number">1</span>（满足任何一个），则立刻返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。如果深度遍历到最底层<span class="literal">null</span>还没返回，说明这棵子树不含<span class="number">1</span>，返回<span class="literal">false</span>；当左、右子树不含<span class="number">1</span>时，将其置为<span class="literal">null</span>。</span><br><span class="line">	注意，当输入全<span class="number">0</span>的树时，dfs处理后只剩根节点[<span class="number">0</span>]，但这不符合输出要求。此时，左右子树均为<span class="literal">null</span>，且标志位为<span class="literal">false</span>，要根据标志位决定是返会root节点，还是直接返回<span class="literal">null</span>，而不是<span class="keyword">new</span> <span class="title class_">TreeNode</span>()。（关键词，左右<span class="number">2</span>个标志位）</span><br></pre></td></tr></table></figure>

<h3 id="048、序列化与反序列化树（297、9月12日）"><a href="#048、序列化与反序列化树（297、9月12日）" class="headerlink" title="048、序列化与反序列化树（297、9月12日）"></a>048、序列化与反序列化树（297、9月12日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，<span class="string">&#x27;,&#x27;</span>分割+满二叉树+队列实现广度优先遍历。这道题是困难题，结合了StringBuilder、字符串分割、和队列等知识，但我竟然本地调试后，提交一次就通过了，简直unbelievable！！耍！</span><br><span class="line">（<span class="number">1</span>）序列化时，</span><br><span class="line">    a.每层节点当其本身不等于<span class="literal">null</span>时，就将其值放入StringBuilder，并将左、右子节点放入队列（不管是否为<span class="literal">null</span>）；</span><br><span class="line">    b.等于<span class="literal">null</span>时，就将“<span class="literal">null</span>,”放入StringBuilder，这样能实现满二叉树，底层没有元素的位置会被填入<span class="literal">null</span>，且<span class="literal">null</span>节点的孩子节点不会被放入队列；</span><br><span class="line">    c.输出字符串<span class="string">&quot;1,2,3,null,null,4,5,null,null,null,null,&quot;</span>；</span><br><span class="line">（<span class="number">2</span>）反序列化时，</span><br><span class="line">    a.先通过split(<span class="string">&quot;,&quot;</span>)将节点数值分割出来，再根据索引遍历，最后一个逗号后面的空不会被设为字符；</span><br><span class="line">    b.遍历时，先peek队列头部，再将本字符串转为TreeNode，如果不为<span class="literal">null</span>，则加入队列；先peek是考虑到，首字符串放入队列再peek得到的是它本身；</span><br><span class="line">    c.这时候队列维护的是“没被安装左、右子节点的parent节点”，观察到对于满二叉树，索引为奇数时是左子节点，为偶数时是右子节点，根据这一规律，在队列头部节点被安装好后poll掉它；且要设置root变量记住根节点，以便返回；（关键词，满二叉树）</span><br></pre></td></tr></table></figure>

<h3 id="049、从根节点到叶节点的路径数字之和（129、9月12日）"><a href="#049、从根节点到叶节点的路径数字之和（129、9月12日）" class="headerlink" title="049、从根节点到叶节点的路径数字之和（129、9月12日）"></a>049、从根节点到叶节点的路径数字之和（129、9月12日）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.思路1，深度优先搜索。因为路径相关问题，大都采用深度优先搜索。这道题用dfs更方便的原因，还在于通过path = path*10+root.val;求当前累积和，比如路径为3-&gt;9-&gt;5，3*10+9=39，39*10+5=395，就能直接把路径数字表示出来。</span><br><span class="line">	对于每个节点，返回其左、右子树的累积结果时，直接return dfs(root.left,path)+dfs(root.right,path)，比如path=39，391+395=...，这都是从数值为9的节点开始的全部路径和。注意叶子节点为null，则返回0。（关键词，dfs相加）</span><br></pre></td></tr></table></figure>

<h3 id="050、向下的路径节点之和（437、9月12日）"><a href="#050、向下的路径节点之和（437、9月12日）" class="headerlink" title="050、向下的路径节点之和（437、9月12日）"></a>050、向下的路径节点之和（437、9月12日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，深度优先搜索+前缀和+回溯。咋这几道中等题反而越来越难想嘞？因为题目要求统计次数，故通过hashMap记录前缀和即可，键为当前累积和path，值为path的出现次数。</span><br><span class="line">    a.对于一条路径，不断深入的过程中path加上节点值，并使得hashMap中path对应的值增加<span class="number">1</span>，每次更新当前累积和path时，在hashMap中寻找(path-target)的出现次数，即为这条路径能提供的目标子串数目；</span><br><span class="line">    b.还要像题目<span class="number">49</span>，把path向左、右子节点传递下去，子节点dfs返回后，要将hashMap中path对应的值减<span class="number">1</span>，抹除本路径、本节点的影响，这样便是回溯。（关键词，前缀和、）</span><br><span class="line"><span class="number">2.</span>这道题的测试用例被添加了奇怪的东西，必须将path设置为<span class="number">64</span>位的Long。</span><br><span class="line"><span class="number">3.</span>DFS的代码都很短，但是想到却很困难。对于root节点到叶子节点的全部路径，或者从任意节点开始的部分路径，dfs怎样操作子节点还是不能轻松想到。再次遇到求部分和次数的题目，看来子数组、子串、子路径都要记住hashMap前缀和的方法。</span><br></pre></td></tr></table></figure>

<h3 id="051、节点之和最大的路径（124、9月12日）"><a href="#051、节点之和最大的路径（124、9月12日）" class="headerlink" title="051、节点之和最大的路径（124、9月12日）"></a>051、节点之和最大的路径（124、9月12日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，深度优先搜索。题目没有对路径限制，那对于每个节点有<span class="number">3</span>种情况，但我分析不出返回值该是啥：</span><br><span class="line">    a.b.从其他节点延申过来，经过其左子树或者右子树的路径；</span><br><span class="line">    c.从其左子树开始，经过本节点，再经过其右子树的路径；</span><br><span class="line">我的疑虑主要在，从root节点到某子节点的路径和某节点自身的左右两边路径，这两种情况怎么设计返回值？</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，深度优先搜索。对于每个节点来说，返回值是其本身的值，加上左子树或者右子树返回的值或者<span class="number">0</span>，这样它不是这条路径的核心，不同时提供左右子树，只提供一个边；对于每个节点来说(想象成root节点)，它通过比较左、右子树的返回值、以及两个返回值加上它本身这<span class="number">3</span>个对象，就能覆盖其节点上的最值信息。（关键词，返回root.val+max(left,right)）</span><br><span class="line"><span class="number">3.</span>这道题很困难，代码简单能量爆炸。</span><br></pre></td></tr></table></figure>

<h3 id="052、展平二叉搜索树（897、9月13日）"><a href="#052、展平二叉搜索树（897、9月13日）" class="headerlink" title="052、展平二叉搜索树（897、9月13日）"></a>052、展平二叉搜索树（897、9月13日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，二叉树中序遍历。因为二叉搜索树本身就维护了递增顺序，只需对其中序遍历，将节点放入List，再按照List中的顺序连接。连接时需要将每个节点的左指针置为空，右指针指向List下一节点，最后节点右指针置为空，记住新的root节点即可。（关键词，中序遍历）</span><br><span class="line">    本题中序遍历用dfs递归实现。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二叉树中序遍历。List中可以不放节点，而是放节点值，重组时新建节点。</span><br><span class="line"><span class="number">3.</span>二叉搜索树，左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点。</span><br></pre></td></tr></table></figure>

<h3 id="053、二叉搜索树中的中序后继（285、9月13日）"><a href="#053、二叉搜索树中的中序后继（285、9月13日）" class="headerlink" title="053、二叉搜索树中的中序后继（285、9月13日）"></a>053、二叉搜索树中的中序后继（285、9月13日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，栈实现中序遍历。设置标志位flag初始为<span class="literal">false</span>，栈实现中序遍历代码中，弹栈时当前节点等于目标节点，则将标志位flag置为<span class="literal">true</span>。由于当前节点的右指针为<span class="literal">null</span>时会弹栈，这时flag等于<span class="literal">true</span>跳出循环，当前节点就是目标节点。（关键词，栈实现、标志位）</span><br><span class="line"><span class="number">2.</span>本来准备用dfs递归实现，但在函数递归调用中传递标志位，并考虑返回值好麻烦，没找到时返回值咋设置。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，二叉搜索树。二叉搜索树自身就有排序功能，能根据其性质按照正确的方向去寻找，每个节点比目标值大则向左找，否则向右。注意只在比目标值大时，才将结果节点result更新储存当前节点，因为接下来往左找时新的当前节点值可能小于等于目标值，等于时result中确实存储其中序后继，小于时则不可能是中序后继。（关键词，大于目标是更新result）</span><br></pre></td></tr></table></figure>

<h3 id="054、所有大于等于节点的值之和（538、1038、9月13日）"><a href="#054、所有大于等于节点的值之和（538、1038、9月13日）" class="headerlink" title="054、所有大于等于节点的值之和（538、1038、9月13日）"></a>054、所有大于等于节点的值之和（538、1038、9月13日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归实现先遍历右子树。这道题一看涉及到累积和path，那肯定传参path，返回path。因为是二叉搜索树，根据题目应该先访问右节点，再中间节点，最后是左节点。dfs辅助函数根据前面的遍历顺序修改path值，注意如果节点等于<span class="literal">null</span>，应该返回path而不是返回<span class="number">0</span>，因为dfs函数返回的是修改后的path值，而不是修改量。（关键词，反序中序遍历）</span><br></pre></td></tr></table></figure>

<h3 id="055、二叉搜索树迭代器（173、9月15日）"><a href="#055、二叉搜索树迭代器（173、9月15日）" class="headerlink" title="055、二叉搜索树迭代器（173、9月15日）"></a>055、二叉搜索树迭代器（173、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，栈实现中序遍历。这道题看了很多遍不知道到底在说什么，就看了题解。next函数是返回二叉搜索树中下一个最小的节点值，因此每次访问next函数，先不断调用next指针并压栈使其触底，next弹栈一个元素取值后，将当前节点指向右指针，即完成了中序遍历。</span><br><span class="line">    （关键词，栈实现中序遍历）</span><br></pre></td></tr></table></figure>

<h3 id="056、二叉搜索树中两个节点之和（653、9月15日）"><a href="#056、二叉搜索树中两个节点之和（653、9月15日）" class="headerlink" title="056、二叉搜索树中两个节点之和（653、9月15日）"></a>056、二叉搜索树中两个节点之和（653、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，栈实现中序遍历+hashMap。这几道题都考察栈实现中序遍历，只需在弹栈时，在hashMap中寻找(k-val)，并将val加入hashMap，找到则返回<span class="literal">true</span>，双层<span class="keyword">while</span>循环结束则返回<span class="literal">false</span>。（关键词，栈实现中序遍历）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，双指针，先不做。</span><br></pre></td></tr></table></figure>

<h3 id="057、值和下标之差都在给定的范围内（220、9月15日）"><a href="#057、值和下标之差都在给定的范围内（220、9月15日）" class="headerlink" title="057、值和下标之差都在给定的范围内（220、9月15日）"></a>057、值和下标之差都在给定的范围内（220、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，TreeMap。维护一个TreeMap，键为数字，值为它在数组中的最新索引。从左向右遍历数组，取TreeMap中恰好小于等于（floor）、大于等于（ceiling）当前遍历数字的键，计算其是否满足要求，并将当前遍历数字和索引放入TreeMap。但是，这么做存在问题，假设（&#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">11</span>,<span class="number">9</span>&#125;，索引=<span class="number">1</span>，差值=<span class="number">2</span>）的数字，当遍历到<span class="number">9</span>时，ceiling会取<span class="number">10</span>，从而不满足条件，即使<span class="number">11</span>满足但不在逻辑中。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，TreeSet。维护一个TreeSet，键为数字，这里把它当作滑动窗口，当超过k时，就剔除nums[i-k]。其他步骤同上。此外，为了应付一些特殊测试用例，应该强制类型转换成<span class="number">64</span>位的<span class="type">long</span>。（关键词，滑动窗口）</span><br></pre></td></tr></table></figure>

<h3 id="058、日程表（729、9月15日）"><a href="#058、日程表（729、9月15日）" class="headerlink" title="058、日程表（729、9月15日）"></a>058、日程表（729、9月15日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，TreeMap。维护一个TreeMap，键为start，值为end。每次book时，（关键词，TreeMap）</span><br><span class="line">    a.先取小于等于start的最大键值对，如果value大于start，则返回<span class="literal">false</span>；</span><br><span class="line">    b.再取大于等于start的最小键值对，如果key小于end，则返回<span class="literal">false</span>；</span><br><span class="line">    因为题目规定[start,end)，因此再判断大小时，相等是没问题的，即首尾重合没有问题。</span><br><span class="line"><span class="number">2.</span>TreeSet和TreeMap使用起来很简单，遇到的题目，解题都是依次调用一遍floor和ceiling做判断，再put本元素即可。</span><br><span class="line"><span class="number">3.</span>HashMap和TreeMap是同级的，都继承AbstractMap。必须TreeMap&lt;Integer,Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();，如果前面Class为Map&lt;Integer,Integer&gt;，则会因为多态而失去TreeMap的方法。</span><br></pre></td></tr></table></figure>

<h3 id="总结之树"><a href="#总结之树" class="headerlink" title="总结之树"></a>总结之树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>二叉树分类定义：</span><br><span class="line">	满二叉树，除了叶子结点之外的每一个结点都有两个孩子结点；即只有有孩子，必然有两个；</span><br><span class="line">	完全二叉树，除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐；和完美二叉树区别在，底层不一定完全填充；</span><br><span class="line">	完美二叉树，除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充，是完全二叉树的特例；</span><br><span class="line">	二叉搜索树，左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点；<span class="comment">//整个左子树小于根节点，而不单是左子节点小于</span></span><br><span class="line">	平衡二叉树，二叉搜索树的特例，还需满足：a.左子树和右子树的高度之差的绝对值小于等于<span class="number">1</span>；b.左子树和右子树也是平衡二叉树；是为了避免二叉搜索树高度过高，使其查找、增加和删除的时间复杂度从O(h)退化到O(n)而存在；</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>DFS的代码都很短，但是想到却很困难。对于root节点到叶子节点的全部路径，或者从任意节点开始的部分路径，dfs怎样操作子节点还是不能轻松想到。再次遇到求部分和次数的题目，看来子数组、子串、子路径都要记住hashMap前缀和的方法。呜呜呜呜....</span><br><span class="line"><span class="number">3.</span>目前遇到的习题，二叉树章节基本考察dfs，队列章节则基本考察bfs。二叉树章节的前几道题，都是dfs的奇思妙想，但本章比较基础也比较关键的是，通过dfs（递归）实现前序、中序和后序遍历，另外更困难的遍历实现是利用栈。</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>二叉树前序、中序和后序遍历，栈解法：</span><br><span class="line">    a.中序遍历，双层<span class="keyword">while</span>循环，内部循环顺着左指针一直向下移动并压栈，弹栈时访问值并将当前节点指向右指针；外层循环判断当前节点是否为<span class="literal">null</span>或者栈是否为空，并以新节点接续顺着左指针压栈；实际就是每到右指针指向节点，又开始遍历其左子树；（关键词，双<span class="keyword">while</span>）</span><br><span class="line">    b.前序遍历，双层<span class="keyword">while</span>循环，和中序遍历一致，就是内层循环一直移动左指针时，就访问节点值；即假设对于最底层节点（没有右指针），中序是在弹栈弹掉最底层节点时访问它的值，再弹栈其上层根节点并访问；前序是现在压栈时访问其上层根节点，再压栈并访问最底层节点，弹栈时不访问，因此根节点最先被访问到；（关键词，双<span class="keyword">while</span>、压栈时访问）</span><br><span class="line">    c.后序遍历，双层<span class="keyword">while</span>循环，和中序遍历一致，就是维护指针prev指向上一次访问的节点，帮助弹栈时做判断。</span><br><span class="line">      弹栈时（其实是peek栈顶，这里说弹栈指对应中序遍历的代码块），</span><br><span class="line">    	如果当前节点cur右指针不为<span class="literal">null</span>且没有指向prev，说明还没有访问cur右子树，将cur指向cur.right进行循环，此时不弹栈；</span><br><span class="line">    	其他情况下是经典操作，直接弹栈并访问弹出节点，将prev指针指向弹出节点做记录，将cur指向<span class="literal">null</span>，等待下次循环栈顶复制；</span><br><span class="line">	（关键词，双<span class="keyword">while</span>，弹栈时判断右指针是否指向上一次cur）</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>Java根据红黑树这种平衡的二叉搜索树实现TreeSet和TreeMap两种数据结构，其查找、添加和删除操作的时间复杂度都是O(logn)；TreeSet常用api：</span><br><span class="line">    ceilling  <span class="comment">//返回键大于或等于给定值的最小键，没有则返回null；</span></span><br><span class="line">    floor	  <span class="comment">//返回键小于或等于给定值的最大键，没有则返回null；</span></span><br><span class="line">    higher	  <span class="comment">//返回键大于给定值的最小键，没有则返回null；</span></span><br><span class="line">    lower	  <span class="comment">//返回键小于给定值的最大键，没有则返回null；</span></span><br><span class="line">TreeMap常用api和TreeSet一致，只是在方法名后加Entry或者Key表示返回键值对还是键，比较的时候都是比较键；</span><br><span class="line">如果题目出现数据集合是动态的，并需要根据数据的大小实现快速查找，则使用TreeSet或TreeMap。HashMap做不到这一点，是因为其只能判断某键是否存在，并不能有“比某键大的所有数字中最小的那一个”这种功能。</span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span>TreeSet和TreeMap使用起来很简单，遇到的题目，解题都是依次调用一遍floor和ceiling做判断，再put本元素即可。    </span><br><span class="line"><span class="number">7.</span>HashMap和TreeMap是同级的，都继承AbstractMap。必须TreeMap&lt;Integer,Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();，如果前面Class为Map&lt;Integer,Integer&gt;，则会因为多态而失去TreeMap的方法。</span><br></pre></td></tr></table></figure>

<h2 id="第九章、堆"><a href="#第九章、堆" class="headerlink" title="第九章、堆"></a>第九章、堆</h2><h3 id="059、数据流的第K大数值（703、9月16日）"><a href="#059、数据流的第K大数值（703、9月16日）" class="headerlink" title="059、数据流的第K大数值（703、9月16日）"></a>059、数据流的第K大数值（703、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，暴力破解。维护一个List存放数字，每次添加元素时，使用官方api进行逆序排列，再根据k索引到目标值。（关键词，集合api）</span><br><span class="line">	Collections.sort(list, Comparator.reverseOrder());</span><br><span class="line"><span class="number">2.</span>Arrays.sort是数组排序，Collections.sort是集合排序，都可以传入Comparator接口的实现类，实现自定义排序。自定义排序这块还是不太熟悉，PriorityQueue、上面的逆排序都需要自定义排序比较器，后面需要掌握。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，最小堆。维护一个PriorityQueue，其默认是最小堆，堆顶是整个堆的最小值，这个堆的目的是保存数组中前k大的数字。设计add函数时，按如下逻辑。因为只维护了PriorityQueue，空间复杂度为O(k)。（关键词，前k大元素的最小堆）</span><br><span class="line">	a.如果当前堆大小小于k，直接将数字添加到堆;</span><br><span class="line">	b.如果当前堆大小大于等于k，且要添加的数字超过堆顶，删除堆顶，并将新数字放入PriorityQueue，否则无视新数字；</span><br><span class="line">	c.这样每次返回堆顶，堆顶是前k大数字中的最小值，即为第k大的数字；</span><br><span class="line"> <span class="number">4.</span>最小堆常求前k大元素，最大堆常求前k小元素，是反的。</span><br></pre></td></tr></table></figure>

<h3 id="060、出现频率最高的k个数字（347、9月16日）"><a href="#060、出现频率最高的k个数字（347、9月16日）" class="headerlink" title="060、出现频率最高的k个数字（347、9月16日）"></a>060、出现频率最高的k个数字（347、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，最小堆。先遍历一遍，将数字和出现次数放入hashMap；再遍历hashMap，按照上一题的方式，不满时放入最小堆，满时比较堆顶元素决定是否删除堆顶并放入。但是，这么做出现了问题，因为放入堆时会根据数字大小构造最小堆，而不是数字频率。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，最小堆。维护一个PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt;，构造函数传入的Comparator用键的值比较。</span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; minHeap =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1.getValue()-e2.getValue());</span><br><span class="line">	这里用了lambda表达式。（关键词，最小堆放entry）</span><br></pre></td></tr></table></figure>

<h3 id="061、和最小的k个数对（373、9月16日）"><a href="#061、和最小的k个数对（373、9月16日）" class="headerlink" title="061、和最小的k个数对（373、9月16日）"></a>061、和最小的k个数对（373、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，最大堆。维护一个PriorityQueue&lt;<span class="type">int</span>[]&gt;，自定义Comparator如下：</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;(e2[<span class="number">0</span>]+e2[<span class="number">1</span>])-(e1[<span class="number">0</span>]+e1[<span class="number">1</span>]));</span><br><span class="line">两层<span class="keyword">for</span>循环遍历两个数组，按照上一题的方式，不满时放入最大堆，满时比较堆顶元素决定是否删除堆顶并放入。</span><br><span class="line">遍历完后，如果最大堆的大小小于k，则再两层<span class="keyword">for</span>循环遍历两个数组将所有结果放入返回值；否则将堆中结果放入返回值。</span><br><span class="line">	（关键词，最大堆<span class="type">int</span>[]）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，我的想法优化。因为两个数组是递增排序的，双层<span class="keyword">for</span>循环时不必遍历全部元素，都只用遍历前k个：</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Math.min(k,nums1.length);i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; Math.min(k,nums2.length); j++) &#123;</span><br><span class="line">  此外，可以用<span class="keyword">while</span>(!maxHeap.isEmpty())避免最大堆大小小于k，即双层<span class="keyword">for</span>的全部结果数目小于k的情况，不用额外再双<span class="keyword">for</span>原始数组。</span><br></pre></td></tr></table></figure>

<h3 id="总结之堆"><a href="#总结之堆" class="headerlink" title="总结之堆"></a>总结之堆</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Arrays.sort是数组排序，Collections.sort是集合排序，都可以传入Comparator接口的实现类，实现自定义排序。自定义排序这块还是不太熟悉，PriorityQueue、上面的逆排序都需要自定义排序比较器，后面需要掌握。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>堆分类定义（堆通常用完全二叉树实现，最大特点是最值位于堆顶）：</span><br><span class="line">    最大堆，每个节点的值总是大于或等于其任意子节点的值；在最大堆中，根节点就是整个堆的最大值；</span><br><span class="line">    最小堆，每个节点的值总是小于或等于其任意子节点的值；在最小堆中，根节点就是整个堆的最小值；</span><br><span class="line"><span class="number">3.</span>堆的经典面试题，就是求一个数据集合中值最大或最小的k个元素；如果面试题是求出一个动态集合中的最大值或最小值，考虑用堆。最小堆常求前k大元素，最大堆常求前k小元素，是反的。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>Java提供了PriorityQueue实现堆结构，默认情况下是一个最小堆，如果使用最大堆调用构造函数时就需要传入Comparator改变比较排序规则，其常用api：</span><br><span class="line">	add(e)  <span class="comment">//插入新的元素，会抛出异常；而offer(e)等效但不抛异常，而是返回null</span></span><br><span class="line">	remove  <span class="comment">//删除堆顶元素，会抛出异常；而poll等效但不抛出异常，而是返回null</span></span><br><span class="line">	element <span class="comment">//返回堆顶元素，会抛出异常；而peek等效但不抛出异常</span></span><br><span class="line">    Java中PriorityQueue实现了Queue接口，但它并不是一个队列，不按照“先入先出”顺序删除元素；它本质是一个堆，每次调用remove或者poll都是删除堆顶元素。最大堆中每次删除值最大的元素，最小堆中每次删除值最小的元素。element和peek同理。</span><br><span class="line"><span class="number">5.</span>PriorityQueue中，使用lambda表达式自定义Comparator例子：</span><br><span class="line">   PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; minHeap =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1.getValue()-e2.getValue()); </span><br></pre></td></tr></table></figure>

<h2 id="第十章、前缀树"><a href="#第十章、前缀树" class="headerlink" title="第十章、前缀树"></a>第十章、前缀树</h2><h3 id="062、实现前缀树（208、9月16日）"><a href="#062、实现前缀树（208、9月16日）" class="headerlink" title="062、实现前缀树（208、9月16日）"></a>062、实现前缀树（208、9月16日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，前缀树。定义前缀树节点时，可以将其children指针指向长度为<span class="number">26</span>的TrieNode数组，因为前缀树一般考察小写字母，此外，维护一个布尔标志位，表示路径截止到该字符是否为字符串。本题需要先定义静态前缀树节点类，在insert、search和startsWith方法实现时，根据children指针遍历路径时，记住根节点是空的，还有children数组中不为<span class="literal">null</span>的单元即代表有效字母即可。（关键词，定义TrieNode）</span><br></pre></td></tr></table></figure>

<h3 id="063、替换单词（648、9月17日）"><a href="#063、替换单词（648、9月17日）" class="headerlink" title="063、替换单词（648、9月17日）"></a>063、替换单词（648、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，前缀树。用前缀树解决问题分为两步，第一步是创建前缀树，第二步是在前缀树中查找。</span><br><span class="line">创建前缀树时，</span><br><span class="line">	遍历前缀树，当children对应字母指针为<span class="literal">null</span>时，在该字母指针上添加新节点，遍历晚字符串将当前节点isWord标志位设置为<span class="literal">null</span>。注意，对于字典中的每个字符串，都是从root节点开始遍历前缀树，每到新字符串要将node指向root；</span><br><span class="line">	在前缀树中查找时，通过StringBuilder累积路径，当isWord标志位为<span class="literal">true</span>说明是最短前缀，或者children对应字母指针为<span class="literal">null</span>说明不存在前缀，这时候跳出循环并根据条件返回。</span><br><span class="line">	在主函数中，通过以下api分割和组合字符串：</span><br><span class="line">		 String[] units = sentence.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		 <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>,units);</span><br></pre></td></tr></table></figure>

<h3 id="064、神奇的字典（676、9月17日）"><a href="#064、神奇的字典（676、9月17日）" class="headerlink" title="064、神奇的字典（676、9月17日）"></a>064、神奇的字典（676、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，前缀树。创建前缀树逻辑如旧。在前缀树中查找时，显然是用递归。每次访问新的字母时，尝试当前节点的<span class="number">26</span>个children字母指针，并根据是否为当前字母，决定“已修改次数标志位”是否加<span class="number">1</span>，并继续递归。对于我目前水平来说，还是不熟悉dfs方法传参和返回值的设计：</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TrieNode root,String word,<span class="type">int</span> i,<span class="type">int</span> edit)</span>  <span class="comment">//传参新节点，word，当前字母位置，修改次数</span></span><br><span class="line">需要考虑的情况：</span><br><span class="line">    a.<span class="literal">false</span>边界：root为<span class="literal">null</span>，说明不存在该字母指针，即字典不存在该单词；</span><br><span class="line">    b.<span class="literal">true</span>边界：当前字母位置i走到尽头，root是单词，已经修改一次；</span><br><span class="line">    c.当前字母位置i没有走到尽头，且标志位修改小于等于<span class="number">1</span>次，继续递归；</span><br><span class="line">    d.方法边界：其他情况都返回<span class="literal">false</span>，<span class="literal">true</span>只有“<span class="literal">true</span>边界”那一种情况；</span><br><span class="line">    （关键词，dfs）</span><br></pre></td></tr></table></figure>

<h3 id="065、最短的单词编码（820、9月17日）"><a href="#065、最短的单词编码（820、9月17日）" class="headerlink" title="065、最短的单词编码（820、9月17日）"></a>065、最短的单词编码（820、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>题目解释，这道题是给出单词数组words，但希望换成字符串s表示，并且字符串尽可能短。要求words[i]在s中以#结束，故不能考虑前缀重合，这时候就需要把一些尾缀相同的words[i]联合起来，但是为了表明words[i]在s中的开始位置，就用indices[i]索引words[i]的开始位置。题目答案要给出最短的字符串s长度。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，前缀树。将words中的单词逆序生成前缀树，实际维护了后缀相同的单词，此时要查询生成最短字符串的长度。对字符串a和b来说，如果a恰被淹没在b的路径里，那么只需累加b的长度；如果a和b只是部分前缀重合，那么a和b的长度都需要累加，这样能发现，最短字符串即全部叶子节点到root节点的路径。由于只需要统计长度，那就递归即可。dfs函数的设计还是很巧妙：</span><br><span class="line">    a.先将标志位isLeaf设置为<span class="literal">true</span>；</span><br><span class="line">    b.遍历<span class="number">26</span>个字母指针，如果指针不指向<span class="literal">null</span>，继续递归，并把标志位修改为<span class="literal">false</span>；</span><br><span class="line">    c.继而判断标志位是否为<span class="literal">true</span>，如果为<span class="literal">true</span>说明没有修改，即children指针均指向<span class="literal">null</span>，是叶子节点，此时累加长度；</span><br><span class="line">    初始化length为<span class="number">1</span>，即root节点（空节点）为<span class="number">1</span>，第一个节点时length为<span class="number">2</span>，满足“第一个字母#”长度为<span class="number">2</span>的要求。（关键词，dfs）</span><br><span class="line"><span class="number">3.</span>前缀树中dfs用标志位判断是否为叶子节点，不用root==<span class="literal">null</span>，因为大多数children指针确实为<span class="literal">null</span>。</span><br></pre></td></tr></table></figure>

<h3 id="066、单词之和（677、9月17日）"><a href="#066、单词之和（677、9月17日）" class="headerlink" title="066、单词之和（677、9月17日）"></a>066、单词之和（677、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashMap+前缀树。维护一个HashMap&lt;String,Integer&gt;和一个前缀树。insert方法把新键值插入hashMap的同时，还要把新键加入到前缀树中。这里重点说sum方法，是我为数不多自己实现回溯：</span><br><span class="line">    先通过prefix字符串遍历到最后的节点，并将prefix加入StringBuilder，进入dfs函数：</span><br><span class="line">     dfs(TrieNode node,<span class="type">int</span>[] sum,StringBuilder builder,<span class="type">int</span> index)</span><br><span class="line">    a.遍历当前节点node的<span class="number">26</span>个字母指针，如果不为<span class="literal">null</span>，将builder增加当前字母，并放入dfs继续递归，传入下一层字符的索引值index+<span class="number">1</span>，回溯时再在builder中删除当前字母；注意index初始为prefix长度，而不是<span class="number">0</span>；</span><br><span class="line">    b.如果当前节点为单词，将builder转化为字符串，从hashMap中根据键取值，并累积到最终结果；（关键词，dfs+hashMap）</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，前缀树。相比我的想法改进在，如果一个节点对应一个字符串的最后一个字符，那么该节点的整数字段的值就设为字符串的值，否则设为<span class="number">0</span>；这时候需要修改TrieNode定义，不再需要<span class="type">boolean</span>标志位isWord，而是整数值value。</span><br></pre></td></tr></table></figure>

<h3 id="067、最大的异或（421、9月17日）"><a href="#067、最大的异或（421、9月17日）" class="headerlink" title="067、最大的异或（421、9月17日）"></a>067、最大的异或（421、9月17日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，暴力破解。双层<span class="keyword">for</span>循环遍历，Math.max(value,nums[i]^nums[j])，然而超时了。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，前缀树。因为对于整数异或位运算，相异为<span class="number">1</span>，相同为<span class="number">0</span>，为使结果数值更大，应该尽量高位为<span class="number">1</span>。故构建前缀树时，高位作为前缀。遍历nums整数数组时，从高位开始遍历当前数字num的<span class="number">32</span>位，看前缀树是否有与当前位不同的位，</span><br><span class="line">    a.如果有则将node节点优先移动到该位，并将结果的该位置为<span class="number">1</span>；  xor = (xor&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    b.没有则移动到相同位，并将结果的该位置为<span class="number">0</span>；  xor = xor&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	当前数字num按位访问结束后，通过Math.max(max,xor)更新结果值。（关键词，高位前缀树取不同）</span><br><span class="line">        </span><br><span class="line"><span class="number">3.</span>回忆整数章节技巧：</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> (num&gt;&gt;i)&amp;<span class="number">1</span>;   <span class="comment">//从32位整数高位开始，右移i位，每次只保留末尾位</span></span><br></pre></td></tr></table></figure>

<h3 id="总结之前缀树"><a href="#总结之前缀树" class="headerlink" title="总结之前缀树"></a>总结之前缀树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>前缀树定义：</span><br><span class="line">	前缀树是一棵多叉树，一个节点可能有多个子节点。前缀树中除根节点外，每个节点表示字符串中的一个字符，而字符串由前缀树的路径表示。例如，“can”和“cat”前两个字符相同，它们在前缀树对应的两条路径中最开始的<span class="number">3</span>个节点重叠（根节点，<span class="string">&#x27;c&#x27;</span>和<span class="string">&#x27;a&#x27;</span>）。</span><br><span class="line"><span class="number">2.</span>前缀树主要用来解决字符串查找相关的问题，一般题目要求根据字符串的前缀进行查找。用前缀树解决问题分为两步，第一步是创建前缀树，第二步是在前缀树中查找。这部分需要熟练TrieNode节点定义、创建前缀树经典代码这<span class="number">2</span>步惯性操作，查找通常用dfs比较多样。</span><br><span class="line"><span class="number">3.</span>可以按需求修改TrieNode定义，比如增加字段<span class="type">int</span> value，记录单词对应的值。</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>越来越觉得，递归、回溯以及dfs方法要从四个方向考虑：<span class="literal">false</span>边界、<span class="literal">true</span>边界、继续递归条件和方法边界，而传参和返回值看代码需要什么，是后面才补充的。这部分还是不太熟练。</span><br><span class="line"><span class="number">5.</span>前缀树中dfs用标志位判断是否为叶子节点，不用root==<span class="literal">null</span>，因为大多数children指针确实为<span class="literal">null</span>。</span><br></pre></td></tr></table></figure>

<h2 id="第十三章、回溯法"><a href="#第十三章、回溯法" class="headerlink" title="第十三章、回溯法"></a>第十三章、回溯法</h2><h3 id="079、所有子集（78、9月18日）"><a href="#079、所有子集（78、9月18日）" class="headerlink" title="079、所有子集（78、9月18日）"></a>079、所有子集（78、9月18日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。从左到右遍历整数数组nums，用subSet记录当前集合。遍历到每个元素时，可以选择不放入当前元素继续递归；或者将当前元素放入subSet后继续递归，递归结束将元素从当前集合删除。当遍历深度达到数组长度，则将subSet纳入结果。这道题需要注意：</span><br><span class="line">	a.使用LinkedList，在删除元素时用removeLast方法；而不是使用List，删除元素时用remove(index)。这是因为，假设当前index为<span class="number">2</span>，subSet=[<span class="number">3</span>]，即前两次加的都是空，这样remove(<span class="number">2</span>)时就会越界，为了恢复状态应该用removeLast方法；</span><br><span class="line">	b.双层List嵌套结果，需要用下面的方式放入结果。如果直接result.add(subSet)，后面再操作subSet时，会改变result中subSet值：</span><br><span class="line">		result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line">（关键词，回溯经典）</span><br></pre></td></tr></table></figure>

<h3 id="080、含有k个元素的组合（77、9月18日）"><a href="#080、含有k个元素的组合（77、9月18日）" class="headerlink" title="080、含有k个元素的组合（77、9月18日）"></a>080、含有k个元素的组合（77、9月18日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。显然不能穷举，k为多少就设多少层循环，应该传index回溯。这道题和上一道逻辑相同，因为需要提取k个数，所以外界判断subSet是否到达k，达到则纳入结果；当没有到达k时，有两种选择，可以选择不放入当前元素继续递归，给其他元素一个机会；或者将当前元素放入subSet后继续递归，递归结束将元素从当前集合删除。需注意当前元素不可越界，越界后会走不到判断逻辑并返回，不会继续越界。</span><br><span class="line">     <span class="keyword">if</span>(subSet.size()==k)&#123;</span><br><span class="line">            results.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(start&lt;=n)&#123;</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                </span><br><span class="line">                subSet.add(start);</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                subSet.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">（关键词，回溯经典）</span><br></pre></td></tr></table></figure>

<h3 id="081、允许重复选择元素的组合（39、9月19日）"><a href="#081、允许重复选择元素的组合（39、9月19日）" class="headerlink" title="081、允许重复选择元素的组合（39、9月19日）"></a>081、允许重复选择元素的组合（39、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。做完前几道有点进步了，按照惯性思路完成本题。dfs函数设计如下，index用于定位当前数字，sum是当前累积和，subSet是本集合，results是最终结果集合。</span><br><span class="line">	dfs(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> index, <span class="type">int</span>[] sum, LinkedList&lt;Integer&gt; subSet,List&lt;List&lt;Integer&gt;&gt; results)</span><br><span class="line">dfs逻辑为，当前累计和sum小于target时，有两种选择：</span><br><span class="line">    a.index加一，不访问本索引数字，直接递进下个数字的dfs；</span><br><span class="line">    b.subSet和sum都累加本索引数字，index不变进入下一轮dfs，dfs结束后subSet和sum恢复原状，这样涵盖了多次使用一个数字的情况；</span><br><span class="line">当前累积和sum等于target时，将本集合subSet纳入结果；超过target则没有逻辑自动返回；</span><br><span class="line">（关键词，重复不加）</span><br></pre></td></tr></table></figure>

<h3 id="082、含有重复元素集合的组合（40、9月19日）"><a href="#082、含有重复元素集合的组合（40、9月19日）" class="headerlink" title="082、含有重复元素集合的组合（40、9月19日）"></a>082、含有重复元素集合的组合（40、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。经过题解点拨，“避免重复组合的方法是，当在某一步决定跳过某个值为m的数字时，跳过所有值为m的数字”。因此dfs逻辑为，当前累积和sun小于target时只有一种选择：</span><br><span class="line">	subSet和sum都累加本索引数字，index加一，进入下一轮dfs，dfs结束后subSet和sum恢复原状，这样就不会使用某元素多次；</span><br><span class="line">但是，需要解决不同位置、值相同元素造成的结果重复。这时候，可以先通过Arrays.sort(candidates)排序初始数组，遍历到某数字时，如果下一数字等于本数字，就不断自增index直到不同的数字再dfs。（关键词，要跳全跳）</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>写完才发现完全依靠这句点拨，否则还是难想，辅以示例；比如原始数字集合candidates为[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]，某目标subSet为[<span class="number">2</span>,<span class="number">2</span>]，但会有<span class="number">3</span>种重复，用上面的逻辑，决定调<span class="number">2</span>时会跳出所有的<span class="number">2</span>，那么就会排除重复解：</span><br><span class="line">    a.跳过第一个<span class="number">2</span>，保留后两个<span class="number">2</span>；	b.跳过中间的<span class="number">2</span>，保留前后的<span class="number">2</span>；</span><br><span class="line">这样，任何对<span class="number">2</span>的需求，都是取靠前位置的<span class="number">2</span>，靠后位置的<span class="number">2</span>不被选择故不会重复。</span><br></pre></td></tr></table></figure>

<h3 id="083、没有重复元素集合的全排列（46、9月19日）"><a href="#083、没有重复元素集合的全排列（46、9月19日）" class="headerlink" title="083、没有重复元素集合的全排列（46、9月19日）"></a>083、没有重复元素集合的全排列（46、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。题解的思路基于示例更好说明，假设输入集合[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，对于第一个位置，这<span class="number">3</span>个数字都有可能；对于第二个位置，只有<span class="number">2</span>个数字有可能；第三个位置已经没得选择。dfs函数设计如下：</span><br><span class="line">    a.当索引i达到数组长度时，将当前数组转换为List并纳入结果；</span><br><span class="line">    b.当索引i还没有达到数组长度时，从i开始，后面的每个数字都可以与i位置数字交换，i自增后进入下一轮dfs，dfs结束后将i位置和j位置数字交换回来；</span><br><span class="line">这种思路，每次交换到前面的数字都不再被访问，随着i的增加后面位置情况减少。</span><br><span class="line">（关键词，回溯交换）</span><br></pre></td></tr></table></figure>

<h3 id="084、含有重复元素集合的全排列（47、9月19日）"><a href="#084、含有重复元素集合的全排列（47、9月19日）" class="headerlink" title="084、含有重复元素集合的全排列（47、9月19日）"></a>084、含有重复元素集合的全排列（47、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。当索引i还没有到达数组长度时，从i开始，后面的每个数字只有与位置i的数字不同，都可以与i位置数字交换，其他步骤同第<span class="number">83</span>题。但是，有很多测试用例没通过。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，回溯法。观察题解发现，这里不能只判断“后面的每个数字只有与位置i的数字不同”，还有如果某数字已经与位置i的数字交换，那么与其值相同的数字就不应该再与位置i的数字交换。比如数组[<span class="number">1</span>,<span class="number">2</span>,i=<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]，这时候第二个<span class="number">3</span>不应该交换，第二个<span class="number">5</span>也不应该交换。</span><br><span class="line">（关键词，回溯交换+hashSet）</span><br></pre></td></tr></table></figure>

<h3 id="085、生成匹配的括号（22、9月19日）"><a href="#085、生成匹配的括号（22、9月19日）" class="headerlink" title="085、生成匹配的括号（22、9月19日）"></a>085、生成匹配的括号（22、9月19日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。这应该是第二次做这道题，虽然间隔很久，但是还是做出来了。思路就是，通过StringBuilder增加‘(’字符，进入下一轮dfs，dfs结束后将该字符从builder中移除，再同样操作‘)’字符。当递进深度达到<span class="number">2</span>*n时，判断字符串是否为有效括号，有效则纳入结果。</span><br><span class="line">    判断有效括号： ‘(’字符时压栈，‘)’字符时弹栈，弹栈时如果栈为空则<span class="literal">false</span>，全部字符遍历结束则返回<span class="literal">true</span>。</span><br><span class="line">但是，只击败了<span class="number">5</span>%的同学，肯定不是最优解了。  （关键词，先递进再判断）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，回溯法。相比我的优点是，不用专门判断括号是否有效。由于只存在圆括号“()”，那只需注意两点：</span><br><span class="line">    a.‘(’括号和‘)’括号，数目都不能超过n；</span><br><span class="line">    b.为满足括号匹配，任意时刻左括号数目 &gt;= 右括号数目；</span><br><span class="line">因此，当left&lt;n时，dfs进入left+<span class="number">1</span>；当left&gt;right时，dfs进入right+<span class="number">1</span>。  （关键词，left&gt;=n）</span><br></pre></td></tr></table></figure>

<h3 id="086、分割回文字符串（131、9月20日）"><a href="#086、分割回文字符串（131、9月20日）" class="headerlink" title="086、分割回文字符串（131、9月20日）"></a>086、分割回文字符串（131、9月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯法。从start开始遍历，如果从start开始到i结束(包括i)的字符串为回文字符串，那就通过s.substring(start,i+<span class="number">1</span>)把这段字符串切割出来，从(i+<span class="number">1</span>)进入下一轮dfs，dfs结束后将该段字符串删除。</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;s.length();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPara(s,start,i))&#123;</span><br><span class="line">判断回文字符串的isPara方法，是用双指针实现，通过<span class="keyword">while</span>确定左右两指针是否相遇，在这一过程对比字符。又是只击败了<span class="number">5</span>%，可能还是最后双层List&lt;List&lt;String&gt;&gt; 转 String[][]的步骤太耗费时间。</span><br><span class="line">    （关键词，先判断后递进）</span><br><span class="line"><span class="number">2.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="087、复原IP（93、9月20日）"><a href="#087、复原IP（93、9月20日）" class="headerlink" title="087、复原IP（93、9月20日）"></a>087、复原IP（93、9月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。当没有遍历到末尾，且<span class="string">&#x27;.&#x27;</span>字符数量不足<span class="number">3</span>时，对于当前字符有两种选择：</span><br><span class="line">    a.如果seg加当前字符后仍然有效，可以不创建新段，直接seg+ch，并进入下一轮dfs；</span><br><span class="line">    	<span class="keyword">if</span>(isAvaliable(seg+ch))</span><br><span class="line">    b.如果<span class="string">&#x27;.&#x27;</span>字符数量小于<span class="number">3</span>，且当前段有字符，可以创建新段<span class="string">&#x27;&#x27;</span>+ch，并在ip上添加当前段seg+<span class="string">&#x27;.&#x27;</span>，再进入下一轮dfs；</span><br><span class="line">		<span class="keyword">if</span>(numSplit&lt;<span class="number">3</span>&amp;&amp;seg.length()&gt;<span class="number">0</span>)</span><br><span class="line">这道题的边界条件比较复杂，比较难想到。此外，其isAvaliable方法设计很简洁，即规定范围且要满足<span class="number">0</span>的出现要求：</span><br><span class="line">	<span class="keyword">return</span> Integer.parseInt(s)&lt;=<span class="number">255</span>&amp;&amp;(s.equals(<span class="string">&quot;0&quot;</span>)||s.charAt(<span class="number">0</span>)!=<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">这道题解法并没有回溯，更像是所有可能走到头的穷举。估计下次做还是做不出来hhhh</span><br><span class="line">（关键词，先判断后递进）</span><br><span class="line"><span class="number">2.</span>字符串值比较一定要用s.equals(<span class="string">&quot;0&quot;</span>)，而不是s==<span class="string">&quot;0&quot;</span>，这里s是通过<span class="string">&quot;&quot;</span>+ch不断累加得到的。</span><br></pre></td></tr></table></figure>

<h3 id="总结之回溯法"><a href="#总结之回溯法" class="headerlink" title="总结之回溯法"></a>总结之回溯法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>官方描述提炼：</span><br><span class="line">	a.在采用回溯法解决问题时，如果到达树形结构的叶子节点，就找到了问题的一个解；</span><br><span class="line">	b.如果在前往某个节点时对问题的解的状态进行了修改，那么在回溯到它的父节点时要记得清除相应的修改；</span><br><span class="line">	c.如果明确知道某些子树没有必要遍历，那么在遍历的时候应该避开这些子树以优化效率，这种操作叫剪枝；</span><br><span class="line"><span class="number">2.</span>组合（子集）不看顺序，排列需要注意顺序（排列题目用swap）。</span><br><span class="line"><span class="number">3.</span>LinkedList类有removeLast方法，而ArrayList类并没有，注意多态别List。</span><br><span class="line"><span class="number">4.</span>双层List嵌套结果，需要用下面的方式放入结果。如果直接result.add(subSet)，后面再操作subSet时，会改变result中subSet值：</span><br><span class="line">		result.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>回溯法dfs函数的经典结构（组合问题）：</span><br><span class="line">    <span class="keyword">if</span>(subSet.size()==k)&#123;</span><br><span class="line">            results.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(subSet));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(start&lt;=n)&#123;</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                </span><br><span class="line">                subSet.add(start);</span><br><span class="line">                dfs(n,k,start+<span class="number">1</span>,subSet,results);</span><br><span class="line">                subSet.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="number">6.</span>避免重复组合的方法是，当在某一步决定跳过某个值为m的数字时，跳过所有值为m的数字。</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> index;</span><br><span class="line">    <span class="keyword">while</span>(step+<span class="number">1</span>&lt;candidates.length&amp;&amp;candidates[step+<span class="number">1</span>] == candidates[step])&#123;</span><br><span class="line">        step += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(candidates, target, step + <span class="number">1</span>, sum, subSet, results);</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>双层List&lt;List&lt;String&gt;&gt; 转 String[][]，内层不定长时的coding技巧：</span><br><span class="line">    String[][] finals = <span class="keyword">new</span> <span class="title class_">String</span>[results.size()][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;results.size();i++)&#123;</span><br><span class="line">        List&lt;String&gt; list = results.get(i);</span><br><span class="line">        finals[i] = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>适合回溯法的问题的一个特点是解决这个问题存在多个解，而且题目往往要求列出所有的解。</span><br></pre></td></tr></table></figure>

<h2 id="第十一章、二分查找"><a href="#第十一章、二分查找" class="headerlink" title="第十一章、二分查找"></a>第十一章、二分查找</h2><h3 id="068、查找插入位置（35、9月23日）"><a href="#068、查找插入位置（35、9月23日）" class="headerlink" title="068、查找插入位置（35、9月23日）"></a>068、查找插入位置（35、9月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举。从左到右遍历数组，如果当前数字大于等于目标值，返回当前索引；否则遍历结束后，返回数组长度，即目标值应该插入有序数组的最后一位。（关键词，穷举）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二分查找。经典的二分查找代码，维护left和right双指针，当left&lt;=right时，每轮取中间与目标值比较，根据大小关系决定移动哪个指针，下一轮遍历哪半部分。其中，left等于right是因为，长度为<span class="number">1</span>的子数组也是有效范围。</span><br><span class="line">    稍有不同的是，指针越界则返回left指针，说明上一轮指针重合，target恰好介于二者之间。</span><br></pre></td></tr></table></figure>

<h3 id="069、山峰数组的顶部（852、9月23日）"><a href="#069、山峰数组的顶部（852、9月23日）" class="headerlink" title="069、山峰数组的顶部（852、9月23日）"></a>069、山峰数组的顶部（852、9月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举+标志位。维护一个整型标志位flagIndex，记录山峰位置索引。从索引<span class="number">1</span>开始，从左到右遍历数组，如果当前值大于上一个值，就更新flagIndex，否则跳出循环，返回结果flagIndex。本题简单是因为输入是标准的山峰数组。（关键词，标志位）</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二分查找。经典二分查找代码，但不知道如何维护边界。因为山峰的范围在[<span class="number">1</span>,length-<span class="number">2</span>]，故左指针从<span class="number">1</span>开始，右指针从（length-<span class="number">1</span>）开始，其他不变。（关键词，山峰边界）</span><br></pre></td></tr></table></figure>

<h3 id="070、排序数组中只出现一次的数字（540、9月23日）"><a href="#070、排序数组中只出现一次的数字（540、9月23日）" class="headerlink" title="070、排序数组中只出现一次的数字（540、9月23日）"></a>070、排序数组中只出现一次的数字（540、9月23日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举+标志位。维护一个整型标志位flag，记录当前遍历节点。因为是有序列表，如果本元素和前元素相等，就将flag恢复为Integer.MIN_VALUE，如果不相等，则返回上一元素。遍历到新数字时，如果flag等于Integer.MIN_VALUE，说明前两元素相等并清空了flag，这时候要将flag设置为本数字，避免本数字为最后的数字。（关键词，标志位）</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二分查找。对于<span class="number">3</span>前面的每个数对如(<span class="number">1</span>,<span class="number">1</span>)，第一个数是偶数；对于<span class="number">3</span>后面的每个数对如(<span class="number">4</span>,<span class="number">4</span>)，第一个数是奇数。因此，每次取到偶数mid时，如果nums[mid] == nums[mid + <span class="number">1</span>]说明mid是在<span class="number">3</span>之前，就移动左指针到mid+<span class="number">2</span>（下一个偶数），反之移动右指针到mid。（关键词，索引奇偶性找规律）</span><br><span class="line">	[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>]</span><br><span class="line">    [偶,奇,偶,奇,偶,奇,偶,奇,偶]</span><br><span class="line">    （二分查找看了几遍，没做出来）</span><br></pre></td></tr></table></figure>

<h3 id="071、按权重生成随机数（528、9月26日）"><a href="#071、按权重生成随机数（528、9月26日）" class="headerlink" title="071、按权重生成随机数（528、9月26日）"></a>071、按权重生成随机数（528、9月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，前缀和+二分查找。这道题要求按权重获取随机数，题解思路的精妙之处，在于维护一个前缀和数组，比如权重[<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]，维护一个前缀和数组[<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">12</span>],从[<span class="number">1</span>,<span class="number">12</span>]的范围里通过random API平均取随机数，如果取到<span class="number">9</span>，就对应取到前缀和数组中的索引<span class="number">3</span>，这样就实现了下标按权重随机获取。Solution构造方法初始化前缀和数组，pickIndex方法[<span class="number">0</span>,权重总和]随机获取值后，在前缀和数组里二分查找获取索引。</span><br><span class="line">    （关键词，前缀和数组）</span><br><span class="line"><span class="number">2.</span>本题数组中存着前缀和，因此要在[<span class="number">1</span>,total]中随机取值</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total);  <span class="comment">//在[0,total-1]中随机取值</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total)+<span class="number">1</span>;  <span class="comment">//在[1,total]中随机取值</span></span><br></pre></td></tr></table></figure>

<h3 id="072、求平方根（69、9月25日）"><a href="#072、求平方根（69、9月25日）" class="headerlink" title="072、求平方根（69、9月25日）"></a>072、求平方根（69、9月25日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，二分查找。每次取left、right指针的中间，如果mid*mid小于目标值，移动左指针到(mid-<span class="number">1</span>)，否则移动右指针到(mid+<span class="number">1</span>)。注意，判断条件left&lt;=right，这样如果目标值为<span class="number">0</span>就能处理。结果返回(left-<span class="number">1</span>)，因为mid才是平方恰小于目标值的数。（关键词，二分查找）</span><br><span class="line">    还需要<span class="type">long</span>来处理一些特别的测试用例。</span><br></pre></td></tr></table></figure>

<h3 id="073、狒狒吃香蕉（875、9月26日）"><a href="#073、狒狒吃香蕉（875、9月26日）" class="headerlink" title="073、狒狒吃香蕉（875、9月26日）"></a>073、狒狒吃香蕉（875、9月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，二分查找。没想到这样的题也能用二分查找，首先是在给定速度speed下时间的计算公式：</span><br><span class="line">	<span class="type">int</span> <span class="variable">curTime</span> <span class="operator">=</span> (pile+speed-<span class="number">1</span>)/speed;</span><br><span class="line">	time += curTime;</span><br><span class="line">这道题的思路就是，在最低、最高速度范围内，通过二分查找选出速度，并计算时间，如果时间低于目标值，就减小速度的最高界，反之增加速度的最低界。根据题解，狒狒吃香蕉速度最低每小时<span class="number">1</span>根，最高每小时最大堆根，因此将left、right指针分别指向<span class="number">0</span>和max，在二分查找时更新left、right指针，并更新获得的最低速度。</span><br><span class="line">    （关键词，二分查找速度+计算时间再判断）</span><br></pre></td></tr></table></figure>

<h3 id="总结之二分查找"><a href="#总结之二分查找" class="headerlink" title="总结之二分查找"></a>总结之二分查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>在一个长度为n的数组中查找一个数字，从左到右遍历的话需要O(n)的时间；如果数组是排序的（通常递增），那么可以采用二分查找进行优化。二分查找步骤如下：</span><br><span class="line">	取出位于数组中间的数字和目标数字比较，如果中间数字大于目标数字，那么只需要查找数组的前半部分，没必要再看后半部分。</span><br><span class="line"><span class="number">2.</span>经典二分查找代码：（关键词，left和right双指针，每轮取中间）</span><br><span class="line">    经典的二分查找代码，维护left和right双指针，当left&lt;=right时，每轮取中间与目标值比较，根据大小关系决定移动哪个指针，下一轮遍历哪半部分。其中，left等于right是因为，长度为<span class="number">1</span>的子数组也是有效范围。</span><br><span class="line">	<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> left;  <span class="comment">//如果找不到则返回比target大的后一位</span></span><br><span class="line"><span class="number">3.</span>Random API复制记录：</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total);  <span class="comment">//在[0,total-1]中随机取值</span></span><br><span class="line">  	<span class="keyword">new</span> <span class="title class_">Random</span>.nextInt(total)+<span class="number">1</span>;  <span class="comment">//在[1,total]中随机取值</span></span><br></pre></td></tr></table></figure>

<h2 id="第十二章、排序"><a href="#第十二章、排序" class="headerlink" title="第十二章、排序"></a>第十二章、排序</h2><h3 id="074、合并区间（56、9月26日）"><a href="#074、合并区间（56、9月26日）" class="headerlink" title="074、合并区间（56、9月26日）"></a>074、合并区间（56、9月26日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，先排序再比较。先将二维数组内层根据start从小到达排序，这时候就可比较相邻数组的end。这里使用双重<span class="keyword">while</span>控制，对于内层<span class="keyword">while</span>，如果遍历到的新数组start仍小于临时数组的end，就将新数组范围添加到临时数组（即更新临时数组end），直到某新数组不符合要求，则将临时数组添加到结果集中，在当前遍历点开始新一轮外层循环。</span><br><span class="line">    （关键词，排序后双<span class="keyword">while</span>）</span><br><span class="line"><span class="number">2.</span>数组操作相关api：</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]);  <span class="comment">//将二维数组intervals中的数组，按照索引0位置大小排序</span></span><br><span class="line">	<span class="comment">//将List转换为二维数组，需要先定义有外层初值的二维数组resultArray，再调用toArray API</span></span><br><span class="line">	List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	<span class="type">int</span>[][] resultArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][];</span><br><span class="line">	resultArray = result.toArray(resultArray);</span><br></pre></td></tr></table></figure>

<h3 id="075、数组相对排序（1122、9月27日）"><a href="#075、数组相对排序（1122、9月27日）" class="headerlink" title="075、数组相对排序（1122、9月27日）"></a>075、数组相对排序（1122、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>计数排序：如果数组长度为n，整数范围（最大整数和最小整数的差值）为k，对于k远小于n的场景，计数排序的时间复杂度优于其他基于比较的排序算法（如归并排序，快速排序等）。计数排序的基本思想是，先统计数组中每个整数在数组中出现的次数，然后按照从小到大的顺序将每个整数按照它出现的次数填到数组中。</span><br><span class="line">    即先根据输入的极值为每个可能的位置挖好坑（辅助数组），再遍历数组将每个位置的次数输入辅助数组，最后按顺序遍历辅助数组即可得到有序的结果。时间复杂度O(n+k)，空间复杂度O(k)。（关键词，counts数组）</span><br><span class="line">    <span class="comment">//计数排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            min = Math.min(min,num);</span><br><span class="line">            max = Math.max(max,num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[max-min+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            counts[num-min]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num=min;num&lt;=max;num++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(counts[num-min]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums[i++] = num;</span><br><span class="line">                counts[num-min] -- ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，计数排序。题目提示<span class="number">0</span> &lt;= arr1[i], arr2[i] &lt;= <span class="number">1000</span>，给出了数字范围k，是可以用计数排序的提示。先定义counts数组为<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>]，将arr1数组中每个数字的次数填入counts数组的对应索引位置，遍历arr2数组将counts数组对应数字依次取出，再将counts数组剩余元素依次取出，即可得到有序结果。（关键词，arr1放入counts[<span class="number">1001</span>]）</span><br></pre></td></tr></table></figure>

<h3 id="076、数组中的第k大的数字（215、9月27日）"><a href="#076、数组中的第k大的数字（215、9月27日）" class="headerlink" title="076、数组中的第k大的数字（215、9月27日）"></a>076、数组中的第k大的数字（215、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>快速排序：快速排序的基本思想是分治法，排序过程如下：在输入数组中随机选取一个元素作为中间值（pivot），然后对数组进行分区（partition），使所有比中间值小的数据移动到数组的左边，所有比中间值大的数据移动到数组的右边。接下来对两侧的子数组用相同的步骤排序，直到子数组只有一个数字为止。（关键词，随机获取中间值+small指针交换）</span><br><span class="line">	<span class="comment">//快速排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray_quick(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        quicksort(nums,<span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end&gt;start)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(nums,start,end);</span><br><span class="line">            quicksort(nums,start,pivot-<span class="number">1</span>);</span><br><span class="line">            quicksort(nums,pivot+<span class="number">1</span>,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//small指针始终指向已经发现的最后一个小于中间值的数字</span></span><br><span class="line">	<span class="comment">//即对于某一子数组，从左到右遍历时，如果发现nums[i]小于中间值，就和small指针位置的数字交换；介于small到i的数字，都是比中间值要大的数字，当i到达end时，将small指针位置数字和end交换，就使得大于中间值的数字放在了右边。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(end-start+<span class="number">1</span>)+start;</span><br><span class="line">        swap(nums,random,end);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> start - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[end])&#123;</span><br><span class="line">                small++;</span><br><span class="line">                swap(nums,i,small);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        small++;</span><br><span class="line">        swap(nums,small,end);</span><br><span class="line">        <span class="comment">//不是返回random，而是返回small，观察两次交换，random位置的值先到end，再到了small</span></span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index1,<span class="type">int</span> index2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index1!=index2)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">            nums[index1] = nums[index2];</span><br><span class="line">            nums[index2] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，快速排序+二分查找。先通过partition方法获取确定的中间值索引index，如果index小于目标索引位置，说明需要在右侧子数组中继续寻找，将二分查找的left指针指向index+<span class="number">1</span>；如果index大于目标索引位置，说明需要在左侧子数组中继续寻找，将二分查找的right指针指向index-<span class="number">1</span>；并继续递归调用partition方法，直到撞出目标索引位置后返回。（关键词，快排+二分查找）</span><br></pre></td></tr></table></figure>

<h3 id="077、链表排序（148、9月27日）"><a href="#077、链表排序（148、9月27日）" class="headerlink" title="077、链表排序（148、9月27日）"></a>077、链表排序（148、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>归并排序：归并排序也是一种基于分治法的排序算法，为了排序长度为n的数组，需要先排序两个长度为n/<span class="number">2</span>的子数组，然后合并两个排序的子数组。示例：  需要维护两个数组来回倒腾（关键词，子数组翻倍排序）</span><br><span class="line">    [<span class="number">4</span>,<span class="number">1</span>, <span class="number">5</span>,<span class="number">6</span>, <span class="number">2</span>,<span class="number">7</span>, <span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">  -&gt;[<span class="number">1</span>,<span class="number">4</span>, <span class="number">5</span>,<span class="number">6</span>, <span class="number">2</span>,<span class="number">7</span>, <span class="number">3</span>,<span class="number">8</span>]</span><br><span class="line">  -&gt;[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>    <span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">  -&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>   ]</span><br><span class="line">	<span class="comment">//归并排序 非递归实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray_guibing(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] src = nums;</span><br><span class="line">        <span class="type">int</span>[] dst = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">    	<span class="comment">//外层遍历每次翻倍合并两个数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> seg=<span class="number">1</span>;seg&lt;length;seg+=seg)&#123;</span><br><span class="line">            <span class="comment">//内层遍历从左到右，合并排序2*seg范围里的两个有序子数组，</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> start=<span class="number">0</span>;start&lt;length;start+=seg*<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> Math.min(start+seg, length);</span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(start+seg*<span class="number">2</span>,length);</span><br><span class="line">                <span class="type">int</span> i=start,j=mid,k=start;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;mid||j&lt;end)&#123;</span><br><span class="line">                    <span class="comment">//靠右的子数组可能先结束，如果其提前结束，就只选取前一数组的值</span></span><br><span class="line">                    <span class="keyword">if</span>(j == end||(i&lt;mid&amp;&amp;src[i]&lt;src[j]))&#123;</span><br><span class="line">                        dst[k++] = src[i++];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dst[k++] = src[j++];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换src和temp，屠龙勇士终成龙</span></span><br><span class="line">            <span class="type">int</span>[] temp = src;</span><br><span class="line">            src = dst;</span><br><span class="line">            dst = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序 递归实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray_guibing2(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span>[] dst = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dst = Arrays.copyOf(nums,nums.length);</span><br><span class="line">        mergeSort(nums,dst,<span class="number">0</span>,nums.length);</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] src,<span class="type">int</span>[] dst,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start+<span class="number">1</span>&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start+end)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(dst,src,start,mid);</span><br><span class="line">        mergeSort(dst,src,mid,end);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start,j = mid,k = start;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;mid||j&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == end||(i&lt;mid&amp;&amp;src[i]&lt;src[j]))&#123;</span><br><span class="line">                dst[k++] = src[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dst[k++] = src[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，归并排序。最近有点急火攻心，感冒了也迷茫了，在不知道的位置滚雪球，真的是在前进吗？总体结构如下代码，先通过split方法（快慢指针）获取链表的中间位置并切开，递归调用sortList将两边排序好后，再用merge方法组合两个链表。在merge方法中，因为传入两个链表的目的就是合并，因此可以移动两个链表的头指针，比较两个头指针大小后接到新链表cur上。</span><br><span class="line">    （关键词，快慢指针切开+归并排序）</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> split(head);</span><br><span class="line">        </span><br><span class="line">        head1 = sortList(head1);</span><br><span class="line">        head2 = sortList(head2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(head1,head2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="078、合并排序链表（23、9月27日）"><a href="#078、合并排序链表（23、9月27日）" class="headerlink" title="078、合并排序链表（23、9月27日）"></a>078、合并排序链表（23、9月27日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，最小堆。定义PriorityQueue如下，首先将每个链表的表头放入minHeap，由于是最小堆，此时poll操作获取值最小的节点，先将该节点链入新列表，再将其next指针指向的节点再放入minHeap，重复次操作直到最小堆为空。</span><br><span class="line">	PriorityQueue&lt;ListNode&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1.val-e2.val);</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，归并排序。将这些列表看作经典代码split方法切割后的列表。这时候只有对两边数组排序后再合并即可。注意边界调节，如果某范围start+<span class="number">1</span>==end，说明只有一条链表，此时不用再切开递进，直接返回后准备在上一层和另一条链表进行合并。</span><br><span class="line">    （关键词，索引切开+链表归并排序+最小单位是一条链表）</span><br></pre></td></tr></table></figure>

<h3 id="总结之排序"><a href="#总结之排序" class="headerlink" title="总结之排序"></a>总结之排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>面试经常要求应聘者比较插入排序、冒泡排序、堆排序、计数排序、归并排序和快速排序等不同算法的优劣，需要能够从额外空间消耗、平均时间复杂度和最差时间复杂度方面比较，最可能遇到的是计数排序、快速排序和归并排序。</span><br><span class="line"><span class="number">2.</span>排序能够为二分查找创建基础，在时间复杂度允许的情况下，可以先排序再解题。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>数组操作相关api记录复制：</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]);  <span class="comment">//将二维数组intervals中的数组，按照索引0位置大小排序</span></span><br><span class="line">	<span class="comment">//将List转换为二维数组，需要先定义有外层初值的二维数组resultArray，再调用toArray API</span></span><br><span class="line">	List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	<span class="type">int</span>[][] resultArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()][];</span><br><span class="line">	resultArray = result.toArray(resultArray);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>计数排序定义即经典代码 见<span class="number">075</span>、数组相对排序；  	    时间O(n+k)</span><br><span class="line">  快速排序定义即经典代码 见<span class="number">076</span>、数组中的第k大的数字；	  平均时间O(nlogn)</span><br><span class="line">  归并排序定义即经典代码 见<span class="number">077</span>、链表排序；			 时间O(nlogn)  空间O(n)</span><br><span class="line"><span class="number">5.</span>链表归并排序，合并时的经典复用代码（即按顺序合并两条有序的单链表）：</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1,ListNode head2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(head1!=<span class="literal">null</span>&amp;&amp;head2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head1.val&lt;=head2.val)&#123;</span><br><span class="line">                cur.next = head1;</span><br><span class="line">                <span class="comment">//改造链表是因为，当被传入merge时已经是切成的小段，目的就是连城大段</span></span><br><span class="line">                head1= head1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = head2;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = head1==<span class="literal">null</span>?head2:head1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">6.</span>从<span class="number">8</span>月<span class="number">14</span>日走向<span class="number">9</span>月<span class="number">27</span>日，从最开始感受到稳定进步的兴奋，到现在每天滚着雪球惯性向前的茫然，这一个半月，听着师兄们找工作的挫败感，记起最初Java安全岗的梦想飘然远逝，在西电的深色夜幕中，汹涌人潮在黑暗中起落不止，失去光彩的星星一颗颗砸入噤声的大海。</span><br><span class="line">	不管怎么样，一个原以为坚持不下来的小阶段，还是磕磕绊绊地完成了，我知道了刷题到底是怎么回事。在接下来的“动态规划”和“图”两章中，我要适当放慢自己地脚步，将刷题约束在明确时间范围内，并在十月结束前刷完这本书，结束笔记。剩下的时间追逐梦想吧！！！</span><br></pre></td></tr></table></figure>

<h2 id="第十四章、动态规划"><a href="#第十四章、动态规划" class="headerlink" title="第十四章、动态规划"></a>第十四章、动态规划</h2><h3 id="088、爬楼梯的最少成本（746、10月31日）"><a href="#088、爬楼梯的最少成本（746、10月31日）" class="headerlink" title="088、爬楼梯的最少成本（746、10月31日）"></a>088、爬楼梯的最少成本（746、10月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>打算用整个十一月把top100和剑指offer2刷完，遂重启该部分，开始学习动态规划。</span><br><span class="line"><span class="number">2.</span>我的想法，递归。我知道爬楼梯的公式是f(x)=f(x-<span class="number">1</span>)+f(x-<span class="number">2</span>)，但显然使用递归是不理智的，因为对于dfs(<span class="number">8</span>)或dfs(<span class="number">9</span>)都要计算dfs(<span class="number">7</span>)及以下，时间开销很大所以没通过。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，动态规划。用迭代实现，规定dp[i]从i位置起步的最小开销，则有dp[<span class="number">0</span>]=cost[<span class="number">0</span>]，dp[<span class="number">1</span>]=cost[<span class="number">1</span>]，从i=<span class="number">2</span>开始计算即可。</span><br></pre></td></tr></table></figure>

<h3 id="089、房屋偷盗（198、10月31日）"><a href="#089、房屋偷盗（198、10月31日）" class="headerlink" title="089、房屋偷盗（198、10月31日）"></a>089、房屋偷盗（198、10月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。感觉自己还是挺聪明的，懂得变化。这道题不能偷盗相邻的房子，和爬楼梯的最少成本很相似，因此，定义dp[i]表示偷盗到第i个房子的积累金额，那么dp[i]的计算由于无后效性，不应该太远：</span><br><span class="line">	合法的上一次偷盗是dp[i-<span class="number">2</span>]，但是dp[i-<span class="number">2</span>]不能包括dp[i-<span class="number">3</span>]的情况，故表示该情况为dp[i-<span class="number">1</span>]-nums[i]，故计算公式如下：</span><br><span class="line">	dp[i] = Math.max(dp[i-<span class="number">2</span>],dp[i-<span class="number">1</span>]-nums[i-<span class="number">1</span>])+nums[i];   <span class="comment">//两种情况：不相邻的合法、相邻的合法</span></span><br></pre></td></tr></table></figure>

<h3 id="090、环形房屋偷盗（213、10月31日）"><a href="#090、环形房屋偷盗（213、10月31日）" class="headerlink" title="090、环形房屋偷盗（213、10月31日）"></a>090、环形房屋偷盗（213、10月31日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这道题相比第<span class="number">89</span>道题多了一条限制，即路径中不可以同时出现第<span class="number">0</span>号屋子和第(nums.length-<span class="number">1</span>)号屋子。因此，将问题划分为两个子问题，[<span class="number">0</span>,nums.length-<span class="number">2</span>]范围里的最优解和[<span class="number">1</span>,nums.lenght-<span class="number">1</span>]范围里的最优解，只需要将输入数组范围改变即可。</span><br><span class="line">    对于[<span class="number">1</span>,nums.lenght-<span class="number">1</span>]范围，可以初始化dp[<span class="number">0</span>]=<span class="number">0</span>，dp[<span class="number">1</span>]=nums[<span class="number">1</span>]，dp[<span class="number">2</span>]=nums[<span class="number">2</span>]，从i=<span class="number">3</span>开始公式计算；对于[<span class="number">0</span>,nums.length-<span class="number">2</span>]范围照旧即可。最后返回这两个最优解中的最大值。</span><br><span class="line">    此外，需要注意nums.length&lt;=<span class="number">2</span>时的特殊情况。</span><br></pre></td></tr></table></figure>

<h3 id="091、粉刷房子（256、11月2日）"><a href="#091、粉刷房子（256、11月2日）" class="headerlink" title="091、粉刷房子（256、11月2日）"></a>091、粉刷房子（256、11月2日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。没得想法，看到题解状态转移公式时恍然大悟，一共有三个表达式r(i)、b(i)和g(i)，计算方法一致皆为</span><br><span class="line">    r(i) = min(b(i-<span class="number">1</span>),g(i-<span class="number">1</span>))+cost[i][<span class="number">0</span>]  <span class="comment">//r(i)表示本次选择粉刷红色时，从0到i所有房子的最小成本</span></span><br><span class="line">因此，每栋房子粉刷的颜色受上一幢房子决定，无后效性。</span><br><span class="line">    <span class="keyword">return</span> Math.min(r[n-<span class="number">1</span>],Math.min(b[n-<span class="number">1</span>],g[n-<span class="number">1</span>]));  <span class="comment">//三值比较更为优雅的写法</span></span><br><span class="line">因为转移公式中只涉及dp[i-<span class="number">1</span>]和dp[i]，可以进一步减小空间复杂度：</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">如示例中，b[i-<span class="number">1</span>]表示为dp[(j+<span class="number">1</span>)%<span class="number">3</span>][(i-<span class="number">1</span>)%<span class="number">2</span>]，g[i-<span class="number">1</span>]表示为dp[(j+<span class="number">2</span>)%<span class="number">3</span>][(i-<span class="number">1</span>)%<span class="number">2</span>]。</span><br></pre></td></tr></table></figure>

<h3 id="092、翻转字符（926、11月3日）"><a href="#092、翻转字符（926、11月3日）" class="headerlink" title="092、翻转字符（926、11月3日）"></a>092、翻转字符（926、11月3日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。显然这道题要分情况讨论，应该有两个状态转移方程。根据题解，设f(i)表示把字符串中从<span class="number">0</span>到i的字符变成符合要求的字符并且最后一个字符是<span class="string">&#x27;0&#x27;</span>所需最少翻转次数；设g[i]表示把字符串从<span class="number">0</span>到i的字符变成符合要求并且最后一个字符时<span class="string">&#x27;1&#x27;</span>所需最少反转次数。</span><br><span class="line">	当字符串中下标i的字符是<span class="string">&#x27;0&#x27;</span>时，f(i)=f(i-<span class="number">1</span>)，是<span class="string">&#x27;1&#x27;</span>时则f(i)=f(i-<span class="number">1</span>)+<span class="number">1</span>；</span><br><span class="line">	当字符串中下标i的字符是<span class="string">&#x27;0&#x27;</span>时，g(i)=min&#123;f(i-<span class="number">1</span>),g(i-<span class="number">1</span>)&#125;+<span class="number">1</span>，是<span class="string">&#x27;1&#x27;</span>时则g(i)=min(f(i-<span class="number">1</span>),g(i-<span class="number">1</span>))；</span><br><span class="line"><span class="number">2.</span>做这道题时，猜到会和粉刷房子一样，存在两个转移方程。但还是差点感觉，所有转移函数的定义都是包含本索引的，在本索引做了什么事情后，从<span class="number">0</span>到本索引的最小成本。无后效性，本索引i的成本只与(i-<span class="number">1</span>)相关，除非(i-<span class="number">1</span>)不能表达所有情况，才会与(i-<span class="number">2</span>)相关，但是不会太远。</span><br></pre></td></tr></table></figure>

<h3 id="093、最长斐波那契数列（873、11月3日）"><a href="#093、最长斐波那契数列（873、11月3日）" class="headerlink" title="093、最长斐波那契数列（873、11月3日）"></a>093、最长斐波那契数列（873、11月3日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划+hashMap。这道题很难，状态转移公式为 dp(i,j) = dp(j,k)+<span class="number">1</span>，即假如(k,j,i)组成了斐波那契数列，则其延续的是(?,k,j)数列的长度。转移公式是通过(i,j)两位确定下来，即数列也是通过两位才能确定，单纯的i并不能确定。 </span><br><span class="line">    （关键词， 双层数组 dp(i,j) = dp(j,k)+<span class="number">1</span>）</span><br><span class="line"><span class="number">2.</span>此外，需要注意<span class="keyword">return</span> result&gt;<span class="number">0</span>?result+<span class="number">2</span>:<span class="number">0</span>，即最终数列还包含前<span class="number">2</span>个数字。</span><br></pre></td></tr></table></figure>

<h3 id="094、最少回文分割（132、11月5日）"><a href="#094、最少回文分割（132、11月5日）" class="headerlink" title="094、最少回文分割（132、11月5日）"></a>094、最少回文分割（132、11月5日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。首先维护二维数组isHuwen[i][j]，表示从i到j的字符串是否为回文。通过Arrays.fill填满<span class="literal">true</span>，然后双层<span class="keyword">for</span>循环，外层i从n-<span class="number">1</span>到<span class="number">0</span>，内层j从<span class="number">0</span>到i+<span class="number">1</span>到n。这两步很有技巧性，也是本题的关键，这里说明：</span><br><span class="line">	a.填满True的原因，计算公式为下面式子，如果i=<span class="number">3</span>，j=<span class="number">4</span>，isHuiwen[<span class="number">4</span>][<span class="number">3</span>]没有意义，所以要isHuiwen[<span class="number">4</span>][<span class="number">3</span>]=<span class="literal">true</span>，这样只考虑前面</span><br><span class="line">    	isHuiwen[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; isHuiwen[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">	b.为什么从末尾开始，是因为计算isHuiwen[i][j]时，isHuiwen[i+<span class="number">1</span>][j-<span class="number">1</span>]已经被上一层外层循环计算了.如果从<span class="number">0</span>开始，要计算isHuiwen[<span class="number">0</span>][<span class="number">3</span>]，此时isHuiwen[<span class="number">1</span>][<span class="number">2</span>]还没被计算。</span><br><span class="line">	最后要计算分割次数f，就是从<span class="number">0</span>开始遍历，如果isHuiwen[<span class="number">0</span>][i]为<span class="literal">true</span>则f[i]=<span class="number">0</span>；如果isHuiwen[<span class="number">0</span>][i]为<span class="literal">false</span>，则 <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)，min&#123;f[j&#125;]+<span class="number">1</span>=f[i]；最后返回f[n-<span class="number">1</span>]；</span><br><span class="line">        </span><br><span class="line"><span class="number">2.</span>Arrays.fill(g[i], <span class="literal">true</span>);  <span class="comment">//g是二维数组，则需要for循环索引填充每层一维数组g[i]</span></span><br></pre></td></tr></table></figure>

<h3 id="095、最长公共子序列（1143、11月9日）"><a href="#095、最长公共子序列（1143、11月9日）" class="headerlink" title="095、最长公共子序列（1143、11月9日）"></a>095、最长公共子序列（1143、11月9日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。确实打不过，没办法实力差距，一直都在想将dp[i][j-&gt;m]和dp[i-&gt;n][j]都设置为dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>，但是逻辑有点乱。这道题关键想法在，dp[i-<span class="number">1</span>][j-<span class="number">1</span>]是第（i开始至末尾）个text1字符和第（j开始至末尾）个text2字符没参与过的，</span><br><span class="line">	a.如果第i个text1字符和第j个text2字符相等，则dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>，即使j前的text2字符也可能与（i）相等；</span><br><span class="line">	b.如果第i个text1字符和第j个text2字符不等，则dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])，即可能(i）或(j)造成了相等，并继续维持下去；</span><br><span class="line">	这样的好处是a情况，后来又有一个j字符与i相等，并不是从dp[i][(j-<span class="number">1</span>)以前]去计算。</span><br><span class="line"><span class="number">2.</span>本题需要考虑dp[<span class="number">0</span>][<span class="number">0</span>]，所以设置dp大小为dp[n+<span class="number">1</span>][m+<span class="number">1</span>], 注意dp和text1、text2的索引关系即可。</span><br><span class="line"><span class="number">3.</span>做dp的题好有意思唉，各种各样的转移方程都见过了，还是做不出来啊啊。</span><br></pre></td></tr></table></figure>

<h3 id="096、字符串交织（97、11月9日）"><a href="#096、字符串交织（97、11月9日）" class="headerlink" title="096、字符串交织（97、11月9日）"></a>096、字符串交织（97、11月9日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。感觉和上一道题很像，但是还是做不出来。根据题解分析下吧。定义dp[i][j]表示s1的前i个字符和s2的前j个字符能否组成s3的前（i+j）个字符。那么dp[i][j]既可能因为第（i-<span class="number">1</span>）个s1字符变为<span class="literal">true</span>，也可能因为第（j-<span class="number">1</span>）个s2字符变为<span class="literal">true</span>，故计算如下：</span><br><span class="line">	dp[i][j] = dp[i-<span class="number">1</span>][j]&amp;&amp;(s1.charAt(i-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>));    <span class="comment">//因为第(i-1)个字符</span></span><br><span class="line">	dp[i][j] = dp[i][j] || (dp[i][j-<span class="number">1</span>]&amp;&amp;(s2.charAt(j-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>)));   <span class="comment">//因为第(j-1)个字符</span></span><br><span class="line">此外，需要注意还要计算dp[<span class="number">1</span>][<span class="number">0</span>]、dp[<span class="number">2</span>][<span class="number">0</span>]、dp[<span class="number">0</span>][<span class="number">1</span>]、dp[<span class="number">0</span>][<span class="number">2</span>]等，故不能 <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>)<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>)。</span><br></pre></td></tr></table></figure>

<h3 id="098、路径的数目（62、12月2日）"><a href="#098、路径的数目（62、12月2日）" class="headerlink" title="098、路径的数目（62、12月2日）"></a>098、路径的数目（62、12月2日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。本来以为这道题是图章节的，就跳过没做。其实比较容易记住，和爬楼梯一样，先初始化dp，将最左面和最上面的边界点dp设置为<span class="number">1</span>，其他位置dp来源于其左边和上边dp的求和：</span><br><span class="line">	dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h3 id="099、最小路径之和（64、12月6日）"><a href="#099、最小路径之和（64、12月6日）" class="headerlink" title="099、最小路径之和（64、12月6日）"></a>099、最小路径之和（64、12月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。这道题做过，很快就做出来了。定义dp[i][j]表示以(i,j)结尾的最短路径和，转移方程为：</span><br><span class="line">	dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">	只需要特殊处理最左边和最上边的情况即可。</span><br></pre></td></tr></table></figure>

<h3 id="100、三角形中最小路径之和（120、12月6日）"><a href="#100、三角形中最小路径之和（120、12月6日）" class="headerlink" title="100、三角形中最小路径之和（120、12月6日）"></a>100、三角形中最小路径之和（120、12月6日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。这道题如出一辙，还是挺简单的。因为路径每次移动，都只会向下方相邻节点（同索引或索引加一）移动，所以状态转移方程为：</span><br><span class="line">    dpRow.add(Math.min(dp.get(i-<span class="number">1</span>).get(j),dp.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>))+temp.get(j));  </span><br><span class="line">	<span class="comment">//min&#123;上一行同索引位置、上一行索引加一位置&#125;+本位置数值</span></span><br><span class="line">此外，需要考虑三角形每层元素，对于第一个元素转移方程为：dpRow.add(dp.get(i-<span class="number">1</span>).get(<span class="number">0</span>)+temp.get(<span class="number">0</span>));</span><br><span class="line">对于最后一个元素转移方程为：dpRow.add(dp.get(i-<span class="number">1</span>).get(temp.size()-<span class="number">2</span>)+temp.get(temp.size()-<span class="number">1</span>));</span><br><span class="line">最后，选取三角形最后一层元素中的dp最小值即可。</span><br></pre></td></tr></table></figure>

<h3 id="101、分割等和子集（416、12月20日）"><a href="#101、分割等和子集（416、12月20日）" class="headerlink" title="101、分割等和子集（416、12月20日）"></a>101、分割等和子集（416、12月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>背包问题，先不做。</span><br><span class="line">https:<span class="comment">//leetcode.cn/problems/NUPfPr/solution/by-flix-c3fv/</span></span><br><span class="line"><span class="number">2.</span>没想到再做已经是<span class="number">19</span>日了，在这个光景里好像做啥都不大顶用，我想去做安全又何必刷题呢，不说了，还是保持每天的刷题吧。</span><br><span class="line"><span class="number">3.</span>背包问题：假设有限定容量为C的背包，一堆物品，假设物品i的重量为Wi，价值为Vi，希望能在不超过重量C的前提下，背包内的物品价值最大。<span class="number">0</span>-<span class="number">1</span>背包问题要求物品只能取零次或一次，完全背包问题则没有限制。</span><br><span class="line"><span class="number">4.</span>思路<span class="number">1</span>，动态规划。本题转化为<span class="number">0</span>-<span class="number">1</span>背包问题：背包为所有数字之和的一半，能否选取部分数字，使得恰好装满背包。定义dp[i][j]表示从i个数字中选取若干数，使得这若干数的和为j。定义dp[nums.length][target+<span class="number">1</span>]，首先考虑状态转移方程：</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=num)&#123;</span><br><span class="line">                <span class="comment">//因为每次j都是从1开始遍历，当j&gt;=nums[i]时，dp[i][j]的布尔值来源于两方面</span></span><br><span class="line">                <span class="comment">//a.假设这次不选nums[i]，dp[i][j]=dp[i-1][j];</span></span><br><span class="line">                <span class="comment">//b.假设这次选nums[i]，dp[i][j]=dp[i-1][j-nums[i]];即前(i-1)位置中若干能否组成(j-nums[i])</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j]|dp[i-<span class="number">1</span>][j-nums[i]];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//当j&lt;nums[i]时，在i位置肯定不能选nums[i]，否则会溢出j，</span></span><br><span class="line">                <span class="comment">//此时布尔值只能考虑前i位置中若干位能否组成j</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">最终结果返回dp[nums.length-<span class="number">1</span>][target]即可，再考虑如何初始化：</span><br><span class="line">	dp[任意位][<span class="number">0</span>] = True;  <span class="comment">//这是因为前i位中都可以不选，使得组成0；</span></span><br><span class="line">	dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = True;	<span class="comment">//因为第0位当然可以组成nums[0]，其他位置需要考虑(i-1)位置，故要单独拿出</span></span><br><span class="line"><span class="number">5.</span>这TM八岁，第一次做背包问题，啥也不说了，继续OpenRASP，开溜~</span><br></pre></td></tr></table></figure>

<h3 id="102、加减的目标值（494、12月20日）"><a href="#102、加减的目标值（494、12月20日）" class="headerlink" title="102、加减的目标值（494、12月20日）"></a>102、加减的目标值（494、12月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯法。这道题用回溯做是标准的模板题，每次递归时考虑加减两方面，注意边界即可。</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target,<span class="type">int</span> index,<span class="type">int</span> sum,<span class="type">int</span>[] result)</span></span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，动态规划。设数组元素和为sum，添加减号的元素（都是正数）和为neg，添加加号的元素和为sum-neg；则有 </span><br><span class="line">    (sum-neg)-neg=target；进一步可得 neg = (sum-target)/<span class="number">2</span>；</span><br><span class="line">	问题转化为第<span class="number">101</span>题，能否从nums数组中选取若干位，其和为 (sum-target)/<span class="number">2</span>；思路和第<span class="number">101</span>题类似，但因为需要统计方案数目，定义dp[i][j]表示从nums数组的前i位选取若干位，其和恰为j的方案数目；</span><br><span class="line">    这里的初始化很奇怪，又和第<span class="number">101</span>题差不多，还是用回溯好了。</span><br><span class="line"><span class="number">3.</span>总结一哈<span class="number">0</span>-<span class="number">1</span>背包问题的模板：</span><br><span class="line">	a.推导出目标值target，建立dp[nums.length][target+<span class="number">1</span>]二维数组，<span class="type">int</span>或<span class="type">boolean</span>根据题目看；</span><br><span class="line">	b.初始化dp数组，从dp[i][<span class="number">0</span>]=True或<span class="number">1</span>，以及dp[<span class="number">0</span>][nums[<span class="number">0</span>]]两方面考虑；</span><br><span class="line">	c.双层<span class="keyword">for</span>循环进行状态转移，当j&gt;=nums[i]时，考虑是否加上nums[i]；当j&lt;nums[i]时，只能选择不加nums[i]；</span><br><span class="line">    d.最后返回dp[nums.length-<span class="number">1</span>][target]；</span><br></pre></td></tr></table></figure>

<h3 id="103、最少的硬币数目（322、12月21日）"><a href="#103、最少的硬币数目（322、12月21日）" class="headerlink" title="103、最少的硬币数目（322、12月21日）"></a>103、最少的硬币数目（322、12月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这道题很快就做出来了，可能是昨天有对背包问题的印象。根据题目可知是完全背包问题，dp[i]表示组成金额i所需硬币数目的最小值，设dp[amount+<span class="number">1</span>]。这样可得状态转移方程：</span><br><span class="line">	对于金额i，dp[i] = Math.min(dp[i],dp[i-coin]+<span class="number">1</span>);,即<span class="keyword">for</span>(<span class="type">int</span> coin:coins)，对每种金额进行遍历，表示这次选该金额的硬币。	每轮遍历时，因为取最小，dp[i]初值为Integer.MAX_VALUE，(i-coin)&gt;=<span class="number">0</span>保证不越界，dp[i-coin]!=Integer.MAX_VALUE保证该位置的硬币数有效。</span><br><span class="line"><span class="number">2.</span>Integer.MAX_VALUE就像标志位一样，表示该位置没有合法的硬币数目。</span><br></pre></td></tr></table></figure>

<h3 id="104、排列的数目（377、12月21日）"><a href="#104、排列的数目（377、12月21日）" class="headerlink" title="104、排列的数目（377、12月21日）"></a>104、排列的数目（377、12月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。真是神奇唉，二十分钟连坐两道动态规划，简直比<span class="number">79</span>分钟的姆巴佩还要猛。思路和第<span class="number">103</span>题一致，dp[i]表示组成整数i的方案数目，设dp[target+<span class="number">1</span>]。这样可得状态转移方程：</span><br><span class="line">    对于整数i，dp[i]初值为<span class="number">0</span>，遍历nums中的所有数字，当(i-num)&gt;=<span class="number">0</span>时，dp[i]+=dp[i-num]，即累加前面(i-num)的方案数目。最后返回dp[target]即可。</span><br></pre></td></tr></table></figure>

<h3 id="总结之动态规划"><a href="#总结之动态规划" class="headerlink" title="总结之动态规划"></a>总结之动态规划</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.爬楼梯问题、房屋偷盗问题的根源公式都是f(x)=f(x-1)+f(x-2)，即x位置的状态计算由它的相邻位置和它的最后不相邻位置决定。</span><br></pre></td></tr></table></figure>

<h2 id="第十五章、图"><a href="#第十五章、图" class="headerlink" title="第十五章、图"></a>第十五章、图</h2><h3 id="105、岛屿的最大面积（695、11月20日）"><a href="#105、岛屿的最大面积（695、11月20日）" class="headerlink" title="105、岛屿的最大面积（695、11月20日）"></a>105、岛屿的最大面积（695、11月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题首先图不需要用邻接表或临界矩阵表示，直接在输入的二维数组上搜索。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，广度优先搜索。首先通过两个<span class="keyword">for</span>循环遍历图，维护<span class="type">boolean</span>数组visited表示是否访问过</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rowLen;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;columnLen;j++)&#123; <span class="keyword">if</span>(!visited[i][j]&amp;&amp;grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line"> 如果某个节点符合条件，就通过getArea计算该节点所在岛屿的面积，并更新result结果。getArea的实现逻辑为：</span><br><span class="line">     将(i,j)放入队列，<span class="keyword">while</span>在队列不为空时，向左右、上下四个方向搜索图，如果新位置“没有越界&amp;&amp;没访问过&amp;&amp;是陆地”，就将该新位置(row,column)也加入队列，从队列弹出节点时将area值加一。</span><br><span class="line">     上面的条件“没有访问过&amp;&amp;是陆地”，保证了岛屿面积不会被重复计算，先访问的节点会向四周延申并直接得到所在岛屿的面积。</span><br></pre></td></tr></table></figure>

<h3 id="106、二分图（785、11月20日）"><a href="#106、二分图（785、11月20日）" class="headerlink" title="106、二分图（785、11月20日）"></a>106、二分图（785、11月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题的意思是，把图中节点划分为两个子集，图中的每条边都是跨子集连通的返回True，否则返回<span class="literal">false</span>。本题中的图是邻接表。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，着色法。首先维护colors[rowLen]表示节点染色情况，初始化为-<span class="number">1</span>表示未染色。通过<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rowLen;i++)遍历节点，如果未染色就setColor，如果setColor返回<span class="literal">false</span>就说明染色出错不能形成二分图，全部循环结束则返回<span class="literal">true</span>。</span><br><span class="line">    setColor使用广度优先搜索进行染色，维护队列queue， <span class="keyword">while</span>(!deque.isEmpty())时，弹出队列头部节点并访问其所有邻居节点，如果邻居节点已经被染色，判断染色是否和当前节点相反；如果未被染色，就染上相反色，并放入queue。<span class="keyword">while</span>结束则返回<span class="literal">true</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>这道题解法比较标准，我还是产生了疑惑，广度优先搜索为啥要维护队列，只判断每个节点的相邻节点不就行吗？其实这样破坏了通式。试想节点<span class="number">0</span>连接节点<span class="number">1</span>、节点<span class="number">2</span>，节点<span class="number">1</span>和节点<span class="number">2</span>也有边，访问节点<span class="number">0</span>时会将节点<span class="number">1</span>、<span class="number">2</span>染成同色，这时候访问节点<span class="number">1</span>、<span class="number">2</span>时，因为节点<span class="number">1</span>、<span class="number">2</span>已经被染色就不会setColor，所以不会报警该染色错误。故没访问未染色节点，就要<span class="keyword">while</span>(!queue.isEmpty())搜索它的所有连通区域，这是广度优先图搜索的通式。</span><br></pre></td></tr></table></figure>

<h3 id="107、矩阵中的距离（542、11月20日）"><a href="#107、矩阵中的距离（542、11月20日）" class="headerlink" title="107、矩阵中的距离（542、11月20日）"></a>107、矩阵中的距离（542、11月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先搜索+层长度。遍历到某节点时，如果值不为<span class="number">0</span>，就通过getLen求得到最近的<span class="number">0</span>的距离，并将result的对应位置设为该距离。getLen的逻辑，就是通过队列deque广度优先遍历时，记录每层长度，如果访问完一层的节点，就将Len值加一，并更新层长度为当前deque.size。访问节点遇到合法节点且为<span class="number">0</span>时，返回当前Len，只合法则将其加入deque。结果是因为超时倒在倒数第二个测试用例。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，广度优先搜索。这道题解的想法，巧妙之处在把<span class="number">0</span>看得更重要，并不是遇到<span class="number">1</span>时再找最近的<span class="number">0</span>。首先将双层<span class="keyword">for</span>遍历图，将所有<span class="number">0</span>的位置(i,j)都放入队列，并设置visited[i][j]=<span class="literal">true</span>。当deque不为空时，弹出队列头部节点，并搜索其四个方向位置，如果某位置没有被访问过，则有如下公式：</span><br><span class="line">	result[row][column] = result[position[<span class="number">0</span>]][position[<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">看到这里就会明白，最开始队列全部是<span class="number">0</span>，然后与这些<span class="number">0</span>相邻的位置会被设为<span class="number">1</span>，再一层相邻的位置再此基础上继续加一。就像涟漪一样不断扩散到最远的<span class="number">1</span>。（关键词，所有<span class="number">0</span>的队列+涟漪加一）</span><br></pre></td></tr></table></figure>

<h3 id="109、开密码锁（752、11月20日）"><a href="#109、开密码锁（752、11月20日）" class="headerlink" title="109、开密码锁（752、11月20日）"></a>109、开密码锁（752、11月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，广度优先搜索。首先维护两个HashSet，deadends记录死亡字符串，visited记录访问过的字符串，维护队列Deque&lt;String&gt;准备进行BFS。 </span><br><span class="line">    <span class="keyword">while</span>(!deque.isEmpty())，首先获取deque.size，通过<span class="keyword">for</span>(size)遍历每层节点，对于每个字符串，枚举它改变一个字符后的相邻字符串集合；</span><br><span class="line">    遍历相邻字符串集合，将相邻字符串放入visited和deque，如果等于目标则返回层次深度；否则在所有结束返回-<span class="number">1</span>；</span><br><span class="line">	特殊情况是，<span class="string">&quot;0000&quot;</span>是target则返回<span class="number">0</span>，<span class="string">&quot;0000&quot;</span>是死亡字符串则返回-<span class="number">1</span>。</span><br><span class="line"><span class="number">2.</span>这道题挺经典的，它提供了两个做图BFS的技巧。</span><br><span class="line">	a.队列实现对路径长度的计数(size就是每层节点的数目，它能区分层次)：</span><br><span class="line">	<span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line">        step ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> deque.remove();</span><br><span class="line">            ...</span><br><span class="line">			<span class="comment">//操作该节点并将其相邻节点加入队列</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b.替换String中的某一位，<span class="type">char</span>计算公式：</span><br><span class="line">    <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> strArray[i];</span><br><span class="line">    strArray[i] = temp==<span class="string">&#x27;0&#x27;</span>?<span class="string">&#x27;9&#x27;</span>:(<span class="type">char</span>)(temp-<span class="number">1</span>);</span><br><span class="line">    result.add(<span class="keyword">new</span> <span class="title class_">String</span>(strArray));</span><br></pre></td></tr></table></figure>

<h3 id="110、所有路径（797、11月20日）"><a href="#110、所有路径（797、11月20日）" class="headerlink" title="110、所有路径（797、11月20日）"></a>110、所有路径（797、11月20日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，深度优先遍历。因为这道题说明图为无环图，必然是要穷举所有情况，可设dfs函数如下，首先将i添加到result，再遍历graph[i]中每个num，继续 dfs(num)，并回溯删除该num。当i等于（n-<span class="number">1</span>）时，可把当前result放入结果集results。</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph,List&lt;List&lt;Integer&gt;&gt; results,List&lt;Integer&gt; result,<span class="type">int</span> i,<span class="type">int</span> n)</span></span><br></pre></td></tr></table></figure>

<h3 id="111、计算除法（399、11月21日）"><a href="#111、计算除法（399、11月21日）" class="headerlink" title="111、计算除法（399、11月21日）"></a>111、计算除法（399、11月21日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，广度优先遍历。这道题看着题解抄了一小时，抄的云里雾里的。思路很简单，就是先通过equations画权重图，画成邻接表的形式List&lt;List&lt;Pair&gt;&gt;，其中Pair类保存index（表示去向点），value（表示这条边权重）。然后对queries中的每个查询进行计算，如果查询的两个数值都是已经出现的变量，就计算传播权重，查询方法是队列实现BFS。</span><br><span class="line">    其中判断条件 <span class="keyword">while</span>(!points.isEmpty()&amp;&amp;ratios[vb]&lt;<span class="number">0</span>) 比较特殊，是因为ratios初始化为负值，当节点被传播到时修正为正直。</span><br><span class="line"><span class="number">2.</span>代码老长惹好累，希望下次能刷地做出来。</span><br></pre></td></tr></table></figure>

<h3 id="113、课程顺序（210、11月22日-29日）"><a href="#113、课程顺序（210、11月22日-29日）" class="headerlink" title="113、课程顺序（210、11月22日-29日）"></a>113、课程顺序（210、11月22日-29日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这两三周开始分析OpenRASP源码，准备做成面试项目，导致出现了经典的“研究-安全-Leetcode”纠结问题，大约半个多月没认真碰LeetCode了，接下来还是坚持轻松一点每天一道吧。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，拓扑排序。拓扑排序能保证，任意一条边的起始节点一定排在终止节点的前面，因此拓扑排序得到的序列与先修顺序一定不会存在冲突，问题转变为如何求有向图的拓扑排序序列。</span><br><span class="line">    首先通过hashMap构建邻接表&lt;起始节点，终止节点List&gt;，然后通过题目中“prerequisites先修顺序”填充邻接表并计算每个节点的入度，维护队列deque，将入度为<span class="number">0</span>的节点先填入deque， <span class="keyword">while</span>(!deque.isEmpty())时，弹出节点并获取该节点的终止节点List，将List中每个节点的入度减一，如果减为<span class="number">0</span>则将该终止节点也填入deque。</span><br><span class="line">    最后，如果弹出节点数目为numCourses，则将弹出节点序列返回；否则返回<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>]。</span><br></pre></td></tr></table></figure>

<h3 id="115、重建序列（444、11月29日）"><a href="#115、重建序列（444、11月29日）" class="headerlink" title="115、重建序列（444、11月29日）"></a>115、重建序列（444、11月29日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>超序列和子序列是两个相对概念，如果序列A中的所有元素按照先后顺序都在序列B中出现，那么A是B的子序列，B是A的超序列。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，拓扑排序。题目是找到二维数组sequences中满足所有序列的最短的超序列，判断其是否唯一。如果将sequences中每个序列的每个数字视为一个节点，那么边就是相邻数字，从前一数字指向后一数字。我们知道拓扑排序会维护序列先后顺序，构建sequences中所有节点和边组成的图后，查找该有向图的拓扑排序，判断该拓扑排序是否唯一，唯一是通过对照nums判断。</span><br><span class="line"><span class="number">3.</span>这道题解起来很麻烦的地方是，不能简单定义<span class="type">int</span>[n] degrees这样的入度数组，因为nums可能不是最短的，不能以nums的长度为标准。如测试用例，nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，sequences=[[<span class="number">2</span>,<span class="number">3</span>]]。注意索引，其他和第<span class="number">113</span>题课程顺序类似。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>题解：先维护HashMap&lt;Integer,List&lt;Integer&gt;&gt; graph和HashMap&lt;Integer,Integer&gt; inDegrees，表示该图和入度表，再根据sequences构建graph和inDegrees，然后维护队列queue，将入度为<span class="number">0</span>的数字先填入queue，注意判断条件为 <span class="keyword">while</span>(queue.size()==<span class="number">1</span>)，弹出节点并获取该节点的终止节点List，将List中每个节点的入度减一，如果减为<span class="number">0</span>则将该终止节点也填入deque。最终比较弹出节点顺序和nums是否相同。</span><br><span class="line">    这里 <span class="keyword">while</span>(queue.size()==<span class="number">1</span>)我也想到了，就是每次应该有唯一选择，如果不满足跳出循环，此时弹出节点顺序必然不够nums，从而返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure>

<h3 id="116、省份的数量（547、11月30日）"><a href="#116、省份的数量（547、11月30日）" class="headerlink" title="116、省份的数量（547、11月30日）"></a>116、省份的数量（547、11月30日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，广度优先遍历。维护<span class="type">boolean</span>数组visited，<span class="keyword">for</span>循环遍历节点，如果当前节点没有访问过，就调用辅助方法updateVisit访问它的所有连通节点，并设置这些连通节点已经访问（经典queue实现）。因此，主方法<span class="keyword">for</span>循环，每当出现当前节点没访问，说明出现一个省份，就将最终结果加<span class="number">1</span>。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，并查集。第一次学习并查集，感觉有套路吧，难度主要是想到为什么可以使用并查集。并查集解决问题需要实现合并和查找，并维护一个根节点数组，维护每个元素的根节点信息。合并和查找经典代码如下。</span><br><span class="line"><span class="comment">//合并子集</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] fathers,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fatheri</span> <span class="operator">=</span> findFather(fathers,i);</span><br><span class="line">    <span class="type">int</span> <span class="variable">fatherj</span> <span class="operator">=</span> findFather(fathers,j);</span><br><span class="line">    <span class="keyword">if</span>(fatheri!=fatherj)&#123;</span><br><span class="line">        fathers[fatheri] = fatherj;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找根节点并路径压缩</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findFather</span><span class="params">(<span class="type">int</span>[] fathers,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fathers[i]!=i)&#123;</span><br><span class="line">        fathers[i] = findFather(fathers,fathers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fathers[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span>因此，题解就是初始化n个节点，每个节点的根节点为自己，即有n个子集。双层<span class="keyword">for</span>循环，对当前节点的每个直接连通节点，如果这两个节点的根节点不同，则合并子集，并将子集数目n减一。</span><br></pre></td></tr></table></figure>

<h3 id="118、多余的边（684、11月30日）"><a href="#118、多余的边（684、11月30日）" class="headerlink" title="118、多余的边（684、11月30日）"></a>118、多余的边（684、11月30日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>如果将树看成图，那么一颗有n个节点的树有n-<span class="number">1</span>条边，如果再在树中添加一条边连接任意两个节点，则必然会形成环。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，并查集。初始化n个节点属于n个子集，如果两个节点属于不同的子集，并添加一条边连接它们，就会将它们所在的子集连接在一起，但不会形成环；如果两个节点属于同一子集，同样添加边则会形成环。</span><br><span class="line">    因为edges为[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]]，遍历每条边，如果这条边两端节点的根节点相同，说明这条边会造成环，返回该边即可。</span><br><span class="line"><span class="number">3.</span>特殊情况，</span><br><span class="line">    a.因为节点是<span class="number">1</span>到N，需维护fathers[n+<span class="number">1</span>]，保证索引和节点编号对应，通过edges遍历，也不会使用到fathers[<span class="number">0</span>]。</span><br><span class="line">    b.注意在合并子集时，是fathers[fatherOfi] = fatherOfj，是根节点的父指针指向另一根节点，而不是当前节点i。</span><br></pre></td></tr></table></figure>

<h3 id="119、最长连续序列（128、12月1日）"><a href="#119、最长连续序列（128、12月1日）" class="headerlink" title="119、最长连续序列（128、12月1日）"></a>119、最长连续序列（128、12月1日）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，哈希表+并查集。这道题思路很巧妙，贴一下大佬的博客。维护hashMap，初始化时以&lt;num,num&gt;填入hashMap，然后进行 union(num,num+<span class="number">1</span>)操作，即如果存在num+<span class="number">1</span>，就将num的根节点设为num+<span class="number">1</span>，然后再次遍历nums，对每个数求find(num)-num+<span class="number">1</span>，并不断通过该结果更新result。这是因为，find(num)会递归查找根节点，则必然找到连续的最大值。但由于nums没有排序，所以需要遍历更新。</span><br><span class="line">	大佬的博客：https:<span class="comment">//leetcode.cn/circle/discuss/qmjuMW/。</span></span><br><span class="line">虽然这个解法时间、空间都很慢，但还是很机智，尤其是 union(num,num+<span class="number">1</span>)，是我一直想不到的相邻关系。</span><br></pre></td></tr></table></figure>

<h3 id="总结之图"><a href="#总结之图" class="headerlink" title="总结之图"></a>总结之图</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>图的定义：图由若干节点及节点之间的边组成，确定图中的节点和边是应用图相关算法解决问题的前提。图可以分为有向图和无向图。图可以用邻接表（链表）或连接矩阵（规整的二维数组，<span class="number">1</span>表示有边，<span class="number">0</span>表示没边）表示。图还可以分为有权图和无权图。</span><br><span class="line"><span class="number">2.</span>图的搜索：找出一条从起始节点到目标结点的路径或遍历所有节点，是与图相关的最重要的算法。</span><br><span class="line">	a.广度优先搜索需要一个先进先出的队列，首先将起始节点添加到队列中，接下来每次从队列中取出一个节点，然后将与该节点相邻并且之前还没有到达过的节点添加到队列，重复至所有节点都被访问到。</span><br><span class="line">	b.深度优先搜索沿着图中的边尽可能深入地搜索，走不动时开始回溯，回溯遇到每个节点时，就沿着该节点的另一相邻节点继续深入，重复至所有节点都被访问到。</span><br><span class="line">	</span><br><span class="line"><span class="number">3.</span>广度优先搜索能够保证在无权图中从某个起始节点出发用最短的距离到达目标节点，深度优先搜索则很容易知道从起始节点到达目标节点的路径所经过的所有节点。因此找最短距离适合广度优先，找路径适合深度优先。</span><br><span class="line"><span class="number">4.</span>图中可能存在环，在图中搜索会遇到死循环问题，解决该问题需要记录已经访问过的节点，用visited二维数组记录是一般的方式。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>拓扑排序是指对一个有向无环图的节点进行排序之后得到的序列。如果存在一条从节点A指向节点B的边，那么在拓扑排序的序列中节点A出现在节点B的前面。</span><br><span class="line">    节点v的入度指的是以节点v为终点的边的数目，而节点v的出度指的是以节点v为起点的边的数目。</span><br><span class="line">    常用的拓扑排序算法：每次从有向无环图中取出一个入度为<span class="number">0</span>的节点添加到拓扑排序序列中，然后删除该节点及所有以它为起点的边。重复这个步骤，直到图为空或图中不存在入度为<span class="number">0</span>的节点。如果最终图为空，那么图是有向无环图，且找到了拓扑排序序列；如果图不为空并且已经不存在入度为<span class="number">0</span>的节点，那么图中一定有环。</span><br><span class="line"><span class="number">6.</span>拓扑排序材料：入度degrees，出边hashMap&lt;Integer,List&lt;Integer&gt;，qeque入度<span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span>并查集是一种树形数据结构，用来表示不相交集合的数据。并查集中每个子集是一棵树，每个元素是某棵树的一个节点。树中的每个节点有一个指向父节点的指针，树的根节点的指针指向它自己。并查集支持两种操作，即合并和查找。</span><br><span class="line">    合并：将两个子集合并成一个集合，只需要将一个子集对应的树的根节点的指针，指向另一个自己对应的树的根节点。</span><br><span class="line">    查找：从元素v对应的节点开始沿着指向父节点的指针一直找到树的根节点，树的根节点的判断标志是，树的根节点的指针指向它自己。通过查看两个节点所在树的根节点是否相同，从而能判断它们是否属于同一个子集。</span><br><span class="line">    所谓路径压缩，就是对每个节点，重要的信息不是它的父节点，而是它所在子树的根节点，需要在一次查找后记录&lt;该节点，它的根节点&gt;这样的映射关系，从而降低查找的时间复杂度。</span><br><span class="line">    更加通俗易懂的解释在：https:<span class="comment">//blog.csdn.net/weixin_38279101/article/details/112546053</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://bmsk1994.github.io">bmsk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bmsk1994.github.io/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/">https://bmsk1994.github.io/2022/11/14/剑指offer-专项突破/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/14/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"><img class="prev-cover" src="/img/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">学习日志</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/14/HOT-100/"><img class="next-cover" src="/img/hot100.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">HOT 100</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/11/14/HOT-100/" title="HOT 100"><img class="cover" src="/img/hot100.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-14</div><div class="title">HOT 100</div></div></a></div><div><a href="/2023/03/20/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88/" title="剑指offer第二版"><img class="cover" src="/img/%E5%89%91%E6%8C%87offer2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="title">剑指offer第二版</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">bmsk</div><div class="author-info__description">锦衣疾马，自此西行</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/BMSK1994"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/BMSK1994" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1679897187@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%91%E6%8C%87Offer%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4%E7%89%88"><span class="toc-number">1.</span> <span class="toc-text">剑指Offer专项突破版</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.</span> <span class="toc-text">第三章、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#014-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D-567%E3%80%818%E6%9C%8814%E6%97%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">014.字符串中的变位词 (567、8月14日)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#015-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%98%E4%BD%8D%E8%AF%8D-438%E3%80%818%E6%9C%8815%E6%97%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">015.字符串中的所有变位词(438、8月15日)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#016-%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-3%E3%80%818%E6%9C%8815%E6%97%A5"><span class="toc-number">1.1.3.</span> <span class="toc-text">016.不含重复字符的最长连续子字符串(3、8月15日)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#017-%E5%90%AB%E6%9C%89%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8876%E3%80%818%E6%9C%8815%E6%97%A5%E3%80%8120%E6%97%A5%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">017.含有所有字符的最短字符串（76、8月15日、20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#018-%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%96%87%EF%BC%88125%E3%80%818%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.1.5.</span> <span class="toc-text">018.有效的回文（125、8月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#019-%E6%9C%80%E5%A4%9A%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%BE%97%E5%88%B0%E5%9B%9E%E6%96%87%EF%BC%88680%E3%80%818%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.1.6.</span> <span class="toc-text">019.最多删除一个字符得到回文（680、8月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#020-%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%88647%E3%80%818%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.1.7.</span> <span class="toc-text">020.回文子字符串的个数（647、8月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.8.</span> <span class="toc-text">总结之字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">第四章、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#021-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8819%E3%80%818%E6%9C%8821%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">021.删除链表的倒数第n个节点（19、8月21日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#022-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%EF%BC%88142%E3%80%818%E6%9C%8821%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">022.链表中环的入口节点（142、8月21日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#023-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%87%8D%E5%90%88%E8%8A%82%E7%82%B9%EF%BC%88160%E3%80%818%E6%9C%8821%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">023.两个链表的第一个重合节点（160、8月21日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#024-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88206%E3%80%818%E6%9C%8822%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">024.反转链表（206、8月22日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#025%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88445%E3%80%818%E6%9C%8822%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">025、链表中的两数相加（445、8月22日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#026%E3%80%81%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%EF%BC%88143%E3%80%818%E6%9C%8822%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.6.</span> <span class="toc-text">026、重排链表（143、8月22日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#027%E3%80%81%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%88234%E3%80%818%E6%9C%8822%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.7.</span> <span class="toc-text">027、回文链表（234、8月22日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#028%E3%80%81%E5%B1%95%E5%B9%B3%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%88430%E3%80%818%E6%9C%8823%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.8.</span> <span class="toc-text">028、展平多级双向链表（430、8月23日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#029%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%88708%E3%80%818%E6%9C%8824%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.9.</span> <span class="toc-text">029、排序的循环链表（708、8月24日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.10.</span> <span class="toc-text">总结之链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">第二章、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#006%E3%80%81%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%EF%BC%88167%E3%80%818%E6%9C%8824%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">006、排序数组中两个数字之和（167、8月24日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#007%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA0%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0%EF%BC%8815%E3%80%818%E6%9C%8824%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">007、数组中和为0的三个数（15、8月24日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#008%E3%80%81-%E5%92%8C%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E-target-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88209%E3%80%818%E6%9C%8824%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">008、 和大于等于 target 的最短子数组（209、8月24日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#009%E3%80%81%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8Ek%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88713%E3%80%818%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">009、乘积小于k的子数组（713、8月26日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#010%E3%80%81%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88560%E3%80%818%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">010、和为k的子数组（560、8月26日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#011%E3%80%810%E5%92%8C1%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88525%E3%80%818%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.6.</span> <span class="toc-text">011、0和1个数相同的子数组（525、8月26日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#012%E3%80%81%E5%B7%A6%E5%8F%B3%E4%B8%A4%E8%BE%B9%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89%EF%BC%88724%E3%80%818%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.7.</span> <span class="toc-text">012、左右两边子数组的和相等（724、8月27日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#013%E3%80%81%E4%BA%8C%E7%BB%B4%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C%EF%BC%88304%E3%80%818%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.8.</span> <span class="toc-text">013、二维子矩阵的和（304、8月27日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.9.</span> <span class="toc-text">总结之数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%81%E6%95%B4%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">第一章、整数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#001%E3%80%81%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95%EF%BC%8829%E3%80%818%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">001、整数除法（29、8月31日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#002%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%EF%BC%8867%E3%80%818%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">002、二进制加法（67、8月31日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#003%E3%80%81%E5%89%8Dn%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%88338%E3%80%818%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">003、前n个数字二进制中1的个数（338、8月31日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#004%E3%80%81%E5%8F%AA%E5%87%BA%E7%8E%B01%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88137%E3%80%819%E6%9C%881%E6%97%A5%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">004、只出现1次的数字（137、9月1日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#005%E3%80%81%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%EF%BC%88318%E3%80%819%E6%9C%881%E6%97%A5%EF%BC%89"><span class="toc-number">1.4.5.</span> <span class="toc-text">005、单词长度的最大乘积（318、9月1日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E4%B9%8B%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.6.</span> <span class="toc-text">整数之总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">第五章、哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#030%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E9%83%BD%E6%98%AFO-1-%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%88380%E3%80%818%E6%9C%8828%E6%97%A5%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">030、插入、删除和随机访问都是O(1)的容器（380、8月28日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#031%E3%80%81%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%88146%E3%80%819%E6%9C%881%E6%97%A5%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">031、最近最少使用缓存（146、9月1日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#032%E3%80%81%E6%9C%89%E6%95%88%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D%EF%BC%88242%E3%80%819%E6%9C%882%E6%97%A5%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">032、有效的变位词（242、9月2日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#033%E3%80%81%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84%EF%BC%8849%E3%80%819%E6%9C%882%E6%97%A5%EF%BC%89"><span class="toc-number">1.5.4.</span> <span class="toc-text">033、变位词组（49、9月2日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#034%E3%80%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%A8%80%E6%98%AF%E5%90%A6%E6%8E%92%E5%BA%8F%EF%BC%88953%E3%80%819%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.5.5.</span> <span class="toc-text">034、外星语言是否排序（953、9月6日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#035%E3%80%81%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE%EF%BC%88539%E3%80%819%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.5.6.</span> <span class="toc-text">035、最小时间差（539、9月6日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.5.7.</span> <span class="toc-text">总结之哈希表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E6%A0%88"><span class="toc-number">1.6.</span> <span class="toc-text">第六章、栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#036%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88150%E3%80%819%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">036、后缀表达式（150、9月6日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#037%E3%80%81%E5%B0%8F%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E%EF%BC%88735%E3%80%819%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">037、小行星碰撞（735、9月6日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#038%E3%80%81%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6%EF%BC%88739%E3%80%819%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">038、每日温度（739、9月6日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90039%E3%80%81%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%EF%BC%8884%E3%80%819%E6%9C%887%E6%97%A5%EF%BC%89%E3%80%91"><span class="toc-number">1.6.4.</span> <span class="toc-text">【039、直方图最大矩形面积（84、9月7日）】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90040%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2%EF%BC%8885%E3%80%819%E6%9C%887%E6%97%A5%EF%BC%89%E3%80%91"><span class="toc-number">1.6.5.</span> <span class="toc-text">【040、矩阵中最大的矩形（85、9月7日）】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E6%A0%88"><span class="toc-number">1.6.6.</span> <span class="toc-text">总结之栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E9%98%9F%E5%88%97"><span class="toc-number">1.7.</span> <span class="toc-text">第七章、队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#041%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC%EF%BC%88346%E3%80%819%E6%9C%8810%E6%97%A5%EF%BC%89"><span class="toc-number">1.7.1.</span> <span class="toc-text">041、滑动窗口的平均值（346、9月10日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#042%E3%80%81%E6%9C%80%E8%BF%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0%EF%BC%88933%E3%80%819%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">042、最近请求次数（933、9月11日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#043%E3%80%81%E5%BE%80%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%EF%BC%88919%E3%80%819%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.7.3.</span> <span class="toc-text">043、往完全二叉树添加节点（919、9月11日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#044%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%8F%E5%B1%82%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%88515%E3%80%819%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.7.4.</span> <span class="toc-text">044、二叉树每层的最大值（515、9月11日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#045%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%BA%95%E5%B1%82%E6%9C%80%E5%B7%A6%E8%BE%B9%E7%9A%84%E5%80%BC%EF%BC%88513%E3%80%819%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.7.5.</span> <span class="toc-text">045、二叉树最底层最左边的值（513、9月11日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#046%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E4%BE%A7%E8%A7%86%E5%9B%BE%EF%BC%88199%E3%80%819%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.7.6.</span> <span class="toc-text">046、二叉树的右侧视图（199、9月11日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E9%98%9F%E5%88%97"><span class="toc-number">1.7.7.</span> <span class="toc-text">总结之队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%81%E6%A0%91"><span class="toc-number">1.8.</span> <span class="toc-text">第八章、树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#047%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D%EF%BC%88814%E3%80%819%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.1.</span> <span class="toc-text">047、二叉树剪枝（814、9月11日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#048%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%A0%91%EF%BC%88297%E3%80%819%E6%9C%8812%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.2.</span> <span class="toc-text">048、序列化与反序列化树（297、9月12日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#049%E3%80%81%E4%BB%8E%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%EF%BC%88129%E3%80%819%E6%9C%8812%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.3.</span> <span class="toc-text">049、从根节点到叶节点的路径数字之和（129、9月12日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#050%E3%80%81%E5%90%91%E4%B8%8B%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C%EF%BC%88437%E3%80%819%E6%9C%8812%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.4.</span> <span class="toc-text">050、向下的路径节点之和（437、9月12日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#051%E3%80%81%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%88124%E3%80%819%E6%9C%8812%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.5.</span> <span class="toc-text">051、节点之和最大的路径（124、9月12日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#052%E3%80%81%E5%B1%95%E5%B9%B3%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88897%E3%80%819%E6%9C%8813%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.6.</span> <span class="toc-text">052、展平二叉搜索树（897、9月13日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#053%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7%EF%BC%88285%E3%80%819%E6%9C%8813%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.7.</span> <span class="toc-text">053、二叉搜索树中的中序后继（285、9月13日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#054%E3%80%81%E6%89%80%E6%9C%89%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E4%B9%8B%E5%92%8C%EF%BC%88538%E3%80%811038%E3%80%819%E6%9C%8813%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.8.</span> <span class="toc-text">054、所有大于等于节点的值之和（538、1038、9月13日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#055%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88173%E3%80%819%E6%9C%8815%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.9.</span> <span class="toc-text">055、二叉搜索树迭代器（173、9月15日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#056%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C%EF%BC%88653%E3%80%819%E6%9C%8815%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.10.</span> <span class="toc-text">056、二叉搜索树中两个节点之和（653、9月15日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#057%E3%80%81%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E4%B9%8B%E5%B7%AE%E9%83%BD%E5%9C%A8%E7%BB%99%E5%AE%9A%E7%9A%84%E8%8C%83%E5%9B%B4%E5%86%85%EF%BC%88220%E3%80%819%E6%9C%8815%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.11.</span> <span class="toc-text">057、值和下标之差都在给定的范围内（220、9月15日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#058%E3%80%81%E6%97%A5%E7%A8%8B%E8%A1%A8%EF%BC%88729%E3%80%819%E6%9C%8815%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.12.</span> <span class="toc-text">058、日程表（729、9月15日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E6%A0%91"><span class="toc-number">1.8.13.</span> <span class="toc-text">总结之树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%E3%80%81%E5%A0%86"><span class="toc-number">1.9.</span> <span class="toc-text">第九章、堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#059%E3%80%81%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AC%ACK%E5%A4%A7%E6%95%B0%E5%80%BC%EF%BC%88703%E3%80%819%E6%9C%8816%E6%97%A5%EF%BC%89"><span class="toc-number">1.9.1.</span> <span class="toc-text">059、数据流的第K大数值（703、9月16日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#060%E3%80%81%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84k%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%88347%E3%80%819%E6%9C%8816%E6%97%A5%EF%BC%89"><span class="toc-number">1.9.2.</span> <span class="toc-text">060、出现频率最高的k个数字（347、9月16日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#061%E3%80%81%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%E5%AF%B9%EF%BC%88373%E3%80%819%E6%9C%8816%E6%97%A5%EF%BC%89"><span class="toc-number">1.9.3.</span> <span class="toc-text">061、和最小的k个数对（373、9月16日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E5%A0%86"><span class="toc-number">1.9.4.</span> <span class="toc-text">总结之堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">1.10.</span> <span class="toc-text">第十章、前缀树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#062%E3%80%81%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%88208%E3%80%819%E6%9C%8816%E6%97%A5%EF%BC%89"><span class="toc-number">1.10.1.</span> <span class="toc-text">062、实现前缀树（208、9月16日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#063%E3%80%81%E6%9B%BF%E6%8D%A2%E5%8D%95%E8%AF%8D%EF%BC%88648%E3%80%819%E6%9C%8817%E6%97%A5%EF%BC%89"><span class="toc-number">1.10.2.</span> <span class="toc-text">063、替换单词（648、9月17日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#064%E3%80%81%E7%A5%9E%E5%A5%87%E7%9A%84%E5%AD%97%E5%85%B8%EF%BC%88676%E3%80%819%E6%9C%8817%E6%97%A5%EF%BC%89"><span class="toc-number">1.10.3.</span> <span class="toc-text">064、神奇的字典（676、9月17日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#065%E3%80%81%E6%9C%80%E7%9F%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E7%BC%96%E7%A0%81%EF%BC%88820%E3%80%819%E6%9C%8817%E6%97%A5%EF%BC%89"><span class="toc-number">1.10.4.</span> <span class="toc-text">065、最短的单词编码（820、9月17日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#066%E3%80%81%E5%8D%95%E8%AF%8D%E4%B9%8B%E5%92%8C%EF%BC%88677%E3%80%819%E6%9C%8817%E6%97%A5%EF%BC%89"><span class="toc-number">1.10.5.</span> <span class="toc-text">066、单词之和（677、9月17日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#067%E3%80%81%E6%9C%80%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96%EF%BC%88421%E3%80%819%E6%9C%8817%E6%97%A5%EF%BC%89"><span class="toc-number">1.10.6.</span> <span class="toc-text">067、最大的异或（421、9月17日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">1.10.7.</span> <span class="toc-text">总结之前缀树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E3%80%81%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">第十三章、回溯法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#079%E3%80%81%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86%EF%BC%8878%E3%80%819%E6%9C%8818%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.1.</span> <span class="toc-text">079、所有子集（78、9月18日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#080%E3%80%81%E5%90%AB%E6%9C%89k%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%84%E5%90%88%EF%BC%8877%E3%80%819%E6%9C%8818%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.2.</span> <span class="toc-text">080、含有k个元素的组合（77、9月18日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#081%E3%80%81%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%84%E5%90%88%EF%BC%8839%E3%80%819%E6%9C%8819%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.3.</span> <span class="toc-text">081、允许重复选择元素的组合（39、9月19日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#082%E3%80%81%E5%90%AB%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%84%E5%90%88%EF%BC%8840%E3%80%819%E6%9C%8819%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.4.</span> <span class="toc-text">082、含有重复元素集合的组合（40、9月19日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#083%E3%80%81%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8846%E3%80%819%E6%9C%8819%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.5.</span> <span class="toc-text">083、没有重复元素集合的全排列（46、9月19日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#084%E3%80%81%E5%90%AB%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8847%E3%80%819%E6%9C%8819%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.6.</span> <span class="toc-text">084、含有重复元素集合的全排列（47、9月19日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#085%E3%80%81%E7%94%9F%E6%88%90%E5%8C%B9%E9%85%8D%E7%9A%84%E6%8B%AC%E5%8F%B7%EF%BC%8822%E3%80%819%E6%9C%8819%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.7.</span> <span class="toc-text">085、生成匹配的括号（22、9月19日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#086%E3%80%81%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88131%E3%80%819%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.8.</span> <span class="toc-text">086、分割回文字符串（131、9月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#087%E3%80%81%E5%A4%8D%E5%8E%9FIP%EF%BC%8893%E3%80%819%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.9.</span> <span class="toc-text">087、复原IP（93、9月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-number">1.11.10.</span> <span class="toc-text">总结之回溯法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.12.</span> <span class="toc-text">第十一章、二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#068%E3%80%81%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%8835%E3%80%819%E6%9C%8823%E6%97%A5%EF%BC%89"><span class="toc-number">1.12.1.</span> <span class="toc-text">068、查找插入位置（35、9月23日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#069%E3%80%81%E5%B1%B1%E5%B3%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%B6%E9%83%A8%EF%BC%88852%E3%80%819%E6%9C%8823%E6%97%A5%EF%BC%89"><span class="toc-number">1.12.2.</span> <span class="toc-text">069、山峰数组的顶部（852、9月23日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#070%E3%80%81%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88540%E3%80%819%E6%9C%8823%E6%97%A5%EF%BC%89"><span class="toc-number">1.12.3.</span> <span class="toc-text">070、排序数组中只出现一次的数字（540、9月23日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#071%E3%80%81%E6%8C%89%E6%9D%83%E9%87%8D%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%88528%E3%80%819%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.12.4.</span> <span class="toc-text">071、按权重生成随机数（528、9月26日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#072%E3%80%81%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9%EF%BC%8869%E3%80%819%E6%9C%8825%E6%97%A5%EF%BC%89"><span class="toc-number">1.12.5.</span> <span class="toc-text">072、求平方根（69、9月25日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#073%E3%80%81%E7%8B%92%E7%8B%92%E5%90%83%E9%A6%99%E8%95%89%EF%BC%88875%E3%80%819%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.12.6.</span> <span class="toc-text">073、狒狒吃香蕉（875、9月26日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.12.7.</span> <span class="toc-text">总结之二分查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E3%80%81%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.</span> <span class="toc-text">第十二章、排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#074%E3%80%81%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%EF%BC%8856%E3%80%819%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.13.1.</span> <span class="toc-text">074、合并区间（56、9月26日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#075%E3%80%81%E6%95%B0%E7%BB%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F%EF%BC%881122%E3%80%819%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.13.2.</span> <span class="toc-text">075、数组相对排序（1122、9月27日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#076%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88215%E3%80%819%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.13.3.</span> <span class="toc-text">076、数组中的第k大的数字（215、9月27日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#077%E3%80%81%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%EF%BC%88148%E3%80%819%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.13.4.</span> <span class="toc-text">077、链表排序（148、9月27日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#078%E3%80%81%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%8823%E3%80%819%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.13.5.</span> <span class="toc-text">078、合并排序链表（23、9月27日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8E%92%E5%BA%8F"><span class="toc-number">1.13.6.</span> <span class="toc-text">总结之排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.14.</span> <span class="toc-text">第十四章、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#088%E3%80%81%E7%88%AC%E6%A5%BC%E6%A2%AF%E7%9A%84%E6%9C%80%E5%B0%91%E6%88%90%E6%9C%AC%EF%BC%88746%E3%80%8110%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.1.</span> <span class="toc-text">088、爬楼梯的最少成本（746、10月31日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#089%E3%80%81%E6%88%BF%E5%B1%8B%E5%81%B7%E7%9B%97%EF%BC%88198%E3%80%8110%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.2.</span> <span class="toc-text">089、房屋偷盗（198、10月31日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#090%E3%80%81%E7%8E%AF%E5%BD%A2%E6%88%BF%E5%B1%8B%E5%81%B7%E7%9B%97%EF%BC%88213%E3%80%8110%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.3.</span> <span class="toc-text">090、环形房屋偷盗（213、10月31日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#091%E3%80%81%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90%EF%BC%88256%E3%80%8111%E6%9C%882%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.4.</span> <span class="toc-text">091、粉刷房子（256、11月2日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#092%E3%80%81%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%EF%BC%88926%E3%80%8111%E6%9C%883%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.5.</span> <span class="toc-text">092、翻转字符（926、11月3日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#093%E3%80%81%E6%9C%80%E9%95%BF%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%EF%BC%88873%E3%80%8111%E6%9C%883%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.6.</span> <span class="toc-text">093、最长斐波那契数列（873、11月3日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#094%E3%80%81%E6%9C%80%E5%B0%91%E5%9B%9E%E6%96%87%E5%88%86%E5%89%B2%EF%BC%88132%E3%80%8111%E6%9C%885%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.7.</span> <span class="toc-text">094、最少回文分割（132、11月5日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#095%E3%80%81%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%881143%E3%80%8111%E6%9C%889%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.8.</span> <span class="toc-text">095、最长公共子序列（1143、11月9日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#096%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E7%BB%87%EF%BC%8897%E3%80%8111%E6%9C%889%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.9.</span> <span class="toc-text">096、字符串交织（97、11月9日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#098%E3%80%81%E8%B7%AF%E5%BE%84%E7%9A%84%E6%95%B0%E7%9B%AE%EF%BC%8862%E3%80%8112%E6%9C%882%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.10.</span> <span class="toc-text">098、路径的数目（62、12月2日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#099%E3%80%81%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C%EF%BC%8864%E3%80%8112%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.11.</span> <span class="toc-text">099、最小路径之和（64、12月6日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#100%E3%80%81%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%AD%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C%EF%BC%88120%E3%80%8112%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.12.</span> <span class="toc-text">100、三角形中最小路径之和（120、12月6日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#101%E3%80%81%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86%EF%BC%88416%E3%80%8112%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.13.</span> <span class="toc-text">101、分割等和子集（416、12月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#102%E3%80%81%E5%8A%A0%E5%87%8F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%80%BC%EF%BC%88494%E3%80%8112%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.14.</span> <span class="toc-text">102、加减的目标值（494、12月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#103%E3%80%81%E6%9C%80%E5%B0%91%E7%9A%84%E7%A1%AC%E5%B8%81%E6%95%B0%E7%9B%AE%EF%BC%88322%E3%80%8112%E6%9C%8821%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.15.</span> <span class="toc-text">103、最少的硬币数目（322、12月21日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#104%E3%80%81%E6%8E%92%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE%EF%BC%88377%E3%80%8112%E6%9C%8821%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.16.</span> <span class="toc-text">104、排列的数目（377、12月21日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.14.17.</span> <span class="toc-text">总结之动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%E3%80%81%E5%9B%BE"><span class="toc-number">1.15.</span> <span class="toc-text">第十五章、图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#105%E3%80%81%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%EF%BC%88695%E3%80%8111%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.15.1.</span> <span class="toc-text">105、岛屿的最大面积（695、11月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#106%E3%80%81%E4%BA%8C%E5%88%86%E5%9B%BE%EF%BC%88785%E3%80%8111%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.15.2.</span> <span class="toc-text">106、二分图（785、11月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#107%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%9D%E7%A6%BB%EF%BC%88542%E3%80%8111%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.15.3.</span> <span class="toc-text">107、矩阵中的距离（542、11月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#109%E3%80%81%E5%BC%80%E5%AF%86%E7%A0%81%E9%94%81%EF%BC%88752%E3%80%8111%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.15.4.</span> <span class="toc-text">109、开密码锁（752、11月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#110%E3%80%81%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%EF%BC%88797%E3%80%8111%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.15.5.</span> <span class="toc-text">110、所有路径（797、11月20日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#111%E3%80%81%E8%AE%A1%E7%AE%97%E9%99%A4%E6%B3%95%EF%BC%88399%E3%80%8111%E6%9C%8821%E6%97%A5%EF%BC%89"><span class="toc-number">1.15.6.</span> <span class="toc-text">111、计算除法（399、11月21日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#113%E3%80%81%E8%AF%BE%E7%A8%8B%E9%A1%BA%E5%BA%8F%EF%BC%88210%E3%80%8111%E6%9C%8822%E6%97%A5-29%E6%97%A5%EF%BC%89"><span class="toc-number">1.15.7.</span> <span class="toc-text">113、课程顺序（210、11月22日-29日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#115%E3%80%81%E9%87%8D%E5%BB%BA%E5%BA%8F%E5%88%97%EF%BC%88444%E3%80%8111%E6%9C%8829%E6%97%A5%EF%BC%89"><span class="toc-number">1.15.8.</span> <span class="toc-text">115、重建序列（444、11月29日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#116%E3%80%81%E7%9C%81%E4%BB%BD%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%88547%E3%80%8111%E6%9C%8830%E6%97%A5%EF%BC%89"><span class="toc-number">1.15.9.</span> <span class="toc-text">116、省份的数量（547、11月30日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#118%E3%80%81%E5%A4%9A%E4%BD%99%E7%9A%84%E8%BE%B9%EF%BC%88684%E3%80%8111%E6%9C%8830%E6%97%A5%EF%BC%89"><span class="toc-number">1.15.10.</span> <span class="toc-text">118、多余的边（684、11月30日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#119%E3%80%81%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%EF%BC%88128%E3%80%8112%E6%9C%881%E6%97%A5%EF%BC%89"><span class="toc-number">1.15.11.</span> <span class="toc-text">119、最长连续序列（128、12月1日）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%8B%E5%9B%BE"><span class="toc-number">1.15.12.</span> <span class="toc-text">总结之图</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88/" title="剑指offer第二版"><img src="/img/%E5%89%91%E6%8C%87offer2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="剑指offer第二版"/></a><div class="content"><a class="title" href="/2023/03/20/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88/" title="剑指offer第二版">剑指offer第二版</a><time datetime="2023-03-20T05:35:41.000Z" title="Created 2023-03-20 13:35:41">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/Fastjson-before-1-2-48/" title="Fastjson before 1.2.48"><img src="/img/fastjson1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Fastjson before 1.2.48"/></a><div class="content"><a class="title" href="/2023/03/20/Fastjson-before-1-2-48/" title="Fastjson before 1.2.48">Fastjson before 1.2.48</a><time datetime="2023-03-20T05:11:30.000Z" title="Created 2023-03-20 13:11:30">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%A4%8D%E4%B9%A0%E7%AF%87/" title="Tomcat内存马复习篇"><img src="/img/webshell.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tomcat内存马复习篇"/></a><div class="content"><a class="title" href="/2023/03/20/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%A4%8D%E4%B9%A0%E7%AF%87/" title="Tomcat内存马复习篇">Tomcat内存马复习篇</a><time datetime="2023-03-20T05:10:49.000Z" title="Created 2023-03-20 13:10:49">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/Log4j2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" title="Log4j2漏洞分析"><img src="/img/log4j2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Log4j2漏洞分析"/></a><div class="content"><a class="title" href="/2023/03/20/Log4j2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" title="Log4j2漏洞分析">Log4j2漏洞分析</a><time datetime="2023-03-20T05:10:23.000Z" title="Created 2023-03-20 13:10:23">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/RMI/" title="RMI"><img src="/img/RMI.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RMI"/></a><div class="content"><a class="title" href="/2023/03/20/RMI/" title="RMI">RMI</a><time datetime="2023-03-20T05:09:46.000Z" title="Created 2023-03-20 13:09:46">2023-03-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By bmsk</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>