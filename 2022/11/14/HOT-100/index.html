<!DOCTYPE html><html lang="[&quot;zh-cn&quot;,&quot;en&quot;,&quot;default&quot;]" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>HOT 100 | BMSK</title><meta name="author" content="bmsk"><meta name="copyright" content="bmsk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Leetcode刷题笔记1.两数之和（7月31日）1.int[]型返回值占位 return new int[0];2.哈希表实现	&#x2F;&#x2F;使用哈希表，可以将寻找 target - x 的时间复杂度降低到从O(N)降低到O(1)。    &#x2F;&#x2F;思路：把前面的数字和索引放入hashmap中，遍历到后面的数字时只需对hashmap做一次查找    public int[] twoSum2(int[] nums">
<meta property="og:type" content="article">
<meta property="og:title" content="HOT 100">
<meta property="og:url" content="https://bmsk1994.github.io/2022/11/14/HOT-100/index.html">
<meta property="og:site_name" content="BMSK">
<meta property="og:description" content="Leetcode刷题笔记1.两数之和（7月31日）1.int[]型返回值占位 return new int[0];2.哈希表实现	&#x2F;&#x2F;使用哈希表，可以将寻找 target - x 的时间复杂度降低到从O(N)降低到O(1)。    &#x2F;&#x2F;思路：把前面的数字和索引放入hashmap中，遍历到后面的数字时只需对hashmap做一次查找    public int[] twoSum2(int[] nums">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bmsk1994.github.io/img/hot100.jpg">
<meta property="article:published_time" content="2022-11-14T12:05:09.000Z">
<meta property="article:modified_time" content="2022-11-14T12:37:21.158Z">
<meta property="article:author" content="bmsk">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bmsk1994.github.io/img/hot100.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://bmsk1994.github.io/2022/11/14/HOT-100/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HOT 100',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-14 20:37:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/hot100.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">BMSK</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HOT 100</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-11-14T12:05:09.000Z" title="Created 2022-11-14 20:05:09">2022-11-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-11-14T12:37:21.158Z" title="Updated 2022-11-14 20:37:21">2022-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode/">LeetCode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">16.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>56min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HOT 100"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Leetcode刷题笔记"><a href="#Leetcode刷题笔记" class="headerlink" title="Leetcode刷题笔记"></a>Leetcode刷题笔记</h1><h2 id="1-两数之和（7月31日）"><a href="#1-两数之和（7月31日）" class="headerlink" title="1.两数之和（7月31日）"></a>1.两数之和（7月31日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="type">int</span>[]型返回值占位 <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line"><span class="number">2.</span>哈希表实现</span><br><span class="line">	<span class="comment">//使用哈希表，可以将寻找 target - x 的时间复杂度降低到从O(N)降低到O(1)。</span></span><br><span class="line">    <span class="comment">//思路：把前面的数字和索引放入hashmap中，遍历到后面的数字时只需对hashmap做一次查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum2(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hashmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashmap.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashmap.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-两数相加（7月31日）"><a href="#2-两数相加（7月31日）" class="headerlink" title="2.两数相加（7月31日）"></a>2.两数相加（7月31日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>头插法的起始写法（别用“头部循环外处理+l1.next判断”了，是真的逻辑乱）</span><br><span class="line">    ListNode head=<span class="literal">null</span>,tail=<span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">while</span>(l1!=<span class="literal">null</span>||l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">        	head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">        	tail = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>对齐技巧</span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> l1!=<span class="literal">null</span>?l1.val:<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> l2!=<span class="literal">null</span>?l2.val:<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-无重复字符的最长子串（7月31日、滑动窗口）"><a href="#3-无重复字符的最长子串（7月31日、滑动窗口）" class="headerlink" title="3.无重复字符的最长子串（7月31日、滑动窗口）"></a>3.无重复字符的最长子串（7月31日、滑动窗口）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 花了很长时间没有做出来，我的想法是，维护两个hashMap，分别存储&lt;字母，该字母后的长度&gt;和&lt;字母，该字母的出现位置&gt;，当某个字母判断为重复后，删除该字母及其出现位置以前所有其他字母的hashMap。这样做，倒在了最后两个测试用例，</span><br><span class="line">    分析发现超时原因主要出现在删除该位置以前所有的haspMap，改进增加限制条件“自上一次删除后”，通过测试，击败<span class="number">9.63</span>%哈哈</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>滑动窗口</span><br><span class="line">    滑动窗口就是一个队列，这个队列维护无重复字符的最长子串，每当遇到重复字符时，我们更新队列左端；</span><br><span class="line">    更新队列左端会遇到两种情况，假设重复字符a已经在hashMap中：</span><br><span class="line">    	以baba为例，左端更新到第二个b的位置，字符a的位置小于队列左端，说明第一个字符a出现后，其他字符的重复造成左端更新大于第一个a的位置，此时队列左端就需要保持不动；</span><br><span class="line">    	以cabab为例，左端更新到c的位置，字符a的位置大于队列左端，说明从c以来，a的重复出现打破了队列维护的无重复子串，此时队列左端就需要更新到a的位置；</span><br><span class="line">    这两种情况，为了维护队列，更新左端都是考虑重复字符第一次出现位置和旧左端谁更大：</span><br><span class="line">    	left = Math.max(left,map.get(s.charAt(i)));</span><br><span class="line"></span><br><span class="line">	在队列右端向右探索时，右端接触的字符需要更新位置：map.put(s.charAt(i),i+<span class="number">1</span>)；这里加一是因为左端要从hashMap中取，而本字符造成了重复，它的下一位才是不重复的；</span><br><span class="line">    并计算当前维护无重复子串队列的长度：max = Math.max(max,i-left+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>我的思路为什么慢了？</span><br><span class="line">    向右探索时，我是遍历维护的hashMap，为每个元素维护的子串长度加一，并判断是否大于maxValue；当遇到重复元素时，我需要找到该重复元素旧位置以前的其他元素，因为他们的子串因为包含此元素子串，所以要从hashMap中删除这些其他元素。即向右探索存在两个遍历。</span><br></pre></td></tr></table></figure>

<h2 id="4-寻找两个正序数组的中位数（8月1日）"><a href="#4-寻找两个正序数组的中位数（8月1日）" class="headerlink" title="4.寻找两个正序数组的中位数（8月1日）"></a>4.寻找两个正序数组的中位数（8月1日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>本题一遍过了，就是中位数是两个有序数组中的第 (m+n)/<span class="number">2</span> 个元素和第 (m+n)/<span class="number">2</span> 个元素的平均值，故遍历只需进行到两个数组总长度的中间位置。需要注意一个数组先结束的情况，外层套上数组边界判断，这种情况下只探索另一数组。</span><br><span class="line"><span class="number">2.</span><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=(nums1.length+nums2.length)/<span class="number">2</span>;i++)，这样小于等于的话，如果总长度为奇数，中间位置即为最后元素；如果总长度为偶数，中间位置即为最后两个元素取平均；注意先要把<span class="keyword">for</span>循环i最后多加的<span class="number">1</span>去掉。</span><br></pre></td></tr></table></figure>

<h2 id="5-最长回文子串（8月6日、动态规划）"><a href="#5-最长回文子串（8月6日、动态规划）" class="headerlink" title="5.最长回文子串（8月6日、动态规划）"></a>5.最长回文子串（8月6日、动态规划）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题比较困难，甚至暴力破解都想不出来，看题解第一次接触动态规划。动态规划是一种用空间换时间的做法，即把一些子序列的结果保存起来，长序列利用子序列的结果。本题中假设例子是“babac”，已知子序列“aba”的结果为回文，那只需要考虑两端b≠c，即长序列不是回文。</span><br><span class="line"><span class="number">2.</span>因为是从短序列推导长序列，应该外围遍历是序列长度，计算每个位置开始的固定序列长度的结果，遍历长序列时，只需利用dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];获得长序列的结果。</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> L=<span class="number">2</span>;L&lt;=len;L++)</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="number">3.</span>考虑的特殊情况，a.单字符即为回文；b.双字符没有子序列，直接给出结果；c.在每个双层遍历后判断是否大于maxlen且为回文，并记录该序列的起始位置，用于返回裁剪字符串。</span><br></pre></td></tr></table></figure>

<h2 id="10-正则表达式匹配（8月6日、动态规划）"><a href="#10-正则表达式匹配（8月6日、动态规划）" class="headerlink" title="10.正则表达式匹配（8月6日、动态规划）"></a>10.正则表达式匹配（8月6日、动态规划）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">看晕了，DP太难啦</span><br></pre></td></tr></table></figure>

<h2 id="11-盛最多水的容器（8月6日、双指针）"><a href="#11-盛最多水的容器（8月6日、双指针）" class="headerlink" title="11.盛最多水的容器（8月6日、双指针）"></a>11.盛最多水的容器（8月6日、双指针）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法是，用冒泡排序的结构遍历一遍所有可能的情况，更新maxValue，但是超出了时间限制。</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line"><span class="number">2.</span>双指针代表的是，可以作为容器边界的所有位置的范围，开始时，左右指针分别指向左右边界。每次计算容量后，只移动一个指针，且移动高度更低的指针。</span><br><span class="line">	这是因为，假设指针距离为t，此时右指针位置桶壁更高，则容量为min(x,y)*t=x*t,</span><br><span class="line">	假设向左移动右指针，指针距离t-<span class="number">1</span>，min(x,<span class="keyword">new</span> <span class="title class_">y</span>)&lt;=x,则此时min(x,<span class="keyword">new</span> <span class="title class_">y</span>)*(t-<span class="number">1</span>)&lt;x*t,</span><br><span class="line">	说明这种移动没有任何意义，从这种移动出发找不到比当前位置更高的容量，所以移动的条件是移动更低桶壁的指针位置。</span><br><span class="line">	结束的条件是，因为是每次只移动一个指针，即两个指针最终不能指向同一位置。<span class="keyword">while</span>(left!=right)</span><br><span class="line"><span class="number">3.</span>双指针算法没超过时间限制的原因是，一直在剔除不可能的情况。时间复杂度为O(N)，只需遍历数组一次。</span><br></pre></td></tr></table></figure>

<h2 id="15-三数之和（8月7日、排序-双指针）"><a href="#15-三数之和（8月7日、排序-双指针）" class="headerlink" title="15.三数之和（8月7日、排序+双指针）"></a>15.三数之和（8月7日、排序+双指针）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法是三重循环，运行后发现还需要编写去重，那铁定得超时了。查看题解说三重循环+哈希去重是一般想法，肯定会超时，这里哈希去重指的是哪种操作呢？</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：如果数组是有序的，枚举到的三元组(a,b,c)满足a&lt;=b&lt;=c,保证了内容(a,b,c)不会以(b,a,c)、(c、a、b)等其他顺序出现，故数组应该有序。此外，如果满足“对每一重循环而言，相邻两次枚举的元素不能相同”，即每个数字都有代表元，三重循环每一重不会遍历到相同元素，不同层会遍历到同一元素，但序列递增导致序列不同，这样就彻底做到去重。</span><br><span class="line">	Arrays.sort(nums); <span class="comment">//无需返回值的数组排序</span></span><br><span class="line">	List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">//结果数组的定义</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;      <span class="comment">//每层遍历范围的衔接，因为等于i+1，或者后面式子不等于才该遍历</span></span><br><span class="line">        <span class="keyword">if</span>(j&gt;i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>; k &lt; nums.length; k++)&#123; </span><br><span class="line">但是，这种算法还是会导致运行超时，时间复杂度仍然是O(N^<span class="number">3</span>)。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>：当固定第<span class="number">1</span>重循环元素i后，第<span class="number">2</span>、<span class="number">3</span>重循环就会存在并列关系，和为(<span class="number">0</span>-nums[i])。这样随着第<span class="number">2</span>重循环元素严格递增，势必存在第<span class="number">3</span>重循环元素严格递减，那么就可以用双指针，左指针右移，右指针左移，导致整体需要遍历元素数目减少。</span><br><span class="line">  a.我的实现： <span class="keyword">while</span>(j&lt;k)为外层，当nums[j] + nums[k] &lt; target时将左指针右移，&gt;target时将右指针左移，=target时记录位置并将两个指针同时移动；需要处理的特殊情况是，当同层循环遍历相同元素时应<span class="keyword">continue</span>，故有两个<span class="keyword">continue</span>判断。</span><br><span class="line">  b.Leetcode的实现：<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> first + <span class="number">1</span>; second &lt; n; ++second)为外层，即以second为基准，相比我的优化是，当&gt;target时一直将右指针左移，即能在到一个second时就最大限度降低右指针，到下一个second时third也足够小。</span><br><span class="line">      <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) --third;</span><br><span class="line">            </span><br><span class="line"><span class="number">4.</span>Leetcode定义：这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从O(N^<span class="number">2</span>)减少至O(N)。本题由于存在第一重循环，双指针复杂度O(N^<span class="number">2</span>)。</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span>简述：确定第一重循环后，问题简化为双指针问题，移动指针的策略是：由于右指针左移会减小target，即尽可能左移右指针,求得在当前左指针下等于target的位置；当和&lt;target后，将左指针右移使和增大，在新左指针下再继续移动右指针。故Leetcode的<span class="keyword">for</span>循环实现更清晰些。</span><br></pre></td></tr></table></figure>

<h2 id="17-电话号码的字母组合（8月7日、回溯）"><a href="#17-电话号码的字母组合（8月7日、回溯）" class="headerlink" title="17.电话号码的字母组合（8月7日、回溯）"></a>17.电话号码的字母组合（8月7日、回溯）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>第一次做本题是抱着学习常用api的目的，比如这里的StringBuffer类，能通过：a.append方法添加<span class="type">char</span>类型元素，b.通过deleteCharAt方法实现根据索引删除元素，c.通过toString方法把结果转化为String类。这就能实现一个类似python中“ <span class="string">&quot;&quot;</span>+a ”这样的效果。</span><br><span class="line"><span class="number">2.</span>因为想不通到底要写多少层<span class="keyword">for</span>循环才行，看了题解。题解用了回溯算法，就是递归。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>：通过StringBuffer类创建一个字符缓冲区，每到一层获取一个元素，继续向更深层递进，直到层数达到数字序列的长度，保存结果后开始返回；返回到每一层，先删除本层缓存的元素，再将本层另一元素放入缓冲区，继续向深层递进，直到每层的循环都结束。因为达到最大长度才需要记录结果，故函数不需要思考返回值。</span><br></pre></td></tr></table></figure>

<h2 id="19-删除链表的倒数第-N-个结点（8月8日、快慢指针）"><a href="#19-删除链表的倒数第-N-个结点（8月8日、快慢指针）" class="headerlink" title="19.删除链表的倒数第 N 个结点（8月8日、快慢指针）"></a>19.删除链表的倒数第 N 个结点（8月8日、快慢指针）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的next指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。</span><br><span class="line"><span class="number">2.</span>思路一：先遍历链表获取链表长度，再从头节点开始遍历，遍历到（L-n+<span class="number">1</span>）个节点时，它就是需要删除的节点。以[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">2</span>为例</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length-n+<span class="number">1</span>;i++)&#123; cur = cur.next;&#125;</span><br><span class="line">	<span class="comment">//由于加了dummy节点，先有i再有对应位置node，所以最后到node3结束，i增加为4跳出，恰删除node4</span></span><br><span class="line">	<span class="comment">//需要有dummy节点，是假如是以[1],1为例，cur.next会报错，即没有把头节点普通化，放到普通节点的逻辑里。</span></span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>：快慢指针，先不做。</span><br></pre></td></tr></table></figure>

<h2 id="20-有效的括号（8月8日）"><a href="#20-有效的括号（8月8日）" class="headerlink" title="20.有效的括号（8月8日）"></a>20.有效的括号（8月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题比较简单，就是用栈解决，当(、&#123;、[来时压栈，当)、]、&#125;来时开始判断合法性并弹栈，这个时候栈为空或者栈顶不是对应括号即为非法。此外，通过字符串长度是否为偶数，也能先判断合法性。</span><br><span class="line"><span class="number">2.</span>常用建栈api的掌握：</span><br><span class="line">	Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();   <span class="comment">//此时可用stack.peek()，.push(cur)、.pop()等栈方法</span></span><br><span class="line"><span class="number">2.</span>在这里记录史凯超的一个问题：<span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();这种为什么要这样写？</span><br><span class="line">  这是对依赖倒置原则：</span><br><span class="line">    a.这样当某位置需要存储list时，它可以设置为接受List从而既存储ArrayList，有存储LinkedList；</span><br><span class="line">    b.list只能使用ArrayList中已经实现了的List接口中的方法，而没有在List接口中定义的方法不能被访问到。</span><br></pre></td></tr></table></figure>

<h2 id="21-合并两个有序链表-8月8日"><a href="#21-合并两个有序链表-8月8日" class="headerlink" title="21.合并两个有序链表(8月8日)"></a>21.合并两个有序链表(8月8日)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题比较简单，虽然第一次写，先判断是否为空，又判断大小，代码重复性很大，没有注意可以直接用原链的节点。但是，还使用到了前面学习的dummy节点技巧，这是因为假如<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>在<span class="number">4</span>语句后，就会使得链尾添加一个新节点，此时已跳出循环，结果为[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>],考虑去除<span class="number">0</span>的逻辑很麻烦；改进应该是先添加节点，再填充新节点数据，但这样第一个节点直接用了list3tail.next就没被处理，所以应该设一个head的前驱节点dummy，返回dummy.next，这样就能把head节点和后续位置节点一样处理。</span><br><span class="line">    ListNode list3dummy=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">list3tail</span> <span class="operator">=</span> list3dummy;</span><br><span class="line">	<span class="keyword">while</span>(tail1!=<span class="literal">null</span>||tail2!=<span class="literal">null</span>)&#123;</span><br><span class="line">    	。。。</span><br><span class="line">     	<span class="keyword">if</span>(tail1.val&gt;=tail2.val)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();  <span class="comment">//1</span></span><br><span class="line">            list3tail.next = node;           <span class="comment">//2</span></span><br><span class="line">            list3tail = node;                <span class="comment">//3</span></span><br><span class="line">            list3tail.val=tail2.val;         <span class="comment">//4</span></span><br><span class="line">            tail2 = tail2.next;        </span><br><span class="line">   		&#125;</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="keyword">return</span> list3dummy.next;</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>：递归法，先不做</span><br></pre></td></tr></table></figure>

<h2 id="22-括号生成（8月11日）"><a href="#22-括号生成（8月11日）" class="headerlink" title="22.括号生成（8月11日）"></a>22.括号生成（8月11日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法是按照<span class="number">20</span>题“有效的括号”那样做，并加上回溯的结构，即新输入满足一定要求后才能回溯。但可能花了<span class="number">2</span>小时写了一泡狗屎，不知道为啥理不清栈在回溯中的表现，明明应该出栈的括号却能剩下来，stack.size()变成了当前字符中左括号的数目，太烧脑了，调试傻了，再做也是浪费时间。TMD,真是超级无比垃圾狗蛋题。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>：暴力破解。就是先通过递归生成指定长度的括号，再判断括号字符串是否有效。这里判断括号是否有效的思路比<span class="number">20</span>题简单，因为只判断圆括号<span class="string">&#x27;()&#x27;</span>,只需维护一个循环外<span class="type">int</span>变量balance，当<span class="string">&#x27;(&#x27;</span>来时balance加<span class="number">1</span>，当<span class="string">&#x27;)&#x27;</span>来时balance减<span class="number">1</span>，每轮循环balance小于<span class="number">0</span>说明括号无效，数组遍历完balance为<span class="number">0</span>也说明括号无效，否则有效。这里收获了<span class="type">char</span>[]和String互相转换的API:</span><br><span class="line">	String -&gt; <span class="type">char</span>[] : <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">	<span class="type">char</span>[] -&gt; String : <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(charArray);</span><br><span class="line">	StringBuffer -&gt; String : result.toString()   result为StringBuffer类</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>：回溯法。这种方法比较难想，因为只有圆括号<span class="string">&#x27;()&#x27;</span>,添加右括号只需注意，不要在当下超过左括号数目，添加左括号只需不大于n即可。在这种情况下，逻辑变成了，当满足数目条件时才添加括号、递归并回溯，StringBuffer满足长度要求时放入结果。不是最后做判断。</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; ans,StringBuffer cur,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> max)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="23-合并K个升序链表（8月12日）"><a href="#23-合并K个升序链表（8月12日）" class="headerlink" title="23.合并K个升序链表（8月12日）"></a>23.合并K个升序链表（8月12日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法是，以最左边的数组为curValue，并考虑到链表遍历为空的情况下向右更新curValue。<span class="keyword">for</span>向右遍历数组时，通过<span class="keyword">while</span>遍历数组元素，小于curValue的将被添加到链表，维护两个指针，一个指向链表尾部，一个指向上一次更新curValue的位置，这样就能在curValue左右添加链表节点。当然这个思路最后乱掉了，因为不知道如何描述listFinal的前一个节点。</span><br><span class="line"><span class="number">2.</span>我最初的想法是，维护一个和链表长度相同的数组，记录每个输入链表数组的头指针位置，在每轮中取头指针数组中最小的链表节点，并更新该链表的头指针，直到所有头指针都指向<span class="literal">null</span>。这种想法的问题是如何求最小，最简单的思路是利用具有排序功能的集合，在更新节点放入集合时就排号序，这样就能更容易地实现。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>：使用优先队列。用优先队列实现上一想法，定义Status类实现comparable接口，其中compareTo实现如下：</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Status status2)</span> &#123;<span class="keyword">return</span> <span class="built_in">this</span>.val - status2.val;&#125;</span><br><span class="line">将每个链表数组的头指针按<span class="keyword">new</span> <span class="title class_">Status</span>(node.val, node)放入优先队列，queue.poll()后会弹出最小元素，这样将该最小的头指针后移继续放入queue.offer(<span class="keyword">new</span> <span class="title class_">Status</span>(f.ptr.next.val, f.ptr.next))，最后直到优先队列为空。</span><br></pre></td></tr></table></figure>

<h2 id="94、二叉树中序遍历（10月6日）"><a href="#94、二叉树中序遍历（10月6日）" class="headerlink" title="94、二叉树中序遍历（10月6日）"></a>94、二叉树中序遍历（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈实现二叉树中序遍历。这是经典代码，带没想到这么快就忘了呜呜呜</span><br><span class="line">	<span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            cur = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="101、对称二叉树（10月6日）"><a href="#101、对称二叉树（10月6日）" class="headerlink" title="101、对称二叉树（10月6日）"></a>101、对称二叉树（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归。判断二叉树是否对称需要看<span class="number">3</span>点：</span><br><span class="line">	a.左树根节点的值 == 右树根节点的值；</span><br><span class="line">	b.左树的左子树 和 右树的右子树 对称；</span><br><span class="line">	c.左树的右子树 和 右数的左子树 对称；</span><br><span class="line">	其中，b和c两点就是递归点，设计比较左子树和右子树的递归函数即可，此外再考虑特殊情况。</span><br></pre></td></tr></table></figure>

<h2 id="102、二叉树的层序遍历（10月6日）"><a href="#102、二叉树的层序遍历（10月6日）" class="headerlink" title="102、二叉树的层序遍历（10月6日）"></a>102、二叉树的层序遍历（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>，我的想法，队列实现二叉树广度优先遍历。这是经典代码，记住要维护每层的长度len即可</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.pop();</span><br><span class="line">                result.add(node.val);</span><br><span class="line">                len -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            results.add(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="104、二叉树的最大深度（10月6日）"><a href="#104、二叉树的最大深度（10月6日）" class="headerlink" title="104、二叉树的最大深度（10月6日）"></a>104、二叉树的最大深度（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归。递归函数设计如下，每个节点和根节点一样，都向左子树和右子树深度优先遍历，并记录当前深度，当遇到左子树或右子树为空时，通过Math.max更新当前最大深度。</span><br><span class="line">     dfs(TreeNode root,<span class="type">int</span>[] maxDeep,<span class="type">int</span> deep)</span><br></pre></td></tr></table></figure>

<h2 id="105、从前序与中序遍历序列构造二叉树（10月7日）"><a href="#105、从前序与中序遍历序列构造二叉树（10月7日）" class="headerlink" title="105、从前序与中序遍历序列构造二叉树（10月7日）"></a>105、从前序与中序遍历序列构造二叉树（10月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，递归。这道题想起来是很困难的，核心点是，因为题目说明元素不相同，前序遍历首先会访问根节点，再到中序遍历中寻找根节点，则中序遍历根节点左侧为左子树，中序遍历根节点右侧为右子树。如</span><br><span class="line">    前序遍历：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]    中序遍历：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>] -&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="number">0</span> [<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    也可以看到：左子树长度等于 <span class="number">3</span>-<span class="number">0</span>=<span class="number">3</span>，这时候前序遍历左子树索引范围[<span class="number">0</span>+<span class="number">1</span>,<span class="number">0</span>+<span class="number">3</span>]，右子树索引范围为[<span class="number">0</span>+<span class="number">3</span>+<span class="number">1</span>,<span class="number">5</span>]；</span><br><span class="line">    <span class="comment">//表示从ininorder_start开始，不包含inorder_index的串长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">preorder_len</span> <span class="operator">=</span> inorder_index - inorder_start;</span><br><span class="line">    <span class="comment">//后面4个int变量，分别是前序、后续遍历的索引起始范围，都是可以渠道的</span></span><br><span class="line">    root.left = dfs(preorder,hashMap,preorder_start+<span class="number">1</span>,preorder_start+preorder_len,inorder_start,inorder_index-<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">因为preorder_len是根据中序遍历计算的，不懂，下次再做吧</span><br></pre></td></tr></table></figure>

<h2 id="121、买卖股票的最佳时机（10月6日）"><a href="#121、买卖股票的最佳时机（10月6日）" class="headerlink" title="121、买卖股票的最佳时机（10月6日）"></a>121、买卖股票的最佳时机（10月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，左指针。双层<span class="keyword">for</span>循环会超过时间限制，因此维护一个指向当前最小元素的指针。从左到右遍历时，如果当前元素小于左指针指向的元素，就更新左指针；如果当前元素大于左指针指向的元素，就通过Math.max更新最大利润。</span><br></pre></td></tr></table></figure>

<h2 id="136、只出现一次的数字（10月7日）"><a href="#136、只出现一次的数字（10月7日）" class="headerlink" title="136、只出现一次的数字（10月7日）"></a>136、只出现一次的数字（10月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，HashSet。从左到右遍历数组，如果当前数组元素不在hashSet中，将数组元素放入hashSet；存在则移除该数组元素，最终hashSet仅存的元素就是该数字。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，按位异或。因为其他数字都出现两次，^为异或，a^a=<span class="number">0</span>，<span class="number">0</span>^a=a，</span><br><span class="line">    且异或满足交换律和结合律：a^b^c=(a^b)^c=a^(b^c)=(a^c)^b</span><br><span class="line">    设result初值为<span class="number">0</span>，故从左到右遍历，通过result ^= num更新result，结果只剩唯一值。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，按位累加运算。维护一个大小为<span class="number">32</span>的数组bitNums，表示一个整数的每一位，通过bitNums[i] += (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;累加得到所有数字的和，再通过<span class="keyword">for</span>(<span class="number">32</span>)中的result = (result&lt;&lt;<span class="number">1</span>)+bitNums[i]%<span class="number">2</span>;得到那唯一的数字；</span><br><span class="line">    bitNums[i] += (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;    <span class="comment">//仅保留最后一位，因为1的前面位置全为0</span></span><br><span class="line"> 	result = (result&lt;&lt;<span class="number">1</span>)+bitNums[i]%<span class="number">2</span>;    <span class="comment">//不断左移，在末尾加上低位</span></span><br><span class="line"><span class="number">2.</span>HashSet遍历的两种方式：</span><br><span class="line">    a.迭代器</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();  </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">        System.out.println(iterator.next());              </span><br><span class="line">    &#125;		</span><br><span class="line">	b.直接遍历</span><br><span class="line">    <span class="keyword">for</span> (String s:set) &#123;  </span><br><span class="line"> 		System.out.println(s);  </span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<h2 id="34、在排序数组中查找元素的第一个和最后一个位置（10月8日）"><a href="#34、在排序数组中查找元素的第一个和最后一个位置（10月8日）" class="headerlink" title="34、在排序数组中查找元素的第一个和最后一个位置（10月8日）"></a>34、在排序数组中查找元素的第一个和最后一个位置（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>师爷，翻译翻译，什么叫TMD、TMD非递减？</span><br><span class="line">  好嘞，意思是关键字递增序排列，但是并非单调递增（因为有重复的关键字）从小到大或者允许中间有相等的情形。</span><br><span class="line"><span class="number">2.</span>我的想法，二分查找。由于是递增但是非单调的序列，故能使用二分查找。首先用二分查找确定nums中等于target的一个数的位置，再以该数为起点，确定相同值的最小索引和最大索引。本题从二分查找出发很好想，下面是二分查找经典代码（left、right指针）：</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">targetIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            targetIndex = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="49、字母异位词分组（10月8日）"><a href="#49、字母异位词分组（10月8日）" class="headerlink" title="49、字母异位词分组（10月8日）"></a>49、字母异位词分组（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashMap。这道题以前做过，又忘了。核心是维护一个HashMap&lt;String,List&lt;String&gt;&gt;，key为Arrays.sort(strArray)排序好的字符串，这样“tea”、“ate”、“eat”的key都为“aet”，就能放到value的列表中储存。</span><br></pre></td></tr></table></figure>

<h2 id="53、最大子数组和（10月8日）"><a href="#53、最大子数组和（10月8日）" class="headerlink" title="53、最大子数组和（10月8日）"></a>53、最大子数组和（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>子序列可以不连续，连续必然是子序列。</span><br><span class="line"><span class="number">2.</span>我的想法，滑动窗口。使用双层<span class="keyword">for</span>循环，外层确定窗口大小len，内层从左到右遍历，并通过Math.max更新窗口的最大sum。但是，这会导致O(n^<span class="number">2</span>)的复杂度，在最后的测试用例上出现超时。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，动态规划。动态规划的关键在于：如何定义状态？（如何定义子问题？）</span><br><span class="line">题解中的思路转变是这样，子问题这样定义：[-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">    经过-<span class="number">2</span>的连续子数组的最大和是多少？</span><br><span class="line">    经过<span class="number">1</span>的连续子数组的最大和是多少？  ...</span><br><span class="line">但是这样定义，子问题之间很难看出联系，这说明子问题的描述不够准确，转换为：</span><br><span class="line">    以-<span class="number">2</span>结尾的连续子数组的最大和是多少？</span><br><span class="line">    以<span class="number">1</span>结尾的连续子数组的最大和是多少？  ...</span><br><span class="line">这时候子问题就产生了联系，状态转移方程如下：</span><br><span class="line">	当dp[i-<span class="number">1</span>]&lt;<span class="number">0</span>时，dp[i]=nums[i];</span><br><span class="line">	当dp[i-<span class="number">1</span>]&gt;<span class="number">0</span>时，dp[i] = dp[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">从左到右求解状态转移方程，并找出dp[i]中的最大值，即可解本题。</span><br><span class="line"><span class="number">3.</span>第一次正面认识动态规划，记录两点收获：</span><br><span class="line">    a.动态规划中状态的定义和题目中问题的定义并不相等，求解完状态再分析才能解出题目；</span><br><span class="line">    b.动态规划中子问题（状态）的定义需要有无后效性，后面求解的子问题不再影响前面解出的结果；</span><br></pre></td></tr></table></figure>

<h2 id="124、二叉树的最大路径和（10月8日）"><a href="#124、二叉树的最大路径和（10月8日）" class="headerlink" title="124、二叉树的最大路径和（10月8日）"></a>124、二叉树的最大路径和（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，深度优先搜索。这道题以前做得很痛苦，这次看到了关键的提示root.val+max(left,right)，还是比较轻松做出来了。对于每个节点，它负责的是：</span><br><span class="line">	a.在该节点更新最大值maxValue，考虑：root.val，root.val+left，root.val+right，root.val+left+right四种情况，为了使代码更加优雅，可以用<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Math.max(<span class="number">0</span>,dfs(root.left,maxSumLeft));</span><br><span class="line">	b。向上层返回root.val+max(left,right)；</span><br></pre></td></tr></table></figure>

<h2 id="300、最长上升子序列（10月8日）"><a href="#300、最长上升子序列（10月8日）" class="headerlink" title="300、最长上升子序列（10月8日）"></a>300、最长上升子序列（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。感觉这种子数组、子序列问题，就要将子问题设置为：</span><br><span class="line">	<span class="comment">//状态：以i结尾的最长递增子序列</span></span><br><span class="line">用双层<span class="keyword">for</span>循环做，外层确定当前状态，内层确定[<span class="number">0</span>,当前状态-<span class="number">1</span>]对当前状态的影响，状态转移方程为：</span><br><span class="line">     dp[i] = max(dp[<span class="number">0</span>],dp[<span class="number">1</span>],...,dp[i-<span class="number">1</span>])+<span class="number">1</span>;  <span class="comment">//其中，max中的dp[j]需满足nums[当前]&gt;nums[j]</span></span><br><span class="line">找到最大的dp即为题解。</span><br></pre></td></tr></table></figure>

<h2 id="347、前K个高频元素（10月8日）"><a href="#347、前K个高频元素（10月8日）" class="headerlink" title="347、前K个高频元素（10月8日）"></a>347、前K个高频元素（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>PriorityQueue默认是最小堆，即Comparator为(e1,e2)-&gt;&#123;e1-e2&#125;，元素按照升序排列；</span><br><span class="line">    如果要降序排列，则比较器的顺序为(e1,e2)-&gt;&#123;e2-e1&#125;，降序排列队列头部为最大值。</span><br><span class="line"><span class="number">2.</span>我的想法，hashMap+PriorityQueue。维护一个hashMap&lt;数字，次数&gt;，将hashMap的键值对放入PriorityQueue根据值维护的最小堆，注意最小堆大小超过k时，要先放入新键值，再剔除堆顶。</span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;(e1.getValue()-e2.getValue()));</span><br></pre></td></tr></table></figure>

<h2 id="32、最长有效括号（10月8日）"><a href="#32、最长有效括号（10月8日）" class="headerlink" title="32、最长有效括号（10月8日）"></a>32、最长有效括号（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。设置子问题为，以当前字符结尾的有小括号子串长度。</span><br><span class="line">	当前字符为<span class="string">&#x27;(&#x27;</span>时，dp[i]=<span class="number">0</span>；</span><br><span class="line">	当前字符为<span class="string">&#x27;)&#x27;</span>时，</span><br><span class="line">    	a.如果前一字符为<span class="string">&#x27;(&#x27;</span>则将dp[i]初值设为<span class="number">2</span>，并循环累加<span class="number">2</span>个字符前有效<span class="string">&#x27;)&#x27;</span>的dp；</span><br><span class="line">    	b.如果前一字符为<span class="string">&#x27;)&#x27;</span>，则dp[i] = dp[i-<span class="number">1</span>]+<span class="number">2</span>；如果(i-<span class="number">1</span>)的串再加补全<span class="string">&#x27;(&#x27;</span>前还是有效<span class="string">&#x27;)&#x27;</span>,则：</span><br><span class="line">    		dp[i] = dp[i-<span class="number">1</span>]+<span class="number">2</span>+dp[i-<span class="number">2</span>-dp[i-<span class="number">1</span>]];</span><br><span class="line">    但是，没有考虑完整情况。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，动态规划。本以为又会耗费很多时间，一看题解发现和我考虑的情况一致，就是我外加了上述的循环累加，修改为<span class="keyword">if</span>即通过。</span><br><span class="line">    Q：为什么循环累加不行？</span><br><span class="line">    A：上面b情况，考虑的是<span class="string">&quot;...))&quot;</span>，靠前面的<span class="string">&#x27;(&#x27;</span>补全当前<span class="string">&#x27;)&#x27;</span>后，如果此前还位有效<span class="string">&#x27;)&#x27;</span>，则应该再加上其dp；</span><br><span class="line">       上面a情况，考虑的是<span class="string">&quot;...()&quot;</span>，写<span class="keyword">while</span>循环考虑的是<span class="string">&quot;...)()&quot;</span>，其中前面的<span class="string">&#x27;)&#x27;</span>有效，应该不断向前循环累加有效<span class="string">&#x27;)&#x27;</span>的dp，但这是不对的，不必要再循环，更前面的有效<span class="string">&#x27;)&#x27;</span>已经在先遇到的<span class="string">&#x27;)&#x27;</span>dp所包含。</span><br><span class="line">    总而言之，非常非常接近答案，但是长时间的思考愈发理不清前面的状态，甚至可以向，dp中本来就不应该有<span class="keyword">while</span>。</span><br><span class="line">    简介，前面为(，再考虑一层；前面为)，再考虑两层。</span><br></pre></td></tr></table></figure>

<h2 id="206、反转链表（10月8日）"><a href="#206、反转链表（10月8日）" class="headerlink" title="206、反转链表（10月8日）"></a>206、反转链表（10月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，迭代法三指针。反转链表迭代法，就是要维护pre，cur和after三枚指针，最开始将cur指向head.next，pre指向head，pre.next指向<span class="literal">null</span>，通过以下方式更新链表：</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">after</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = after;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">这种方式的坏处是，如果head指向<span class="literal">null</span>，就需要额外的判断，所以初值设置应该为：</span><br><span class="line">    cur指向head，pre指向<span class="literal">null</span>。</span><br></pre></td></tr></table></figure>

<h2 id="114、二叉树展开为链表（10月9日）"><a href="#114、二叉树展开为链表（10月9日）" class="headerlink" title="114、二叉树展开为链表（10月9日）"></a>114、二叉树展开为链表（10月9日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>经典的栈实现二叉树前序遍历</span><br><span class="line">    Deque&lt;TreeNode&gt; stack= <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();	</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//访问cur.val</span></span><br><span class="line">            list.add(cur);</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>我的想法，二叉树前序遍历。经典的二叉树前序遍历代码，不断遍历left指针，遇到<span class="literal">null</span>时弹栈，获取最近的right指针，再进行相同操作。没啥可说的，list中是前序遍历结果，通过perv、curr指针从<span class="number">1</span>遍历完即可。不用考虑末尾的双<span class="literal">null</span>，因为在原链表该节点也是双<span class="literal">null</span>。这样空间复杂度是O(n)，不是O(<span class="number">1</span>)。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>，空间复杂度为O(<span class="number">1</span>)的方法。涉及到指针这种引用类型，很多转引用、存储后的操作是不能保护值的，这在做这些题的时候要注意。题解的思想很简单，就是通过cur的left指针不为空时，就尽可能沿着right方向遍历cur.left节点，并将cur.right接在cur.left.right的最底层。因为对左子树来说，也是最右边的节点被最后访问，把root节点的右子树接在左子树最右边的底层是合理的。</span><br></pre></td></tr></table></figure>

<h2 id="31、下一个排列（10月10日）"><a href="#31、下一个排列（10月10日）" class="headerlink" title="31、下一个排列（10月10日）"></a>31、下一个排列（10月10日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，两次遍历。寻找下一个排列，本质是从后向前扫描时，要找到顺序对满足a[i]&lt;a[i+<span class="number">1</span>]，这时候从[i+<span class="number">1</span>,len-<span class="number">1</span>]范围内从后向前找到a[j]满足a[j]&gt;a[i]，因为此时[i+<span class="number">1</span>,len-<span class="number">1</span>]都不存在顺序对，故a[j]恰比a[i]大。替换a[i]和a[j]后，将[i+<span class="number">1</span>,len-<span class="number">1</span>]按顺序排列。</span><br><span class="line">    如“<span class="number">652341</span>”，第一个顺序对是“<span class="number">34</span>”，a[i]=<span class="number">3</span>，a[j]=<span class="number">4</span>，此时下一个排列是“<span class="number">652413</span>”，前面的<span class="number">2</span>不会替换<span class="number">3</span>，因为高位压阵，恰下一个；</span><br><span class="line">    如“<span class="number">652431</span>”，第一个顺序对是“<span class="number">24</span>”，a[i]=<span class="number">2</span>，a[j]=<span class="number">3</span>，此时下一个排列是“<span class="number">653124</span>”；</span><br><span class="line">    （没啥好说的，记住从后往前找顺序对，替换后在排列即可。）</span><br><span class="line"><span class="number">2.</span>实现过程，由于i+<span class="number">1</span>往后都是倒序排列，要实现顺序排列只需依次交换两端元素:</span><br><span class="line">	<span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        swap(nums,left,right);</span><br><span class="line">        left++;right--;</span><br><span class="line">    &#125;</span><br><span class="line">另外如果输入为“<span class="number">654321</span>”这种极端情况，第一次遍历结束必然i为-<span class="number">1</span>，判断此情况后，直接reverse(nums,i+<span class="number">1</span>);并返回即可。</span><br></pre></td></tr></table></figure>

<h2 id="33、搜索旋转排序数组（10月10日）"><a href="#33、搜索旋转排序数组（10月10日）" class="headerlink" title="33、搜索旋转排序数组（10月10日）"></a>33、搜索旋转排序数组（10月10日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，本来以为题意是，寻找旋转前数组中目标值的索引，先遍历找到旋转点i后，然后根据nums[<span class="number">0</span>]、nums[i]和target的大小关系，再到两段顺序序列中找到目标值索引，并根据长度恢复出旋转前索引。后来，发现题解好像就是找旋转后的索引，那一轮<span class="keyword">for</span>就搞定。但是，这时候复杂度为O(n)，不满足题意。</span><br><span class="line"><span class="number">2.</span>我的想法，二分查找。根据target和nums[<span class="number">0</span>]的关系，可以知道target出现在前一段序列or后一段序列。</span><br><span class="line">    如果出现在前一段序列，二分查找时mid&gt;=nums[<span class="number">0</span>]，说明mid也落入前一段，这时候可以按一般二分查找移动指针，否则只移动right指针到mid-<span class="number">1</span>；</span><br><span class="line">    如果出现在后一段序列，二分查找时mid&lt;nums[<span class="number">0</span>]（注意不带等于），说明mid也落入后一段，这时候可以按一般二分查找移动指针，否则只移动left指针到mid+<span class="number">1</span>；</span><br><span class="line">    （关键词，根据target和nums[<span class="number">0</span>]的关系进入不同的二分查找策略）</span><br></pre></td></tr></table></figure>

<h2 id="39、组合总和（10月10日）"><a href="#39、组合总和（10月10日）" class="headerlink" title="39、组合总和（10月10日）"></a>39、组合总和（10月10日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯。定义dfs函数如下，当sum等于目标值target时，将<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(result)添加到results中。但是，这样做得问题是会产生重复，如[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]，[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]，并且想不到去重策略。</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target,<span class="type">int</span> deep,<span class="type">int</span> sum,List&lt;Integer&gt; result,List&lt;List&lt;Integer&gt;&gt; results)</span></span><br><span class="line"><span class="number">2.</span>没必要记录深度，可以在返回时用combine.remove(combine.size() - <span class="number">1</span>)清除效果。</span><br><span class="line"><span class="number">3.</span>重复的原因在，没有按照一个方向选取元素，如[<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>]，假设取完元素<span class="number">2</span>后再取元素<span class="number">3</span>，则不能折回来再取元素<span class="number">2</span>，这时候就要记录遍历的index，遇到每个元素应该选择本元素（index不增）或者跳过（index+<span class="number">1</span>）。这时多一种最终判断，就是：</span><br><span class="line">    <span class="keyword">if</span>(index==candidates.length) <span class="keyword">return</span>; 	<span class="comment">//否则会栈溢出</span></span><br><span class="line">	(关键词，按顺序加索引，不加深度)</span><br></pre></td></tr></table></figure>

<h2 id="40、接雨水（10月11日）"><a href="#40、接雨水（10月11日）" class="headerlink" title="40、接雨水（10月11日）"></a>40、接雨水（10月11日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，来自评论区的总结，找左右两边最大值中的小者，减去本身高度。这时候在[<span class="number">1</span>,heigh.length-<span class="number">1</span>]范围内从左到右遍历，遍历到heigh[j]时，寻找它左侧、右侧最大值maxLeft、maxRight，如果都小于等于它本身则result+<span class="number">0</span>，否则result+min&#123;maxLeft,maxRight&#125;-heigh[j]。时间复杂度O(n^<span class="number">2</span>)。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，动态规划。上一种解法中，时间复杂度为O(n^<span class="number">2</span>)的原因，在于需要搜索heigh[j]左右两侧的最大值，如果已知两边最值，时间复杂度就能降到O(n)。可以维护两个数组leftMax[]、rightMax[]记录每个j两侧最值，先通过从前向后、从后向前扫描初始化这两个数组。再从左向右遍历累加结果。</span><br><span class="line"><span class="number">3.</span>思路<span class="number">3</span>，双指针。进一步观察发现，并不需要明确知道最大值，维护两个指针left、right，left从<span class="number">0</span>开始向右移动，right从height.length - <span class="number">1</span>开始向左移动，只要：</span><br><span class="line">    a.height[left]&lt;height[right]，则必有 leftMax&lt;rightMax，此时移动left指针</span><br><span class="line">    b.height[left]≥height[right]，则必有 leftMax≥rightMax，此时移动right指针</span><br><span class="line">    这样每次只移动更小处的指针。</span><br></pre></td></tr></table></figure>

<h2 id="84、柱状图中的最大矩形（10月11日）"><a href="#84、柱状图中的最大矩形（10月11日）" class="headerlink" title="84、柱状图中的最大矩形（10月11日）"></a>84、柱状图中的最大矩形（10月11日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>来自评论区的总结，题解讲得有点复杂，不利于理解。。。说白了，这题考的基础模型其实就是：在一维数组中对每一个数找到第一个比自己小的元素。这类“在一维数组中找第一个满足某种条件的数”的场景就是典型的单调栈应用场景。</span><br><span class="line"><span class="number">2.</span>第一次遇见单调栈，思路原理是，如果新元素小于栈顶元素，就一直弹栈，直到新元素大于栈顶元素：</span><br><span class="line">	此时，栈顶元素是新元素左边，比新元素小的第一个元素；</span><br><span class="line">	每次弹栈时，新元素是栈顶元素右边，比栈顶元素小的第一个元素；</span><br><span class="line">这样经过一次遍历，就能找到数组中每个元素左右两边第一个比它小的元素，当然还是更关注左边。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>思路<span class="number">1</span>，单调栈。目标是计算每个高度限制的最大矩形面积，从左到右遍历高度：</span><br><span class="line">	<span class="number">1.</span>假如新元素大于栈顶元素，则直接压栈，不是该高度的出场日；</span><br><span class="line">	<span class="number">2.</span>假如新元素小于栈顶元素，就将栈顶元素出栈，对于这个出栈的元素A而言，</span><br><span class="line">		a.新元素是A右边，比A小的第一个元素；</span><br><span class="line">		b.新的栈顶元素，是A左边比A小的第一个元素；</span><br><span class="line">	这样就得到了当前出栈高度左右两边的界限，从而可知当前出栈高度为上限的最大矩形面积。</span><br><span class="line">(简言之，所有面积都是出栈时候求的，因为只有出栈的元素，才会有左边界和右边界)</span><br><span class="line"><span class="number">4.</span>这道题解法的巧妙之处在于创建新数组new_heights，在原始数组左右两端各补一个<span class="number">0</span>。</span><br><span class="line">	 <span class="type">int</span>[] new_heights = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; heights.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">     	new_heights[i] = heights[i - <span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">这样做的好处是，能够省去很麻烦的边界判断：</span><br><span class="line">	a.在前端补<span class="number">0</span>，使得第<span class="number">0</span>个元素有了左边界；</span><br><span class="line">	b.在后端补<span class="number">0</span>，能避免由于输入数组是单调增，导致一直在压栈，只有出栈时有边界才会计算面积。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>本题是困难题，第一次接触单调栈，简直疯狂掉头发，希望能记住吧，弹栈有边界才更新面积。。。</span><br></pre></td></tr></table></figure>

<h2 id="70、爬楼梯（10月11日）"><a href="#70、爬楼梯（10月11日）" class="headerlink" title="70、爬楼梯（10月11日）"></a>70、爬楼梯（10月11日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>本题只需记住f(x)=f(x−<span class="number">1</span>)+f(x−<span class="number">2</span>)，因为对于这一阶台阶来说，可能是跨越一步上来的，也可能是跨越两步过来的：</span><br><span class="line">	跨越一步上来时，f(x)和f(x-<span class="number">1</span>)的次数相同；跨越两步上来时，f(x)和f(x-<span class="number">2</span>)的次数相同，因此f(x)=f(x−<span class="number">1</span>)+f(x−<span class="number">2</span>)；</span><br><span class="line"><span class="number">2.</span>没啥说的，baby请你记住f(x)=f(x−<span class="number">1</span>)+f(x−<span class="number">2</span>)这个公式。爬楼梯啊爬楼梯~~~</span><br></pre></td></tr></table></figure>

<h2 id="46、全排列（10月17日）"><a href="#46、全排列（10月17日）" class="headerlink" title="46、全排列（10月17日）"></a>46、全排列（10月17日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题前面做过，一周没有刷题了手很生，看了题目只知道用回溯。实则全排列问题一定涉及交换，需要写swap辅助函数，此时本题就变简单了，只需维护index到达数组长度时放入结果，不到数组长度时index和后面每一个位置交换。</span><br></pre></td></tr></table></figure>

<h2 id="56、合并区间（10月17日）"><a href="#56、合并区间（10月17日）" class="headerlink" title="56、合并区间（10月17日）"></a>56、合并区间（10月17日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题前面也做过，甚至今天就用它优化了实验方案，但是又忘了该咋排序。解题逻辑是，双<span class="keyword">while</span>循环，每轮外围<span class="keyword">while</span>循环维护一个<span class="type">int</span>[] tmpResult，将其赋值为start区间，当下一区间和tmp区间产生交互时，将tmp区间右端更新为两者右端的最大值，并继续向右递进<span class="keyword">while</span>循环，直到不产生交互，将tmp区间放入结果，并从当前区间开展新一轮外层<span class="keyword">while</span>。</span><br><span class="line">    Arrays.sort(intervals,(<span class="type">int</span>[] e1,<span class="type">int</span>[] e2)-&gt;e1[<span class="number">0</span>]-e2[<span class="number">0</span>]); <span class="comment">//这里需要注明类型</span></span><br></pre></td></tr></table></figure>

<h2 id="55、跳跃游戏（10月18日）"><a href="#55、跳跃游戏（10月18日）" class="headerlink" title="55、跳跃游戏（10月18日）"></a>55、跳跃游戏（10月18日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，贪心算法。贪心算法(又称贪婪算法)是指,在对问题求解时,总是做出在当前看来是最好的选择。这道题需要理解题意，对于序列[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]而言，第<span class="number">0</span>个位置跨度为<span class="number">3</span>，能到第<span class="number">3</span>个位置，不会更远。因此从左到右遍历，每次更新能到达的最远位置，如果最远位置大于（nums.length - <span class="number">1</span>）,则为True；遍历到末尾，则为<span class="literal">false</span>。注意只有遍历i&lt;=maxValue时，才去更新maxValue。</span><br></pre></td></tr></table></figure>

<h2 id="78、子集（10月18日）"><a href="#78、子集（10月18日）" class="headerlink" title="78、子集（10月18日）"></a>78、子集（10月18日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，回溯。这道题可能做过，做出来还是比较容易。思路就是，维护一个表示深度的变量index，当index没到达nums.length时，可以选择result不添加index位置的元素进行回溯，或者添加index位置的元素进行回溯，回溯结束后从result删除该元素。</span><br></pre></td></tr></table></figure>

<h2 id="96、不同的二叉搜索树（10月18日）"><a href="#96、不同的二叉搜索树（10月18日）" class="headerlink" title="96、不同的二叉搜索树（10月18日）"></a>96、不同的二叉搜索树（10月18日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这道题没啥说的，确实没思路。没写</span><br></pre></td></tr></table></figure>

<h2 id="98、验证二叉搜索树（10月18日）"><a href="#98、验证二叉搜索树（10月18日）" class="headerlink" title="98、验证二叉搜索树（10月18日）"></a>98、验证二叉搜索树（10月18日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题更新了我对二叉搜索树的认识，它不是单纯的根节点大于左子节点，小于右子节点，而且根节点要大于左子树的所有节点，小于右子树的所有节点。这样，中序遍历二叉搜索树时，一定得到单调升的结果。比如[<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">	<span class="number">5</span> - (<span class="number">4</span> <span class="number">6</span>)- ((<span class="literal">null</span> <span class="literal">null</span>) (<span class="number">3</span> <span class="number">7</span>))  <span class="comment">//其中右子树的节点3小于根节点5，所以不是二叉搜索树</span></span><br><span class="line">	很自然想到，对于压栈的每个节点，要判断是否左节点小于它，再走到左节点；对于弹栈的每个节点，要判断是否右节点大于它，再走到右节点；此外，还要考虑到根节点<span class="number">5</span>大于很久以后的右节点<span class="number">3</span>这种情况，就很复杂。</span><br><span class="line">    当知道二叉树的中序遍历是单调升后，就可以省去以上判断，维护一个pre节点记录上次遍历到的有值节点，然后只判断是否单调升。</span><br><span class="line"> 	此外，由于存在特殊测试用例，需要<span class="type">double</span> <span class="variable">preValue</span> <span class="operator">=</span> -Double.MAX_VALUE。</span><br></pre></td></tr></table></figure>

<h2 id="141、环形链表（10月18日）"><a href="#141、环形链表（10月18日）" class="headerlink" title="141、环形链表（10月18日）"></a>141、环形链表（10月18日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，快慢指针。这道题以前做过，稍微有点忘了，解法有两种：哈希表、快慢指针。用快慢指针做时，<span class="keyword">while</span>(slow!=fast)内部只需要在fast==<span class="literal">null</span>||fast.next==<span class="literal">null</span>为<span class="literal">true</span>时返回<span class="literal">false</span>，这样能保证fast.next.next能被访问到，那slow指针更能被访问到。</span><br></pre></td></tr></table></figure>

<h2 id="139、单词拆分（10月20日）"><a href="#139、单词拆分（10月20日）" class="headerlink" title="139、单词拆分（10月20日）"></a>139、单词拆分（10月20日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>最近做题陷入了怪圈，必须瞟眼答案关键字，有概率恍然大悟，然后遇到复杂的边界条件，总是差些火候写对，最终还是得看完整答案修修补补。比如这道题，我有经验设置<span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()+<span class="number">1</span>]; ，因为我知道<span class="number">0</span>位置不好对付就整体右移，但这时候边界条件又把我整怕了唉~</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，动态规划。设置子问题dp[i]表示前i个字符是否在wordDict中，从左到右遍历i，再从左到i遍历j，如果dp[j]为真且剩下到i的单词在wordDict中，则dp[i]为<span class="literal">true</span>。</span><br></pre></td></tr></table></figure>

<h2 id="142、环形链表Ⅱ（10月20日）"><a href="#142、环形链表Ⅱ（10月20日）" class="headerlink" title="142、环形链表Ⅱ（10月20日）"></a>142、环形链表Ⅱ（10月20日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashSet。从头开始遍历链表，将链表节点放入hashSet，如果hashSet中已经包含该节点，说明该节点是环的起始节点。</span><br><span class="line"><span class="number">2.</span>我的想法，快慢指针。快指针和慢指针相遇时，设从头到环入口的距离为a，环的周长为b，相遇位置与环入口距离为c，则快指针走过的路径长度为a+Xb+c，慢指针走过的路径长度为a+Yb+c，快慢指针的路径长度差值为b的整数倍。</span><br><span class="line">	a+Xb+c = <span class="number">2</span>*(a+Yb+c)  =&gt;  a+c = (X-2Y)*b   <span class="comment">//环外的长度a + 未走满的部分b = 环周长的整数倍</span></span><br><span class="line">  求到这个有点闷，毕竟不知道确切多少倍，就无法得到周长。实际上，如果此时还有一个慢指针从起始点出发，他走距离a到达环入口，同时本慢指针从该点继续移动，也走距离a就能到达环入口，故这两个慢指针相遇点为环入口。</span><br><span class="line">    注意，写代码时外围 <span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)，而不是<span class="keyword">while</span>(slow!=fast)，后者初始化时给slow、fast都赋值head不好做判断，且初始化为head.next、head.next.next会陷入无穷循环。</span><br></pre></td></tr></table></figure>

<h2 id="234、回文链表（10月20日）"><a href="#234、回文链表（10月20日）" class="headerlink" title="234、回文链表（10月20日）"></a>234、回文链表（10月20日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，快慢指针。先快慢指针找到链表中间，再将后半部分链表反转，再将前半部分和反转后的后半部分进行比较。</span><br><span class="line">    注意，快慢指针找链表中间需要dummy节点，这样能保证不管链表是单数还是双数，下一节点都是后半部分的起始节点。</span><br></pre></td></tr></table></figure>

<h2 id="283、移动零（10月21日）"><a href="#283、移动零（10月21日）" class="headerlink" title="283、移动零（10月21日）"></a>283、移动零（10月21日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，双指针。再次败北，麻了不说了。思路很简单，就是left指针指向已经处理好的序列，即最后一个非零树，右边指针一直向右遍历，如果该位置非零，则交换left、right指针指向的元素。</span><br></pre></td></tr></table></figure>

<h2 id="148、排序链表（10月21日）"><a href="#148、排序链表（10月21日）" class="headerlink" title="148、排序链表（10月21日）"></a>148、排序链表（10月21日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，优先队列。将链表节点放入最小堆priorityQueue，依次出堆后形成新链表。</span><br><span class="line">	 PriorityQueue&lt;ListNode&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;(e1.val-e2.val));</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，归并排序。首先记住归并排序不是二分查找，是从左到右均分为长度<span class="number">2</span>的小段，排序后合并为长度<span class="number">4</span>的小段，重复此操作。本题的归并实现，是先用快慢指针找到链表中点，将前后两段排序后，再通过依次比较两个链表节点大小从而连接起来。</span><br><span class="line">    注意,这里递归是直接调用原函数sortList，需要在原函数判断<span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"><span class="comment">//没啥可说的，第二次用这个思路做，算是重写的时候快了点吧。</span></span><br></pre></td></tr></table></figure>

<h2 id="160、相交链表（10月21日）"><a href="#160、相交链表（10月21日）" class="headerlink" title="160、相交链表（10月21日）"></a>160、相交链表（10月21日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashSet。将链表headA的所有节点放入hashSet，遍历headB的节点，如果某节点在hashSet中已经存在，就返回该节点；如果循环结束，就返回<span class="literal">null</span>；</span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，双指针。设链表headA非公共部分为a，链表headB非公共部分为b，链表公共部分为c，如果两个速度为<span class="number">1</span>的指针分别从headA、headB出发，则有：</span><br><span class="line">    a+c+b == b+c+a  <span class="comment">//即只有某指针走到末尾就切换赛道，必然会在下次c的起始节点相遇</span></span><br><span class="line">如果headA和headB不相交</span><br><span class="line">    a+<span class="number">0</span>+b = b+<span class="number">0</span>+a  <span class="comment">//即必然会在null相遇</span></span><br><span class="line"><span class="number">3.</span>这道题思路很多，归根结底是想解决掉链表headA和headB间的长度差值。</span><br></pre></td></tr></table></figure>

<h2 id="146、LRU缓存（10月22日）"><a href="#146、LRU缓存（10月22日）" class="headerlink" title="146、LRU缓存（10月22日）"></a>146、LRU缓存（10月22日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的思路，双项链表+hashMap。这道题需要维护双向链表节点head和tail，在初始化时连接两个节点如下。接下来不管put还是get操作，不能移动head和tail节点。</span><br><span class="line">    比如添加新节点到链表头部时，将新节点置为head，这是不对的，这会导致原始head节点（值为<span class="number">0</span>）被移动到链表中央。</span><br><span class="line">	head.next = tail;</span><br><span class="line">	tail.prev = head;</span><br><span class="line">当get或put操作一个已经存在的键时，需要从head.next开始遍历，直到tail结束寻找val为该键的链表节点，代码如下，这也是上面不能移动head和tail节点的原因：</span><br><span class="line">    <span class="type">DoubleNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span>(temp!=tail)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.val==key)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">此外，注意删除双向链表节点时指针和真实引用的区别即可。</span><br><span class="line">	第二次做这道题，一直没敢做，以为还是做不出来，没想到调试着思路还挺流畅，再接再厉！！</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，双向链表+hashMap。官方题解中，hashMap定义如下：</span><br><span class="line">    Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">双向链表中存储<span class="type">int</span> key，<span class="type">int</span> value，很容易理解，能够通过键直接确定节点位置，从而省去<span class="keyword">while</span>循环。</span><br></pre></td></tr></table></figure>

<h2 id="169、多数元素（10月23日）"><a href="#169、多数元素（10月23日）" class="headerlink" title="169、多数元素（10月23日）"></a>169、多数元素（10月23日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashMap。维护一个hashMap记录每个数字的出现次数，最后遍历hashMap返回出现次数超过n/<span class="number">2</span>的数字。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，排序。由于只有一个多数元素，且出现次数超过n/<span class="number">2</span>，所以排序好后数组中间位置元素一定是该元素。</span><br><span class="line"><span class="number">3.</span>写了下冒泡排序，第二行<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length-<span class="number">1</span>-i;j++)，但显然这种数据不适合冒泡，比Arrays.sort(nums);慢太多。</span><br></pre></td></tr></table></figure>

<h2 id="287、寻找重复数（10月23日）"><a href="#287、寻找重复数（10月23日）" class="headerlink" title="287、寻找重复数（10月23日）"></a>287、寻找重复数（10月23日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashSet。维护一个hashSet存储已经访问过的数字，如果某数字再次出现，则hashSet中存在，返回该数字。</span><br><span class="line"><span class="comment">//这道题有二分查找、快慢指针等方法，且题目要求了O(1)的时间复杂度没办法，就这样吧思路有点特殊，不想深入。</span></span><br></pre></td></tr></table></figure>

<h2 id="208、实现前缀树（10月24日）"><a href="#208、实现前缀树（10月24日）" class="headerlink" title="208、实现前缀树（10月24日）"></a>208、实现前缀树（10月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，前缀树。这是第二次做这道题，本来以为TrieNode中维护“children = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">26</span>];”，但如何指向下一节点却犯了难，实则TrieNode定义代码如下，在children节点中的isWord字段记录其是否为单词，其他操作顺水推舟：</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> TrieNode[] children;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> isWord;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>前缀树主要用来实现字符串查找，解题的步骤有两步，第一步是创建前缀树，第二步是在前缀树中查找。这种题，需要熟悉TrieNode的定义、创建前缀树经典代码这两步惯性操作。</span><br></pre></td></tr></table></figure>

<h2 id="215、数组中第K个最大元素（10月24日）"><a href="#215、数组中第K个最大元素（10月24日）" class="headerlink" title="215、数组中第K个最大元素（10月24日）"></a>215、数组中第K个最大元素（10月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，最小堆。看到题目中第K个最大元素，就知道反过来要用最小堆，当堆大小超过K时，从堆顶弹出元素，直到所有元素经过堆处理，此时堆顶元素恰好为第K个最大元素。</span><br><span class="line">	PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((e1,e2)-&gt;e1-e2);</span><br><span class="line"><span class="number">2.</span>我的想法，快速排序。手写快速排序是一个基本题目，需要注意以下函数配合：</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end&gt;start)&#123;</span><br><span class="line">            <span class="comment">//调用getRandom，在mid两侧递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(end-start+<span class="number">1</span>)+start;</span><br><span class="line">       		<span class="comment">//修改nums内容，将范围内的数组，根据比randomNum的大小放在其左右两边</span></span><br><span class="line">       		<span class="comment">//方法是维护small指针，指向最后一个比randomNum小的元素，因此从start-1开始</span></span><br><span class="line">   这道题还是看了以前的笔记，因为快排还是容易忘，特点就是在随机数两边分治递归。幸运的是看着笔记还是一下做出来了，本题的方法是快速排序+二分查找。只是二分查找位置不再是<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        而是<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> getRandom(nums,left,right);</span><br></pre></td></tr></table></figure>

<h2 id="560、和为K的子数组（10月24日）"><a href="#560、和为K的子数组（10月24日）" class="headerlink" title="560、和为K的子数组（10月24日）"></a>560、和为K的子数组（10月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>做了半小时滑动窗口，以为胜利在望，发现数据里有负数，歪江难受得雅痞。</span><br><span class="line"><span class="number">2.</span>我的想法，暴力破解。两层<span class="keyword">for</span>循环击败<span class="number">5</span>%：</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;nums.length;j++)&#123;</span><br><span class="line"><span class="number">3.</span>思路<span class="number">2</span>，前缀和+哈希表优化。上面的方法时间复杂度是O(n^<span class="number">2</span>)，但我们其实不需要通过遍历求每个数组的和，而是能通过前缀和计算出任意数组的和，假设pre[i]表示[<span class="number">0</span>,i]中所有数字的和，pre[j]表示[<span class="number">0</span>,j]中所有数字的和(i&lt;j)，那么</span><br><span class="line">    数组[i+<span class="number">1</span>,j] = pre[j] - pre[i];       <span class="comment">//pre[j] - pre[i] = k</span></span><br><span class="line">    这时候只要把前缀和都放到hashMap，每获得一个新pre，从hashMap中查找(pre-k)的键值。</span><br><span class="line">    注意，最开始时要“ hashMap.put(<span class="number">0</span>,<span class="number">1</span>); ”，因为<span class="number">0</span>位置以前的前缀和为<span class="number">0</span>也算一种情况，即该子数组从<span class="number">0</span>开始。</span><br><span class="line"><span class="number">4.</span>今天这几道题写得都挺好的，主要是以前的一些经典代码，不过还是需要提示关键逻辑才能再写出来。</span><br></pre></td></tr></table></figure>

<h2 id="394、字符串解码（10月25日）"><a href="#394、字符串解码（10月25日）" class="headerlink" title="394、字符串解码（10月25日）"></a>394、字符串解码（10月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归。这道题主要考察字符串相关api，以及递归的逻辑。我将dfs函数设计如下：</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[] charArray,<span class="type">int</span> start,StringBuilder builder)</span></span><br><span class="line">对于一段序列：</span><br><span class="line">	a.如果是小写字母，直接加入builder；</span><br><span class="line">	b.如果是数字，将其后的几个数字一起加入builder2，并将builder2转换为数字；dfs(charArray,i+<span class="number">1</span>,builder1);递归处理<span class="string">&#x27;[&#x27;</span>后面的字符串，并将builder1扩展n倍后加入本轮的builder，将i设置为dfs返回值，即递归<span class="string">&#x27;]&#x27;</span>的索引；</span><br><span class="line">    c.如果是<span class="string">&#x27;]&#x27;</span>，则<span class="keyword">return</span> i，说明本轮递归调用结束。</span><br><span class="line">这样的处理方法，是因为递归的dfs会返回<span class="string">&#x27;]&#x27;</span>的索引，从该索引位置继续遍历，直到遇到本轮的<span class="string">&#x27;]&#x27;</span>。</span><br><span class="line"><span class="number">2.</span>官方题解的简写代码（处理字符串中的连续整数）：</span><br><span class="line">    <span class="comment">//每个dfs维护一个整数</span></span><br><span class="line">    	<span class="type">int</span> <span class="variable">multi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//当遇到整数时，就构造完整的整数</span></span><br><span class="line">		<span class="keyword">if</span>(s.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">			multi = multi * <span class="number">10</span> + Integer.parseInt(String.valueOf(s.charAt(i))); </span><br><span class="line">	<span class="comment">//当递归的dfs返回，扩展递归的返回字符串时，就将该整数减回0，从而不用专门为整数构造builder2</span></span><br><span class="line">		<span class="keyword">while</span>(multi &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.append(result1);</span><br><span class="line">            multi--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>字符串处理api记录复制：</span><br><span class="line">	<span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(builder2.toString());  <span class="comment">//String转int</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> Integer.parseInt(String.valueOf(charArray[i]));  <span class="comment">//char转int</span></span><br><span class="line">	Character.isDigit(charArray[i]) 		<span class="comment">//判断char是否为数字</span></span><br><span class="line">	Character.isLowerCase(charArray[i])		<span class="comment">//判断char是否为小写字母</span></span><br></pre></td></tr></table></figure>

<h2 id="448、找到所有数组中消失的数字（10月25日）"><a href="#448、找到所有数组中消失的数字（10月25日）" class="headerlink" title="448、找到所有数组中消失的数字（10月25日）"></a>448、找到所有数组中消失的数字（10月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，HashSet。将nums中所有数字放入hashSet，再在“ <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length+<span class="number">1</span>;i++) ”范围里遍历，如果i不在hashSet中，就将i加入结果。</span><br><span class="line"><span class="number">2.</span>官方题解，原地修改。HashSet的存在是为了记录nums中的数字，由于nums的长度也为n，恰好能记录[<span class="number">1</span>,n]个数字，遍历数组时将遍历到的索引位置加n，则没遍历到的索引位置势必小于n，再次遍历找到该位置即可。时间复杂度 O(<span class="number">2</span>*n)=O(n)。</span><br><span class="line">    nums[(nums[i]-<span class="number">1</span>)%n] += n;   <span class="comment">//就是处理第一轮索引的情况，10%10-1=-1，但是(10-1)%10=9</span></span><br></pre></td></tr></table></figure>

<h2 id="155、最小栈（10月26日）"><a href="#155、最小栈（10月26日）" class="headerlink" title="155、最小栈（10月26日）"></a>155、最小栈（10月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，双栈。这道题思路很简单，我们最开始的想法是用一个minValue变量存储最小值，每当元素压栈时，就尝试更新最小值，但我们之所以不敢这么做，是因为如果弹栈元素恰好为最小值，那下一个最小值该是谁呢？优化这个思路的方法就是双栈，维护一个最小值栈，原始栈中的每个栈顶与最小值栈中的栈顶一一对应，原始栈弹栈同时也将最小值栈弹栈。</span><br><span class="line">	（关键词，双栈对应）</span><br></pre></td></tr></table></figure>

<h2 id="234、回文链表（10月26日）"><a href="#234、回文链表（10月26日）" class="headerlink" title="234、回文链表（10月26日）"></a>234、回文链表（10月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，快慢指针+反转链表。今天要做研究，就挑个软柿子捏一捏。没啥说的，快慢指针时注意初值fast=slow=dummy，反转链表时注意维护prev、cur和temp三枚指针。</span><br></pre></td></tr></table></figure>

<h2 id="461、汉明距离（10月26日）"><a href="#461、汉明距离（10月26日）" class="headerlink" title="461、汉明距离（10月26日）"></a>461、汉明距离（10月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，按位运算。突然想到下面的方法，即比较x和y的每一位，相等时将最终结果result加一。</span><br><span class="line">    (num&gt;&gt;(<span class="number">31</span>-i))&amp;<span class="number">1</span>;   <span class="comment">//获取32位int型数字的每一位</span></span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，异或。x和y异或（x^y）后，获取结果的每一位并累加到result。</span><br></pre></td></tr></table></figure>

<h2 id="128、最长连续序列（10月27日）"><a href="#128、最长连续序列（10月27日）" class="headerlink" title="128、最长连续序列（10月27日）"></a>128、最长连续序列（10月27日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，排序。将数组nums排好序后，从左到右遍历，维护一个变量prev指向前一个访问的数字，如果本数字恰为前一个数字加一，则更新累积长度tmpValue；<span class="keyword">else</span> <span class="keyword">if</span>本数字不等于前一数字，更新最大累积长度，并将tmpValue恢复为初值<span class="number">1</span>。结束循环后还需要再更新一次最大累积长度，否则会漏掉最后的tmpValue。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，HashSet。<span class="keyword">for</span>(<span class="type">int</span> num:nums)遍历数组，将数字放入hashSet；再<span class="keyword">for</span>(<span class="type">int</span> num:nums)遍历数字，如果hashSet中不包含num-<span class="number">1</span>，说明是一个新序列，将prev初值设置为num，满足<span class="keyword">while</span>(hashSet.contains(prev+<span class="number">1</span>))的情况下，不断更新该序列长度。</span><br></pre></td></tr></table></figure>

<h2 id="226、反转二叉树（11月2日）"><a href="#226、反转二叉树（11月2日）" class="headerlink" title="226、反转二叉树（11月2日）"></a>226、反转二叉树（11月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，层序遍历二叉树。观察题意，其实操作并不复杂，就是交换每个节点的左、右子节点。经典的层序遍历二叉树，是通过维护队列和每层长度count实现的，这道题不需要分层，就按层序遍历时把节点可劲儿往队列里丢，弹出时再交换其左右子节点即可。只是指针变化。</span><br></pre></td></tr></table></figure>

<h2 id="338、比特位计数（11月5日）"><a href="#338、比特位计数（11月5日）" class="headerlink" title="338、比特位计数（11月5日）"></a>338、比特位计数（11月5日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，按位与。从<span class="number">0</span>到n遍历数字i，由于i为<span class="type">int</span>型，通过下面方法计数i中<span class="number">1</span>的个数，并将本轮结果放入results[i]。</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)	result += (i&gt;&gt;j)&amp;<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="10、正则表达式匹配（11月7日）"><a href="#10、正则表达式匹配（11月7日）" class="headerlink" title="10、正则表达式匹配（11月7日）"></a>10、正则表达式匹配（11月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题太难了，看了很多遍题解都无法想通，就这样吧。</span><br></pre></td></tr></table></figure>

<h2 id="53、把二叉树搜索树转换为累加树（11月7日）"><a href="#53、把二叉树搜索树转换为累加树（11月7日）" class="headerlink" title="53、把二叉树搜索树转换为累加树（11月7日）"></a>53、把二叉树搜索树转换为累加树（11月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈实现后序遍历二叉树。完了我TM傻掉了，啊啊啊啊，后序遍历指的是中间节点最后访问，这个应该是反序中序遍历，怪不得重新看栈实现后序遍历这么迷。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，递归实现反序中序遍历二叉树。先converBST(root.right)，返回后根据本节点值更新sum，再更新本节点值，最后converBST(root.right)即可。</span><br></pre></td></tr></table></figure>

<h2 id="543、二叉树的直径（11月7日）"><a href="#543、二叉树的直径（11月7日）" class="headerlink" title="543、二叉树的直径（11月7日）"></a>543、二叉树的直径（11月7日）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法，深度优先搜索。这道题比较经典，就是dfs左、右叶子节点，通过Math.max(result[0],left+right)判断经过本根节点的路径，向上返回Math.max(left,right)+1即选左边或者右边。</span><br><span class="line">2.我这里遇到root==null时，会返回当前累计长度len-1，这导致需要一个记录深度的变量deep，本位置的更新转化为Math.max(results[0],(left-deep)+(right-deep));，有点复杂了，实际只需要root==null时返回0，不用记录len和deep。</span><br></pre></td></tr></table></figure>

<h2 id="236、二叉树的最近公共祖先（11月8日）"><a href="#236、二叉树的最近公共祖先（11月8日）" class="headerlink" title="236、二叉树的最近公共祖先（11月8日）"></a>236、二叉树的最近公共祖先（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，HashMap+HashSet+dfs。首先通过dfs遍历二叉树，按&lt;本节点，本节点的父节点&gt;形式放入hashMap，这样就获知了每个节点的父节点信息。从p开始向上遍历至root节点，将路径中遇到的节点都存入hashSet，然后从q开始向上遍历至root节点，观察路径中的节点是否出现在hashSet，若出现则为最近的公共祖先。（关键词，&lt;本节点，本节点的父节点&gt;）</span><br></pre></td></tr></table></figure>

<h2 id="617、合并二叉树（11月8日）"><a href="#617、合并二叉树（11月8日）" class="headerlink" title="617、合并二叉树（11月8日）"></a>617、合并二叉树（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，广度优先遍历二叉树。这道题和经典广度优先有所差别，也让我有所顾忌。先维护三个队列，分别用于新Tree、root1和root2的广度优先遍历。</span><br><span class="line">    a.以某位置左子节点为例，只有left1和left2都不为<span class="literal">null</span>时，才将其放入各自队列，否则只是连接不为<span class="literal">null</span>的子节点到新Tree，并不放入队列。因为目标是将节点放到新Tree，此时已经把该左子树全都放到新Tree，没有必要继续遍历。</span><br><span class="line">    b.外层循环为 <span class="keyword">while</span>(!tree1.isEmpty()&amp;&amp;!tree2.isEmpty())是和不是或，其实无所谓，上一步已经保证了tree1和tree2在每一时刻都是同步的，相同大小。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，递归实现深度优先遍历。递归实现还是比较简单的，直接在mergeTrees递归。首先，root1.val = root1.val+root2.val;，然后分别对二者左、右子树进行mergeTrees，将返回值分别连接到root1的left指针和right指针，最后返回root1即可。</span><br></pre></td></tr></table></figure>

<h2 id="198、打家劫舍（11月8日）"><a href="#198、打家劫舍（11月8日）" class="headerlink" title="198、打家劫舍（11月8日）"></a>198、打家劫舍（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。这道题几天前做过，dp[i]表示偷窃第i号房间的最大收益，dp[i]的计算要考虑合法位置，合法位置包括dp[i-<span class="number">2</span>]和dp[i-<span class="number">3</span>]这两种，其中dp[i-<span class="number">3</span>]可以用dp[i-<span class="number">1</span>]-nums[i-<span class="number">1</span>]表示。最后<span class="keyword">return</span> Math.max(dp[n-<span class="number">2</span>],dp[n-<span class="number">1</span>])即可。</span><br></pre></td></tr></table></figure>

<h2 id="238、除自身以外数组的乘积（11月8日）"><a href="#238、除自身以外数组的乘积（11月8日）" class="headerlink" title="238、除自身以外数组的乘积（11月8日）"></a>238、除自身以外数组的乘积（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，分治法。最简单的想法是双层<span class="keyword">for</span>循环，但是会超越时间限制，然后就只能想到除再没有办法了。题解的思路为，任意位置result[i]=它左边的所有数乘积*它右边的所有数乘积，故通过<span class="keyword">for</span>+<span class="keyword">for</span>维护leftNums、rightNums数组，leftNums[i]表示i以左所有数字的乘积，rightNums[i]表示i以右所有数字的乘积，result[i]=leftNums[i]*rightNums[i]。</span><br></pre></td></tr></table></figure>

<h2 id="739、每日温度（11月8日）"><a href="#739、每日温度（11月8日）" class="headerlink" title="739、每日温度（11月8日）"></a>739、每日温度（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，单调栈。最简单的想法还是双层<span class="keyword">for</span>循环，但是会超越时间限制。这是一道单调栈的模板题，我用以下思路实现单调栈，突然发现题解也是这样写得，芜湖起飞：</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;   <span class="comment">//如果新元素比栈顶大，就循环弹栈</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (temperatures[i]&gt;temperatures[index])&#123;</span><br><span class="line">                result[index] = i-index;    <span class="comment">//业务逻辑</span></span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);   <span class="comment">//遇到新元素不论如何都要压栈</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>再记录一下什么时候想到用单调栈：</span><br><span class="line">    通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。</span><br></pre></td></tr></table></figure>

<h2 id="438、找到字符串中所有字母异位词（11月8日）"><a href="#438、找到字符串中所有字母异位词（11月8日）" class="headerlink" title="438、找到字符串中所有字母异位词（11月8日）"></a>438、找到字符串中所有字母异位词（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，滑动窗口。可能很长时间没做滑动窗口了，竟然第一时间没做出来。顾虑主要是如何对比hashMap或者<span class="type">int</span>[]，这里是直接Arrays.equals(countS,countP)比较，那就没啥说的了，就是先在countS和countP中分别放pLen个s和p中的数字，做第一次比较后，再开始通过<span class="keyword">for</span>(<span class="type">int</span> i=pLen;i&lt;sLen;i++)进行滑动窗口逻辑。</span><br><span class="line"><span class="number">2.</span>比较两个<span class="type">int</span>[]数组是否相等，使用Arrays.equals(countS,countP)；那比较两个hashMap数据是否相等该用啥呢？</span><br></pre></td></tr></table></figure>

<h2 id="337、打家劫舍Ⅲ（11月8日）"><a href="#337、打家劫舍Ⅲ（11月8日）" class="headerlink" title="337、打家劫舍Ⅲ（11月8日）"></a>337、打家劫舍Ⅲ（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，后序dfs+动态规划。每次做到“打家劫舍”系列就顿时感觉到思路巧妙，</span><br><span class="line">  a.“打家劫舍Ⅰ”需要考虑两种合法位置，dp[i] = Math.max(dp[i-<span class="number">1</span>]-nums[i-<span class="number">1</span>],dp[i-<span class="number">2</span>])+nums[i];</span><br><span class="line">  b.“打家劫舍Ⅱ”是环形房屋，需要额外考虑[<span class="number">0</span>,nums.length-<span class="number">2</span>]范围里的最优解和[<span class="number">1</span>,nums.lenght-<span class="number">1</span>]范围里的最优解两种情况；</span><br><span class="line">  c.“打家劫舍Ⅲ”是二叉树房屋，则和“offertwo92翻转字符”类似要分情况讨论，有两个状态转移方程，列一下注释即明白：</span><br><span class="line">	Map&lt;TreeNode,Integer&gt; f = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">//选取当前节点后的最大收益</span></span><br><span class="line">	Map&lt;TreeNode,Integer&gt; g = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">//放弃当前节点后的最大收益</span></span><br><span class="line">	<span class="comment">//如果选择偷盗当前root位置，则收益为放弃其左右子节点的收益之和</span></span><br><span class="line">	f.put(root,g.getOrDefault(root.left,<span class="number">0</span>)+g.getOrDefault(root.right,<span class="number">0</span>)+root.val);</span><br><span class="line">    <span class="comment">//如果选择放弃root位置，对于子节点既可以选取，又可以放弃，则收益组成，Math.max(选取左，放弃左)+Math.max(选取右，放弃右)</span></span><br><span class="line">	g.put(root,Math.max(f.getOrDefault(root.left,<span class="number">0</span>),g.getOrDefault(root.left,<span class="number">0</span>))</span><br><span class="line">                +Math.max(f.getOrDefault(root.right,<span class="number">0</span>),g.getOrDefault(root.right,<span class="number">0</span>)));</span><br><span class="line"><span class="number">2.</span>本题遍历二叉树时，采用递归dfs实现，需要后序遍历，因为计算根节点收益时，需要知道左子节点和右子节点的收益情况。</span><br></pre></td></tr></table></figure>

<h2 id="309、最佳买卖股票时机含冷冻期（11月8日）"><a href="#309、最佳买卖股票时机含冷冻期（11月8日）" class="headerlink" title="309、最佳买卖股票时机含冷冻期（11月8日）"></a>309、最佳买卖股票时机含冷冻期（11月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这是一种新的动态规划题型，转移方程表示最大收益，包括状态和行动分情况讨论，将转移方程列为下式：</span><br><span class="line">    （<span class="number">1</span>）.f[i][<span class="number">0</span>]  <span class="comment">//状态：我们在第i天拥有一支股票  行动：这只股票可以是第i天买入，也可以不是第i天买入</span></span><br><span class="line">    	f[<span class="number">0</span>][<span class="number">0</span>] = -prices[i]</span><br><span class="line">    	<span class="keyword">if</span> i!=<span class="number">0</span>: f[i][<span class="number">0</span>] = Math.max(f[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i]，f[i-<span class="number">1</span>][<span class="number">0</span>])   <span class="comment">//前者是第i-1天买入，后者是第i-1天已经持有</span></span><br><span class="line">    （<span class="number">2</span>）.f[i][<span class="number">1</span>]  <span class="comment">//状态：我们在第i天不拥有一张股票  行动：我们在第i天卖掉股票（造成不拥有），造成第i+1天的冷冻期</span></span><br><span class="line">		f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> i!=<span class="number">0</span>: f[i][<span class="number">1</span>] = f[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]    <span class="comment">//上一状态只能是第i-1天拥有股票</span></span><br><span class="line">	（<span class="number">3</span>）.f[i][<span class="number">2</span>]  <span class="comment">//状态：我们在第i天不拥有一张股票  行动：它是（i-1）或以前卖掉的，所以第（i+1）天不存在冷冻期</span></span><br><span class="line">         f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">         <span class="keyword">if</span> i!=<span class="number">0</span>: f[i][<span class="number">2</span>] = Math.max(f[i-<span class="number">1</span>][<span class="number">1</span>],f[i-<span class="number">1</span>][<span class="number">2</span>])  <span class="comment">//上一状态是i-1天卖掉造成不拥有，或者更为长期的不拥有</span></span><br><span class="line">  通过上面这些式子，我们可以看到收益的传播，上一状态是非冷冻期不持有的最大收益，则会传播到下一状态购入股票的最大收益。最终返回Math.max(f[n-<span class="number">1</span>][<span class="number">1</span>],f[n-<span class="number">1</span>][<span class="number">2</span>])即可，即股票已经被卖掉了。</span><br><span class="line"><span class="number">2.</span>这道题又和分情况讨论不同，它定义转移方程时，需要从状态和行动考虑，会出现同一状态选择不同的行动。下次再做时估计还是难以想到，不过还是在分析中感受到动态规划的魅力。</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://bmsk1994.github.io">bmsk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bmsk1994.github.io/2022/11/14/HOT-100/">https://bmsk1994.github.io/2022/11/14/HOT-100/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/hot100.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/"><img class="prev-cover" src="/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">剑指offer 专项突破</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/" title="剑指offer 专项突破"><img class="cover" src="/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-14</div><div class="title">剑指offer 专项突破</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">bmsk</div><div class="author-info__description">锦衣疾马，自此西行</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/BMSK1994"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/BMSK1994" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1679897187@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">Leetcode刷题笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%887%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">1.两数之和（7月31日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%887%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">2.两数相加（7月31日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%887%E6%9C%8831%E6%97%A5%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">3.无重复字符的最长子串（7月31日、滑动窗口）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%888%E6%9C%881%E6%97%A5%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">4.寻找两个正序数组的中位数（8月1日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%888%E6%9C%886%E6%97%A5%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">5.最长回文子串（8月6日、动态规划）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%888%E6%9C%886%E6%97%A5%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">10.正则表达式匹配（8月6日、动态规划）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%888%E6%9C%886%E6%97%A5%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">11.盛最多水的容器（8月6日、双指针）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%888%E6%9C%887%E6%97%A5%E3%80%81%E6%8E%92%E5%BA%8F-%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">15.三数之和（8月7日、排序+双指针）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%EF%BC%888%E6%9C%887%E6%97%A5%E3%80%81%E5%9B%9E%E6%BA%AF%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">17.电话号码的字母组合（8月7日、回溯）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%888%E6%9C%888%E6%97%A5%E3%80%81%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-number">1.10.</span> <span class="toc-text">19.删除链表的倒数第 N 个结点（8月8日、快慢指针）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%EF%BC%888%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.</span> <span class="toc-text">20.有效的括号（8月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-8%E6%9C%888%E6%97%A5"><span class="toc-number">1.12.</span> <span class="toc-text">21.合并两个有序链表(8月8日)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%EF%BC%888%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.13.</span> <span class="toc-text">22.括号生成（8月11日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%888%E6%9C%8812%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.</span> <span class="toc-text">23.合并K个升序链表（8月12日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8810%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.15.</span> <span class="toc-text">94、二叉树中序遍历（10月6日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101%E3%80%81%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8810%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.16.</span> <span class="toc-text">101、对称二叉树（10月6日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8810%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.17.</span> <span class="toc-text">102、二叉树的层序遍历（10月6日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%8810%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.18.</span> <span class="toc-text">104、二叉树的最大深度（10月6日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105%E3%80%81%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8810%E6%9C%887%E6%97%A5%EF%BC%89"><span class="toc-number">1.19.</span> <span class="toc-text">105、从前序与中序遍历序列构造二叉树（10月7日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121%E3%80%81%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%8810%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.20.</span> <span class="toc-text">121、买卖股票的最佳时机（10月6日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#136%E3%80%81%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8810%E6%9C%887%E6%97%A5%EF%BC%89"><span class="toc-number">1.21.</span> <span class="toc-text">136、只出现一次的数字（10月7日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%8810%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.22.</span> <span class="toc-text">34、在排序数组中查找元素的第一个和最后一个位置（10月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49%E3%80%81%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84%EF%BC%8810%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.23.</span> <span class="toc-text">49、字母异位词分组（10月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E3%80%81%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%EF%BC%8810%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.24.</span> <span class="toc-text">53、最大子数组和（10月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%8810%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.25.</span> <span class="toc-text">124、二叉树的最大路径和（10月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#300%E3%80%81%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%8810%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.26.</span> <span class="toc-text">300、最长上升子序列（10月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347%E3%80%81%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%EF%BC%8810%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.27.</span> <span class="toc-text">347、前K个高频元素（10月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%EF%BC%8810%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.28.</span> <span class="toc-text">32、最长有效括号（10月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%8810%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.29.</span> <span class="toc-text">206、反转链表（10月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8%EF%BC%8810%E6%9C%889%E6%97%A5%EF%BC%89"><span class="toc-number">1.30.</span> <span class="toc-text">114、二叉树展开为链表（10月9日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97%EF%BC%8810%E6%9C%8810%E6%97%A5%EF%BC%89"><span class="toc-number">1.31.</span> <span class="toc-text">31、下一个排列（10月10日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%8810%E6%9C%8810%E6%97%A5%EF%BC%89"><span class="toc-number">1.32.</span> <span class="toc-text">33、搜索旋转排序数组（10月10日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39%E3%80%81%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%EF%BC%8810%E6%9C%8810%E6%97%A5%EF%BC%89"><span class="toc-number">1.33.</span> <span class="toc-text">39、组合总和（10月10日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40%E3%80%81%E6%8E%A5%E9%9B%A8%E6%B0%B4%EF%BC%8810%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.34.</span> <span class="toc-text">40、接雨水（10月11日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84%E3%80%81%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%EF%BC%8810%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.35.</span> <span class="toc-text">84、柱状图中的最大矩形（10月11日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70%E3%80%81%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%8810%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.36.</span> <span class="toc-text">70、爬楼梯（10月11日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46%E3%80%81%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8810%E6%9C%8817%E6%97%A5%EF%BC%89"><span class="toc-number">1.37.</span> <span class="toc-text">46、全排列（10月17日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56%E3%80%81%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%EF%BC%8810%E6%9C%8817%E6%97%A5%EF%BC%89"><span class="toc-number">1.38.</span> <span class="toc-text">56、合并区间（10月17日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55%E3%80%81%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%8810%E6%9C%8818%E6%97%A5%EF%BC%89"><span class="toc-number">1.39.</span> <span class="toc-text">55、跳跃游戏（10月18日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78%E3%80%81%E5%AD%90%E9%9B%86%EF%BC%8810%E6%9C%8818%E6%97%A5%EF%BC%89"><span class="toc-number">1.40.</span> <span class="toc-text">78、子集（10月18日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%8810%E6%9C%8818%E6%97%A5%EF%BC%89"><span class="toc-number">1.41.</span> <span class="toc-text">96、不同的二叉搜索树（10月18日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98%E3%80%81%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%8810%E6%9C%8818%E6%97%A5%EF%BC%89"><span class="toc-number">1.42.</span> <span class="toc-text">98、验证二叉搜索树（10月18日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%8810%E6%9C%8818%E6%97%A5%EF%BC%89"><span class="toc-number">1.43.</span> <span class="toc-text">141、环形链表（10月18日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#139%E3%80%81%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%EF%BC%8810%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.44.</span> <span class="toc-text">139、单词拆分（10月20日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1%EF%BC%8810%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.45.</span> <span class="toc-text">142、环形链表Ⅱ（10月20日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234%E3%80%81%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%8810%E6%9C%8820%E6%97%A5%EF%BC%89"><span class="toc-number">1.46.</span> <span class="toc-text">234、回文链表（10月20日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#283%E3%80%81%E7%A7%BB%E5%8A%A8%E9%9B%B6%EF%BC%8810%E6%9C%8821%E6%97%A5%EF%BC%89"><span class="toc-number">1.47.</span> <span class="toc-text">283、移动零（10月21日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148%E3%80%81%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%8810%E6%9C%8821%E6%97%A5%EF%BC%89"><span class="toc-number">1.48.</span> <span class="toc-text">148、排序链表（10月21日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160%E3%80%81%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%EF%BC%8810%E6%9C%8821%E6%97%A5%EF%BC%89"><span class="toc-number">1.49.</span> <span class="toc-text">160、相交链表（10月21日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146%E3%80%81LRU%E7%BC%93%E5%AD%98%EF%BC%8810%E6%9C%8822%E6%97%A5%EF%BC%89"><span class="toc-number">1.50.</span> <span class="toc-text">146、LRU缓存（10月22日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#169%E3%80%81%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%EF%BC%8810%E6%9C%8823%E6%97%A5%EF%BC%89"><span class="toc-number">1.51.</span> <span class="toc-text">169、多数元素（10月23日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#287%E3%80%81%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%EF%BC%8810%E6%9C%8823%E6%97%A5%EF%BC%89"><span class="toc-number">1.52.</span> <span class="toc-text">287、寻找重复数（10月23日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#208%E3%80%81%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%8810%E6%9C%8824%E6%97%A5%EF%BC%89"><span class="toc-number">1.53.</span> <span class="toc-text">208、实现前缀树（10月24日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%EF%BC%8810%E6%9C%8824%E6%97%A5%EF%BC%89"><span class="toc-number">1.54.</span> <span class="toc-text">215、数组中第K个最大元素（10月24日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#560%E3%80%81%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%8810%E6%9C%8824%E6%97%A5%EF%BC%89"><span class="toc-number">1.55.</span> <span class="toc-text">560、和为K的子数组（10月24日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#394%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81%EF%BC%8810%E6%9C%8825%E6%97%A5%EF%BC%89"><span class="toc-number">1.56.</span> <span class="toc-text">394、字符串解码（10月25日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#448%E3%80%81%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8810%E6%9C%8825%E6%97%A5%EF%BC%89"><span class="toc-number">1.57.</span> <span class="toc-text">448、找到所有数组中消失的数字（10月25日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155%E3%80%81%E6%9C%80%E5%B0%8F%E6%A0%88%EF%BC%8810%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.58.</span> <span class="toc-text">155、最小栈（10月26日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234%E3%80%81%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%EF%BC%8810%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.59.</span> <span class="toc-text">234、回文链表（10月26日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#461%E3%80%81%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%EF%BC%8810%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.60.</span> <span class="toc-text">461、汉明距离（10月26日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128%E3%80%81%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%EF%BC%8810%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.61.</span> <span class="toc-text">128、最长连续序列（10月27日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226%E3%80%81%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8811%E6%9C%882%E6%97%A5%EF%BC%89"><span class="toc-number">1.62.</span> <span class="toc-text">226、反转二叉树（11月2日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#338%E3%80%81%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0%EF%BC%8811%E6%9C%885%E6%97%A5%EF%BC%89"><span class="toc-number">1.63.</span> <span class="toc-text">338、比特位计数（11月5日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%8811%E6%9C%887%E6%97%A5%EF%BC%89"><span class="toc-number">1.64.</span> <span class="toc-text">10、正则表达式匹配（11月7日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E3%80%81%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91%EF%BC%8811%E6%9C%887%E6%97%A5%EF%BC%89"><span class="toc-number">1.65.</span> <span class="toc-text">53、把二叉树搜索树转换为累加树（11月7日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#543%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%EF%BC%8811%E6%9C%887%E6%97%A5%EF%BC%89"><span class="toc-number">1.66.</span> <span class="toc-text">543、二叉树的直径（11月7日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%8811%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.67.</span> <span class="toc-text">236、二叉树的最近公共祖先（11月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#617%E3%80%81%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8811%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.68.</span> <span class="toc-text">617、合并二叉树（11月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#198%E3%80%81%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%EF%BC%8811%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.69.</span> <span class="toc-text">198、打家劫舍（11月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#238%E3%80%81%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF%EF%BC%8811%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.70.</span> <span class="toc-text">238、除自身以外数组的乘积（11月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#739%E3%80%81%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6%EF%BC%8811%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.71.</span> <span class="toc-text">739、每日温度（11月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#438%E3%80%81%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%EF%BC%8811%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.72.</span> <span class="toc-text">438、找到字符串中所有字母异位词（11月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#337%E3%80%81%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E2%85%A2%EF%BC%8811%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.73.</span> <span class="toc-text">337、打家劫舍Ⅲ（11月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#309%E3%80%81%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F%EF%BC%8811%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.74.</span> <span class="toc-text">309、最佳买卖股票时机含冷冻期（11月8日）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/18/Java-Agent/" title="Java Agent"><img src="/img/Java%20agent.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java Agent"/></a><div class="content"><a class="title" href="/2022/11/18/Java-Agent/" title="Java Agent">Java Agent</a><time datetime="2022-11-18T14:39:45.000Z" title="Created 2022-11-18 22:39:45">2022-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/14/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/" title="学习日志"><img src="/img/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习日志"/></a><div class="content"><a class="title" href="/2022/11/14/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/" title="学习日志">学习日志</a><time datetime="2022-11-14T12:09:14.000Z" title="Created 2022-11-14 20:09:14">2022-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/" title="剑指offer 专项突破"><img src="/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="剑指offer 专项突破"/></a><div class="content"><a class="title" href="/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/" title="剑指offer 专项突破">剑指offer 专项突破</a><time datetime="2022-11-14T12:07:42.000Z" title="Created 2022-11-14 20:07:42">2022-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/14/HOT-100/" title="HOT 100"><img src="/img/hot100.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HOT 100"/></a><div class="content"><a class="title" href="/2022/11/14/HOT-100/" title="HOT 100">HOT 100</a><time datetime="2022-11-14T12:05:09.000Z" title="Created 2022-11-14 20:05:09">2022-11-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/hot100.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By bmsk</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>