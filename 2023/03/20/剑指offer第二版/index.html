<!DOCTYPE html><html lang="[&quot;zh-cn&quot;,&quot;en&quot;,&quot;default&quot;]" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>剑指offer第二版 | BMSK</title><meta name="author" content="bmsk"><meta name="copyright" content="bmsk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="剑指Offer(第二版)刷题笔记03、数组中重复的数字（12月22日）1.我的想法1，排序。做一个pre指针初始为-1，将nums排好序后从左向右遍历，如果当前num等于pre则返回num，否则将pre指向num。2.我的想法2，hashSet。维护hashSet，从左到右遍历nums，如果当前num在hashSet已经存在就返回num，否则将当前num加入hashSet。3.没有别的想法，就是想">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer第二版">
<meta property="og:url" content="https://bmsk1994.github.io/2023/03/20/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88/index.html">
<meta property="og:site_name" content="BMSK">
<meta property="og:description" content="剑指Offer(第二版)刷题笔记03、数组中重复的数字（12月22日）1.我的想法1，排序。做一个pre指针初始为-1，将nums排好序后从左向右遍历，如果当前num等于pre则返回num，否则将pre指向num。2.我的想法2，hashSet。维护hashSet，从左到右遍历nums，如果当前num在hashSet已经存在就返回num，否则将当前num加入hashSet。3.没有别的想法，就是想">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bmsk1994.github.io/img/%E5%89%91%E6%8C%87offer2.jpg">
<meta property="article:published_time" content="2023-03-20T05:35:41.000Z">
<meta property="article:modified_time" content="2023-03-20T05:36:59.346Z">
<meta property="article:author" content="bmsk">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bmsk1994.github.io/img/%E5%89%91%E6%8C%87offer2.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://bmsk1994.github.io/2023/03/20/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '剑指offer第二版',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-20 13:36:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E5%89%91%E6%8C%87offer2.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">BMSK</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">剑指offer第二版</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-03-20T05:35:41.000Z" title="Created 2023-03-20 13:35:41">2023-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-03-20T05:36:59.346Z" title="Updated 2023-03-20 13:36:59">2023-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode/">LeetCode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>25min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="剑指offer第二版"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="剑指Offer-第二版-刷题笔记"><a href="#剑指Offer-第二版-刷题笔记" class="headerlink" title="剑指Offer(第二版)刷题笔记"></a>剑指Offer(第二版)刷题笔记</h1><h2 id="03、数组中重复的数字（12月22日）"><a href="#03、数组中重复的数字（12月22日）" class="headerlink" title="03、数组中重复的数字（12月22日）"></a>03、数组中重复的数字（12月22日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法<span class="number">1</span>，排序。做一个pre指针初始为-<span class="number">1</span>，将nums排好序后从左向右遍历，如果当前num等于pre则返回num，否则将pre指向num。</span><br><span class="line"><span class="number">2.</span>我的想法<span class="number">2</span>，hashSet。维护hashSet，从左到右遍历nums，如果当前num在hashSet已经存在就返回num，否则将当前num加入hashSet。</span><br><span class="line"><span class="number">3.</span>没有别的想法，就是想简单题重拳出击！</span><br></pre></td></tr></table></figure>

<h2 id="04、二维数组中的查找（240、12月22日）"><a href="#04、二维数组中的查找（240、12月22日）" class="headerlink" title="04、二维数组中的查找（240、12月22日）"></a>04、二维数组中的查找（240、12月22日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，二分查找。这道题比较简单，是经典的二分查找模板题。首先要在二维数组中选取指定行，选取行的过程不需要二分查找，只要row[<span class="number">0</span>]&lt;=target，就对该行再进行二分查找。</span><br></pre></td></tr></table></figure>

<h2 id="06、从尾到头打印链表（12月23日）"><a href="#06、从尾到头打印链表（12月23日）" class="headerlink" title="06、从尾到头打印链表（12月23日）"></a>06、从尾到头打印链表（12月23日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，栈。注意不可<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stack.size();i++)，这样<span class="keyword">for</span>循环内部出栈后，stack.size()每次都会改变。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，递归实现。维护类变量List&lt;Integer&gt; tmp，实现辅助函数 recur(ListNode node)，该辅助函数递归调用recur(node.next)，递归返回时，将node.val加入tmp。从这也可看到，递归本质就是一种栈，实现了先入后出。</span><br></pre></td></tr></table></figure>

<h2 id="07、重建二叉树（12月24日）"><a href="#07、重建二叉树（12月24日）" class="headerlink" title="07、重建二叉树（12月24日）"></a>07、重建二叉树（12月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，根节点关系公式。这道题很特殊，只要记得前序是中左右，[num,[左子树]，[右子树]]；中序是左中右，[[左子树],num,[右子树]]，根据num的位置关系即可确定左右子树。</span><br><span class="line">    实现思路是，先将inorder按&lt;num,索引&gt;放入hashMap，查看preorder[preorderLeft]在hashMap中的索引值，通过inorder计算出左子树的长度，将root节点值设为preorderLeft索引对应的值，并递归构建左右子树：</span><br><span class="line">    root.left = myBuildTree(...)</span><br><span class="line"><span class="number">2.</span>实际上，inorder的作用一直是辅助计算左子树长度，还是以preorder为主。</span><br></pre></td></tr></table></figure>

<h2 id="08、用两个栈实现队列（12月24日）"><a href="#08、用两个栈实现队列（12月24日）" class="headerlink" title="08、用两个栈实现队列（12月24日）"></a>08、用两个栈实现队列（12月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，来回倒腾。维护两个Stack&lt;Integer&gt;，分别是stackMain和stackTmp，appendTail时，直接将num压入stackMain。</span><br><span class="line">	deleteHead执行时，先判断stackMain如果为空，则直接返回-<span class="number">1</span>，表示没有元素；如果不为空，就将stackMain元素依次出栈，压入stackTmp；弹栈取出stackTmp栈顶值时，再依次压入stackMain。（不规定main和tmp，可能会提高效率）</span><br><span class="line"><span class="number">2.</span>注意，用Deque实现栈时，pop和remove都是操作队列首部，并不是弹栈，removeLast才是弹栈。Stack完全遵守栈逻辑。</span><br></pre></td></tr></table></figure>

<h2 id="10-Ⅰ、斐波那契数列（12月24日）"><a href="#10-Ⅰ、斐波那契数列（12月24日）" class="headerlink" title="10-Ⅰ、斐波那契数列（12月24日）"></a>10-Ⅰ、斐波那契数列（12月24日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。维护三个<span class="type">int</span>变量p、q和r，其中p代表f(n-<span class="number">2</span>)，q代表f(n-<span class="number">1</span>)，r代表f(n)，每次计算时，p = q、q = r，新r通过(p+q)%<span class="number">1000000007</span>求得。这样就实现了滚动数组。</span><br><span class="line"><span class="number">2.</span>我的想法，递归。递归出现重复计算，很容易超时，需要维护数组，为每个n保存初始值为-<span class="number">1</span>，只有不是-<span class="number">1</span>才递归计算f(n)。</span><br><span class="line">    Arrays.fill(results,-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="10-Ⅱ、青蛙跳台阶问题（12月25日）"><a href="#10-Ⅱ、青蛙跳台阶问题（12月25日）" class="headerlink" title="10-Ⅱ、青蛙跳台阶问题（12月25日）"></a>10-Ⅱ、青蛙跳台阶问题（12月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，动态规划。这道题就是上楼梯问题，设dp[i]表示上第i阶楼梯有多少种上法，则状态转移方程：</span><br><span class="line">    dp[i] = (dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])%<span class="number">1000000007</span>;</span><br></pre></td></tr></table></figure>

<h2 id="11、旋转数组的最小数字（154、12月25日）"><a href="#11、旋转数组的最小数字（154、12月25日）" class="headerlink" title="11、旋转数组的最小数字（154、12月25日）"></a>11、旋转数组的最小数字（154、12月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，<span class="keyword">for</span>遍历。从左到右遍历，找到比前面一位小的nums[i]，否则返回nums[<span class="number">0</span>]。</span><br></pre></td></tr></table></figure>

<h2 id="12、矩阵中的路径（79、12月25日）"><a href="#12、矩阵中的路径（79、12月25日）" class="headerlink" title="12、矩阵中的路径（79、12月25日）"></a>12、矩阵中的路径（79、12月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，图BFS。总觉得做过，但翻笔记又没找到。看题目，能感觉到visited数组是需要变化的，某条路径可能访问过该点，不构成word，但其他路径可能需要该点。本题题解的关键，在于图BFS时回溯的思想，先将visited[i][j]置为<span class="literal">true</span>，递归执行BFS后，再将visited[i][j]置为<span class="literal">false</span>，表示消除这条路径的影响。</span><br></pre></td></tr></table></figure>

<h2 id="14-Ⅰ、剪绳子（343、12月25日）"><a href="#14-Ⅰ、剪绳子（343、12月25日）" class="headerlink" title="14-Ⅰ、剪绳子（343、12月25日）"></a>14-Ⅰ、剪绳子（343、12月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。每次看到题解都惊为天人。设dp[i]表示将正整数拆分成至少两个整数后，这些整数的最大乘积。状态转移方程如下，表示每次拆解i的话，都必须拆解为至少<span class="number">2</span>块，要不然至此结束j*(i-j)，要不然继续拆解j*dp[i-j]。</span><br><span class="line">	<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Math.max(j*(i-j),j*dp[i-j]);</span><br><span class="line">当然，这只是按j拆解的结果，还需要更新最终结果dp[i] = Math.max(dp[i],result)。</span><br></pre></td></tr></table></figure>

<h2 id="14-Ⅱ、剪绳子Ⅱ（343、12月25日）"><a href="#14-Ⅱ、剪绳子Ⅱ（343、12月25日）" class="headerlink" title="14-Ⅱ、剪绳子Ⅱ（343、12月25日）"></a>14-Ⅱ、剪绳子Ⅱ（343、12月25日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，大数运算+动态规划。这道题和剪绳子Ⅰ不同在，结果需要模<span class="number">1e9</span>+<span class="number">7</span>，dp[i]累积乘起来的话，n等于<span class="number">120</span>时就会溢出。此时需要<span class="keyword">import</span> java.math.BigInteger，进行大数运算，基本逻辑一致，只需返回时取模。其他题解都是数学方法，还是不再看了。</span><br><span class="line"><span class="number">2.</span>大数运算<span class="keyword">import</span> java.math.BigInteger</span><br><span class="line">	BigInteger dp[] = <span class="keyword">new</span> <span class="title class_">BigInteger</span>[n + <span class="number">1</span>];  <span class="comment">//定义数组</span></span><br><span class="line">	Arrays.fill(dp, BigInteger.valueOf(<span class="number">1</span>));   <span class="comment">//赋值</span></span><br><span class="line">	dp[i - j].multiply(BigInteger.valueOf(j)) <span class="comment">//相乘</span></span><br><span class="line">	dp[i].max(result)						<span class="comment">//取最大值，其中dp[i]和result均为BigInteger</span></span><br><span class="line">	dp[n].mod(BigInteger.valueOf(<span class="number">1000000007</span>)).intValue();	<span class="comment">//取模，并恢复成int类型</span></span><br></pre></td></tr></table></figure>

<h2 id="15、二进制中1的个数（191、12月26日）"><a href="#15、二进制中1的个数（191、12月26日）" class="headerlink" title="15、二进制中1的个数（191、12月26日）"></a>15、二进制中1的个数（191、12月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，位运算。求<span class="type">int</span>型整数中<span class="number">1</span>的个数，只需遍历该整数的<span class="number">32</span>位，在每一位上与<span class="number">1</span>相与，并累加结果。当然也可(<span class="number">1</span> &lt;&lt; i)。</span><br><span class="line">	 <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) result += (n&gt;&gt;i)&amp;<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="16、数值的整数次方（50、12月26日）"><a href="#16、数值的整数次方（50、12月26日）" class="headerlink" title="16、数值的整数次方（50、12月26日）"></a>16、数值的整数次方（50、12月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，快速幂+递归。如果要计算x^<span class="number">64</span>，从x，x^<span class="number">2</span>，x^<span class="number">3</span>累积是不理智的，应该计算x^<span class="number">2</span>，x^<span class="number">4</span>，x^<span class="number">8</span>，x^<span class="number">16</span>，x^<span class="number">32</span>，x^<span class="number">64</span>。那如果是x^<span class="number">65</span>呢？就需要x^<span class="number">64</span>*x，就需要判断按幂数a%<span class="number">2</span>分情况讨论。这种关系能通过递归实现： <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> quickMul(x,a/<span class="number">2</span>); y*y or y*y*x。</span><br></pre></td></tr></table></figure>

<h2 id="17、打印从1到最大的n位数（12月26日）"><a href="#17、打印从1到最大的n位数（12月26日）" class="headerlink" title="17、打印从1到最大的n位数（12月26日）"></a>17、打印从1到最大的n位数（12月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，幂运算。这道题难道是看不起我，用幂运算即可，需注意Math.pow返回<span class="type">double</span>，数字从<span class="number">1</span>开始。</span><br><span class="line">	<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">10</span>,n);</span><br><span class="line"><span class="number">2.</span>看题解要考虑大数，看来需要对大数运算、去除前导<span class="number">0</span>等总结一哈。</span><br></pre></td></tr></table></figure>

<h2 id="18、删除链表的节点（12月26日）"><a href="#18、删除链表的节点（12月26日）" class="headerlink" title="18、删除链表的节点（12月26日）"></a>18、删除链表的节点（12月26日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，双指针。维护prev初始为<span class="literal">null</span>、tmp初始为head，通过tmp遍历链表，交替更新。特殊情况是，head.val==val，直接返回head.next即可。</span><br></pre></td></tr></table></figure>

<h2 id="21、调整数组顺序使奇数位于偶数前面（12月27日）"><a href="#21、调整数组顺序使奇数位于偶数前面（12月27日）" class="headerlink" title="21、调整数组顺序使奇数位于偶数前面（12月27日）"></a>21、调整数组顺序使奇数位于偶数前面（12月27日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，双指针。维护奇数指针pointOdd初始化为<span class="number">0</span>，偶数指针pointEven初始化为nums.length-<span class="number">1</span>，当pointOdd指向的num为偶数时，就与pointEven指向元素交换位置，并将pointEven减一；当pointOdd指向的num为奇数时，将pointOdd加一。</span><br><span class="line">    当然，可以通过压缩pointEven指针位置优化执行速度。</span><br></pre></td></tr></table></figure>

<h2 id="22、链表中倒数第k个节点（12月27日）"><a href="#22、链表中倒数第k个节点（12月27日）" class="headerlink" title="22、链表中倒数第k个节点（12月27日）"></a>22、链表中倒数第k个节点（12月27日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，快慢指针。维护指针first、second，让first指针先走k步，然后两指针并行，直到first指针走到链表尾，此时second指针指向倒数第k个节点。</span><br></pre></td></tr></table></figure>

<h2 id="24、反转链表（206、12月27日）"><a href="#24、反转链表（206、12月27日）" class="headerlink" title="24、反转链表（206、12月27日）"></a>24、反转链表（206、12月27日）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法，三指针。反转链表，只要记得维护3个指针即可，prev初始为0，tmp初始为head，tmpNext在遍历中存储tmp.next。</span><br></pre></td></tr></table></figure>

<h2 id="25、合并两个排序链表（21、12月27日）"><a href="#25、合并两个排序链表（21、12月27日）" class="headerlink" title="25、合并两个排序链表（21、12月27日）"></a>25、合并两个排序链表（21、12月27日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，dummy节点。初始dummy节点为<span class="keyword">new</span> <span class="title class_">ListNode</span>()，head指针指向dummy节点。通过<span class="keyword">while</span>(l1!=<span class="literal">null</span>&amp;&amp;l2!=<span class="literal">null</span>)遍历连个链表，跳出循环说明l1和l2至少有<span class="number">1</span>个，指向<span class="literal">null</span>，连接非<span class="literal">null</span>节点即可。</span><br></pre></td></tr></table></figure>

<h2 id="26、树的子结构（12月27日）"><a href="#26、树的子结构（12月27日）" class="headerlink" title="26、树的子结构（12月27日）"></a>26、树的子结构（12月27日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，递归。首先先序遍历二叉树A，对二叉树A的每个节点，判断以该节点为根的子树，是否和B子树相等。这道题递归很巧妙，先序遍历是这样设计的：</span><br><span class="line">    dfs(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B)</span><br><span class="line">递归时，如果B子树的节点为<span class="literal">null</span>，说明能匹配到最后，返回<span class="literal">true</span>；当B节点不为<span class="literal">null</span>，A节点为<span class="literal">null</span>或不相等，说明子树不匹配；相等，则继续dfs递归A和B相同方向的子树。</span><br></pre></td></tr></table></figure>

<h2 id="27、二叉树的镜像（226、12月28日）"><a href="#27、二叉树的镜像（226、12月28日）" class="headerlink" title="27、二叉树的镜像（226、12月28日）"></a>27、二叉树的镜像（226、12月28日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，递归。这道题以前好像做过，但还是觉得拿不下来。记住后序遍历递归就好了。先对root的左、右子树进行递归反转，再将root的左、右子节点交换位置。（关键词、后序遍历递归）</span><br></pre></td></tr></table></figure>

<h2 id="28、对称的二叉树（101、12月28日）"><a href="#28、对称的二叉树（101、12月28日）" class="headerlink" title="28、对称的二叉树（101、12月28日）"></a>28、对称的二叉树（101、12月28日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，递归。这道题也还是不会。设计递归函数时，考虑比较传入的左、右子节点的值，比较左子节点的right和右子节点的left，再比较左子节点的left和右子节点的right，做这<span class="number">3</span>种比较。</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDuiCheng</span><span class="params">(TreeNode leftRoot,TreeNode rightRoot)</span></span><br><span class="line">	边界值，如果leftRoot和rightRoot都为<span class="literal">null</span>，返回<span class="literal">true</span>，说明该路径比较结束；否则，有一个不为<span class="literal">null</span>，则不对称。</span><br><span class="line">（关键词，dfs做<span class="number">3</span>种比较）</span><br></pre></td></tr></table></figure>

<h2 id="29、顺时针打印矩阵（54、12月28日）"><a href="#29、顺时针打印矩阵（54、12月28日）" class="headerlink" title="29、顺时针打印矩阵（54、12月28日）"></a>29、顺时针打印矩阵（54、12月28日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，图BFS。这道题的意思是，在数组中按顺时针螺旋获取元素。题解为，首先计算元素个数total，维护<span class="type">int</span>型数组result和<span class="type">boolean</span>型数组visit，规定方向顺序为（右，下，左，上）。按<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;total;i++)获取数组元素，再按方向顺序确定新元素的位置。</span><br><span class="line"><span class="number">2.</span>但是，我做题时是用<span class="keyword">for</span> <span class="keyword">break</span>方式确定新元素，这会造成在向上时，只能向上一个单元（只会在向上发生）。题解的解决办法是，维护<span class="keyword">for</span>循环外变量directionIndex ，保留住方向的惯性。出现不满足的情况，才会</span><br><span class="line">    directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;   <span class="comment">//换下一个方向，新位置必然合法</span></span><br></pre></td></tr></table></figure>

<h2 id="30、包含min函数的栈（155、12月28日）"><a href="#30、包含min函数的栈（155、12月28日）" class="headerlink" title="30、包含min函数的栈（155、12月28日）"></a>30、包含min函数的栈（155、12月28日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，双栈。维护两个栈mainStack和minStack，每当在mainStack压入元素时，同步在minStack压入当前最小元素。弹栈也同步。min函数会获取minStack栈顶元素。</span><br><span class="line"><span class="number">2.</span>其实，可以预先在minStack压栈Integer.MAX_VALUE，这样代码会更优雅，不会存在空栈判断。</span><br></pre></td></tr></table></figure>

<h2 id="31、栈的压入、弹出序列（946、12月29日）"><a href="#31、栈的压入、弹出序列（946、12月29日）" class="headerlink" title="31、栈的压入、弹出序列（946、12月29日）"></a>31、栈的压入、弹出序列（946、12月29日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，辅助栈。维护一个辅助栈stack，通过压栈序列在stack上模拟压栈过程，当栈顶和弹栈序列当前位置元素相等时，就对stack弹栈，并将弹栈序列位置加一。当弹栈序列错误时，一些元素被栈顶压着形成死锁，最终栈不为空。</span><br></pre></td></tr></table></figure>

<h2 id="32、从上到下打印二叉树（12月29日）"><a href="#32、从上到下打印二叉树（12月29日）" class="headerlink" title="32、从上到下打印二叉树（12月29日）"></a>32、从上到下打印二叉树（12月29日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，层序遍历二叉树。这道题没要求区分层次，只要求从左到右打印。所以，只需要维护队列deque，不需要维护每层长度dequeLen，当队列不为空时，弹出队首元素，如果该元素不为<span class="literal">null</span>，则把val放入结果，把左右子节点放入deque。</span><br></pre></td></tr></table></figure>

<h2 id="32-Ⅱ、从上到下打印二叉树Ⅱ（12月29日）"><a href="#32-Ⅱ、从上到下打印二叉树Ⅱ（12月29日）" class="headerlink" title="32-Ⅱ、从上到下打印二叉树Ⅱ（12月29日）"></a>32-Ⅱ、从上到下打印二叉树Ⅱ（12月29日）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.我的想法，层序遍历二叉树。这道题区分层次，需要维护队列deque和每层长度dequeLen，我的解法不变，需要判断满足dequeLen为0时，将当前层元素集合result放入结果集，并重置dequeLen和result。</span><br></pre></td></tr></table></figure>

<h2 id="32-Ⅲ、从上到下打印二叉树Ⅲ（12月29日）"><a href="#32-Ⅲ、从上到下打印二叉树Ⅲ（12月29日）" class="headerlink" title="32-Ⅲ、从上到下打印二叉树Ⅲ（12月29日）"></a>32-Ⅲ、从上到下打印二叉树Ⅲ（12月29日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，层序遍历二叉树。这道题需要交替方向，打印不同层次。题解中巧妙点在于，当前层元素集合result不再是list，而是deque，灵活地选择在队列头部或尾部插入元素，可以造成从左到右或从右到左打印的效果，最后再将deque按内容转换为list。</span><br><span class="line">	Deque&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//假如该层有元素[1,2,3]，已经插入元素1，此时要插入元素2</span></span><br><span class="line">	result.addLast(tmp.val);	<span class="comment">//addLast是默认操作，会在队列尾部插入元素，队列变成[1,2]</span></span><br><span class="line">	result.addFirst(tmp.val);	<span class="comment">//addFirst会在队列头部插入元素，即1以前，队列变成[2,1]</span></span><br><span class="line">	...</span><br><span class="line">	results.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(result));	</span><br></pre></td></tr></table></figure>

<h2 id="33、二叉搜索树的后序遍历序列（12月30日）"><a href="#33、二叉搜索树的后序遍历序列（12月30日）" class="headerlink" title="33、二叉搜索树的后序遍历序列（12月30日）"></a>33、二叉搜索树的后序遍历序列（12月30日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，分治法。二叉搜索树，左子树中所有节点的值都小于本根节点，右子树中所有节点的值都大于本根节点，由于是后序遍历，本根节点在序列的最后一位。那么，就检测左右子树是否满足该性质，并记录右子树的开始位置（第一个大于序列最后一位的元素位置），并再递归到左子树、右子树继续判断。</span><br><span class="line">	边界条件是，当dfs某子树时，left&gt;=right，说明不存在该子树，或只有<span class="number">1</span>位，此时返回<span class="literal">true</span>。</span><br></pre></td></tr></table></figure>

<h2 id="34、二叉树中和为某一值的路径（113、12月30日）"><a href="#34、二叉树中和为某一值的路径（113、12月30日）" class="headerlink" title="34、二叉树中和为某一值的路径（113、12月30日）"></a>34、二叉树中和为某一值的路径（113、12月30日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，递归。经典的模板题，注意一点即可：题目中定义叶子节点，是没有子节点的节点，路径以叶子节点结束。</span><br></pre></td></tr></table></figure>

<h2 id="35、复杂链表的复制（138、12月30日）"><a href="#35、复杂链表的复制（138、12月30日）" class="headerlink" title="35、复杂链表的复制（138、12月30日）"></a>35、复杂链表的复制（138、12月30日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，递归+hashMap。这道题要打破思路，不要想着按next顺序一个接着一个，而是要递归。建立新链表的难点是，random指针指向的新节点，有可能还没有建立，所以需要hashMap建立联系。</span><br><span class="line">    dfs的逻辑是，如果node（原链）还没有缓存在hashMap，就新建newNode，将映射关系&lt;node,newNode&gt;放在hashMap，并递归建立newNode的left指针和random指针指向的节点。（关键词，不按next按递归）</span><br></pre></td></tr></table></figure>

<h2 id="36、二叉搜索树与双向链表（426、12月30日）"><a href="#36、二叉搜索树与双向链表（426、12月30日）" class="headerlink" title="*36、二叉搜索树与双向链表（426、12月30日）"></a>*36、二叉搜索树与双向链表（426、12月30日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的思路，中序遍历。我的思路，递归函数返回右子节点，首次遍历到左、右子节点均为<span class="literal">null</span>的节点时，将其设置为head。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，中序遍历。其实和我思路类似，它维护了类变量指针pre、head，pre指向最后操作的root节点。MD，还是有点难，很难描述，下次再说。真的不知道为啥类变量不初始为<span class="literal">null</span>、函数传参初始为<span class="literal">null</span>会有差别？？？</span><br></pre></td></tr></table></figure>

<h2 id="38、字符串的排列（12月30日）"><a href="#38、字符串的排列（12月30日）" class="headerlink" title="38、字符串的排列（12月30日）"></a>38、字符串的排列（12月30日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，回溯。这道题知道用递归，但是递归过程中哪些数字已经被访问，出现重复数字怎么办，这些没有一下想到解决方案。本题解的思路是，维护visited数组表示是否访问过该数，通过排序避免重复数字造成重复序列。巧妙点如下，只取相同数字的第一个保证了不重复：</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="comment">//如果访问过该数字，则不再访问</span></span><br><span class="line">        <span class="comment">//如果该数字不是相同数字序列的第一个，则不再访问</span></span><br><span class="line">    	<span class="keyword">if</span>(visited[j]||(j&gt;<span class="number">0</span>&amp;&amp;!visited[j-<span class="number">1</span>]&amp;&amp;arrs[j-<span class="number">1</span>]==arrs[j]))</span><br><span class="line">    		<span class="keyword">continue</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="39、数组中出现次数超过一半的数字（169、12月30日）"><a href="#39、数组中出现次数超过一半的数字（169、12月30日）" class="headerlink" title="39、数组中出现次数超过一半的数字（169、12月30日）"></a>39、数组中出现次数超过一半的数字（169、12月30日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的思路，排序后取中间。我的思路<span class="number">1</span>，hashMap统计次数。</span><br><span class="line"><span class="number">2.</span>这道题还要求，在空间复杂度为O(<span class="number">1</span>)、时间复杂度很低情况下完成，现在先不考虑。</span><br></pre></td></tr></table></figure>

<h2 id="42、连续子数组的最大和（53、12月30日）"><a href="#42、连续子数组的最大和（53、12月30日）" class="headerlink" title="42、连续子数组的最大和（53、12月30日）"></a>42、连续子数组的最大和（53、12月30日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的思路，动态规划。本来想用古老的滑动窗口，发现复杂度O(n)遂放弃。用动态规划的话，dp[i]表示以nums[i]结尾的数组和的最大值，维护result，在求dp[i]后不断更新result，就能得到所有子数组的最大情况。</span><br></pre></td></tr></table></figure>

<h2 id="46、把数字翻译成字符串（12月31日）"><a href="#46、把数字翻译成字符串（12月31日）" class="headerlink" title="46、把数字翻译成字符串（12月31日）"></a>46、把数字翻译成字符串（12月31日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。定义dp[i]表示以第i位字符结束的数字，该数字有dp[i]种翻译方式。状态转移方程，需要考虑两方面：</span><br><span class="line">	a.当第i-<span class="number">1</span>位字符和第i位字符组成的数字，不在[<span class="number">10</span>,<span class="number">25</span>]范围里，不是合法英文字母，此时dp[i]=dp[i-<span class="number">1</span>];</span><br><span class="line">	b.在[<span class="number">10</span>,<span class="number">25</span>]范围里，dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>]，表示翻译方式来源于单独翻译nums[i]，还是合体翻译两位数；</span><br><span class="line">实现以上思路时，由于转移方程存在dp[i-<span class="number">2</span>]，我根据经验定义dp[[src.length()+<span class="number">1</span>]]，平移避免初始化。</span><br><span class="line"><span class="number">2.</span>字符串和整数比较方法：</span><br><span class="line">	<span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> src.substring(i-<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(tmp.compareTo(<span class="string">&quot;25&quot;</span>)&lt;=<span class="number">0</span>)		<span class="comment">//判断字符串是否小于等于25</span></span><br></pre></td></tr></table></figure>

<h2 id="47、礼物的最大价值（12月31日）"><a href="#47、礼物的最大价值（12月31日）" class="headerlink" title="47、礼物的最大价值（12月31日）"></a>47、礼物的最大价值（12月31日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的思路，动态规划。这是路径和、路径数目的经典模板题，设dp[i][j]表示以(i,j)结尾的最大礼物价值，则转移方程为：</span><br><span class="line">    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">此外，需要注意初始化最左边一列、以及最上边一行。</span><br></pre></td></tr></table></figure>

<h2 id="37、序列化二叉树（297、12月31日）"><a href="#37、序列化二叉树（297、12月31日）" class="headerlink" title="37、序列化二叉树（297、12月31日）"></a>37、序列化二叉树（297、12月31日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>想一想研究生生涯就是从序列化开始的，<span class="number">2022</span>年的最后一天恰好碰到这道困难题，正好同时翻越<span class="number">250</span>题的门槛，有点天命的味道。从最开始跟着cmz师兄贪婪学习的小学弟，到后来目睹zlw师兄这届痛苦的秋招历程，在技术上迷茫，在研究里打旋，至今反而愈发看开，人生大抵如此，有些事儿拼完全力也未必能行，有些时候不撞南墙是不会回头。我感受到阳光和勇气在流失，感受到纸盒子扣在我的生活里，万幸有波吉的陪伴，让我在这段时光里没有轻言放弃，看到生活中剥离技术后的温暖瞬间。说实话，真的想留在<span class="number">2022</span>年，这时候大家都在我的身边。fighting阿琨！</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>我的想法，队列实现层序遍历二叉树。想法很简单，第二次还是做出来了，最开始还以为有双向链表，结果是LRU那道题。思路是，在序列化二叉树时，序列化为“<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,”，即转换成满二叉树；在反序列化时，同样用deque实现层序遍历，如果!arrs[i].equals(<span class="string">&quot;null&quot;</span>)，将新节点连接到deque弹出的节点上，并将新节点放入队列。</span><br><span class="line"><span class="number">3.</span>注意，不能用arrs[i]==<span class="string">&quot;null&quot;</span>去比较字符串，因为arrs[i]是split分割字符串得到的，应该是调用了<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xxx&quot;</span>)，这是新的对象，比较结果必然是<span class="literal">false</span>，应该用equals比较字符串内容。</span><br></pre></td></tr></table></figure>

<h2 id="48、最长不含重复字符的子字符串（3、1月1日）"><a href="#48、最长不含重复字符的子字符串（3、1月1日）" class="headerlink" title="48、最长不含重复字符的子字符串（3、1月1日）"></a>48、最长不含重复字符的子字符串（3、1月1日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，滑动窗口+hashMap。从左到右遍历字符串，当满足“hashMap中不包含该字符或者该字符的重复位置小于滑动窗口left”时，就更新result；当不满足时，说明该字符重复，且重复位置大于left，需要更新left，每轮遍历将&lt;字符，新位置i&gt;的映射放入hashMap。</span><br></pre></td></tr></table></figure>

<h2 id="49、丑数（264、1月1日）"><a href="#49、丑数（264、1月1日）" class="headerlink" title="49、丑数（264、1月1日）"></a>49、丑数（264、1月1日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，优先队列+hashSet去重。这道题仔细看题解，质因子只有&#123;<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>&#125;，并不包含其他质数。Java中默认优先队列为最小堆，这时候可以往优先队列pq中放入<span class="number">2</span>、<span class="number">3</span>、<span class="number">5</span>，此时<span class="number">2</span>为最小元素先出堆，用<span class="number">2</span>再去依次乘&#123;<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>&#125;，把新的结果再放入堆中。这样做，每次出堆的小数字成为新的因子，去乘&#123;<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>&#125;，得到入堆的新数字。只要注意，放入堆前用hashSet去重，避免某个数字是&#123;<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>&#125;的公倍数。</span><br></pre></td></tr></table></figure>

<h2 id="50、第一个只出现一次的字符（1月1日）"><a href="#50、第一个只出现一次的字符（1月1日）" class="headerlink" title="50、第一个只出现一次的字符（1月1日）"></a>50、第一个只出现一次的字符（1月1日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举。因为都是小写字母，维护<span class="type">int</span>型数组counts统计<span class="number">26</span>个字母词频。先从左到右遍历s，统计字母词频；再从左到右遍历s，取出第一个词频为<span class="number">1</span>的字母。只要记住ascii和<span class="type">char</span>相互转换咋写即可。</span><br><span class="line"><span class="number">2.</span><span class="type">char</span>型字母和<span class="type">int</span>型ascii相互转换：</span><br><span class="line">	<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.charAt(i)-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	(<span class="type">char</span>) (<span class="number">97</span>+positions[i]);</span><br></pre></td></tr></table></figure>

<h2 id="60、n个骰子的点数（1月1日）"><a href="#60、n个骰子的点数（1月1日）" class="headerlink" title="*60、n个骰子的点数（1月1日）"></a>*60、n个骰子的点数（1月1日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，动态规划。这道题怎么看都需要背下来，现在看完全不懂。第（i-<span class="number">1</span>）个骰子点数之和数组的第j个值，它影响第i个骰子的tmp[j+k]个值。每轮结束将新的tmp数组赋值给dp。</span><br></pre></td></tr></table></figure>

<h2 id="52、两个链表的第一个公共节点（160、1月2日）"><a href="#52、两个链表的第一个公共节点（160、1月2日）" class="headerlink" title="52、两个链表的第一个公共节点（160、1月2日）"></a>52、两个链表的第一个公共节点（160、1月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashSet。首先遍历headA链表，将节点都放在hashSet；再遍历headB链表，遇到第一个已经在hashSet存在的节点，即为第一个公共节点。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，双指针。假设链表长度headA=a+c，链表长度headB=b+c，如果两个链表同步更新，必然有a+c+b=b+c+a，同时到达公共节点。实现就是，遍历headA到<span class="literal">null</span>时，下一位指向headB。</span><br></pre></td></tr></table></figure>

<h2 id="53、在排序数组中查找数字Ⅰ（34、1月2日）"><a href="#53、在排序数组中查找数字Ⅰ（34、1月2日）" class="headerlink" title="53、在排序数组中查找数字Ⅰ（34、1月2日）"></a>53、在排序数组中查找数字Ⅰ（34、1月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，二分查找。先通过二分查找，找到等于target的目标位置，再向下或向上确定其他等于target的目标位置，统计次数。注意，向下确定时需满足i&gt;=<span class="number">0</span>，向上确定时需满足i&lt;=nums.length-<span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<h2 id="53-Ⅱ、0-n-1中缺失的数字（1月2日）"><a href="#53-Ⅱ、0-n-1中缺失的数字（1月2日）" class="headerlink" title="53-Ⅱ、0~n-1中缺失的数字（1月2日）"></a>53-Ⅱ、0~n-1中缺失的数字（1月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，直接遍历。从左往右遍历，不满足nums[i]==i即返回，都满足则返回nums.length。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，二分查找。有序数组中的搜索问题，首先想到二分法解决。左右数组不同点在于，左边数组nums[i]==i，右边数组nums[i]!=i，题目转换为，通过二分查找找到第一个nums[i]!=i的数字。</span><br><span class="line">	注意临界条件是left&lt;=right，因为每次都是移动<span class="number">1</span>位，必然有left==right。当left==right时，如果nums[mid]!=mid，移动right指针，此时left指针仍指向第一个不满足的数字；如果nums[mid]==mid，移动left指针一位，就指向了第一个不满足的数字。在这种临界条件下，结果返回left就好。</span><br></pre></td></tr></table></figure>

<h2 id="54、二叉搜索树的第k大节点（1月2日）"><a href="#54、二叉搜索树的第k大节点（1月2日）" class="headerlink" title="54、二叉搜索树的第k大节点（1月2日）"></a>54、二叉搜索树的第k大节点（1月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，按右中左顺序遍历二叉树。但是，如何传递k成了难事，k并不是随深度递增，而是到最底层后，回归时不断减小。这种时候，除非在dfs返回值中返回k，更优雅的解法是使用全局变量。dfs访问自身root节点时，就将k减少<span class="number">1</span>位，如果k减少为<span class="number">0</span>，就将res赋值为root.val。每次先访问完root.right后，如果k已经为<span class="number">0</span>，就直接返回，不再访问root和root.left。</span><br></pre></td></tr></table></figure>

<h2 id="55-Ⅰ、二叉树的深度（104、1月2日）"><a href="#55-Ⅰ、二叉树的深度（104、1月2日）" class="headerlink" title="55-Ⅰ、二叉树的深度（104、1月2日）"></a>55-Ⅰ、二叉树的深度（104、1月2日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，队列实现层序遍历二叉树。注意，还是判断tmp.left!=<span class="literal">null</span>，tmp.right!=<span class="literal">null</span>后，将不为<span class="literal">null</span>的节点放入deque，逻辑更清除一些。</span><br></pre></td></tr></table></figure>

<h2 id="55-Ⅱ、平衡二叉树（110、1月3日）"><a href="#55-Ⅱ、平衡二叉树（110、1月3日）" class="headerlink" title="55-Ⅱ、平衡二叉树（110、1月3日）"></a>55-Ⅱ、平衡二叉树（110、1月3日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，自顶向下递归。对于每个节点root，通过辅助函数height()求其left、right子树的高度，需满足两子树高度差小于等于<span class="number">1</span>，同时需递归调用isBalanced判断left、right子树是否满足平衡。（关键词，两个递归）</span><br><span class="line">	Math.max(height(root.left), height(root.right)) + <span class="number">1</span>;   <span class="comment">//height核心逻辑，也是通过递归累积高度</span></span><br><span class="line"><span class="number">2.</span>思路<span class="number">2</span>，自底向上的递归。在上面的方法中，显然height在被重复调用，求root节点时height(root.left)会递归到height(root.left.left)，求root.left是否平衡时，也会调用height(root.left.left)，这种重复非常普遍。本质是，前面方法为先序遍历，先判断root是否平衡，再判断左右子树，理想解法是后序遍历，题解巧妙在设置标志位为-<span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<h2 id="56-Ⅰ、数组中数字出现的次数（1月4日）"><a href="#56-Ⅰ、数组中数字出现的次数（1月4日）" class="headerlink" title="*56-Ⅰ、数组中数字出现的次数（1月4日）"></a>*56-Ⅰ、数组中数字出现的次数（1月4日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashMap。先遍历nums将数字和次数放入hashMap，再遍历hashMap取出次数为<span class="number">1</span>的数字。</span><br><span class="line"><span class="number">2.</span>如果找出一堆数字中唯一的只出现<span class="number">1</span>次的数字，则将全部数字进行异或就能得到。</span><br></pre></td></tr></table></figure>

<h2 id="63、股票的最大利润（121、1月5日）"><a href="#63、股票的最大利润（121、1月5日）" class="headerlink" title="63、股票的最大利润（121、1月5日）"></a>63、股票的最大利润（121、1月5日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，穷举法。从左到右遍历prices，从<span class="number">0</span>到当前位置前一位获取历史价格，取差价的最大值。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，动态规划。设置dp[i]表示第i天以前能赚到的最大值，维护minValue表示最低价格。从左到右遍历时，状态转移方程如下，用prices[i]更新minValue。</span><br><span class="line">    dp[i] = Math.max(dp[i-<span class="number">1</span>],prices[i]-minValue);</span><br></pre></td></tr></table></figure>

<h2 id="64、求1-2-…-n（1月6日）"><a href="#64、求1-2-…-n（1月6日）" class="headerlink" title="64、求1+2+…+n（1月6日）"></a>64、求1+2+…+n（1月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>这道题不能用等差数列、<span class="keyword">for</span>、<span class="keyword">while</span>、<span class="keyword">if</span>、<span class="keyword">else</span>等逻辑判断。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，递归。递归的终止条件是，当n减小到<span class="number">0</span>时，直接<span class="keyword">return</span> <span class="number">0</span>，否则<span class="keyword">return</span> n+sumNums(n-<span class="number">1</span>)。但是题目不允许<span class="keyword">if</span>，题解用了更巧妙地实现表示该逻辑：</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> n &gt; <span class="number">0</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;  <span class="comment">//后面的&gt;0没有意义，只因返回boolean</span></span><br></pre></td></tr></table></figure>

<h2 id="57、和为s的两个数字（1月6日）"><a href="#57、和为s的两个数字（1月6日）" class="headerlink" title="57、和为s的两个数字（1月6日）"></a>57、和为s的两个数字（1月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，二分查找。由于nums是递增排序的数组，所以每轮left指针指向(i+<span class="number">1</span>)，right指针指向(nums.lenght-<span class="number">1</span>)，进行二分查找。</span><br><span class="line"><span class="number">2.</span>其他解法，hashSet，双指针。</span><br></pre></td></tr></table></figure>

<h2 id="57-Ⅱ、和为s的连续正数序列（1月6日）"><a href="#57-Ⅱ、和为s的连续正数序列（1月6日）" class="headerlink" title="57-Ⅱ、和为s的连续正数序列（1月6日）"></a>57-Ⅱ、和为s的连续正数序列（1月6日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，双指针。从<span class="number">1</span>到target遍历right指针，如果当前sum&lt;=target，当等于时，将<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(result)添加到results，不管小于还是等于，都将right指针向后移动<span class="number">1</span>位，将sum加上当前right。当sum&gt;right时，通过<span class="keyword">while</span>循环删除result最开始的元素。最后将List&lt;List&lt;Integer&gt;&gt;转换为<span class="type">int</span>[][]，由于是<span class="type">int</span>不是String，不能用list.toArray(<span class="type">int</span>[])。</span><br></pre></td></tr></table></figure>

<h2 id="66、构建乘积数组（1月7日）"><a href="#66、构建乘积数组（1月7日）" class="headerlink" title="66、构建乘积数组（1月7日）"></a>66、构建乘积数组（1月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，暴力破解。两层<span class="keyword">for</span>循环，result[i]为不包含a[i]的其他元素的乘积。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，辅助数组。设L[i]表示i往左所有数字乘积之和，R[i]表示i往右所有数字乘积之和，可知L[i]=L[i-<span class="number">1</span>]*a[i-<span class="number">1</span>]。有了L[i]和R[i]辅助数组后，可知resule[i] = L[i]*R[i]，因为它俩都不包含a[i]。</span><br></pre></td></tr></table></figure>

<h2 id="58-Ⅰ、翻转单词顺序（151、1月7日）"><a href="#58-Ⅰ、翻转单词顺序（151、1月7日）" class="headerlink" title="58-Ⅰ、翻转单词顺序（151、1月7日）"></a>58-Ⅰ、翻转单词顺序（151、1月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，暴力破解。通过s.split(<span class="string">&quot; &quot;</span>)将字符串切割后，String数组存在很多<span class="string">&quot;&quot;</span>，先编写循环剔除<span class="string">&quot;&quot;</span>，再编写循环将其翻转，注意特殊处理最后的字符，其后面不需要加<span class="string">&quot;&quot;</span>。</span><br></pre></td></tr></table></figure>

<h2 id="58-Ⅱ、左旋转字符串（1月7日）"><a href="#58-Ⅱ、左旋转字符串（1月7日）" class="headerlink" title="58-Ⅱ、左旋转字符串（1月7日）"></a>58-Ⅱ、左旋转字符串（1月7日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，StringBuilder。通过<span class="keyword">for</span>(n-&gt;s.length)先获取后半段，再通过<span class="keyword">for</span>(<span class="number">0</span>-&gt;n)获取前半段，拼接两部分即可。</span><br></pre></td></tr></table></figure>

<h2 id="61、扑克牌中的顺子（1月8日）"><a href="#61、扑克牌中的顺子（1月8日）" class="headerlink" title="61、扑克牌中的顺子（1月8日）"></a>61、扑克牌中的顺子（1月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，hashSet。思路比较其他，因为是<span class="number">5</span>张牌组成的顺子，除大小王外，每张牌都有固定位置，即不能有重复。此时，maxValue-minValue&lt;<span class="number">5</span>，即大小王在内部时=<span class="number">4</span>，在外部时=<span class="number">3</span>。实现该思路，就是hashSet不重复的前提下，不断更新maxValue和minValue。</span><br></pre></td></tr></table></figure>

<h2 id="62、圆圈中最后剩下的数字（1月8日）"><a href="#62、圆圈中最后剩下的数字（1月8日）" class="headerlink" title="*62、圆圈中最后剩下的数字（1月8日）"></a>*62、圆圈中最后剩下的数字（1月8日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，迭代法。这道题没啥说的，就是公式推导：f(n,m) = (f(n-<span class="number">1.</span>m)+m)%n;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i != n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        f = (m + f) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="68-Ⅰ、二叉搜索树的最近公共祖先（235、1月9日）"><a href="#68-Ⅰ、二叉搜索树的最近公共祖先（235、1月9日）" class="headerlink" title="68-Ⅰ、二叉搜索树的最近公共祖先（235、1月9日）"></a>68-Ⅰ、二叉搜索树的最近公共祖先（235、1月9日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>思路<span class="number">1</span>，两次遍历。对TreeNode节点p和q计算路径，再通过同步遍历pathP和pathQ，找到最后一个不相同的节点，即为最近祖先。</span><br></pre></td></tr></table></figure>

<h2 id="68-Ⅱ、二叉树的最近公共祖先（236、1月9日）"><a href="#68-Ⅱ、二叉树的最近公共祖先（236、1月9日）" class="headerlink" title="68-Ⅱ、二叉树的最近公共祖先（236、1月9日）"></a>68-Ⅱ、二叉树的最近公共祖先（236、1月9日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，深度优先搜索。这道题和搜索树不同的点，在于对TreeNode节点p和q计算路径的思路，搜索树有明确的方向，普通二叉树需要通过dfs找到目标路径。这里我维护了<span class="type">boolean</span>[]变量flag，当找到目标节点时，将flag置为<span class="literal">true</span>，回溯时根据该flag标志位，不再进入其他路径，也不再删除本路径的节点。</span><br></pre></td></tr></table></figure>

<h2 id="65、不用加减乘除做加法（1月10日）"><a href="#65、不用加减乘除做加法（1月10日）" class="headerlink" title="*65、不用加减乘除做加法（1月10日）"></a>*65、不用加减乘除做加法（1月10日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>表示a与b求和后，本位的变化为：a异或b；表示a与b求和后，进位的变化为：(a&amp;b)&lt;&lt;<span class="number">1</span>。</span><br><span class="line"><span class="number">2.</span>思路<span class="number">1</span>，模拟加法。将整数a和b的求和，拆分为a和b的无进位加法结果和进位结果的和。carry为啥这样就表示进位，俺也不懂。。。。。。</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = a ^ b;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2283、判断一个数字的数字计数是否等于数位的值（1月11日）"><a href="#2283、判断一个数字的数字计数是否等于数位的值（1月11日）" class="headerlink" title="2283、判断一个数字的数字计数是否等于数位的值（1月11日）"></a>2283、判断一个数字的数字计数是否等于数位的值（1月11日）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>我的想法，hashMap。遍历两次，第一次用hashMap统计词频，第二次比较hashMap和输入数组。</span><br><span class="line"><span class="number">2.</span>获取“<span class="number">1210</span>”中每个数字不能是简单的num.charAt(i)，那样<span class="number">0</span>会变成<span class="number">48</span>，有两种方式正确计算：</span><br><span class="line">	a.<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.parseInt(String.valueOf(num.charAt(i)));</span><br><span class="line">	b.<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> num.charAt(i) - <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://bmsk1994.github.io">bmsk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bmsk1994.github.io/2023/03/20/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88/">https://bmsk1994.github.io/2023/03/20/剑指offer第二版/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/%E5%89%91%E6%8C%87offer2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/29/openrasp-js%E6%A3%80%E6%B5%8B%E9%80%BB%E8%BE%91/"><img class="prev-cover" src="/img/js.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">OpenRASP-js检测逻辑</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/20/Fastjson-before-1-2-48/"><img class="next-cover" src="/img/fastjson1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Fastjson before 1.2.48</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/11/14/HOT-100/" title="HOT 100"><img class="cover" src="/img/hot100.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-14</div><div class="title">HOT 100</div></div></a></div><div><a href="/2022/11/14/%E5%89%91%E6%8C%87offer-%E4%B8%93%E9%A1%B9%E7%AA%81%E7%A0%B4/" title="剑指offer 专项突破"><img class="cover" src="/img/%E5%89%91%E6%8C%87offer%E4%B8%93%E9%A1%B9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-14</div><div class="title">剑指offer 专项突破</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">bmsk</div><div class="author-info__description">锦衣疾马，自此西行</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/BMSK1994"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/BMSK1994" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1679897187@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%91%E6%8C%87Offer-%E7%AC%AC%E4%BA%8C%E7%89%88-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">剑指Offer(第二版)刷题笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8812%E6%9C%8822%E6%97%A5%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">03、数组中重复的数字（12月22日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%EF%BC%88240%E3%80%8112%E6%9C%8822%E6%97%A5%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">04、二维数组中的查找（240、12月22日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06%E3%80%81%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%EF%BC%8812%E6%9C%8823%E6%97%A5%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">06、从尾到头打印链表（12月23日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07%E3%80%81%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8812%E6%9C%8824%E6%97%A5%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">07、重建二叉树（12月24日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08%E3%80%81%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%EF%BC%8812%E6%9C%8824%E6%97%A5%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">08、用两个栈实现队列（12月24日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E2%85%A0%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%EF%BC%8812%E6%9C%8824%E6%97%A5%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">10-Ⅰ、斐波那契数列（12月24日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E2%85%A1%E3%80%81%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98%EF%BC%8812%E6%9C%8825%E6%97%A5%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">10-Ⅱ、青蛙跳台阶问题（12月25日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%EF%BC%88154%E3%80%8112%E6%9C%8825%E6%97%A5%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">11、旋转数组的最小数字（154、12月25日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8879%E3%80%8112%E6%9C%8825%E6%97%A5%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">12、矩阵中的路径（79、12月25日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E2%85%A0%E3%80%81%E5%89%AA%E7%BB%B3%E5%AD%90%EF%BC%88343%E3%80%8112%E6%9C%8825%E6%97%A5%EF%BC%89"><span class="toc-number">1.10.</span> <span class="toc-text">14-Ⅰ、剪绳子（343、12月25日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E2%85%A1%E3%80%81%E5%89%AA%E7%BB%B3%E5%AD%90%E2%85%A1%EF%BC%88343%E3%80%8112%E6%9C%8825%E6%97%A5%EF%BC%89"><span class="toc-number">1.11.</span> <span class="toc-text">14-Ⅱ、剪绳子Ⅱ（343、12月25日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%88191%E3%80%8112%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.12.</span> <span class="toc-text">15、二进制中1的个数（191、12月26日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%EF%BC%8850%E3%80%8112%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.13.</span> <span class="toc-text">16、数值的整数次方（50、12月26日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0%EF%BC%8812%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.14.</span> <span class="toc-text">17、打印从1到最大的n位数（12月26日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%8812%E6%9C%8826%E6%97%A5%EF%BC%89"><span class="toc-number">1.15.</span> <span class="toc-text">18、删除链表的节点（12月26日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%EF%BC%8812%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.16.</span> <span class="toc-text">21、调整数组顺序使奇数位于偶数前面（12月27日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8812%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.17.</span> <span class="toc-text">22、链表中倒数第k个节点（12月27日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88206%E3%80%8112%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.18.</span> <span class="toc-text">24、反转链表（206、12月27日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%8821%E3%80%8112%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.19.</span> <span class="toc-text">25、合并两个排序链表（21、12月27日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%EF%BC%8812%E6%9C%8827%E6%97%A5%EF%BC%89"><span class="toc-number">1.20.</span> <span class="toc-text">26、树的子结构（12月27日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%88226%E3%80%8112%E6%9C%8828%E6%97%A5%EF%BC%89"><span class="toc-number">1.21.</span> <span class="toc-text">27、二叉树的镜像（226、12月28日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88101%E3%80%8112%E6%9C%8828%E6%97%A5%EF%BC%89"><span class="toc-number">1.22.</span> <span class="toc-text">28、对称的二叉树（101、12月28日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%EF%BC%8854%E3%80%8112%E6%9C%8828%E6%97%A5%EF%BC%89"><span class="toc-number">1.23.</span> <span class="toc-text">29、顺时针打印矩阵（54、12月28日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%EF%BC%88155%E3%80%8112%E6%9C%8828%E6%97%A5%EF%BC%89"><span class="toc-number">1.24.</span> <span class="toc-text">30、包含min函数的栈（155、12月28日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%EF%BC%88946%E3%80%8112%E6%9C%8829%E6%97%A5%EF%BC%89"><span class="toc-number">1.25.</span> <span class="toc-text">31、栈的压入、弹出序列（946、12月29日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8812%E6%9C%8829%E6%97%A5%EF%BC%89"><span class="toc-number">1.26.</span> <span class="toc-text">32、从上到下打印二叉树（12月29日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E2%85%A1%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1%EF%BC%8812%E6%9C%8829%E6%97%A5%EF%BC%89"><span class="toc-number">1.27.</span> <span class="toc-text">32-Ⅱ、从上到下打印二叉树Ⅱ（12月29日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E2%85%A2%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A2%EF%BC%8812%E6%9C%8829%E6%97%A5%EF%BC%89"><span class="toc-number">1.28.</span> <span class="toc-text">32-Ⅲ、从上到下打印二叉树Ⅲ（12月29日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%EF%BC%8812%E6%9C%8830%E6%97%A5%EF%BC%89"><span class="toc-number">1.29.</span> <span class="toc-text">33、二叉搜索树的后序遍历序列（12月30日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%88113%E3%80%8112%E6%9C%8830%E6%97%A5%EF%BC%89"><span class="toc-number">1.30.</span> <span class="toc-text">34、二叉树中和为某一值的路径（113、12月30日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%88138%E3%80%8112%E6%9C%8830%E6%97%A5%EF%BC%89"><span class="toc-number">1.31.</span> <span class="toc-text">35、复杂链表的复制（138、12月30日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%88426%E3%80%8112%E6%9C%8830%E6%97%A5%EF%BC%89"><span class="toc-number">1.32.</span> <span class="toc-text">*36、二叉搜索树与双向链表（426、12月30日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%8812%E6%9C%8830%E6%97%A5%EF%BC%89"><span class="toc-number">1.33.</span> <span class="toc-text">38、字符串的排列（12月30日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88169%E3%80%8112%E6%9C%8830%E6%97%A5%EF%BC%89"><span class="toc-number">1.34.</span> <span class="toc-text">39、数组中出现次数超过一半的数字（169、12月30日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E3%80%81%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%EF%BC%8853%E3%80%8112%E6%9C%8830%E6%97%A5%EF%BC%89"><span class="toc-number">1.35.</span> <span class="toc-text">42、连续子数组的最大和（53、12月30日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46%E3%80%81%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8812%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.36.</span> <span class="toc-text">46、把数字翻译成字符串（12月31日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47%E3%80%81%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC%EF%BC%8812%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.37.</span> <span class="toc-text">47、礼物的最大价值（12月31日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88297%E3%80%8112%E6%9C%8831%E6%97%A5%EF%BC%89"><span class="toc-number">1.38.</span> <span class="toc-text">37、序列化二叉树（297、12月31日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48%E3%80%81%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%883%E3%80%811%E6%9C%881%E6%97%A5%EF%BC%89"><span class="toc-number">1.39.</span> <span class="toc-text">48、最长不含重复字符的子字符串（3、1月1日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49%E3%80%81%E4%B8%91%E6%95%B0%EF%BC%88264%E3%80%811%E6%9C%881%E6%97%A5%EF%BC%89"><span class="toc-number">1.40.</span> <span class="toc-text">49、丑数（264、1月1日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%EF%BC%881%E6%9C%881%E6%97%A5%EF%BC%89"><span class="toc-number">1.41.</span> <span class="toc-text">50、第一个只出现一次的字符（1月1日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60%E3%80%81n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0%EF%BC%881%E6%9C%881%E6%97%A5%EF%BC%89"><span class="toc-number">1.42.</span> <span class="toc-text">*60、n个骰子的点数（1月1日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E3%80%81%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%EF%BC%88160%E3%80%811%E6%9C%882%E6%97%A5%EF%BC%89"><span class="toc-number">1.43.</span> <span class="toc-text">52、两个链表的第一个公共节点（160、1月2日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E3%80%81%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%E2%85%A0%EF%BC%8834%E3%80%811%E6%9C%882%E6%97%A5%EF%BC%89"><span class="toc-number">1.44.</span> <span class="toc-text">53、在排序数组中查找数字Ⅰ（34、1月2日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E2%85%A1%E3%80%810-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%881%E6%9C%882%E6%97%A5%EF%BC%89"><span class="toc-number">1.45.</span> <span class="toc-text">53-Ⅱ、0~n-1中缺失的数字（1月2日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9%EF%BC%881%E6%9C%882%E6%97%A5%EF%BC%89"><span class="toc-number">1.46.</span> <span class="toc-text">54、二叉搜索树的第k大节点（1月2日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E2%85%A0%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%EF%BC%88104%E3%80%811%E6%9C%882%E6%97%A5%EF%BC%89"><span class="toc-number">1.47.</span> <span class="toc-text">55-Ⅰ、二叉树的深度（104、1月2日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E2%85%A1%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88110%E3%80%811%E6%9C%883%E6%97%A5%EF%BC%89"><span class="toc-number">1.48.</span> <span class="toc-text">55-Ⅱ、平衡二叉树（110、1月3日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E2%85%A0%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%881%E6%9C%884%E6%97%A5%EF%BC%89"><span class="toc-number">1.49.</span> <span class="toc-text">*56-Ⅰ、数组中数字出现的次数（1月4日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63%E3%80%81%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6%EF%BC%88121%E3%80%811%E6%9C%885%E6%97%A5%EF%BC%89"><span class="toc-number">1.50.</span> <span class="toc-text">63、股票的最大利润（121、1月5日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64%E3%80%81%E6%B1%821-2-%E2%80%A6-n%EF%BC%881%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.51.</span> <span class="toc-text">64、求1+2+…+n（1月6日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57%E3%80%81%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%881%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.52.</span> <span class="toc-text">57、和为s的两个数字（1月6日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-%E2%85%A1%E3%80%81%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%EF%BC%881%E6%9C%886%E6%97%A5%EF%BC%89"><span class="toc-number">1.53.</span> <span class="toc-text">57-Ⅱ、和为s的连续正数序列（1月6日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66%E3%80%81%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%EF%BC%881%E6%9C%887%E6%97%A5%EF%BC%89"><span class="toc-number">1.54.</span> <span class="toc-text">66、构建乘积数组（1月7日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-%E2%85%A0%E3%80%81%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%88151%E3%80%811%E6%9C%887%E6%97%A5%EF%BC%89"><span class="toc-number">1.55.</span> <span class="toc-text">58-Ⅰ、翻转单词顺序（151、1月7日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-%E2%85%A1%E3%80%81%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%881%E6%9C%887%E6%97%A5%EF%BC%89"><span class="toc-number">1.56.</span> <span class="toc-text">58-Ⅱ、左旋转字符串（1月7日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61%E3%80%81%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90%EF%BC%881%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.57.</span> <span class="toc-text">61、扑克牌中的顺子（1月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62%E3%80%81%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%881%E6%9C%888%E6%97%A5%EF%BC%89"><span class="toc-number">1.58.</span> <span class="toc-text">*62、圆圈中最后剩下的数字（1月8日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-%E2%85%A0%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88235%E3%80%811%E6%9C%889%E6%97%A5%EF%BC%89"><span class="toc-number">1.59.</span> <span class="toc-text">68-Ⅰ、二叉搜索树的最近公共祖先（235、1月9日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-%E2%85%A1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88236%E3%80%811%E6%9C%889%E6%97%A5%EF%BC%89"><span class="toc-number">1.60.</span> <span class="toc-text">68-Ⅱ、二叉树的最近公共祖先（236、1月9日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65%E3%80%81%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%EF%BC%881%E6%9C%8810%E6%97%A5%EF%BC%89"><span class="toc-number">1.61.</span> <span class="toc-text">*65、不用加减乘除做加法（1月10日）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2283%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E6%95%B0%E4%BD%8D%E7%9A%84%E5%80%BC%EF%BC%881%E6%9C%8811%E6%97%A5%EF%BC%89"><span class="toc-number">1.62.</span> <span class="toc-text">2283、判断一个数字的数字计数是否等于数位的值（1月11日）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/29/openrasp-js%E6%A3%80%E6%B5%8B%E9%80%BB%E8%BE%91/" title="OpenRASP-js检测逻辑"><img src="/img/js.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenRASP-js检测逻辑"/></a><div class="content"><a class="title" href="/2023/11/29/openrasp-js%E6%A3%80%E6%B5%8B%E9%80%BB%E8%BE%91/" title="OpenRASP-js检测逻辑">OpenRASP-js检测逻辑</a><time datetime="2023-11-29T07:49:49.000Z" title="Created 2023-11-29 15:49:49">2023-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88/" title="剑指offer第二版"><img src="/img/%E5%89%91%E6%8C%87offer2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="剑指offer第二版"/></a><div class="content"><a class="title" href="/2023/03/20/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88/" title="剑指offer第二版">剑指offer第二版</a><time datetime="2023-03-20T05:35:41.000Z" title="Created 2023-03-20 13:35:41">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/Fastjson-before-1-2-48/" title="Fastjson before 1.2.48"><img src="/img/fastjson1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Fastjson before 1.2.48"/></a><div class="content"><a class="title" href="/2023/03/20/Fastjson-before-1-2-48/" title="Fastjson before 1.2.48">Fastjson before 1.2.48</a><time datetime="2023-03-20T05:11:30.000Z" title="Created 2023-03-20 13:11:30">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%A4%8D%E4%B9%A0%E7%AF%87/" title="Tomcat内存马复习篇"><img src="/img/webshell.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tomcat内存马复习篇"/></a><div class="content"><a class="title" href="/2023/03/20/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%A4%8D%E4%B9%A0%E7%AF%87/" title="Tomcat内存马复习篇">Tomcat内存马复习篇</a><time datetime="2023-03-20T05:10:49.000Z" title="Created 2023-03-20 13:10:49">2023-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/Log4j2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" title="Log4j2漏洞分析"><img src="/img/log4j2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Log4j2漏洞分析"/></a><div class="content"><a class="title" href="/2023/03/20/Log4j2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" title="Log4j2漏洞分析">Log4j2漏洞分析</a><time datetime="2023-03-20T05:10:23.000Z" title="Created 2023-03-20 13:10:23">2023-03-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/%E5%89%91%E6%8C%87offer2.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By bmsk</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>